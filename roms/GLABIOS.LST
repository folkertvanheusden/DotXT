Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-1


					PAGE	 	59,132 
					TITLE		GLaBIOS 
				 
				;----------------------------------------------------------------------------; 
				; GLaBIOS (General Libraries and Basic Input Output System) 
				; 
				; A scratch-built, open-source 8088 PC/clone BIOS alternative. 
				; 
				; Copyright (c) 2022-2024, 640KB and contributors 
				; 
				;----------------------------------------------------------------------------; 
				; 
				; This program is free software: you can redistribute it and/or modify it under the terms  
				; of the GNU General Public License as published by the Free Software Foundation, either  
				; version 3 of the License, or (at your option) any later version. 
				; 
				; This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;  
				; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
				; See the GNU General Public License for more details. 
				; 
				; You should have received a copy of the GNU General Public License along with this program.  
				; If not, see <https://www.gnu.org/licenses/>. 
				; 
				;----------------------------------------------------------------------------; 
				; References, Credits and Inspiration: 
				; 
				;  https://stanislavs.org/helppc/ 
				;  http://www.minuszerodegrees.net/ 
				;  https://www.felixcloutier.com/x86/ 
				;  https://sites.google.com/site/pcdosretro/ (offline) 
				; 
				;  "Programmer's Guide to the IBM(R) PC", Peter Norton 
				;  "System BIOS for IBM(R) PC/XT(TM)/AT(R) Computers and Compatibles", 
				;	Phoenix Technologies Ltd. 
				;  "Programmer's Guide to PC Video Systems", Second Edition, Wilton 
				;  (Many more inline...) 
				; 
				;  Font bitmaps by "VileR", (CC BY-SA 4.0) 
				;  https://int10h.org/oldschool-pc-fonts/readme/#legal_stuff 
				; 
				;  @Raffzahn, Contributor and Meckerhut. 
				; 
				;  https://github.com/640-KB/GLaBIOS#further-credits-to 
				; 
				;  "Every byte is sacred, every byte is great, 
				;  when a byte is wasted, God gets quite irate..." 
				;  - David W. Plummer 
				;----------------------------------------------------------------------------; 
				; Build Instructions: 
				; 
				; Build with MASM 5.0 or MASM 6. 
				; 
				;  MAKE.BAT 
				; 
				; or 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-2


				; 
				;  MASM GLABIOS; 
				;  LINK GLABIOS; 
				;  GLA2ROM GLABIOS.EXE GLABIOS.ROM		; Build 8K ROM 
				; 
				; MASM Build Options: 
				;  /DVER_DATE='02/22/22'			; Must be MM/DD/YY format 
				;  /DARCH_TYPE='X'				; P, X, Y or T (see ARCH_* below) 
				;  /DCPU_TYPE='8'					; 8 or V (see CPU_* below) 
				; 
				;----------------------------------------------------------------------------; 
				; POST Error Beep messages: 
				; 
				; Short  Long 
				;	2	1	CPU register test failure 
				;	3	1	CPU instruction test failed 
				;	4	1	Build is V20 but not detected 
				;	2	2	System BIOS ROM checksum error 
				;	3	2	PIT counter 1 test failed 
				;	4	2	DMA register test failed 
				;	5	2	PIC test register failed 
				;	5	3	PIC test interrupt failed 
				;	1	3	Base RAM (0-16KB) read/write error 
				;	3	3	Error loading video adapter ROM 
				;	1	4	Base RAM (0-16KB) parity error 
				; 
				;----------------------------------------------------------------------------; 
				 
				;----------------------------------------------------------------------------; 
				; Build Target Architecture equates (do not edit these) 
				; 
 = 0050				ARCH_5150		EQU	'P'			; 5150 
 = 0058				ARCH_5160		EQU	'X'			; 5160 v1 
 = 0059				ARCH_5160v2		EQU	'Y'			; 5160 v2/3 
 = 0054				ARCH_TURBO		EQU	'T'			; Standard Turbo or clone 
 = 0053				ARCH_TD3300		EQU	'S'			; TD3300A (ST-xx/UNIQUE/Auva) 
 = 0046				ARCH_FE2010		EQU	'F'			; Faraday FE2010A 
 = 0048				ARCH_EHB		EQU	'H'			; EMM Computers/Homebrew8088 
 = 0045				ARCH_EMU		EQU	'E'			; 86Box/Emulator 
 = 004D				ARCH_M88		EQU	'M'			; micro_8088/NuXT 
 = 0049				ARCH_MIST		EQU	'I'			; PCXT_MiSTer 
 = 0055				ARCH_UM82		EQU	'U'			; UMC UM82C088 / ALi M1101 
 = 0043				ARCH_MARTY		EQU	'C'			; MartyPC Emulator 
 = 0056				ARCH_VEN888		EQU	'V'			; Vendex 888-XT 
 = 004C				ARCH_LASER		EQU	'L'			; VTech Laser Turbo XT 
 = 0042				ARCH_BOOK88		EQU	'B'			; Book 8088 
 = 0051				ARCH_CPQ		EQU	'Q'			; Compaq Portable XT 
 = 004A				ARCH_VIRTUALXT	EQU	'J'			; VirtualXT Emulator 
				 
				; 
				; CPU Instruction Set Target 
				; 
 = 0038				CPU_8088		EQU	'8'			; 808x compatible 
 = 0056				CPU_V20		EQU	'V'			; V20 only 
				 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-3


				; 
				; Boot to Turbo or Normal Speed 
				; 
 = 0054				BOOT_TURBO		EQU	'T' 
 = 004E				BOOT_NORMAL		EQU	'N' 
 = 004D				BOOT_MEDIUM		EQU	'M'			; used by FE2010A 
				 
				; 
				; Turbo Switch Behavior 
				; 
 = 0000				TURBO_NONE		EQU	0			; fixed clock no turbo switching 
 = 0001				TURBO_STD		EQU	1			; standard PPI (1=turbo, 0=normal) 
 = 0002				TURBO_REV		EQU	2			; reversed PPI (0=turbo, 1=normal) 
				 
				;----------------------------------------------------------------------------; 
				; BIOS Product Info 
				; 
 =				VER_NAME		EQU	'GLaBIOS' 
					ENDIF 
					ENDIF 
 =				COPY_YEAR		EQU	'2022-25'		; Copyright year range 
				 
				;----------------------------------------------------------------------------; 
				; BEGIN Configurable Build Options 
				;----------------------------------------------------------------------------; 
				; Very important note on custom configuration: 
				; 
				; Not all options can be combined due to very limited ROM code space of 8K, 
				; and fitting withing fixed compatibility ORGs. 
				; 
				; For experimenting with build options, it's highly recommended to use 
				; MASM 5.0 as it will not build if code space is exceeded. Due to differences 
				; in MASM 6, this does not work and can produce a totally broken build. 
				;----------------------------------------------------------------------------; 
				 
				;----------------------------------------------------------------------------; 
				; Select Target Architecture Preset 
				; 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Sub Architecture Types (use with the ARCH_TYPE in parentheses) 
				; 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Default CPU Instruction Set Target 
				; 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Turbo Type 
				; 
				; Some motherboards boot in Normal mode by default and the BIOS may or may not 
				; switch to Turbo speed on boot. Others invert this behavior where it appears 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-4


				; reversed to the BIOS. Use these options to customize for your motherboard. 
				; 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; CGA Snow Removal Method 
				; 
 = 0003				CGA_SNOW_REMOVE	=	3		; 0: Snow, Normal Flashing, Fastest 
										; 1: Less Snow, Some Flashing, Medium Fast 
										; 2: No Snow, Moderate Flashing, Fast 
										; 3: No Snow, More Flashing, Quite Fast 
				 
				;----------------------------------------------------------------------------; 
				; Personality Traits 
				; 
 = 0001				POST_THEME		=	1		; color theme for POST screen (see below) 
 = 0000				POST_CLS		=	0		; clear screen after POST 
 = 0000				POST_GLADOS		=	0		; say "Starting GLaDOS..." on boot 
 = 0001				POST_CONFIG		=	1		; show CPU, FPU and ports on POST 
 = 0001				POST_FD_COUNT	=	1		; show floppy drive count on POST 
 = 0001				POST_HD_COUNT	=	1		; show hard drive count and params on POST 
 = 0001				POST_HD_PARMS	=	1		; show hard drive parameters on POST 
 = 0001				POST_OPT_ROM	=	1		; show option ROM address and loading info 
 = 0001				POST_VIDEO_TYPE	=	1		; show the video adapter type on POST 
 = 0001				POST_WARM_COLD	=	1		; show boot WARM or COLD 
 = 0001				POST_BANNER		=	1		; show banner and version 
 = 0001				WARM_ENABLE		=	1		; 1=enable WARM boot or 0=always COLD boot 
 = 0001				RANDOM_TAGLINE	=	1		; randomize pithy tagline 
 = 0000				UNITS_IEC		=	0		; 0=period-correct "KB" or 1=modern IEC "KiB" 
				 
				;----------------------------------------------------------------------------; 
				; Enable/Disable POST tests (not all tests can be enabled due to 8K ROM space) 
				; 
 = 0000				POST_TEST_INST	=	0		; POST CPU Instruction/Flag Test 
 = 0001				POST_TEST_DMA	=	1		; POST DMA Register Test 
 = 0001				POST_TEST_DMA_TC0	=	1		; POST DMA Terminal Count Test 
 = 0001				POST_TEST_PIT_1	=	1		; POST Timer Channel 1 Test 
 = 0001				POST_TEST_PIC_REG	=	1		; POST PIC Register Test 
 = 0001				POST_TEST_PIC_INT	=	1		; POST PIC Interrupt Test 
 = 0001				POST_TEST_CHK_ROM	=	1		; POST Checksum ROM 
 = 0001				POST_TEST_FD	=	1		; POST Floppy Drive Test 
 = 0001				POST_TEST_SEEK	=	1		; POST Seek Floppy Drives 
 = 0001				POST_TEST_KB	=	1		; POST Keyboard Test (PKI) 
 = 0001				POST_TEST_KEY	=	1		; POST Key Test (PKEY) 
				 
				;----------------------------------------------------------------------------; 
				; Advanced Options (may void your warranty) 
				; 
 = 0280				MAX_RAM_PC		EQU	640		; 640K: base 0000-A000 (for EGA/VGA) 
 = 02C0				MAX_RAM_MDA		EQU	704		; 704K: include A000-B000 (for MDA) 
 = 02E0				MAX_RAM_CGA		EQU	736		; 736K: include A000-B800 (for CGA) 
 = 0280				MAX_RAM 		=	MAX_RAM_PC	; Max detectable low RAM (in KB) 
 = 0000				MAX_RAM_AUTO	=	0		; Auto-detect MAX_RAM from video DIP switches 
 = 0012				DRAM_REFRESH	=	18		; DRAM refresh divisor 1.193 MHz/18 = 66,287.87 Hz 
										; 0=Disable refresh (use only with SRAM!) 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-5


 = 0001				RAM_PARITY		=	1		; Enable RAM parity checking 
 = 0001				RAM_TEST_LONG	=	1		; Long RAM test on cold boot 
 = 0003				RAM_DIGITS		=	3		; Number of zero-padded digits for RAM (3 or 4) 
 = 0001				BASIC_ROM		=	1		; BASIC ROM support at 0F600h 
 = FE00				OPT_ROM_END		=	0FE00H	; Option ROM scan ending address (must be xx00) 
 = 0001				FDC_ENABLE		=	1		; Enable INT 13h floppy support 
 = 0000				FDC_IPL_SW		=	0		; Use IPL switch to enable/disable floppy 
 = 0001				FDC_HLT_WAIT	=	1		; Halt CPU during FD access 
										;   Some chipsets (TD3300A known affected) 
										;   hang during floppy access if this is 
										;   enabled 
 = 0001				FDC_ADV_SEEK	=	1		; Advanced floppy seeking performance 
										;   Store current head position in BDA 
										;   to avoid unnecessary seek commands 
 = 0000				FDC_ZERO_BDA	=	0		; clear FDC FIFO buffer between ops 
										;   Some HD ROMs appropriate this memory 
 = 0000				FDC_ERR_SEC_CT	=	0		; On error, 0=always return 0 sectors 
										;   1=return partial/successful sector count 
 = 0001				KB_HLT_WAIT		=	1		; Halt CPU during KB wait 
 = 0000				MBR_CHECK		=	0		; Verify magic number of DOS MBR at boot 
										;   note: DOS 1.0 does not use MBR, so 
										;   will not boot if this is enabled 
 = 0001				POST_HD_CHECK	=	1		; Enable POST HD drive count and size 
										;   note: Some older WD controller ROMs 
										;   (version 62-000043-0xx known affected) 
										;   have bugs where INT 13h function are 
										;   unusable during POST. Set to 0 to 
										;   work around (disables POST_HD_PARMS) 
 = 0000				FD_AUTO_DETECT	=	0		; Auto-detect number of floppy drives 
										;   use only for DIP switch-less PCs! 
 = 0001				POST_ERR_WAIT	=	1		; Wait for Any Key press to continue if 
										;   there is a POST error 
 = 0000				INT_19_BOOT_HD	=	0		; Try IPL to floppy then hard drive (80h) 
 = 00C0				SW1_FLP		=	MASK FLP	; Default max number of floppy drives 
 = 0001				MDA_ATTR		=	1		; Display MDA character attributes 
										; 2=all, 1=intensity only, 0=filter all 
 = 0001				LIGHT_PEN		=	1		; INT 10h,4 light pen support 
 = 0000				EXP_UNIT		=	0		; Init 5161 I/O Expansion Unit 
 = 0000				KB_FILTER_SC	=	0		; Filter KB make/break code >= 70h 
 = 0000				INIT_AT_KBC		=	0		; Init AT type KB controller 
 = 0000				INIT_V40		=	0		; Init V40 config registers 
 = 0000				OEM_FONT		=	0		; 1=use OEM style font, 0=clone style 
 = 0000				POST_CARD		=	0		; enable POST codes on port 80H 
 = 0000				MUTE_TANDY		=	0		; mute buzzing on Tandy 3 Voice 
				 
				;----------------------------------------------------------------------------; 
				; Hardware hacks! 
				; These run your system way out of spec. You have been warned. 
				;----------------------------------------------------------------------------; 
				 
				;----------------------------------------------------------------------------; 
				; UNSAFE_FLOPPY: Reduce floppy drive head settling time for possibly faster 
				; seek access and burst transfer reads. Warning: this may result in drive 
				; read errors on some hardware. 
				; Specify UNSAFE_FLP_DIV as percentage of head settling time, as configured 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-6


				; in DBT. 
				; 
 = 0000				UNSAFE_FLOPPY	=	0		; Use % of specified disk head settle time 
				;UNSAFE_FLP_DIV	EQU	<1/3>		; 33% 
 =				UNSAFE_FLP_DIV	EQU	<3/10>	; 30% 
				;UNSAFE_FLP_DIV	EQU	<1/4>		; 25% 
				 
				;	IF FDC_ADV_SEEK EQ 1 
				;UNSAFE_FLOPPY	=	1		; reduce head settle times with FDC_ADV 
				;UNSAFE_FLP_DIV	EQU	<1/2>		; 50% 
				;	ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; UNSAFE_REFRESH: Lower the amount of time spent in DMA/DRAM refresh state. 
				; Depending on hardware configuration, this may result in significant speed 
				; and performance gains of up to 5 to 10%, or it may result in instability 
				; and parity errors. 
				; 
				; This is similar to programs such as "SPEEDER" or "FASTV20", which lowers 
				; refresh from 1/18 (65K/s) to 1/64 (18K/s) and 1/655 (1.8K/s) respectively. 
				; 
				; https://forum.vcfed.org/index.php?threads/fastv20-com.24005/ 
				; https://www.pcorner.com/list/UTILITY/SPEEDER.ZIP/INFO/ 
				; https://www.reenigne.org/blog/how-to-get-away-with-disabling-dram-refresh/ 
				; https://en.wikipedia.org/wiki/Memory_refresh 
				; 
 = 0000				UNSAFE_REFRESH	=	0		; Use unsafe DRAM refresh timing 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; END Configurable Build Options 
				;----------------------------------------------------------------------------; 
				 
				 
				;----------------------------------------------------------------------------; 
				; ARCH/build-specific configuration 
				;----------------------------------------------------------------------------; 
				; Defaults / BIOS ID Byte 
				; 
				; https://stanislavs.org/helppc/id_bytes.html 
				; 
 = 00FE				ARCH_ID		=	0FEH			; 0xFE=XT v1/clone (default) 
 = 0000				CASSETTE		=	0			; disable cassette (default) 
				 
					ENDIF 
				 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Configuration for 5160 boards 
				; 
					ENDIF 
					ENDIF 
				 
					ENDIF 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-7


				 
					ENDIF 
				 
					ENDIF 
				 
					ENDIF 
				 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Configuration for Book 8088 
				; 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Configuration for Compaq XT (incomplete) 
				; 
					ENDIF 
				 
					ENDIF 
				 
					ENDIF 
				 
					ENDIF 
				 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Boot to normal or turbo speed (if supported) 
				; 
 =-0001				IS_TURBO		=	TURBO_TYPE NE TURBO_NONE	; use for conditionals 
				 
					IF IS_TURBO 
 =				BOOT_SPEED		EQU	BOOT_TURBO 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Reconfigure features as needed 
				;----------------------------------------------------------------------------; 
				; If Cassette enabled, some of the following features must be disabled due to 
				; code space limitations. 
				; 
 = 0000				CAS_RELOCATE	=	0			; keep CAS code in contiguous block 
				 
					ENDIF 
				 
					ENDIF 
				 
					ENDIF 
				 
					ENDIF 
				 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-8


				; Secret Menu 
				; 
 = 0000				POST_QUIET		=	0			; Quiet POST, show only memory test 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Enable 186 instructions if V20 
				; 
					ENDIF 
				 
				 
				;----------------------------------------------------------------------------; 
				; POST colors and visuals 
				;----------------------------------------------------------------------------; 
				 
				;----------------------------------------------------------------------------; 
				; PC Text Colors 
				; https://stanislavs.org/helppc/colors.html 
				; 
 = 0000				BLACK			EQU	0 
 = 0001				DARKBLUE		EQU	1 
 = 0002				DARKGREEN		EQU	2 
 = 0003				CYAN			EQU	3 
 = 0004				DARKRED		EQU	4 
 = 0005				DARKMAGENTA		EQU	5 
 = 0006				BROWN			EQU	6 
 = 0007				GRAY			EQU	7 
 = 0008				DARKGRAY		EQU	8 
 = 0009				BLUE			EQU	9 
 = 000A				GREEN			EQU	10 
 = 000B				LIGHTCYAN		EQU	11 
 = 000C				RED			EQU	12 
 = 000D				MAGENTA		EQU	13 
 = 000E				YELLOW		EQU	14 
 = 000F				WHITE			EQU	15 
				 
				;----------------------------------------------------------------------------; 
				; Theme My POST Test! 
				; Pick theme from below or roll your own! 
				;----------------------------------------------------------------------------; 
						ELSE 
						ELSE 
				 
				; Theme #1 - "Old skool BBS" (default) 
 =				POST_CLR_TXT	EQU	CYAN 
 =				POST_CLR_VAL1	EQU	GREEN 
 =				POST_CLR_VAL2	EQU	YELLOW 
 =				POST_CLR_COLD	EQU	BLUE 
 =				POST_CLR_WARM	EQU	DARKRED 
 =				POST_CLR_GB		EQU	GRAY 
						ENDIF 
						ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; POST screen column layout options 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-9


				; 
 =				POST_L		EQU	<' [ '>		; left separator string 
 =				POST_R		EQU	<' ]'>		; right separator string 
 = 0002				L_POST_L		EQU	2			; length of separator 
				 
 = 0020				POST_TAB_COL	EQU	32			; horiz tab width for second column 
 = 0007				POST_COL_LBL_W	EQU	7			; column label width 
 = 0004				POST_COL_PAD	EQU	4			; padding (non colored) space between cols 
				 
 = 0006				POST_COL_W		EQU	POST_COL_LBL_W-1	; zero-based column index 
				 
				; column label width plus separator 
 = 0009				POST_COL_VT		EQU	POST_COL_LBL_W + L_POST_L 
				 
				; space between next column 
 = 0013				POST_TAB_COL_I	EQU	POST_TAB_COL - POST_COL_LBL_W - L_POST_L - POST_COL_PAD 
				 
				; prefer period-correct "KB" or IEC "KiB" 
								ELSE 
 =				POST_K_UNIT		EQU	<'KB'>		; KB size unit abbrev. 
 =				POST_M_UNIT		EQU	<'MB'>		; MB size 
								ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Useful CP-437/Control Chars 
				; 
 = 000D				CR 			EQU	0DH 			; Carriage return 
 = 000A				LF 			EQU	0AH 			; Line feed 
 = 0008				BS			EQU	08H			; Backspace ASCII 
 = 0007				BELL			EQU	07H			; BELL ASCII 
 = 0016				SYN			EQU	16H			; SYN C0 control char 
 = 00B3				VL			EQU	0B3H			; vertical line 
 = 00C4				HL			EQU	0C4H			; horizontal line 
 = 00F4				CURL_TOP		EQU	0F4H 
 = 00F5				CURL_BOT		EQU	0F5H 
 = 00F9				BULL			EQU	0F9H			; Bullet operator (medium centered dot) 
 = 00FA				DOT			EQU	0FAH			; Small middle dot 
 = 00FE				SQUARE		EQU	0FEH			; Black square (rectangle) 
 = 0003				HEART			EQU	03H			; faithful companion 
 = 000D				NOTE1			EQU	0DH 
 = 000E				NOTE2			EQU	0EH 
 = 001D				DBLARROW		EQU	01DH 
 = 00AB				HALF			EQU	0ABH			; 1/2 
 = 00AC				QUARTER		EQU	0ACH			; 1/4 
				 
				;----------------------------------------------------------------------------; 
				; Beepin' Tones 
				; PIT delay = 315,000,000 / 264 / freq (Hz) 
				;----------------------------------------------------------------------------; 
 = 11D1				BEEP_C4		EQU	4561			; Middle C4 (261.626 Hz) (4560.65) 
 = 0A98				BEEP_A4		EQU	2712			; A4 (440.000 Hz)   (2711.78) 
 = 0970				BEEP_B4		EQU	2416 			; B4 (493.883 Hz)   (2415.92) 
 = 08E8				BEEP_C5		EQU	2280			; C5 (523.251 Hz)   (2280.32) 
 = 07F0				BEEP_D5		EQU	2032			; D5 (587.329 Hz)   (2031.54) 
 = 0712				BEEP_E5		EQU	1810			; E5 (659.255 Hz)   (1809.89) 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-10


 = 06AC				BEEP_F5		EQU	1708			; F5 (698.456 Hz)   (1708.31) 
 = 05F2				BEEP_G5		EQU	1522			; G5 (783.991 Hz)   (1521.93) 
 = 054C				BEEP_A5		EQU	1356			; A5 (880.000 Hz)   (1355.89) 
 = 04B8				BEEP_B5		EQU	1208			; B5 (987.766 Hz)   (1207.96) 
 = 0474				BEEP_C6		EQU	1140			; C6 (1046.50 Hz)   (1140.16) 
 = 04A9				BEEP_1K		EQU	1193			; ~1 KHz tone       (1193.18) 
 = 04A0				BEEP_1K7		EQU	1184			; ~1007 Hz (cassette 1 bit) 
 = 0250				BEEP_2K		EQU	BEEP_1K7 / 2	; ~2015 Hz (cassette 0 bit) 
				 
 =				BEEP_DEFAULT	EQU	BEEP_A5		; default beep 
 =				BEEP_ERR_HIGH	EQU	BEEP_F5		; perfect fourth apart for 
 =				BEEP_ERR_LOW	EQU	BEEP_C5		;  alternating error beeps 
				 
				;----------------------------------------------------------------------------; 
				; PC ISA (Instruction Set Architecture) I/O Port Addresses 
				;----------------------------------------------------------------------------; 
				 
				; 8237A DMA Controller 
 = 0000				DMA_0_A		EQU	00H 			; W   Start Address Register channel 0 
 = 0001				DMA_0_C		EQU	01H			; W   Count Register channel 0 
 = 0002				DMA_1_A		EQU	02H			; W   Start Address Register channel 1 
 = 0003				DMA_1_C		EQU	03H			; W   Count Register channel 1 
 = 0004				DMA_2_A		EQU	04H			; W   Start Address Register channel 2 
 = 0005				DMA_2_C		EQU	05H			; W   Count Register channel 2 
 = 0006				DMA_3_A		EQU	06H			; W   Start Address Register channel 3 
 = 0007				DMA_3_C		EQU	07H			; W   Count Register channel 3 
 = 0008				DMA_CMD		EQU	08H			; RW  Status / Command Register 
 = 0009				DMA_REQ		EQU	09H			; W   Request Register 
 = 000A				DMA_MASK		EQU	0AH 			; W   Single Channel Mask Register 
 = 000B				DMA_MODE		EQU	0BH 			; W   Mode Register 
 = 000C				DMA_FF		EQU	0CH 			; W   Flip-Flop Reset Register 
 = 000D				DMA_RESET		EQU	0DH 			; W   Master Reset Register (Mask bits ON) 
 = 000E				DMA_MASKR		EQU	0EH 			; W   Mask Reset Register (Mask bits OFF) 
 = 000F				DMA_MMASK		EQU	0FH 			; RW  MultiChannel Mask Register 
				 
				; DMA Page Registers (74LS670) 
 = 0087				DMA_P_C0		EQU	87H			; DMA Channel (unused on PC) 
 = 0083				DMA_P_C1		EQU	83H			; DMA Channel 0 and 1 
 = 0081				DMA_P_C2		EQU	81H			; DMA Channel 2 
 = 0082				DMA_P_C3		EQU	82H			; DMA Channel 3 
				 
				; 8259 PIC Interrupt Controller 
 = 0020				INT_P0		EQU	20H 			; Port 0 
 = 0021				INT_IMR		EQU	21H 			; Port 1 - OCW1 Interrupt Mask Register 
				 
				; 8253 PIT Timer 
 = 0040				PIT_CH0		EQU	40H			; Timer Channel/Counter 0 
 = 0041				PIT_CH1		EQU	41H			; Timer Channel/Counter 1 
 = 0042				PIT_CH2		EQU	42H			; Timer Channel/Counter 2 - Speaker 
 = 0043				PIT_CTRL		EQU	43H			; Timer Control Word 
				 
				; 8255 PPI Peripheral Interface 
 = 0060				PPI_A			EQU	60H			; PPI (8255) Port A IN  - Keyboard input 
 = 0061				PPI_B			EQU	61H			; PPI (8255) Port B OUT - Speaker, Switch se
				lection, Misc 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-11


 = 0062				PPI_C			EQU	62H			; PPI (8255) Port C IN  - Switches 
 = 0063				PPI_CW		EQU	63H			; PPI (8255) Port Control Word 
				 
				; 8042 (AT) Keyboard Controller 
 = 0060				ATKB_IO		EQU	60H			; 8042 Keyboard input/output buffer register 
 = 0064				ATKB_CMD		EQU	64H			; 8042 Keyboard command/status register 
				 
				; POST TEST card I/O 
 = 0080				POST_CARD_PORT	EQU	80H			; can be 60H, 80H, 300H, 313H 
				 
				; TD3300A (ST-xx/UNIQUE/Auva) Control Registers (90h) 
 = 0070				TD_WS			EQU	70H			; RAM, I/O wait state control 
 = 0090				TD_TURBO		EQU	90H			; Write 2 for Turbo, 3 for Normal 
 = 00E0				TD_MEM		EQU	0E0H			; Memory bank switch 
				 
				; UM82C088 Speed / Status registers 
 = 00C0				UM82_SPEED		EQU	0C0H			; write any value to toggle speed mode 
 = 00E0				UM82_STATUS		EQU	0E0H			; read memory size, speed mode 
				 
				; VTech Laser Turbo XT 
 = 01F0				LASER_TURBO		EQU	1F0H			; CPU speed control port: only bit 7 used 
				 
				; NMI flip/flop 
 = 00A0				NMI_R0		EQU	0A0H			; NMI Mask Register 
				 
				; Joystick / Game Port 
 = 0201				GAME_CTRL		EQU	0201H			; Game Port 
				 
				; 5161 Expansion Unit Port 
 = 0213				EXP_UNIT_CTRL	EQU	0213H			; Extender Card Control Port 
				 
				; Hard Disk Controller 
 = 0320				HDC_READ		EQU	0320H			; Read from/Write to controller 
 = 0321				HDC_CTRL		EQU	0321H			; Read: Controller Status, Write: controller
				 reset 
 = 0322				HDC_PULSE		EQU	0322H			; Write: generate controller select pulse 
 = 0323				HDC_DMA		EQU	0323H			; Write: Pattern to DMA and interrupt mask register 
 = 0324				HDC_STAT		EQU	0324H			; disk attention/status 
				 
				; Video 6845 CRT Controller 
 = 03B8				MDA_CTRL		EQU	03B8H			; MDA CRT Control Port 1 
 = 03BA				MDA_STAT		EQU	03BAH			; MDA Status Register 
 = 03BB				MDA_PEN_RST		EQU	03BBH			; CGA light pen strobe reset 
 = 03D4				CGA_IDX		EQU	03D4H			; CGA Mode Select Register 
 = 03D5				CGA_DATA		EQU	03D5H			; CGA Mode Data Register 
 = 03D8				CGA_CTRL		EQU	03D8H			; CGA Mode Control Register 
 = 03D9				CGA_COLOR		EQU	03D9H			; CGA Color Select register 
 = 03DA				CGA_STAT		EQU	03DAH			; CGA Status Register (R) 
 = 03DB				CGA_PEN_RST		EQU	03DBH			; CGA light pen strobe reset (W) 
				 
				; Serial (COM) ports 
 = 03F8				COM1_DATA		EQU	03F8H 		; 03F8H: TX/RX Buffer, Divisor LSB (RW) 
 = 03F9				COM1_IER		EQU	COM1_DATA+1		; 03F9H: Interrupt Enable Register, Divisor 
				MSB (RW) 
 = 03FA				COM1_IIR		EQU	COM1_DATA+2		; 03FAH: Interrupt Identification Register (
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-12


				R) 
 = 03FB				COM1_LCR		EQU	COM1_DATA+3		; 03FBH: Line Control Register (RW) 
 = 03FC				COM1_MCR		EQU	COM1_DATA+4		; 03FCH: Modem Control Register (RW) 
 = 03FD				COM1_LSR		EQU	COM1_DATA+5		; 03FDH: Line Status Register (R) 
 = 03FE				COM1_MSR		EQU	COM1_DATA+6		; 03FEH: Modem Status Register (R) 
 = 03FF				COM1_SPR		EQU	COM1_DATA+7		; 03FFH: Scratch Pad Register (RW) 
 = 02F8				COM2_DATA		EQU	COM1_DATA-100H	; 02F8H: TX/RX Buffer, Divisor LSB (RW) 
 = 02FA				COM2_IIR		EQU	COM2_DATA+2		; 02FAH: Interrupt Identification Register (
				R) 
 = 03E8				COM3_DATA		EQU	COM2_DATA+0F0H	; 03E8H: TX/RX Buffer, Divisor LSB (RW) 
 = 03EA				COM3_IIR		EQU	COM3_DATA+2		; 03FAH: Interrupt Identification Register (
				R) 
 = 02E8				COM4_DATA		EQU	COM3_DATA-100H	; 02E8H: TX/RX Buffer, Divisor LSB (RW) 
 = 02EA				COM4_IIR		EQU	COM4_DATA+2		; 02EAH: Interrupt Identification Register (
				R) 
				 
				; Parallel (LPT) ports 
 = 03BC				LPT_MDA		EQU	03BCH			; LPT1 data port (MDA) 
 = 0378				LPT1			EQU	0378H			; LPT1 data port (I/O) 
 = 0278				LPT2			EQU	0278H			; LPT2 data port (I/O) 
				 
				; Default LPT/COM I/O timeouts (# of 64K LOOPs) 
 = 0014				LPT_TO		EQU	20			; LPT default timeout 
 = 0001				COM_TO		EQU	1			; COM default timeout 
				 
				; V40 Control Registers 
 = FFF6				V40_WCR2		EQU	0FFF6H		; WCU Wait Cycle 2 Register 
 = FFF5				V40_WCR1		EQU	0FFF5H		; WCU Wait Cycle 1 Register 
				 
				;----------------------------------------------------------------------------; 
				; FDC (NEC PD765x) Controller  
				; 
				 
				; Floppy Disk Controller Ports 
 = 03F0				FDC_A_STAT		EQU	03F0H			; Diskette controller status A 
 = 03F1				FDC_B_STAT		EQU	03F1H			; Diskette controller status B 
 = 03F2				FDC_CTRL		EQU	03F2H			; FD controller control port 
 = 03F4				FDC_STAT		EQU	03F4H			; FD controller status register 
 = 03F5				FDC_DATA		EQU	03F5H			; data register (write 1-9 byte command, see
				 INT 13) 
				 
				; FDC Commands 
 = 0002				FDC_CMD_RTRK	EQU	00000010B		; 02H: Read Track (Diagnostic) 
 = 0003				FDC_CMD_SPEC 	EQU	00000011B		; 03H: Specify Step & Head Load 
 = 0004				FDC_CMD_STAT 	EQU	00000100B		; 04H: Sense Drive Status 
 = 0005				FDC_CMD_WR		EQU	00000101B		; 05H: Write Sector 
 = 0006				FDC_CMD_RD		EQU	00000110B		; 06H: Read Sector 
 = 0007				FDC_CMD_RECAL	EQU	00000111B		; 07H: Recalibrate 
 = 0008				FDC_CMD_SENSE	EQU	00001000B		; 08H: Sense Interrupt Status 
 = 0009				FDC_CMD_WDEL	EQU	00001001B		; 09H: Write Deleted Sector 
 = 000A				FDC_CMD_RSID	EQU	00001010B		; 0AH: Read Sector ID 
 = 000C				FDC_CMD_RDEL	EQU	00001100B		; 0CH: Read Deleted Sector 
 = 000D				FDC_CMD_FMT		EQU	00001101B		; 0DH: Format Track 
 = 000F				FDC_CMD_SEEK	EQU	00001111B		; 0FH: Seek 
				 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-13


				; BDA INT 13H Status Flags  
				; https://stanislavs.org/helppc/int_13-1.html 
 = 0000				FDC_ST_OK		EQU	00H			; No error 
 = 0001				FDC_ST_BADCMD	EQU	01H			; Bad command passed to driver 
 = 0002				FDC_ST_ERR_MARK	EQU	02H			; Address mark not found or bad sector 
 = 0003				FDC_ST_ERR_WP	EQU	03H			; Write Protect Error 
 = 0004				FDC_ST_ERR_SEC	EQU	04H			; Sector not found 
 = 0006				FDC_ST_DISK_CHG	EQU	06H			; diskette changed or removed 
 = 0008				FDC_ST_DMA_OVR	EQU	08H			; DMA overrun 
 = 0009				FDC_ST_DMA_64K	EQU 	09H			; DMA access across 64k boundary 
 = 000C				FDC_ST_ERR_MED	EQU	0CH			; Invalid media type 
 = 0010				FDC_ST_ERR_CRC	EQU	10H			; ECC/CRC error on disk read 
 = 0020				FDC_ST_ERR_FDC	EQU	20H			; Controller error 
 = 0040				FDC_ST_ERR_SEEK	EQU	40H			; Seek failure 
 = 0080				FDC_ST_TIMEOUT	EQU	80H 			; Time out, drive not ready 
 = 00FF				FDC_ST_SENSE	EQU	0FFH 			; Sense operation failed 
				 
				; Trivial RAM / data patterns 
 = 95A5				RAM_TEST_1		EQU 	1001010110100101B	; Simple RAM test 095A5H 
 = 731D				RAM_TEST_2		EQU 	0111001100011101B	; Alternate RAM test 0731DH 
 = 731D				RAM_TEST		=	RAM_TEST_2		; pick one 
 = AA55				MAGIC_WORD		EQU	0AA55H		; Magic Word used for option ROM, IPL device 
				 
				; Warm Boot Flag options set in BDA 40:72H 
 = 0000				COLD_BOOT		EQU	0			; Cold Boot - All POST tests 
 = 1234				WARM_BOOT		EQU	1234H			; Warm Boot - Skip some POST tests 
 = 4321				WARM_BOOT_MEM	EQU	4321H			; Warm Boot - Preserve memory 
 = 5678				WARM_BOOT_SUS	EQU	5678H			; Warm Boot - System suspend 
 = 9ABC				WARM_BOOT_TEST	EQU	9ABCH			; Warm Boot - Manufacturer test 
				 
				; Video Related 
 = 0050				VID_DEF_COLS	EQU	80			; standard video mode columns 
 = 0018				VID_DEF_ROWS	EQU	24			; standard video mode rows 
 = 0020				VID_SP		EQU	' '			; fill byte for blank video RAM char 
				 
				 
				;============================================================================; 
				; 
				; 			   * * *   S T R U C T S   * * * 
				; 
				;============================================================================; 
				 
				;----------------------------------------------------------------------------; 
				; BDA Timer Counters (6CH-70H) 
				;----------------------------------------------------------------------------; 
				TIMER_C STRUC 
 0000  ????			LW		DW	?	; 6CH  Timer Counter Low Word (ticks) 
 0002  ????			HW	  	DW	? 	; 6EH  Timer Counter High Word (hours) 
 0004  ??			OF 		DB	? 	; 70H  Timer Overflow flag 
 0005				TIMER_C ENDS 
				 
				;----------------------------------------------------------------------------; 
				; INT 1E Disk Initialization Parameter Table Vector 
				; 
				; https://stanislavs.org/helppc/dbt.html 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-14


				;----------------------------------------------------------------------------; 
				DBT	STRUC 
 0000  ??			SRT		DB	? 	; 00 step-rate time SRT (0CH), head unload time HUT (0FH) 
 0001  ??			HLT_ND	DB	? 	; 01 head load time HLT (01H), DMA mode ND (0) 
 0002  ??			FMCT		DB	? 	; 02 timer ticks to wait before disk motor shutoff 
 0003  ??			FBPS		DB	? 	; 03 bytes per sector (0=128, 1=256, 2=512, 3=1024) 
 0004  ??			SPT		DB	? 	; 04 sectors per track (last sector number) 
 0005  ??			SGAP		DB	? 	; 05 inter-block gap length/gap between sectors 
 0006  ??			LSEC		DB	? 	; 06 data length, if sector length not specified 
 0007  ??			FGAP		DB	? 	; 07 gap length between sectors for format 
 0008  ??			FFILL		DB	? 	; 08 fill byte for formatted sectors 
 0009  ??			HDST		DB	? 	; 09 head settle time in milliseconds 
 000A  ??			FMST		DB	? 	; 0A motor startup time in eighths of a second 
 000B				DBT	ENDS 
				 
				;----------------------------------------------------------------------------; 
				; FDC Command Status Bytes (FDC_LAST_ST) 
				;----------------------------------------------------------------------------; 
				FDC_CSB STRUC 
 0000  ??			SB0		DB	?	; 00 - status register 0 
 0001  ??			SB1		DB	?	; 01 - status register 1 
 0002  ??			SB2		DB	?	; 02 - status register 2 
 0003  ??			CYL		DB	?	; 03 - cylinder number 
 0004  ??			HEAD		DB	?	; 04 - head number 
 0005  ??			SEC		DB	?	; 05 - sector number 
 0006  ??			BPS		DB	?	; 06 - bytes per sector 
 0007				FDC_CSB ENDS 
				 
				;----------------------------------------------------------------------------; 
				; INT 1D Video Initialization Parameter Table Vector (CRTC) 
				; 
				; https://stanislavs.org/helppc/6845.html 
				;----------------------------------------------------------------------------; 
				CRTC	STRUC 
 0000  ??			H_TC		DB	?	; 00 - Horiz. total characters 
 0001  ??			H_CL		DB	?	; 01 - Horiz. displayed characters per line 
 0002  ??			H_SP		DB	?	; 02 - Horiz. synch position 
 0003  ??			H_SW		DB	?	; 03 - Horiz. synch width in characters 
 0004  ??			V_TL		DB	?	; 04 - Vert. total lines 
 0005  ??			V_SL		DB	?	; 05 - Vert. total adjust (scan lines) 
 0006  ??			V_DR		DB	?	; 06 - Vert. displayed rows 
 0007  ??			V_SP		DB	?	; 07 - Vert. synch position (character rows) 
 0008  ??			IL		DB	?	; 08 - Interlace mode 
 0009  ??			MSL		DB	?	; 09 - Maximum scan line address 
 000A  ??			CSL		DB	?	; 0A - Cursor start (scan line) 
 000B  ??			CEL		DB	?	; 0B - Cursor end (scan line) 
 000C  00			SA_H		DB	0	; 0C - Start address (MSB) 
 000D  00			SA_L		DB	0	; 0D - Start address (LSB) 
 000E  00			CA_H		DB	0	; 0E - Cursor address (MSB) (read/write) 
 000F  00			CA_L		DB	0	; 0F - Cursor address (LSB) (read/write) 
 0010				CRTC	ENDS 
				 
				;============================================================================; 
				; 
				; 			   * * *   R E C O R D S   * * * 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-15


				; 
				;============================================================================; 
				 
				;----------------------------------------------------------------------------; 
				; Define Nibbles to Byte 
				; Convert two nibbles to byte (big endian) 
				;----------------------------------------------------------------------------; 
				DNB	RECORD	HBN:4, LBN:4 
				 
				;----------------------------------------------------------------------------; 
				; Define Bytes to Word 
				; Convert two bytes to word (big endian) 
				;----------------------------------------------------------------------------; 
				DBW	RECORD	HWB:8, LWB:8 
				 
				;----------------------------------------------------------------------------; 
				; Convert KiB to Bytes ( K * 1024 ) 
				;----------------------------------------------------------------------------; 
				KB	RECORD	KBK:6, KBS:10 
				 
				;----------------------------------------------------------------------------; 
				; Convert KiB to Words ( K * 1024 / 2 ) 
				;----------------------------------------------------------------------------; 
				KBW	RECORD	KBWK:7, KBWS:9 
				 
				;----------------------------------------------------------------------------; 
				; Convert KiB to Paragraphs ( K * 1024 / 16 ) 
				;----------------------------------------------------------------------------; 
				KBP	RECORD	KBPK:10, KBPS:6 
				 
				;----------------------------------------------------------------------------; 
				; Convert Word to Paragraphs ( K SHL 4 ) 
				;----------------------------------------------------------------------------; 
				KP	RECORD	KPWP:12, KPWPX:4 
				 
				;----------------------------------------------------------------------------; 
				; x86 EFLAGS 
				;----------------------------------------------------------------------------; 
				EFLAGS86	RECORD FSF:1,FZF:1,FR1:1,FAF:1,FR2:1,FPF:1,FR3:1=1,FCF:1 
				 
				;----------------------------------------------------------------------------; 
				; BDA Equipment Flags (40:10H) 
				;----------------------------------------------------------------------------; 
				; 00      |			- LPT : # of LPT ports 
				;   x     |			- X1  :  unused, PS/2 internal modem 
				;    0    |			- GAM : Game port present 
				;     000 |			- COM : # of COM ports present 
				;        0| 		- DMA : DMA (should always be 0) 
				;         |00	 	- FLP : Floppy drives present (+1) (0=1 drive,1=2,etc) 
				;         |  00		- VID : Video mode (00=EGA/VGA, 01=CGA 40x25, 
				; 				-	10=CGA 80x25, 11=MDA 80x25) 
				;         |    11 	- MBRAM: MB RAM (00=64K, 01=128K, 10=192K, 11=256K+) 
				;         |      0	- FPU : FPU installed 
				;         |       1	- IPL : Floppy drive(s) installed (always 1 on 5160) 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-16


								IF FDC_ENABLE EQ 1 
				EQFLAGS RECORD	LPT:2,X1:1,GAM:1,COM:3,DMA:1,FLP:2,VID:2,MBRAM:2=11b,FPU:1,IPL:1=1 
								ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Video Card (VID) DIP switch settings (bits 4-5) 
				; 
 = 0000				VID_ROM	EQU	00b		; OFF/OFF:	EGA/VGA/Option ROM 
 = 0001				VID_CGA40	EQU	01b		; OFF/ON:	CGA 40 column 
 = 0002				VID_CGA80	EQU	10b		; ON/OFF:	CGA 80 column 
 = 0003				VID_MDA	EQU	11b		; ON/ON:	MDA 
				 
				;----------------------------------------------------------------------------; 
				; GLaBIOS Equipment Flags (40:12H) 
				;----------------------------------------------------------------------------; 
				; 76543210 
				; xxxx    |			- TBD		Reserved 
				;     x   |			- TURBO	Turbo supported 
				;      x  |			- V20		1 if V20, 0 if 8088 
				;       xx|			- TBD		Reserved 
				; 84218421 
				;----------------------------------------------------------------------------; 
				GFLAGS RECORD	GTBD1:4,TURBO:1,V20:1,GTBD2:2 
				 
				;----------------------------------------------------------------------------; 
				; POST status flags are stored in BP 
				;----------------------------------------------------------------------------; 
				; BP: 
				; 76543210 
				; x 	    |			- WARM  	Warm Boot flag 
				;  x 	    |			- PKI   	POST Keyboard Interrupt Received 
				;   x     |			- PKEY  	Keyboard key stuck 
				;    x    |			- PFDC  	FDC init failure 
				;     x   |			- PFSK  	FDC seek test failure 
				;      x  |			- PDMA  	DMA error 
				;       x |			- PMEM  	Memory Error 
				;        x|			- PFXX  	Reserved (do not use) 
				;         |xxxxxx		- TBD 
				;         |      xx	- GRND	Random number for tagline 
				; 84218421 
				;----------------------------------------------------------------------------; 
				PFLAGS RECORD WARM:1,PKI:1,PKEY:1,PFDC:1,PFSK:1,PDMA:1,PMEM:1,PFXX:1,PTBD:6,GRND:2 
				 
				;----------------------------------------------------------------------------; 
				; BDA Keyboard Flags 
				;----------------------------------------------------------------------------; 
				; 40:17	Keyboard Flags Byte 1 (Low) 
				;----------------------------------------------------------------------------; 
				;          84218421 
				; 	    |7 	    	- K1IN	insert is active 
				; 	    | 6 	    	- K1CL	caps-lock is active 
				; 	    |  5	    	- K1NL	num-lock is active 
				; 	    |   4    	- K1SL	scroll-lock is active 
				; 	    |    3   	- K1AL	ALT key depressed 
				; 	    |     2  	- K1CT	CTRL key depressed 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-17


				; 	    |      1 	- K1LS	left shift key depressed 
				; 	    |       0	- K1RS	right shift key depressed 
				;----------------------------------------------------------------------------; 
				KBFLAGS1 RECORD	K1IN:1,K1CL:1,K1NL:1,K1SL:1,K1AL:1,K1CT:1,K1LS:1,K1RS:1 
				 
				;----------------------------------------------------------------------------; 
				; 40:18	Keyboard Flags Byte 2 (High) 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |			- K2IN	insert key is depressed 
				;  6 	    |			- K2CL	caps-lock key is depressed 
				;   5	    |			- K2NL	num-lock key is depressed 
				;    4    |			- K2SL	scroll lock key is depressed 
				;     3   |			- K2PA	pause (Ctrl-NumLock) is active 
				;      2  |			- K2SY	system key depressed and held 
				;       1 |			- K2LA	left ALT key depressed 
				;        0|			- K2LC	left CTRL key depressed 
				;----------------------------------------------------------------------------; 
				KBFLAGS2 RECORD	K2IN:1,K2CL:1,K2NL:1,K2SL:1,K2PA:1,K2SY:1,K2LA:1,K2LC:1 
				 
				;----------------------------------------------------------------------------; 
				; BDA Keyboard Flags - Enhanced 
				;----------------------------------------------------------------------------; 
				; 40:96	Keyboard mode/type 
				;----------------------------------------------------------------------------; 
				;          84218421 
				; 	    |7 	    	- KERD	read ID in process 
				; 	    | 6 	    	- KEFI	last char was first ID char 
				; 	    |  5	    	- KENL	force num-lock if Rd ID & KBX 
				; 	    |   4    	- KEEN	101/102 enhanced keyboard installed 
				; 	    |    3   	- KERA	right ALT key depressed 
				; 	    |     2  	- KERC	right CTRL key depressed 
				; 	    |      1 	- KEE0	last code was the E0 hidden code 
				; 	    |       0	- KEE1	last code was the E1 hidden code 
				;----------------------------------------------------------------------------; 
				KBFLAGS3 RECORD	KERD:1,KEFI:1,KENL:1,KEEN:1,KERA:1,KERC:1,KEE0:1,KEE1:1 
				 
				;----------------------------------------------------------------------------; 
				; 40:97	Keyboard LED flags 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |			- KLTE	keyboard transmit error flag 
				;  6 	    |			- KLMU	mode indicator update 
				;   5	    |			- KLRF	re-send received flag 
				;    4    |			- KLAK	ACK received 
				;     3   |			- KLCI	circus system indicator 
				;      2  |			- KLCL	caps-lock indicator 
				;       1 |			- KLNL	num-lock indicator 
				;        0|			- KLSL	scroll lock indicator 
				;----------------------------------------------------------------------------; 
				KBFLAGS4 RECORD	KLTE:1,KLMU:1,KLRF:1,KLAK:1,KLCI:1,KLCL:1,KLNL:1,KLSL:1 
				 
				;----------------------------------------------------------------------------; 
				; 40:71	BIOS Keyboard Break (BIOS_BREAK) 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-18


				; 84218421 
				; 7 	    |			- KBRK	1=break active 
				;  654321 |			- KBRX	unused 
				;----------------------------------------------------------------------------; 
				KBBRK	RECORD	KBRK:1,KBRX:7 
				 
				;----------------------------------------------------------------------------; 
				; FDC BDA Status Flags 
				;----------------------------------------------------------------------------; 
				; 40:3E	FD_CAL_ST	Drive recalibration status flags 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |			- FWIF	1=working interrupt flag 
				;  654    |			- FSTBD	unused 
				;     3   |			- FCAL3	1=recalibrate drive 3 
				;      2  |			- FCAL2	1=recalibrate drive 2 
				;       1 |			- FCAL1	1=recalibrate drive 1 
				;        0|			- FCAL0	1=recalibrate drive 0 
				;----------------------------------------------------------------------------; 
				FDC_SF RECORD	FWIF:1,FSTBD:3,FCAL3:1,FCAL2:1,FCAL1:1,FCAL0:1 
				 
				;----------------------------------------------------------------------------; 
				; 40:3F	FD_MOTOR_ST	Diskette motor status flags 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |			- FWRT	1=write operation 
				;  654    |			- FMTBD	unused 
				;     3210|			- FMOT	1=drive 3 motor on 
				;----------------------------------------------------------------------------; 
				FDC_MF RECORD	FWRT:1,FMTBD:3,FMOT:4 
				 
				;----------------------------------------------------------------------------; 
				; 40:3F	FD_MOTOR_ST	Diskette motor status flags - separated drives 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7654    |			- FMOTX	unused 
				;     3   |			- FMOT3	1=drive 3 on 
				;      2  |			- FMOT2	1=drive 2 on 
				;       1 |			- FMOT1	1=drive 1 on 
				;        0|			- FMOT0	1=drive 0 on 
				;----------------------------------------------------------------------------; 
				FDC_MFD RECORD	FMOTX:4,FMOT3:1,FMOT2:1,FMOT1:1,FMOT0:1 
				 
				;----------------------------------------------------------------------------; 
				; 40:8F	FD_MODE	Floppy drive mode 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |			- FM1X	unused 
				;  6      |			- FM1D	1=drive 1 determined 
				;   5     |			- FM1M	1=drive 1 supports multiple data rates 
				;    4    |			- FM18	1=drive 1 supports 80-track 
				;     3   |			- FM0X	unused 
				;      2  |			- FM0D	1=drive 0 determined 
				;       1 |			- FM0M	1=drive 0 supports multiple data rates 
				;        0|			- FM08	1=drive 0 supports 80-track 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-19


				;----------------------------------------------------------------------------; 
				FDC_MODE RECORD	FM1X:1,FM1D:1,FM1M:1,FM18:1,FM0X:1,FM0D:1,FM0M:1,FM08:1 
				 
				;----------------------------------------------------------------------------; 
				; 40:90H-93H	Floppy drive media state (drives 0-3) 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 76      |			- FSR		data xfr rate in Kb/s (0=500,1=300,2=250) 
				;   5     |			- FDDS	1=dub step required 
				;    4    |			- FSE		1=media established 
				;     3   |			- FSX		unused 
				;      210|			- FSD		(see below) 
				;----------------------------------------------------------------------------; 
				; FSD values: 
				;	0 = 360K disk/360K drive not established 
				;	1 = 360K disk/1.2M drive not established 
				;	2 = 1.2M disk/1.2M drive not established 
				;	3 = 360K disk/360K drive established 
				;	4 = 360K disk/1.2M drive established 
				;	5 = 1.2M disk/1.2M drive established 
				;	6 = reserved 
				;	7 = none of the above 
				;----------------------------------------------------------------------------; 
				FDC_STATE RECORD	FSR:2,FDDS:1,FSE:1,FDX:1,FSD:3 
				 
				;----------------------------------------------------------------------------; 
				; FDC Digital Output Register at 3F2h (write only) 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |			- FDMD	1 = turn floppy drive D motor on 
				;  6      |			- FDMC	1 = turn floppy drive C motor on 
				;   5     |			- FDMB	1 = turn floppy drive B motor on 
				;    4    |			- FDMA	1 = turn floppy drive A motor on 
				;     3   |			- FDDMA	1 = DMA & I/O interface enabled 
				;      2  |			- FDCEN	1 = FDC enable, 0 = hold FDC at reset 
				;       10|			- FDDRV	floppy drive select (0=A, 1=B, 2=C, 3=D) 
				;----------------------------------------------------------------------------; 
				FDC_DOR RECORD	FDMD:1,FDMC:1,FDMB:1,FDMA:1,FDDMA:1,FDCEN:1,FDSEL:2 
				 
				;----------------------------------------------------------------------------; 
				; FDC 765 Status Flags 
				;----------------------------------------------------------------------------; 
				; FDC Main Status Register at 3F4h (read only) 
				; 84218421 
				; 7 	    |			- FDRR	data reg ready for I/O to/from CPU 
				;  6      |			- FIOD	I/O direction; 1=FDC to CPU; 0=CPU to FDC 
				;   5     |			- FDND	FDC is in non-DMA mode 
				;    4    |			- FDRW	FDC read or write command in progress 
				;     3   |			- F3SK	floppy drive 3 in seek mode/busy 
				;      2  |			- F2SK	floppy drive 2 in seek mode/busy 
				;       1 |			- F1SK	floppy drive 1 in seek mode/busy 
				;        0|			- F0SK	floppy drive 0 in seek mode/busy 
				;----------------------------------------------------------------------------; 
				FDC_MSR RECORD	FDRR:1,FIOD:1,FDND:1,FDRW:1,F3SK:1,F2SK:1,F1SK:1,F0SK:1 
				 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-20


				;----------------------------------------------------------------------------; 
				; FDC Command Status Register 0 at 3F5h 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 76	    |			- ST0CS	last command status (see below) 
				;   5     |			- ST0SK	set to 1 when FDD completes a seek command 
				;    4    |			- ST0CHK	equipment check (see note) 
				;     3   |			- ST0NR	not ready on read/write or SS access to head 1 
				;      2  |			- ST0HD	head number at interrupt (head 0 or 1) 
				;       10|			- ST0DRV	unit selected at interrupt (0=A, 1=B, 2=...) 
				;----------------------------------------------------------------------------; 
				; Bits 
				;	 76  Last Command Status 
				;	 00  command terminated successfully 
				;	 01  command execution started but terminated abnormally 
				;	 10  invalid command issued 
				;	 11  command terminated abnormally due to a change in state of 
				;	     the Ready Signal from the FDC  (reserved on PS/2) 
				; 
				;	- equipment check can occur if FDD signals a fault or track zero is 
				;	  not found after 77 steps on a recalibrate command 
				;----------------------------------------------------------------------------; 
				FDC_ST0 RECORD	ST0CS:2,ST0SK:1,ST0CHK:1,ST0NR:1,ST0HD:1,ST0DRV:2 
				 
				;----------------------------------------------------------------------------; 
				; FDC Command Byte 0 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7       |			- FC0MT	MT = Multi-Track 
				;  6      |			- FC0MF	MF = MFM mode 
				;   5     |			- FC0SK	SK = SKip Deleted-data address mark 
				;    43210|			- FC0CMD	FDC command number 
				;----------------------------------------------------------------------------; 
				FDC_CB RECORD	FC0MT:1,FC0MF:1=1,FC0SK:1,FC0CMD:5 
				 
				;----------------------------------------------------------------------------; 
				; FDC Command Byte 1 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 76543   |			- FC1X	unused 
				;      2  |			- FC1HD	head (0-1) 
				;       10|			- FC1DS	drive (0-3) 
				;----------------------------------------------------------------------------; 
				FDC_CB1 RECORD	FC1X:5,FC1HD:1,FC1DS:2 
				 
				;----------------------------------------------------------------------------; 
				; Port 3BD Printer Status Flags returned from INT 17 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |			- LPBZ	not busy (note: 0 means busy) 
				;  6      |			- LPACK	acknowledge (printer is attached) 
				;   5     |			- LPOP	20H out of paper 
				;    4    |			- LPSEL	10H selected (0 means off-line) 
				;     3   |			- LPIO	08H I/O error 
				;      21 |			- LPX		06H unused 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-21


				;        0|			- LPTO	01H time-out error 
				;----------------------------------------------------------------------------; 
				PRN_STAT RECORD	LPBZ:1,LPACK:1,LPOP:1,LPSEL:1,LPIO:1,LPX:2,LPTO:1 
				 
				;----------------------------------------------------------------------------; 
				; Port 3BE printer control register   (Parallel Printer Port) 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 765	    |			- LCX		unused 
				;    4    |			- LCIRQ	0 = IRQ disable, 1=IRQ enable for ACK 
				;     3   |			- LCDR	1 = printer reads output,  (pin 17) 
				;      2  |			- LCINI	0 = initialize printer,  (pin 16) 
				;       1 |			- LCLF	1 = auto line feed,  (pin 14) 
				;        0|			- LCOUT	1 = output data to printer,  (pin 1) 
				;----------------------------------------------------------------------------; 
				PRN_CTRL RECORD	LCX:3,LCIRQ:1,LCDR:1,LCINI:1,LCLF:1,LCOUT:1 
				 
				;----------------------------------------------------------------------------; 
				; Port 3FB - Line Control Register - LCR (read/write) 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7	    |			- DLAB	1 = baud rate divisor (DLAB) 
				;  6      |			- LCBK	0 = turn break off, 1 = force spacing break state 
				;   5     |			- LCPD	0 = parity disabled, 1 = enabled 
				;    4    |			- LCEPS	0 = odd parity, 1 = even (EPS) 
				;     3   |			- LCPEN	0 = no parity, 1 = parity (PEN) 
				;      2  |			- LCSB	0 = 1 stop bit, 1 = 1.5 or 2 
				;       10|			- LCWLS	word length select bits 
				;----------------------------------------------------------------------------; 
				COM_LCR RECORD	DLAB:1,LCBK:1,LCPD:1,LCEPS:1,LCPEN:1,LCSB:1,LCWLS:2 
				 
				;----------------------------------------------------------------------------; 
				; Port 3FC - Modem Control Register - MCR (read/write) 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 765	    |			- MCRX	unused 
				;    4    |			- MCLB	0 = normal, 1 = loop back test 
				;     3   |			- MCO2	OUT2 
				;      2  |			- MCO1	OUT1 
				;       1 |			- RTS		1 = activate RTS 
				;        0|			- DTR		1 = activate DTR 
				;----------------------------------------------------------------------------; 
				COM_MCR RECORD	MCRX:3,MCLB:1,MCO2:1,MCO1:1,RTS:1,DTR:1 
				 
				;----------------------------------------------------------------------------; 
				; Port 3FE - Modem Status Register - MSR (read only) 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7	    |			- MLSD	1 = receive line signal detect 
				;  6      |			- MRI		1 = ring indicator (RI) 
				;   5     |			- MDSR	1 = DSR 
				;    4    |			- MCTS	1 = CTS 
				;     3   |			- DDCD	1 = DDCD Delta Data Carrier Detect (DCD changed) 
				;      2  |			- DRI		1 = RI ring indicator changed 
				;       1 |			- DDSR	1 = DDSR Delta DSR (DSR changed) 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-22


				;        0|			- DCTS	1 = DCTS Delta CTS (CTS changed) 
				;----------------------------------------------------------------------------; 
				COM_MSR RECORD	MLSD:1,MRI:1,MDSR:1,MCTS:1,DDCD:1,DRI:1,DDSR:1,DCTS:1 
				 
				;----------------------------------------------------------------------------; 
				; Port 3FD/2FD - Line Status Register - LSR (read only) 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7	    |			- LSX		unused 
				;  6      |			- TSRE	1 = transmitter shift register empty (TSRE) 
				;   5     |			- THRE	1 = transmitter holding register empty (THRE) 
				;    4    |			- LBI		1 = break interrupt  (BI) 
				;     3   |			- LFE		1 = framing error (FE) 
				;      2  |			- LPE		1 = parity error (PE) 
				;       1 |			- LOE		1 = overrun error (OE) 
				;        0|			- LDR		1 = data ready 
				;----------------------------------------------------------------------------; 
				COM_LSR RECORD	LSX:1,TSRE:1,THRE:1,LBI:1,LFE:1,LPE:1,LOE:1,LDR:1 
				 
				;----------------------------------------------------------------------------; 
				; HALT_BEEP Pattern - Short / Long 
				;----------------------------------------------------------------------------; 
				BEEP_SL RECORD	BEEP_S:4, BEEP_L: 4 
				 
				;----------------------------------------------------------------------------; 
				; PIT Timer CW 
				;----------------------------------------------------------------------------; 
				; Control Word Counter 1 (port 43H) - System Timer: 
				;  01 		- SC: Select Counter 1 
				;    11		- RW: Read/Write 2xR/2xW 
				;      010		- M:  Mode 2, Rate Gen 
				;         0		- BCD: 0 
				;----------------------------------------------------------------------------; 
				PIT_CW RECORD	PCWSC:2, PCWRW:2, PCWM:3, PCWBCD:1 
				 
				;----------------------------------------------------------------------------; 
				; DMA Mode Register 
				;----------------------------------------------------------------------------; 
				; 01 			; Mode 1 (Single) 
				;   0 		; INC: address decrement 
				;    1 		; Auto-initialization 
				;     10 		; Operation: Read from memory 
				;       00 		; Channel 0 
				;----------------------------------------------------------------------------; 
				DMA_MR RECORD	DMM:2=01B, DMINC:1, DMAI:1=1, DMOP:2, DMCH:2 
				 
				;----------------------------------------------------------------------------; 
				; 8237 DMA Command Register 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |		- DACK	1 = DACK sense active high, 0 = low 
				;  6      |		- DREQ	1 = DREQ sense active high, 0 = low 
				;   5     |		- DWS		1 = Extended write selection, 0 = Late write 
				;    4    |		- DPRI	1 = Rotating priority, 0 = Fixed priority 
				;     3   |		- DTIM	1 = Compressed timing, 0 = Normal timing 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-23


				;      2  |		- DDIS	1 = Controller disable, 0 = Controller enable 
				;       1 |		- DHLD	1 = Channel 0 address hold enable, 0 = disable 
				;        0|		- DM2M	1 = Memory-to-memory enable, 0 = disable 
				;----------------------------------------------------------------------------; 
				DMA_CR RECORD	DACK:1,DREQ:1,DWS:1,DPRI:1,DTIM:1,DDIS:1,DHLD:1,DM2M:1 
				 
				;----------------------------------------------------------------------------; 
				; 8237 DMA Status Register 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |		- CR3		1 = Channel 3 request 
				;  6      |		- CR2		1 = Channel 2 request 
				;   5     |		- CR1		1 = Channel 1 request 
				;    4    |		- CR0		1 = Channel 0 request 
				;     3   |		- TC3		1 = Channel 3 has reached TC 
				;      2  |		- TC2		1 = Channel 2 has reached TC 
				;       1 |		- TC1		1 = Channel 1 has reached TC 
				;        0|		- TC0		1 = Channel 0 has reached TC 
				;----------------------------------------------------------------------------; 
				DMA_SR RECORD	CR3:1,CR2:1,CR1:1,CR0:1,TC3:1,TC2:1,TC1:1,TC0:1 
				 
				;----------------------------------------------------------------------------; 
				; 8237 DMA Single Channel Mask Register 
				;----------------------------------------------------------------------------; 
				; 84218421 
				;      2  |		- SMCLR	1 = Set mask bit, 0 = Clear mask bit 
				;       10|		- SMCH	Select channel mask bit (0-3) 
				;----------------------------------------------------------------------------; 
				DMA_SMR RECORD	SMCLR:6,SMCH:2 
				 
				;----------------------------------------------------------------------------; 
				; PIC Control Registers 
				;----------------------------------------------------------------------------; 
				; ICW1: 
				;  000 		- A7-A5: unused on 8086 mode 
				;     1 		- D4:   1 = ICW1 (and Port 0) 
				;      0 		- LTIM: 0 = Edge Triggered Mode (low to high TTL transition) 
				;       0 		- ADI:  0 = Call Address Interval of 8 
				;        1 		- SNGL: 1 = Single mode (no cascading PICs or ICW3) 
				;         1		- IC4:  1 = ICW4 Needed 
				;----------------------------------------------------------------------------; 
				ICW1	RECORD	D4:4=1, LTIM:1, ADI:1, SNGL:1=1, IC4:1=1 
				 
				; ICW2: 
				;  00001 		- T7-T3: Interrupt Vector Address: 
				;				INT = INT | 8 -> IRQ 0-7 to CPU INT 8-15 
				;       000 	- D2-D0: unused on 8086 mode 
				;----------------------------------------------------------------------------; 
				ICW2	RECORD	ICW2IVA:5, ICW2X:3=0 
				 
				; ICW4: 
				;  000 		- D7-D5: unused 
				;     0		- SFNM: 0 = Not Special Fully Nested Mode 
				;      10		- BUF:  2 = Buffered Mode/Slave 
				;        0		- AEOI: 0 = normal EOI 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-24


				;         1		- uPM:  1 = 8086 system 
				;----------------------------------------------------------------------------; 
				ICW4	RECORD	SFNM:4=0, ICWBUF:2, AEOI:1, uPM:1 
				 
				;----------------------------------------------------------------------------; 
				; IMR / OCW1 Interrupt Mask 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |		- IRQ7	1=interrupt masked (disabled), 0=not masked 
				;  6      |		- IRQ6 
				;   5     |		- IRQ5 
				;    4    |		- IRQ4 
				;     3   |		- IRQ3 
				;      2  |		- IRQ2 
				;       1 |		- IRQ1 
				;        0|		- IRQ0 
				;----------------------------------------------------------------------------; 
				OCW1	RECORD	IRQ7:1,IRQ6:1,IRQ5:1,IRQ4:1,IRQ3:1,IRQ2:1,IRQ1:1,IRQ0:1 
				 
				;----------------------------------------------------------------------------; 
				; OCW2 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 765	    |		- O2CMD	Rotate and End of Interrupt Mode Command 
				;					001b = Non-Specific EOI Command (default) 
				;    43   |		- O2X		unused (00) 
				;      210|		- O2L		Interrupt level acted upon 
				;----------------------------------------------------------------------------; 
				OCW2	RECORD	O2CMD:3=001b, O2X:2, O2L:3 
 = 0020				EOI	EQU		OCW2 <>		; Non-Specific EOI 
				 
				;----------------------------------------------------------------------------; 
				; OCW3 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |		- O3D7	unused (0) 
				;  65     |		- ESMM/SMM	Enable/special mask mode 
				;    43   |		- O3D3	unused (01b) 
				;      2  |		- O3P		1=Poll command, 0=No Poll command 
				;       10|		- O3RR	Read Register command 
				;----------------------------------------------------------------------------; 
				OCW3	RECORD	O3D7:1, ESMM:2, O3D3:2=1, O3P:1, O3RR:2 
				 
				;----------------------------------------------------------------------------; 
				; NMI Mask Register 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; x 	    |		- NMIE	1=enable NMI, 0=disable 
				;  0000000|		- NMIX	unused (0) 
				;----------------------------------------------------------------------------; 
				NMI	RECORD	NMIE:1, NMIX:7 
				 
				;----------------------------------------------------------------------------; 
				; V40 WCY1 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-25


				; 84218421 
				; 76 	    |		- IOW		I/O Wait States (0-3) 
				;   54    |		- UMW		Upper Memory Block Wait States (0-3) 
				;     32  |		- MMW		Middle Memory Block Wait States (0-3) 
				;       10|		- LMW		Lower Memory Block Wait States (0-3) 
				;----------------------------------------------------------------------------; 
				V40_WCY1	RECORD	IOW:2, UMW:2, MMW:2, LMW:2 
				 
				;----------------------------------------------------------------------------; 
				; 6845 Video - Port 3DA Status Register 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7654    |			- VSX		unused 
				;     3   |			- VSVS	vertical retrace, RAM access OK (next 1.25ms) 
				;      2  |			- VSPE	0 = light pen on, 1 = light pen off 
				;       1 |			- VSPT	light pen trigger set 
				;        0|			- VSHS	horiz or vert retrace, RAM access OK 
				;----------------------------------------------------------------------------; 
				VID_STAT	RECORD	VSX:4, VSVS:1, VSPE:1, VSPT:1, VSHS:1 
				 
				;----------------------------------------------------------------------------; 
				; 6845 Video - 3D9 Color Select Register (Text) 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 765     |			- CTX		unused 
				;    4    |			- CTBI	background intensity 
				;     3   |			- CTIN	select intensity setting 
				;      210|			- CTBC	screen/border RGB 
				;----------------------------------------------------------------------------; 
				VID_CSTXT	RECORD	CTX:3=001B, CTBI:1=1B, CTIN:1, CTBC:3 
				 
				;----------------------------------------------------------------------------; 
				; 6845 Video - 3D9 Color Select Register (Graphics) 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 76      |			- CGPH	palette high bits (unused) 
				;   5     |			- CGPL	1 = palette 1, 0=palette 0 
				;    4    |			- CGX		unused 
				;     3   |			- CGIN	intensity 
				;      210|			- CGBG	RGB for background 
				;----------------------------------------------------------------------------; 
				VID_CSGFX	RECORD	CGPH:2,CGPL:1=1B,CGX:1=1B,CGIN:1=1B,CGBG:3=111B 
				 
				;----------------------------------------------------------------------------; 
				; Default video mem attribute byte to fill memory on clear 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7654    |			- VBG		background color (0-15) default black 
				;     3210|			- VFB		foreground color (0-15) default gray 
				;----------------------------------------------------------------------------; 
				VID_ATTR	RECORD	VBG:4=BLACK,VFB:4=GRAY 
				 
				;----------------------------------------------------------------------------; 
				; MDA Character Attributes 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-26


				; 84218421 
				; 7       |			- MDBK	1 = blink, 0 = no blink 
				;  654    |			- MDBG	000b = normal, 111b = Reverse 
				;     3   |			- MDIN	0 = normal, 1 = bold 
				;      210|			- MDFG	111 = normal, 001 = underline, 000 = none 
				;----------------------------------------------------------------------------; 
				MDA_CH_ATTR	RECORD	MDBK:1,MDBG:3,MDIN:1,MDFG:3=111B 
				 
				;----------------------------------------------------------------------------; 
				; 8255 PPI Channel Control Register Byte (Port 63h) Flags 
				;----------------------------------------------------------------------------; 
				; Normal operation: Mode 0, Ports A,C (U and L) as INPUT, Port B as OUTPUT 
				; 84218421 
				; 1 	    |			- PPEN	1=Active 
				;  00     |			- PPAM	Port A Mode: (0 default) 
				;    1    |			- PPAD	Port A Dir: 0=output, 1=input (default) 
				;     1   |			- PPCU	Port C (Upper): 0=output, 1=input (default) 
				;      0  | 		- PPBM	Port B Mode: (0 default) 
				;       0 | 		- PPBD	Port B Dir: 0=output (default), 1=input 
				;        1|			- PPCL	Port C (Lower): 0=output, 1=input (default) 
				;----------------------------------------------------------------------------; 
				PPI_CR RECORD	PPEN:1=1,PPAM:2=00b,PPAD:1=1,PPCU:1=1,PPBM:1,PPBD:1,PPCL:1=1 
				 
							ENDIF		; END ARCH_TYPE EQ ARCH_TD3300 
				 
							ENDIF 
				 
							ENDIF 
				 
							ELSE					; NOT ARCH_FE2010 
								ELSE 
				;----------------------------------------------------------------------------; 
				; 5160/Standard: 8255 PPI Channel B (Port 61h) Flags 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |			- PBKB	0=enable keyboard read, 1=clear 
				;  6      |			- PBKC	0=hold keyboard clock low, 1=enable clock 
				;   5     |			- PBIO	0=enable i/o check, 1=disable 
				;    4    |			- PBPC	0=enable memory parity check, 1=disable 
				;     3   |			- PBSW	0=read SW1-4, 1=read SW-5-8 
				;      2  |			- PBTB	0=turbo, 1=normal 
				;       1 |			- PBSP	0=turn off speaker, 1=turn on 
				;        0|			- PBST	0=turn off timer 2, 1=turn on 
				;----------------------------------------------------------------------------; 
				PPI_B_F RECORD	PBKB:1,PBKC:1,PBIO:1,PBPC:1,PBSW:1,PBTB:1,PBSP:1,PBST:1 
								ENDIF 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; 5160: 8255 PPI Channel C (Port 62h) Flags 
				; * When PPI B PBSW = 0 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |			- PCPE	0=no parity error, 1=memory parity error 
				;  6      |			- PCIE	0=no i/o channel error, 1=i/o channel error 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-27


				;   5     |			- PCT2	timer 2 output / cassette data output 
				;    4    |			- PCCI	cassette data input 
				;     32  |			- PCMB	SW 3,4: MB RAM (00=64K, 01=128K, 10=192K, 11=256K) 
				;       1 |			- PCFP	SW 2: 0=no FPU, 1=FPU installed 
				;        0|			- PCFD	SW 1: Floppy drive (IPL) installed 
				;----------------------------------------------------------------------------; 
				PPI_C_X_L RECORD	PCPE:1,PCIE:1,PCT2:1,PCCI:1,PCMB:2,PCFP:1,PCFD:1 
				 
				;----------------------------------------------------------------------------; 
				; 8255 PPI Channel C Flags (Port 62h) 
				; * When PPI B PBSW = 1 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |			- PC2PE	0=no parity error, 1 r/w memory parity check error 
				;  6      |			- PC2IE	0=no i/o channel error, 1 i/o channel check error 
				;   5     |			- PC2T2	timer 2 output 
				;    4    |			- PC2CI	cassette data input 
				;     32  |			- PCDRV	SW 7,8: # of drives (00=1, 01=2, 10=3, 11=4) 
				;       10|			- PCVID	SW 5,6: video Mode (00=ROM, 01=CG40, 10=CG80, 11=MDA) 
				;----------------------------------------------------------------------------; 
				PPI_C_X_H RECORD	PC2PE:1,PC2IE:1,PC2T2:1,PC2CI:1,PCDRV:2,PCVID:2 
				 
				;----------------------------------------------------------------------------; 
				; Set up boot mode (PPI_B_BOOT) for PPI Channel B 
				;----------------------------------------------------------------------------; 
				 
							ELSE				; ARCH_TYPE NE ARCH_5150 
								IF BOOT_SPEED EQ BOOT_TURBO 
				;----------------------------------------------------------------------------; 
				; Turbo Std Power-On: KB hold low+disable, NMI on, spkr data off, turbo ON/OFF 
				; 
 = 00A8				PPI_B_BOOT	= MASK PBKB OR MASK PBIO OR MASK PBSW 
				 
								ENDIF			; /BOOT_SPEED EQ BOOT_TURBO 
				 
								IF TURBO_TYPE EQ TURBO_REV 
				;----------------------------------------------------------------------------; 
				; Turbo Reverse Power-On: Reverse PBTB 
				; 
 = 00AC				PPI_B_BOOT	= PPI_B_BOOT XOR MASK PBTB 
								ENDIF			; /TURBO_TYPE EQ TURBO_REV 
				 
							ENDIF				; /ARCH_TYPE EQ ARCH_5150 
				 
								ENDIF 
				 
				;============================================================================; 
				; 
				;	 			* * *   M A C R O S   * * * 
				; 
				;============================================================================; 
				 
				;----------------------------------------------------------------------------; 
				; CALL NO STACK - a CALL without a writable stack 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-28


				; Input: 
				;	CALL_JMP = address for CALL 
				;	JMP_SHORT = force SHORT jump 
				; 
				; - SS must be CS 
				;----------------------------------------------------------------------------; 
				CALL_NS 	MACRO CALL_JMP, JMP_SHORT 
						LOCAL	CALL_JMP_PTR, CALL_JMP_RET 
					MOV	SP, OFFSET CALL_JMP_PTR 
							IFNB <JMP_SHORT> 
					JMP	SHORT CALL_JMP 
							ELSE 
					JMP	CALL_JMP 
							ENDIF 
				CALL_JMP_PTR: 
					DW	OFFSET CALL_JMP_RET 
				CALL_JMP_RET: 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Introduce a short delay of ~15 clock cycles for I/O 
				;----------------------------------------------------------------------------; 
				; - Code size: 2 bytes 
				; - 15 clock cycles 
				; - Affects no registers or flags 
				; - CPU Instruction cache is purged 
				; - No stack required 
				;----------------------------------------------------------------------------; 
				IO_DELAY_SHORT	MACRO 
						LOCAL _DONE 
							IF ARCH_TYPE NE ARCH_EMU 
					JMP	SHORT _DONE 
				_DONE: 
							ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Variable delay ~ CX * 15 clock cycles 
				;----------------------------------------------------------------------------; 
				; Input: CX delay in 15 clock cycle increments 
				; Output: CX = 0 
				;----------------------------------------------------------------------------; 
				IO_DELAY	MACRO 
						LOCAL _DONE 
				_DONE: 
					LOOP	_DONE					; long delay for I/O 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Long delay ~1.18m clock cycles (roughly 1/4 second on 4.77MHz) 
				;----------------------------------------------------------------------------; 
				; Output: CX = 0 
				;----------------------------------------------------------------------------; 
				IO_DELAY_LONG	MACRO 
							IF ARCH_TYPE NE ARCH_EMU 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-29


					XOR	CX, CX 				; delay 65535 LOOPs 
					IO_DELAY 
							ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Variable delay with slowdown for Turbo builds 
				;----------------------------------------------------------------------------; 
				; Input: CX delay in 30 clock cycle increments 
				; Output: CX = 0 
				;----------------------------------------------------------------------------; 
				IO_DELAY_TURBO	MACRO 
						LOCAL _DONE 
				_DONE: 
						IF IS_TURBO 
					IO_DELAY_SHORT 
						ENDIF 
					LOOP	_DONE					; long delay for I/O 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Compare an equipment flag 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	FLAG = field name from EQUIP_FLAGS RECORD 
				;	FVAL = value to compare 
				;	SET_BDA = if defined, saves CX and sets DS = BDA 
				;		otherwise assumes DS = BDA and clobbers CX 
				; Output: AX = flag value 
				; 
				; Note: flags must not cross byte boundary (which they don't) 
				;----------------------------------------------------------------------------; 
				CMP_EFLAG	MACRO	FLAG, FVAL, SET_BDA 
						LOCAL FLAG_MASK, FLAG_BIT, FLAG_MEM 
							IFNB <SET_BDA> 
					PUSH	CX					; save CX 
					PUSH	DS 
					MOV	CX, SEG _BDA			; DS = BDA 
					MOV	DS, CX 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Shift if flag is in high byte to low for byte operations 
				; 
							IF FLAG LT 8		; is in low byte? 
				FLAG_MASK	= MASK FLAG 
				FLAG_BIT	= FLAG AND 0111B 
				FLAG_MEM	= EQUIP_FLAGS[0]			; low BDA flags byte 
							ELSE				; is in high byte 
				FLAG_MASK	= HIGH MASK FLAG 
				FLAG_BIT	= (FLAG - 8) AND 0111B 
				FLAG_MEM	= EQUIP_FLAGS[1]			; high BDA flags byte 
							ENDIF 
				 
					MOV	AL, BYTE PTR FLAG_MEM 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-30


					AND	AL, FLAG_MASK 
					CMP	AL, FVAL SHL FLAG_BIT 
				 
							IFNB <SET_BDA> 
					POP	DS 
					POP	CX 
							ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Get an equipment flag 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	FLAG = field name from EQUIP_FLAGS RECORD 
				;	SET_BDA = if defined, saves CX and sets DS = BDA 
				;		otherwise assumes DS = BDA and clobbers CX if 3 or 4 shifts 
				; Output: AX = flag value 
				; 
				; Note: flags must not cross byte boundary (which they don't) 
				;----------------------------------------------------------------------------; 
				GET_EFLAG	MACRO	FLAG, SET_BDA 
						LOCAL FLAG_MASK, FLAG_BIT, FLAG_MEM 
							IFNB <SET_BDA> 
					PUSH	CX					; save CX 
					PUSH	DS 
					MOV	CX, SEG _BDA			; DS = BDA 
					MOV	DS, CX 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Shift if flag is in high byte to low for byte operations 
				; 
							IF FLAG LT 8		; is in low byte? 
				FLAG_MASK	= MASK FLAG 
				FLAG_BIT	= FLAG AND 0111B 
				FLAG_MEM	= EQUIP_FLAGS[0]			; low BDA flags byte 
								IF FLAG + WIDTH FLAG GT 8 
									.ERR 
									%OUT ERROR: BDA EQFLAG crosses byte boundary 
								ENDIF 
							ELSE				; is in high byte 
				FLAG_MASK	= HIGH MASK FLAG 
				FLAG_BIT	= (FLAG - 8) AND 0111B 
				FLAG_MEM	= EQUIP_FLAGS[1]			; high BDA flags byte 
							ENDIF 
				 
					MOV	AL, BYTE PTR FLAG_MEM		; AL = equipment flag byte 
					AND	AX, FLAG_MASK			; isolate bits, clear AH 
				 
				;----------------------------------------------------------------------------; 
				; Determine optimal number of shifts based on bit position and shift 
				; right or left depending on fewest. 
				; 
							IF CPU_TYPE	EQ CPU_V20 
								IF FLAG_BIT GT 4 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-31


					ROL	AL, 8-FLAG_BIT			; shift value into position 
								ELSE 
									IF FLAG_BIT EQ 4 
					ROL4	_AL					; shift value into position 
									ELSE 
					ROR	AL, FLAG_BIT			; shift value into position 
									ENDIF 
								ENDIF 
							ELSE 
								IF FLAG_BIT GT 4	; optimal to roll left 
									FLAG_BIT = 8-FLAG_BIT 
									IF FLAG_BIT GT 2	; 3-4 shifts use CL 
					MOV	CL, FLAG_BIT			; CL = bit(s) position of record 
					ROL	AL, CL				; shift value into position 
									ELSE		; 0-2 shifts use single op(s) 
										REPT FLAG_BIT 
					ROL	AL, 1					; shift value into position 
										ENDM 
									ENDIF 
								ELSE			; optimal to roll right 
									IF FLAG_BIT GT 2 
					MOV	CL, FLAG_BIT			; CL = bit(s) position of record 
					ROR	AL, CL				; shift value into position 
									ELSE 
										REPT FLAG_BIT 
					ROR	AL, 1					; shift value into position 
										ENDM 
									ENDIF 
								ENDIF 
							ENDIF 
							IFNB <SET_BDA> 
					POP	DS 
					POP	CX 
							ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Set an equipment flag 
				;----------------------------------------------------------------------------; 
				; Input:  
				;	AL = flag value (clobbered) 
				;	FLAG = field name from EQUIP_FLAGS RECORD 
				;	SET_BDA = if defined, saves CL and set DS = BDA  
				;		otherwise *requires* DS = BDA and CL clobbered 
				; Output: none 
				;----------------------------------------------------------------------------; 
				SET_EFLAG	MACRO	FLAG, SET_BDA 
							IFNB	<SET_BDA> 
					PUSH	CX 
					PUSH	DS 
					MOV	CX, SEG _BDA			; DS = BDA 
					MOV	DS, CX 
							ENDIF 
				 
							IF FLAG LT 8		; is in low byte? 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-32


				FLAG_MASK	= MASK FLAG 
				FLAG_BIT	= FLAG AND 111B 
				FLAG_MEM	= EQUIP_FLAGS[0]			; low BDA flags byte 
							ELSE				; is in high byte 
				FLAG_MASK	= HIGH MASK FLAG 
				FLAG_BIT	= (FLAG - 8) AND 0111B 
				FLAG_MEM	= EQUIP_FLAGS[1]			; high BDA flags byte 
							ENDIF 
				 
					AND	AL, MASK FLAG SHR FLAG		; isolate flag's bit width 
				 
				;----------------------------------------------------------------------------; 
				; Determine optimal number of shifts based on bit position and shift 
				; right or left depending on fewest. 
				; 
							IF CPU_TYPE	EQ CPU_V20 
								IF FLAG_BIT GT 4 
					ROR	AL, 8-FLAG_BIT			; shift value into position 
								ELSE 
					ROL	AL, FLAG_BIT			; shift value into position 
								ENDIF 
							ELSE 
								IF FLAG_BIT GT 4 
					MOV	CL, 8-FLAG_BIT			; CL = bit(s) position of record 
					ROR	AL, CL				; shift value into position 
								ELSE 
					MOV	CL, FLAG_BIT			; CL = bit(s) position of record 
					ROL	AL, CL				; shift value into position 
								ENDIF 
							ENDIF 
				 
					AND	BYTE PTR FLAG_MEM, NOT FLAG_MASK	; clear existing bits(s) 
					OR	BYTE PTR FLAG_MEM, AL			; set new bit(s) 
				 
							IFNB <SET_BDA> 
					POP	DS 
					POP	CX 
							ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Test a single BDA equipment flag 
				;----------------------------------------------------------------------------; 
				; Input: FLAG = field name from EQUIP_FLAGS RECORD 
				; Output: ZF if 0, NZ if 1 
				; 
				; Requires: DS = BDA 
				;----------------------------------------------------------------------------; 
				TEST_EFLAG	MACRO	FLAG 
							IF FLAG LT 8 
					TEST	BYTE PTR EQUIP_FLAGS, LOW MASK FLAG 
							ELSE 
					TEST	BYTE PTR EQUIP_FLAGS[1], HIGH MASK FLAG 
							ENDIF 
						ENDM 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-33


				 
				;----------------------------------------------------------------------------; 
				; Set a single GLaBIOS flag 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	FLAG = field name from GB_FLAGS RECORD 
				;	FLAG_CLR = if set, zeros flags first 
				; Requires: DS = BDA 
				;----------------------------------------------------------------------------; 
				SET_GFLAG	MACRO	FLAG, FLAG_CLR 
							IFNB	<FLAG_CLR> 
					AND	GB_FLAGS, MASK FLAG		; clear existing flag(s) 
							ENDIF 
					OR	GB_FLAGS, MASK FLAG		; set flag(s) 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Test a single GLaBIOS flag 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	FLAG = field name from GB_FLAGS RECORD 
				; Output: ZF if 0, NZ if 1 
				; 
				; Requires: DS = BDA 
				;----------------------------------------------------------------------------; 
				TEST_GFLAG	MACRO	FLAG 
					TEST	GB_FLAGS, MASK FLAG 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Shortcut to write a null-terminated string to console 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	SZ = string to print 
				;	SAVE_REGS = define (anything) to preserve SI (cost of 2 bytes) 
				;----------------------------------------------------------------------------; 
				PRINT_SZ	MACRO	SZ, SAVE_REGS 
						IFNB	<SAVE_REGS> 
					PUSH	SI					; save SI 
						ENDIF 
						IFDIFI <SZ>,<SI>			; if SZ is not SI 
					MOV	SI, OFFSET SZ 
						ENDIF 
					CALL	OUT_SZ 
						IFNB	<SAVE_REGS> 
					POP	SI 
						ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Same as above but print CRLF at the end 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	SZ = string to print 
				;	SAVE_REGS = define (anything) to preserve SI (cost of 2 bytes) 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-34


				; 
				; If called as PRINTLN_SZ SI, will use SI (effectively an alias to  
				;	'CALL OUTLN_SZ') 
				;----------------------------------------------------------------------------; 
				PRINTLN_SZ	MACRO	SZ, SAVE_REGS 
						IFNB	<SAVE_REGS> 
					PUSH	SI					; save SI 
						ENDIF 
						IFDIFI <SZ>,<SI>			; if SZ is not SI 
					MOV	SI, OFFSET SZ 
						ENDIF 
					CALL	OUTLN_SZ 
						IFNB	<SAVE_REGS> 
					POP	SI 
						ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Set text attribute for a block of chars starting at current cursor 
				;----------------------------------------------------------------------------; 
				; This is a more efficient way to set text colors so any normal way to write 
				; to console may be used. 
				; 
				; Example usage: 
				;   SET_SZ_ATTR 0EH, 10			; set attribute to 0EH for next 10 chars 
				; 
				; Code size: 
				; 	16 bytes if registers NOT saved 
				;	22 bytes if registers saved 
				; 	-3 bytes if ATTR is BL 
				;----------------------------------------------------------------------------; 
				SET_SZ_ATTR	MACRO	ATTR, LN, SAVE_REGS 
							IF POST_THEME NE 0	; display color 
						IFNB	<SAVE_REGS> 
					PUSH	AX 
					PUSH	BX 
					PUSH	CX 
						ENDIF ; IFNB 
					MOV	AX, DBW <9, VID_SP>	; AH = write char w/attr, AL = space 
						IFDIFI <ATTR>,<BL>	; if ATTR is not BL 
					MOV	BX, LOW ATTR		; BH = video page 0, BL = attribute 
						ENDIF	; IFDIFI 
					MOV	CX, LN			; CX = repeat times 
					INT	10H 
						IFNB	<SAVE_REGS> 
					POP	CX 
					POP	BX 
					POP	AX 
						ENDIF	; IFNB 
							ENDIF			; END display color 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; POST column UI 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-35


				POST_COL_1	MACRO LBL_STR, INNER_ATTR, SAVE_REGS, ZERO_BH 
						IFNB	<SAVE_REGS> 
					PUSH	BX					; save BX 
						ENDIF 
						IFNB	<ZERO_BH> 
					MOV	BX, LOW INNER_ATTR		; BH = 0, BL = attribute 
						ELSE 
					MOV	BL, LOW INNER_ATTR		; BL = attribute 
						ENDIF 
					MOV	SI, OFFSET LBL_STR 
					CALL	POST_START_COL_1 
						IFNB	<SAVE_REGS> 
					POP	BX 
						ENDIF 
				 
						ENDM 
				 
				POST_COL_2	MACRO LBL_STR, INNER_ATTR, SAVE_REGS, ZERO_BH 
						IFNB	<SAVE_REGS> 
					PUSH	BX					; save BX 
						ENDIF 
						IFNB	<ZERO_BH> 
					MOV	BX, LOW INNER_ATTR		; BH = 0, BL = attribute 
						ELSE 
					MOV	BL, LOW INNER_ATTR		; BL = attribute 
						ENDIF 
					MOV	SI, OFFSET LBL_STR 
					CALL	POST_START_COL_2 
						IFNB	<SAVE_REGS> 
					POP	BX 
						ENDIF 
						ENDM 
				 
				POST_COL_END	MACRO	SAVE_REGS 
						IFNB	<SAVE_REGS> 
					PUSH	BX					; save BX 
						ENDIF 
					CALL	POST_END_COL 
						IFNB	<SAVE_REGS> 
					POP	BX 
						ENDIF 
						ENDM 
				 
				POST_COL_END_NL	MACRO SAVE_REGS 
						IFNB	<SAVE_REGS> 
					PUSH	BX					; save BX 
						ENDIF 
					CALL	POST_END_COL_NL 
						IFNB	<SAVE_REGS> 
					POP	BX 
						ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Beepin' MACROs 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-36


				;----------------------------------------------------------------------------; 
				; Beep on Man 
				;----------------------------------------------------------------------------; 
				BEEP_ON MACRO 	TONE 
						IFNB	<TONE> 
					MOV	AX, TONE 				; custom tone 
						ELSE 
					MOV	AX, BEEP_DEFAULT 
						ENDIF 
					CALL	BEEP_ON_P 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Beep off Man 
				;----------------------------------------------------------------------------; 
				BEEP_OFF MACRO 
					CALL	BEEP_OFF_P 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Write to POST status card, if enabled 
				;----------------------------------------------------------------------------;; 
				; Input: AL (default) or imm8 
				; 
				; Clobbers AL if imm8 
				;----------------------------------------------------------------------------; 
				POST_CODE	MACRO	CODE 
						IF POST_CARD EQ 1 
							IFNB	<CODE>		; if CODE is not blank 
							IFDIFI <CODE>,<AL>	; if CODE is not AL 
					MOV	AL, LOW CODE 
							ENDIF 
							ENDIF 
					OUT	POST_CARD_PORT, AL 
						ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; BYTES_HERE - Track and enforce code/byte space around fixed ORGs 
				;----------------------------------------------------------------------------; 
				; Use to mark a block of free code space. Outputs assembly warning if code  
				; overruns NEXT_LBL, and defines LBL so space can be viewed. Values displayed 
				; in generated listing. 
				; 
				; WTF: why can't MASM %OUT display the value of NEXT_LBL-$? 
				; WTF2: how to fix for MASM 6.1? 
				; 
					.LALL 
				BYTES_HERE	MACRO	NEXT_LBL 
						LOCAL LBL 
				 
				BYTES_HERE_&NEXT_LBL = NEXT_LBL-$ 
				 
						IFDEF BYTES_HERE_&NEXT_LBL 
						IF2 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-37


						IF BYTES_HERE_&NEXT_LBL LT 0 
						.ERR2 
					%OUT WARNING: Out of space at: NEXT_LBL (&BYTES_HERE_&NEXT_LBL) 
						ENDIF 
						ENDIF 
						ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; x86/V20 Instruction MACROs 
				;----------------------------------------------------------------------------; 
				 
				;----------------------------------------------------------------------------; 
				; AAM, AAD with immediate other than 0AH 
				; 
				AAM_I		MACRO	IMM 
					DB	0D4H, IMM			; AAM	imm 
						ENDM 
				 
				AAD_I		MACRO	IMM 
					DB	0D5H, IMM			; AAD	imm 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; V20 MACROs for instruction mnemonics not supported by MASM 
				;----------------------------------------------------------------------------; 
				 
				;----------------------------------------------------------------------------; 
				; V20_R General Purpose Register operands 
				; 
				V20_R		RECORD	VRW:5, ROPC:3 
				 
				;----------------------------------------------------------------------------; 
				; Format 3 - Single Register OPC, Variant 1 
				; 
				V20_F3	RECORD	VF3_OPC:5=11000b, VF3_SRC:3 
				 
				;----------------------------------------------------------------------------; 
				; Format 4 - Two Register OPC, Variant 1 
				; 
				V20_F4	RECORD	VF4_OPC:2=11b, VF4_DST:3, VF4_SRC:3 
				 
				;----------------------------------------------------------------------------; 
				; Registers used as operands for V20 MACROs 
				; 
 = 0000				_AL	EQU	V20_R	<, 000b>		; reg8 
 = 0001				_CL	EQU	V20_R <, 001b> 
 = 0002				_DL	EQU	V20_R <, 010b> 
 = 0003				_BL	EQU	V20_R <, 011b> 
 = 0004				_AH	EQU	V20_R <, _AL OR 100b> 
 = 0005				_CH	EQU	V20_R <, _CL OR 100b> 
 = 0006				_DH	EQU	V20_R <, _DL OR 100b> 
 = 0007				_BH	EQU	V20_R <, _BL OR 100b> 
 = 0008				_AX	EQU	V20_R <1, _AL>		; reg16 
 = 0009				_CX	EQU	V20_R <1, _CL> 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-38


 = 000A				_DX	EQU	V20_R <1, _DL> 
 = 000B				_BX	EQU	V20_R <1, _BL> 
 = 000C				_SP	EQU	V20_R <1, _AH> 
 = 000D				_BP	EQU	V20_R <1, _CH> 
 = 000E				_SI	EQU	V20_R <1, _DH> 
 = 000F				_DI	EQU	V20_R <1, _BH> 
				 
				;----------------------------------------------------------------------------; 
				; Format 1 - Opcode with Size (Byte/Word) 
				; 
				V20_OP1	MACRO OP, R, IMM 
						LOCAL W 
					W	= (R AND MASK VRW) SHR VRW		; W=1 if 16, 0 if 8 
					DB	0FH, OP OR W				; register Width 
					V20_F3 <, R AND MASK ROPC >			; dest register 
							IFNB <IMM> 
					DB	IMM 
							ENDIF 
						ENDM 
				 
				TEST1		MACRO R, IMM 
					V20_OP1	18H, R, IMM 
						ENDM 
				 
				SET1		MACRO R, IMM 
					V20_OP1	1CH, R, IMM 
						ENDM 
				 
				CLR1		MACRO R, IMM 
					V20_OP1	1AH, R, IMM 
						ENDM 
				 
				NOT1		MACRO R, IMM 
					V20_OP1	1EH, R, IMM 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; V20 (B)INS (Binary INS) - reg/reg form 
				;----------------------------------------------------------------------------; 
				BINS		MACRO D, S 
					DB	0FH, 31H 
					V20_F4 <, S AND MASK ROPC, D AND MASK ROPC > 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; V20 (B)EXT (Binary EXT) - reg/reg form 
				;----------------------------------------------------------------------------; 
				BEXT		MACRO D, S 
					DB	0FH, 33H 
					V20_F4 <, S AND MASK ROPC, D AND MASK ROPC > 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; ROL4: roll nibbles left in AL through R8 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-39


				; R8(low nibble)  = AL(low nibble) 
				; R8(high nibble) = R8(low nibble) 
				; AL(low nibble)  = R8(high nibble) 
				; AL(high nibble) clobbered 
				;----------------------------------------------------------------------------; 
				ROL4		MACRO R8 
					V20_OP1	28H, R8					; ROL4 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; ROR4: roll nibbles right in AL through R8 
				;----------------------------------------------------------------------------; 
				; R8(high nibble) = AL(low nibble) 
				; R8(low nibble)  = R8(high nibble) 
				; AL(low nibble)  = R8(low nibble) 
				; AL(high nibble) clobbered 
				;----------------------------------------------------------------------------; 
				ROR4		MACRO R8 
					V20_OP1	2AH, R8					; ROR4 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Operations on POST test FLAGs 
				;----------------------------------------------------------------------------; 
				POST_FLAG_TEST MACRO	FLAG 
							IF CPU_TYPE	EQ CPU_V20 AND (WIDTH FLAG) EQ 1 
					TEST1	_BP, FLAG				; V20: is FLAG set? 
							ELSE 
					TEST	BP, MASK FLAG			; Is FLAG set? 
							ENDIF 
						ENDM 
				 
				POST_FLAG_SET MACRO	FLAG 
							IF CPU_TYPE	EQ CPU_V20 AND (WIDTH FLAG) EQ 1 
					SET1	_BP, FLAG				; V20: Set FLAG 
							ELSE 
					OR	BP, MASK FLAG			; Set FLAG 
							ENDIF 
						ENDM 
				 
				POST_FLAG_FLIP MACRO	FLAG 
							IF CPU_TYPE	EQ CPU_V20 AND (WIDTH FLAG) EQ 1 
					NOT1	_BP, FLAG				; V20: Invert FLAG 
							ELSE 
					XOR	BP, MASK FLAG			; Invert flag 
							ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; If ZF is needed, set NEED_ZF to use 808x 'AND' instruction instead 
				;----------------------------------------------------------------------------; 
				POST_FLAG_CLR MACRO	FLAG, NEED_ZF 
								LOCAL USE_V20 
							IFNB <NEED_ZF> 
				USE_V20	EQU	0				; use AND instruction instead 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-40


							ELSE 
				USE_V20	EQU	1				; use CLR1 (ZF unaffected) 
							ENDIF 
							IF CPU_TYPE	EQ CPU_V20 AND (WIDTH FLAG) EQ 1 AND USE_V20 
					CLR1		_BP, FLAG			; V20: Clear FLAG 
							ELSE 
					AND	BP, NOT MASK FLAG			; Clear flag 
							ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Jump if Warm Boot 
				;----------------------------------------------------------------------------; 
				JWB		MACRO	LBL 
							IF WARM_ENABLE EQ 1 
					TEST	BP, BP				; is warm boot? 
					JS	LBL					; jump if so 
							ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Jump if not Warm Boot 
				;----------------------------------------------------------------------------; 
				JNWB		MACRO	LBL 
					TEST	BP, BP				; is warm boot? 
					JNS	LBL					; jump if not 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Wait for a video retrace to enable RAM access for CGA 80 column 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	DX = 03DAH (CGA Status Port) 
				; 
				; Output: 
				;	Display is in retrace 
				;	CLI: Interrupts OFF - must be re-enabled after read/write operation 
				; 
				; https://forum.vcfed.org/index.php?threads/cant-get-rid-of-cga-snow.39319/post-478150 
				; 
				; Due to timing requirements this must be unrolled - CALL/PROC too slow 
				;----------------------------------------------------------------------------; 
				CGA_WAIT_SYNC	MACRO 
						LOCAL	WAIT_NO_HSYNC, WAIT_BLANK, IN_VSYNC 
							IF CGA_SNOW_REMOVE EQ 1 
					CLI						; [2] disable interrupts 
							ENDIF 
				WAIT_NO_HSYNC: 
							IF CGA_SNOW_REMOVE GT 1 
					STI						; [2] enable interrupts 
					NOP						; [3] handle pending interrupts 
					CLI						; [2] disable interrupts 
							ENDIF 
					IN	AL, DX				; [12] read CGA status register 
							IF CGA_SNOW_REMOVE GT 1 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-41


					TEST	AL, MASK VSVS			; [5] in vertical? 
					JNZ	IN_VSYNC				; [4/16] if so, do CGA I/O 
							ENDIF 
					SHR	AL, 1					; [2] in horizontal? 
					JC	WAIT_NO_HSYNC			; [4/16] if so, wait for next one 
				WAIT_BLANK: 
					IN	AL, DX				; [12] read CGA status register 
							IF CGA_SNOW_REMOVE GT 1 
					TEST	AL, MASK VSVS OR MASK VSHS	; [5] in either sync? 
					JZ	WAIT_BLANK				; [4/16] 
							ELSE 
					SHR	AL, 1					; [2] in horizontal sync? 
					JNC	WAIT_BLANK				; [4/16] 
							ENDIF 
				IN_VSYNC: 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; IRET with all current flags 
				;----------------------------------------------------------------------------; 
				IRET_F	MACRO 
					RETF	2 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; PUSH multiple (X number of) registers (up to 8) 
				;----------------------------------------------------------------------------; 
				PUSHX	MACRO r1, r2, r3, r4, r5, r6, r7, r8 
							IFNB <r1>			; exit if last reg 
					PUSH	r1 					; push register and repeat 
					PUSHX	r2, r3, r4, r5, r6, r7, r8 
							ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; POP multiple registers (up to 8) 
				;----------------------------------------------------------------------------; 
				POPX	MACRO r1, r2, r3, r4, r5, r6, r7, r8 
							IFNB <r1>			; exit if last reg 
					POP	r1 					; pop register and repeat 
					POPX	r2, r3, r4, r5, r6, r7, r8 
							ENDIF 
						ENDM 
				 
				;============================================================================; 
				; 
				;	   		   * * *   S E G M E N T S   * * *  
				; 
				;============================================================================; 
				 
				;----------------------------------------------------------------------------; 
				; 0000:0000 - 8086 INT vector table 
				;----------------------------------------------------------------------------; 
 0000				_IVT		SEGMENT AT 0H 
 0020						ORG 8H*4 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-42


 0020  ????			IVT_08 		DW	?			; INT 08H - Timer 
 0022  ????			IVT_08_SEG		DW	?			; INT 08H - Timer Segment 
 0024  ????			IVT_09 		DW	?			; INT 09H - Keyboard 
 0026  ????			IVT_09_SEG		DW	?			; INT 09H - Keyboard Segment 
 0040						ORG 10H*4 
 0040  ????			IVT_10		DW	?			; INT 10H - BIOS video services 
 0042  ????			IVT_10_SEG		DW	?			; INT 10H - Segment 
 0060						ORG 18H*4 
 0060  ????			IVT_18		DW	?			; INT 18H - ROM BASIC 
 0062  ????			IVT_18_SEG		DW	?			; INT 18H - Segment 
 0074						ORG 1DH*4 
 0074  ????????			IVT_1D		DD	?			; INT 1DH - CRTC param table 
 0078  ????????			IVT_1E		DD	?			; INT 1EH - Floppy param table 
 007C  ????????			IVT_1F		DD	?			; INT 1FH - User Font bitmap table 
 0080				_IVT 		ENDS 
				 
				;----------------------------------------------------------------------------; 
				; 0000:0400 - BIOS data area (BDA) - Zero Page Segment Addressing 
				;----------------------------------------------------------------------------; 
 = 0400				_BDA_SEG	=	KP < 40H >			; BDA Seg 40H 
 0000				_BDA_ABS	SEGMENT AT 0H 
 041A						ORG	1AH + _BDA_SEG 
 041A  ????			KB_BUF_HD_ABS	DW	?			; 40:1AH Keyboard buffer head ptr 
 043E						ORG	3EH + _BDA_SEG 
 043E  00			FD_CAL_ST_ABS	FDC_SF <>			; 40:3EH Floppy drive recalibration 
 0440						ORG	40H + _BDA_SEG 
 0440  ??			FD_MOTOR_CT_ABS	DB	?			; 40:40H FD motor shutoff counter 
 046B						ORG	6BH + _BDA_SEG 
 046B  ??			INT_LAST_ABS	DB	?			; 40:6BH POST / Interrupt happened? 
 0472						ORG	72H + _BDA_SEG 
 0472  ????			WARM_FLAG_ABS	DW	?			; 40:72H Warm Boot Flag 
 0480						ORG	80H + _BDA_SEG 
 0480  ????			KB_BUF_ST_ABS	DW	?			; 40:80H Keyboard buffer start ptr 
 0482				_BDA_ABS	ENDS 
				 
				;----------------------------------------------------------------------------; 
				; 0030:0000 - Bootstrap temporary stack 
				;----------------------------------------------------------------------------; 
 0000				_BOOT_STACK	SEGMENT AT 30H 
 0000  0080[						DW 	80H DUP(?)		; temporary stack 
	   ????			
			 ]	
				
 0100				STACK_TOP		LABEL WORD			; top of stack 
 0100				_BOOT_STACK	ENDS 
				 
				;----------------------------------------------------------------------------; 
				; 0040:0000 - BIOS data area (BDA) 
				;----------------------------------------------------------------------------; 
				; https://stanislavs.org/helppc/bios_data_area.html 
				; http://www.bioscentral.com/misc/bda.htm 
				;----------------------------------------------------------------------------; 
 0000				_BDA		SEGMENT AT 40H 
 0000  0004[			COM_ADDR		DW	4 DUP(?) 		; 00H  COM1-4 base addresses 
	   ????			
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-43


			 ]	
				
 = 0008				LPT_ADDR_B		EQU	$-_BDA		;	 Low byte hack to force short sign-extend en
				coding 
 0008  0003[			LPT_ADDR		DW	3 DUP(?) 		; 08H  LPT1-3 base addresses 
	   ????			
			 ]	
				
 000E  ????						DW	? 			; 0EH  Extended BIOS data area segment 
 0010  0D00			EQUIP_FLAGS		EQFLAGS <> 			; 10H  Equipment Flags 
 0012  00			GB_FLAGS		GFLAGS <> 			; 12H  Custom Equipment Flags 
 0013  ????			MEM_SZ_KB		DW	?			; 13H  Memory size in kilobytes 
 0015  ????			MEM_SZ_PC		DW	?			; 15H  Memory size SW2 on 5150 
 0017				KB_FLAGS		LABEL WORD 
 0017  00			KB_FLAGS1		KBFLAGS1 <>			; 17H  Keyboard flags 1 
 0018  00			KB_FLAGS2		KBFLAGS2 <>			; 18H  Keyboard flags 2 
 0019  ??			KB_ALT 		DB	?			; 19H  Alt-keypad entry byte 
 001A  ????			KB_BUF_HD		DW	?			; 1AH  Keyboard buffer head ptr 
 001C  ????			KB_BUF_TL		DW	?			; 1CH  Keyboard buffer tail ptr 
 001E  0010[			KB_BUF		DW	16 DUP(?) 		; 1EH  Keyboard buffer 
	   ????			
			 ]	
				
 003E				KB_BUF_END		LABEL WORD			; 3EH  End of keyboard buffer (not inclusive
				) 
 = 003E				KB_BUF_END_B	EQU	3EH			;	 Low byte to force short sign-extend encodin
				g 
 003E  00			FD_CAL_ST		FDC_SF <>			; 3EH  Floppy drive recalibration status 
											;	0 = drive not calibrated 
											;	high bit = working interrupt flag 
 003F  00			FD_MOTOR_ST		FDC_MF <>			; 3FH  FD motor status 
											;	high bit = write operation 
 0040  ??			FD_MOTOR_CT		DB	?			; 40H  FD motor shutoff counter (decr. by IN
				T 8) 
 0041  ??			FD_LAST_OP		DB	?			; 41H  BIOS Status of last FD operation 
 0042  ??			FDC_LAST_ST		FDC_CSB <>			; 42H  FDC command status last result (7 byt
				es) 
 0043  ??			
 0044  ??			
 0045  ??			
 0046  ??			
 0047  ??			
 0048  ??			
				
 0049  ??			VID_MODE		DB	?			; 49H  Current video mode 
 004A  ????			VID_COLS		DW	?			; 4AH  Number of screen columns 
 004C  ????			VID_BUF_SZ		DW	?			; 4CH  Size of video regen buffer in bytes 
 004E  ????			VID_SEG		DW	? 			; 4EH  Starting address in video regen buffer (offse
				t)  
 0050  0008[			VID_CURS_POS	DW	8 DUP(?)		; 50H-5FH Cursor position of pages 1-8, high=row, lo
				w=col 
	   ????			
			 ]	
				
 0060  ????			VID_CURS_TYPE	DW	? 			; 60H  Starting (Top), Ending (bottom) scan line for
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-44


				 cursor 
 0062  ??			VID_PAGE		DB	? 			; 62H  Active display page number 
 0063  ????			VID_PORT		DW	?			; 63H  Base port address for active 6845 CRT
				 controller 
 0065  ??			VID_MODE_REG	DB	?			; 65H  6845 CRT mode control register value (port 3x
				8H) 
 0066  ??			VID_COLOR		DB	? 			; 66H  CGA current color palette setting (po
				rt 3D9H) 
 = 001E				L_VID_BDA		EQU	$-VID_MODE		;      Length in bytes of video data in BDA 
 0067				CAS_TIME_CNT	LABEL WORD			; 67H  5150 Cassette: Counter 
 0067  ????			ROM_INIT_SS		DW	?			; 67H   or Temp location for SS:SP during bl
				ock move 
 0069				CAS_CRC		LABEL	WORD			; 69H  5150 Cassette: CRC 
 0069  ????			ROM_INIT_SP 	DW	? 			; 69H	  or Option ROM init 
 006B				CAS_PREV		LABEL	BYTE			; 6BH  5150 Cassette: Previous byte 
				;FE2010_CONF_REG	LABEL BYTE			; 6BH  FE2010A Config Reg (Standard 63H) 
 006B  ??			INT_LAST		DB	? 			; 6BH  Reserved for POST / Interrupt happene
				d? 
 006C  ????			TIMER			TIMER_C <>			; 6CH-70H Timer Counter 
 006E  ????			
 0070  ??			
				
 0071  ??			BIOS_BREAK		DB	?			; 71H  BIOS break flag (high bit means ctrl-
				break) 
 0072  ????			WARM_FLAG		DW	?			; 72H  Warm Boot Flag (1234H to bypass RAM t
				est) 
 0074  ??			HD_LAST_ST		DB 	? 			; 74H  Status of last hard disk operation (s
				ee INT 13,1) 
 0075  ??			HD_COUNT		DB 	? 			; 75H  Number of hard disks attached 
 0076  ??			HD_CTRL		DB 	? 			; 76H  XT fixed disk drive control byte 
 0077  ??			HD_PORT		DB 	? 			; 77H  Port offset to current fixed disk adapter 
 = 0078				LPT_TIME_B		EQU	$-_BDA		;	 Low byte hack to force short sign-extend en
				coding 
 0078  0004[			LPT_TIME		DB	4 DUP(?) 		; 78H  Time-out value for LPT1-4 (in # of 64
				K LOOPs) 
	    ??			
			 ]	
				
 = 007C				COM_TIME_B		EQU	$-_BDA		;	 Low byte hack to force short sign-extend en
				coding 
 007C  0004[			COM_TIME		DB	4 DUP(?) 		; 7CH  Time-out value for COM1-4 
	    ??			
			 ]	
				
 0080  ????			KB_BUF_ST		DW	?			; 80H  Keyboard buffer start 
 0082  ????						DW	?			; 82H  Keyboard buffer end 
 008B						ORG	08BH 
 008B  ??			FD_LR			DB	?			; 8BH  Last diskette data rate selected 
 008F						ORG	08FH 
 008F  00			FD_MODE		FDC_MODE <>			; 8FH  FDC Drive Mode (see FDC_MODE) 
 0090  0004[			FD_MEDIA_ST		FDC_STATE 4 DUP(<>)	; 90H-93H  Drive 0-3 media state 
	   00			
			 ]	
				
 0094  0002[			FD_TRACK		DB	2 DUP(?)		; 94H-95H  Drive 0-1 current track 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-45


	    ??			
			 ]	
				
 0096  00			EKB_FLAGS1		KBFLAGS3 <>			; 96H  Keyboard mode/type (Enhanced) 
 0097  00			EKB_FLAGS2		KBFLAGS4 <>			; 97H  Keyboard LED flags (Enhanced) 
 00A0						ORG	0A0H 
 00A0  ??			RTC_WAIT		DB	?			; A0H  RTC wait function flag 
 00AC						ORG	0ACH				; ACH-B3H "Reserved" (can be used?) 
 00B0						ORG	0B0H				; B0H-B1H (used by Tandy for keyboard) 
 00E8						ORG	0E8H				; E8H-EFH "Reserved" (can be used?) 
 00E8				VID_MEM_SEG_DW	LABEL DWORD			; E8H-EAH Video mem segment using LDS/LES 
 00E8  ????			CURSOR_DEFAULT	DW	?			; E8H  Power on cursor bottom:top scan line (for Tur
				bo) 
 00EA  ????			VID_MEM_SEG		DW	?			; EAH	 Video mem segment (MDA = B000, CGA 
				= B800) 
 00EC  ??			FE2010_CONF_REG	DB	?			; ECH  FE2010A Config Reg (63H) (alternate) 
 00ED  ??						DB	?			; EDH 
 00EE  ????			RTC_DATA		DW	?			; EEH  GLaTICK address and RTC type 
 00F0				_BDA		ENDS 
				 
				;----------------------------------------------------------------------------; 
				; 0050:0000 - BIOS/DOS Data Area 
				;----------------------------------------------------------------------------; 
 0000				_DOS_DAT	SEGMENT AT 50H 
 0000  ??			PTRSCN_ST		DB 	?			; 00H  Print screen status 
 0001  0003[						DB	3  DUP(?)		; 01H  Used by BASIC 
	    ??			
			 ]	
				
 0004  ??						DB	?			; 04H  Floppy drive flag for single 
											;	  drive systems (0=A,1=B) 
 0005  000A[						DB	10 DUP(?)		; 05H  POST work area 
	    ??			
			 ]	
				
 000F  0013[						DB	19 DUP(?)		 
	    ??			
			 ]	
				
 0022  000E[			DOS_FD_PARAM	DB	14 DUP(?)		; 22H  Floppy drive parameter table 
	    ??			
			 ]	
				
 0030  0004[						DB	4  DUP(?)		; 30H  Mode command 
	    ??			
			 ]	
				
 0034				_DOS_DAT	ENDS 
				 
				;----------------------------------------------------------------------------; 
				; 0000:7C00 - IPL / MBR / Boot Block Segment 
				;----------------------------------------------------------------------------; 
 0000				_IPL_SEG	SEGMENT AT 0H 
 7C00						ORG	07C00H 
 7C00  01FE[			IPL_TOP		DB	510 DUP(?)		; MBR code then MBR magic number 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-46


	    ??			
			 ]	
				
 7DFE  ????			IPL_ID		DW	?			; 0AA55H if valid MBR 
 7E00				_IPL_SEG	ENDS 
				 
				;----------------------------------------------------------------------------; 
				; B000:0000 - MDA Video Memory 
				;----------------------------------------------------------------------------; 
 0000				_MDA_MEM	SEGMENT AT 0B000H 
 0000  1000[			MDA_MEM		DB	1000H DUP(?)	; 4KiB (1000H) total MDA memory 
	    ??			
			 ]	
				
 1000				_MDA_MEM	ENDS 
				 
				;----------------------------------------------------------------------------; 
				; B800:0000 - CGA Video Memory 
				;----------------------------------------------------------------------------; 
 0000				_CGA_MEM	SEGMENT AT 0B800H 
 0000  0800[			CGA_MEM_40		DB	0800H DUP(?)	; page 1 of CGA 40 column (2K) 
	    ??			
			 ]	
				
 0800  3800[			CGA_MEM_80		DB	3800H DUP(?)	; pages 1-4 of CGA 80 column (14K) 
	    ??			
			 ]	
				
 = 4000				CGA_MEM_SZ		= SIZE CGA_MEM_40 + SIZE CGA_MEM_80	; 16 KiB (4000H) total CGA memory 
 = 2000				CGA_MEM_FLD 	= CGA_MEM_SZ / 2		;  8 KiB (2000H) CGA memory field 
 4000				_CGA_MEM	ENDS 
				 
				;----------------------------------------------------------------------------; 
				; C000:0000 - Video Option ROM segment 
				;----------------------------------------------------------------------------; 
 0000				_VID_BIOS	SEGMENT AT 0C000H 
 0000  ????			VID_MN		DW	?			; magic number (0AA55H) 
 0002  ??			VID_BIOS_SZ		DB	?			; length in 512 byte blocks 
 0003  ????			VID_VEC		DW	?			; FAR call to ROM init routine 
 0005				_VID_BIOS	ENDS 
				 
				;----------------------------------------------------------------------------; 
				; C800:0000 - Start of Storage/Other Option ROM segment 
				;----------------------------------------------------------------------------; 
 0000				_OPT_ROM	SEGMENT AT 0C800H 
 0000				_OPT_ROM	ENDS 
				 
				;----------------------------------------------------------------------------; 
				; F000:E000 - System BIOS ROM segment map 
				;----------------------------------------------------------------------------; 
 0000				_BIOS		SEGMENT AT 0F000H 
 E000						ORG	0E000H 
 E000				_BIOS_TOP	LABEL WORD 
 E05B						ORG	0E05BH 
 E05B				_BOOT		LABEL WORD				; BIOS boot offset 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-47


 FFF0						ORG	0FFF0H 
 FFF0				_POWER_ON	LABEL WORD				; CPU power-on jump address 
 FFF0				_BIOS		ENDS 
				 
				;----------------------------------------------------------------------------; 
				; F600:0000 - ROM BASIC segment 
				;----------------------------------------------------------------------------; 
 0000				_BASIC	SEGMENT AT 0F600H 
 0000				BASIC_TOP	LABEL WORD 				; ROM BASIC load offset 
 0000				_BASIC	ENDS 
				 
				;----------------------------------------------------------------------------; 
				; FFFF:0000: 8086 power-on reset vector 
				;----------------------------------------------------------------------------; 
				; The x86 CPU begins code excution at hard-coded address FFFF:0000. 
				; This is that address. Welcome to the party! 
				;----------------------------------------------------------------------------; 
 0000				RESET    	SEGMENT AT 0FFFFH 
 0000				__POWER_ON	LABEL	FAR				; FFFF:0000 
 0000				RESET		ENDS 
				 
				;============================================================================; 
				; 
				;				* * *   C O D E   * * *  
				; 
				;============================================================================; 
				 
				;----------------------------------------------------------------------------; 
				; Main BIOS ROM begins 
				;----------------------------------------------------------------------------; 
				; Note: Memory space from F000:0000 - F000:E05A is available, though a 
				; BIOS identifier string is typically at or near the top of this segment 
				;----------------------------------------------------------------------------; 
						ASSUME	DS:BIOS, SS:BIOS, CS:BIOS, ES:BIOS 
 0000				BIOS    	SEGMENT 
				 
				;----------------------------------------------------------------------------; 
				; F000:FFF0: 8086 power-on reset vector 
				;----------------------------------------------------------------------------; 
				; The x86 CPU begins code excution at hard-coded address FFFF:0000. 
				; This is that address. Welcome to the party! 
				;----------------------------------------------------------------------------; 
 FFF0						ORG	0FFF0H 
 FFF0				POWER_ON	PROC	FAR 
 FFF0  EA E05B ---- R			JMP	FAR	PTR _BOOT 		; always jump to power on routine 
				 
 FFF5						ORG	0FFF5H 
 FFF5  30 31 2F 31 38 2F 32	REL_DATE 	DB	VER_DATE		; Release date 
       35			
				 
 FFFE						ORG	0FFFEH 
 FFFE  FE			ISA_TYPE	DB	ARCH_ID		; Architecture model 
				 
 FFFF						ORG	0FFFFH		; BIOS ROM checksum byte  
 FFFF  ??					DB	?			; (computed at build time) 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-48


 00010000			POWER_ON	ENDP 
				 
				;----------------------------------------------------------------------------; 
				; F000:E000: Top of BIOS ROM 8K segment 
				;----------------------------------------------------------------------------; 
 E000						ORG	0E000H 
 E000				BIOS_TOP	PROC	NEAR 
				 
 E000  0A			TOP_BANNER	DB	LF 
 E001  47 4C 61 42 49 4F 53			DB	VER_NAME, ' [', HEART, '] ' 
       20 5B 03 5D 20		
								IF RANDOM_TAGLINE EQ 1 
 E00D  00					DB	0				; null terminate BANNER string 
								ENDIF 
 E00E  54 68 65 20 68 65 72	TAG0		DB	"The hero we need but don't deserve" 
       6F 20 77 65 20 6E 65	
       65 64 20 62 75 74 20	
       64 6F 6E 27 74 20 64	
       65 73 65 72 76 65	
								IF RANDOM_TAGLINE EQ 1 
 E030  00					DB	0				; null terminate TAG0 string 
								ENDIF 
 E031  0D 0A			COPYRIGHT	DB	CR, LF 
 E033  28 43 29 20 32 30 32			DB	'(C) ', COPY_YEAR, ' ' 
       32 2D 32 35 20		
 E03F  36 34 30 4B 42 20 52			DB	'640KB Released under GPLv3' 
       65 6C 65 61 73 65 64	
       20 75 6E 64 65 72 20	
       47 50 4C 76 33		
 E059  0A					DB	LF 
 E05A  00					DB	0 
				 
 E05B				BIOS_TOP 	ENDP 
				 
				; 
				; 0 BYTES HERE 
				; 
				BYTES_HERE	BOOT 
 = 0000                      1	BYTES_HERE_BOOT = BOOT-$ 
			     1			IFDEF BYTES_HERE_BOOT 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
							ASSUME CS:BIOS, DS:NOTHING, ES:NOTHING, SS:NOTHING 
				;----------------------------------------------------------------------------; 
				; F000:E05B: Beginning of boot execution 
				;----------------------------------------------------------------------------; 
				; Loosely follow these specs for BIOS POST operations: 
				; 
				; http://minuszerodegrees.net/5160/post/5160%20-%20POST%20-%20Detailed%20breakdown.htm 
				; http://minuszerodegrees.net/5150/post/5150%20-%20POST%20-%20Detailed%20breakdown.htm 
				; https://stanislavs.org/helppc/cold_boot.html 
				; http://philipstorr.id.au/pcbook/book1/post.htm 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-49


				;----------------------------------------------------------------------------; 
 E05B						ORG	0E05BH 
 E05B				BOOT	PROC	NEAR 
 E05B  FA				CLI 					; disable CPU interrupts 
 E05C  FC				CLD					; clear direction flag 
				 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; POST Hardware/System Tests 
				;----------------------------------------------------------------------------; 
				 
 E05D				POST_CPU_TEST: 
				;----------------------------------------------------------------------------; 
				; [1] Test and clear all CPU Registers 
				;----------------------------------------------------------------------------; 
				; Check and set all registers to 0. 
				; 
				; On Failure: 2 short and 1 long beep 
				;----------------------------------------------------------------------------; 
							ASSUME DS:_BDA_ABS, ES:_IVT 
 E05D  B8 731D				MOV	AX, RAM_TEST		; use the standard test pattern 
 E060				CPU_REG_TEST: 
 E060  8B D8				MOV	BX, AX			; the game of telephone 
 E062  8E DB				MOV	DS, BX			;  pass a 
 E064  8C D9				MOV	CX, DS			;  known value 
 E066  8E C1				MOV	ES, CX			;  through all 
 E068  8C C6				MOV	SI, ES			;  registers and 
 E06A  8E D6				MOV	SS, SI			;  ensure the 
 E06C  8C D7				MOV	DI, SS			;  same value 
 E06E  8B EF				MOV	BP, DI			;  makes it all 
 E070  8B E5				MOV	SP, BP			;  the way 
 E072  8B D4				MOV	DX, SP			;  to the end 
 E074  F7 C2 8CE2			TEST	DX, NOT RAM_TEST		; expected result? 
 E078  B3 21				MOV	BL, BEEP_SL <2,1>		; on Failure: 2 short and 1 long beep 
 E07A  75 74				JNZ	HALT_ERROR 
 E07C  33 C0				XOR	AX, AX 			; otherwise repeat with AX = 0 
 E07E  85 D2				TEST	DX, DX			; if zero it was second pass 
 E080  75 DE				JNZ	CPU_REG_TEST		; Loop again to zero all registers 
 E082				CPU_REG_PASS: 
				 
				;----------------------------------------------------------------------------; 
				; [1B] A brief test of flags and CPU instructions 
				;----------------------------------------------------------------------------; 
				; On Failure: 2 short and 1 long beep 
				;----------------------------------------------------------------------------; 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; [2] Disable non-maskable interrupts (NMIs) 
				;----------------------------------------------------------------------------; 
 E082				DISABLE_NMI: 
 E082  E6 A0				OUT	NMI_R0, AL			; write AL = 0 to NMI register port 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-50


				; [3] Set Zero Page Register for DMA channels 0 and 1 
				;----------------------------------------------------------------------------; 
 E084  E6 83				OUT	DMA_P_C1, AL 		; AL = high nibble of segment for DMA (0) 
				 
				;----------------------------------------------------------------------------; 
				; [4] Disable MDA/CGA adapters (for now) 
				;----------------------------------------------------------------------------; 
 E086				INIT_VIDEO: 
 E086  BA 03D8				MOV	DX, CGA_CTRL		; DX = 03D8H 
 E089  EE				OUT	DX, AL 			; send Disable to CGA Mode Select Register 
 E08A  40				INC	AX 				; clear MDA control, disable video signal 
 E08B  B2 B8				MOV	DL, LOW MDA_CTRL		; DX = 03B8H 
 E08D  EE				OUT	DX, AL 			; send to MDA CRT Control Port 
					POST_CODE				; optionally display 01 on POST card 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Set up POST flags in BP 
				;----------------------------------------------------------------------------; 
 E08E  81 3E 0472 R 1234		CMP	WARM_FLAG_ABS, WARM_BOOT 
 E094  75 03				JNZ	POST_FLAG_DONE 
 E096  BD 8000				MOV	BP, MASK WARM		; clear and set POST warm boot flag 
 E099				POST_FLAG_DONE: 
				 
							IF RANDOM_TAGLINE EQ 1 
				;----------------------------------------------------------------------------; 
				; Read PIT for seed of random pithy tagline 
				;----------------------------------------------------------------------------; 
 E099  48				DEC	AX				; Counter 0, Latch (00b) 
 E09A  E6 43				OUT	PIT_CTRL, AL		; write command to CTC 
 E09C  E4 40				IN	AL, PIT_CH0			; read low byte of Counter 0 latch 
 E09E  D0 E8				SHR	AL, 1				; low bit is always 0 
 E0A0  24 03				AND	AL, MASK GRND		; use only last two bits 
 E0A2  0B E8				OR	BP, AX			; save to low bits of BP 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Setup SS = CS 
				;----------------------------------------------------------------------------; 
				; Set up temporary stack to point at ROM to enable CALL_NS MACRO 
				;----------------------------------------------------------------------------; 
 E0A4  8C CA				MOV	DX, CS 			; DX = 0F000h (BIOS segment) 
 E0A6  8E D2				MOV	SS, DX			; SS = temp boot stack in CS 
				 
				;----------------------------------------------------------------------------; 
				; [5] Setup 8255 PPI to normal operating state 
				;----------------------------------------------------------------------------; 
				; Normal operation: Mode 0, Ports A,C (U and L) as INPUT, Port B as OUTPUT 
				;----------------------------------------------------------------------------; 
 E0A8				RESET_PPI: 
							ELSE 
 E0A8  B0 99				MOV	AL, PPI_CR <>		; set 8255 A,C to INPUT, B to OUTPUT 
							ENDIF 
 E0AA  E6 63				OUT	PPI_CW, AL 			; send to PPI control port (63H) 
				 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-51


				;----------------------------------------------------------------------------; 
				; Set up PPI port B 
				; 
 E0AC  B0 AC				MOV	AL, PPI_B_BOOT		; KB hold low+disable, NMI on, spkr off 
 E0AE  E6 61				OUT	PPI_B, AL			; send to 8255 Port B 
				 
							ENDIF			; ENDIF ARCH_TD3300 
				 
							ENDIF			; ENDIF ARCH_LASER 
				 
				;			IF (ARCH_TYPE EQ ARCH_EMU) AND (ARCH_SUB_TYPE EQ ARCH_MIST) 
				;----------------------------------------------------------------------------; 
				; Set up Turbo mode for PCXT_MiSTer 
				; 
				;	MOV	DX, MC_PORT			; DX = XTCTL port 
				;	IN	AL, DX			; read current speed 
				;	AND	AL, NOT MCSP_SPD		; clear speed bits 
				;			IF BOOT_SPEED EQ BOOT_TURBO 
				;	OR	AL, MC_XTCTL <MCSP_AT4>	; boot to AT 4MHz 
				;			ELSE 
				;	OR	AL, MC_XTCTL <,,,,MCSP_5> ; boot to XT 5MHz 
				;			ENDIF 
				;	OUT	DX, AL			; set new speed 
				;	MOV	DX, SS			; restore DX 
				;			ENDIF			; ARCH_MIST 
				 
							IF POST_TEST_CHK_ROM EQ 1 
				;----------------------------------------------------------------------------; 
				; [8] Checksum (8 bit) the main ROM to ensure it is not corrupt 
				;----------------------------------------------------------------------------; 
				; Input: AH = 0, BL = 21h, CX = 0, DX = 0F000h 
				; On Failure: 2 long and 2 short beeps 
				;----------------------------------------------------------------------------; 
					JWB	CHECKSUM_OK			; skip on warm boot 
			     1				IF WARM_ENABLE EQ 1 
 E0B0  85 ED                 1		TEST	BP, BP				; is warm boot? 
 E0B2  78 11                 1		JS	CHECKSUM_OK					; jump if so 
			     1				ENDIF 
 E0B4				CHECKSUM_ROM: 
							ASSUME DS:BIOS 
 E0B4  43				INC	BX				; on failure, 2 short and 2 long beeps 
 E0B5  8E DA				MOV	DS, DX			; DS to 0F000h BIOS segment 
 E0B7  BE E000 R			MOV	SI, OFFSET BIOS_TOP 	; offset to top of BIOS ROM 
 E0BA  B5 10				MOV	CH, HIGH KBW < 8 >	; checksum 8KB (in 2 byte words) 
 E0BC				CHECKSUM: 
 E0BC  AD				LODSW 				; next two bytes into AL and AH 
 E0BD  02 D0				ADD	DL, AL			; DL = accumulator for sum 
 E0BF  02 D4				ADD	DL, AH			; ZF if sum is 0 
 E0C1  E2 F9				LOOP	CHECKSUM 			; loop through entire ROM 
 E0C3  75 2B				JNZ	HALT_ERROR			; if sum not 0, fail 
 E0C5				CHECKSUM_OK: 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; [9] Disable the 8237 DMA controller chip. 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-52


				;----------------------------------------------------------------------------; 
 E0C5				INIT_DMA1: 
 E0C5  B0 04				MOV	AL, MASK DDIS		; Set Controller Disable bit 
 E0C7  E6 08				OUT	DMA_CMD, AL 		; write to DMA Command Register 
				 
							IF POST_TEST_PIT_1 EQ 1 
				;----------------------------------------------------------------------------; 
				; [10] Test Channel #1 on 8253 timer chip. 
				;----------------------------------------------------------------------------; 
				; Channel #1 on 8253 timer chip. Channel #1 is used in RAM refresh process.   
				; If the test fails, beep failure code 
				; 
				; Test that all data lines are working by reading counter and checking  
				; that all bits from counter go both high and low. 
				;----------------------------------------------------------------------------; 
				; Use 16-bit mode to test low three address lines using high byte of counter. 
				; This avoids a situation where the read counter code is a binary multiple 
				; of the counter causing a bit to not be observed as changing. 
				; 
				; Control Word Counter 1 (port 43H) - System Timer: 
				;  01 		- SC: Select Counter 1 
				;    11		- RW: Read/Write 2xR/2xW 
				;      010		- M:  Mode 2, Rate Gen 
				;         0		- BCD: 0 
				; 
				; Output: Success SI and DI = 0, Failure 3 short, 2 long beeps 
				;----------------------------------------------------------------------------; 
						IF DRAM_REFRESH GT 0	; is DRAM refresh enabled? 
 E0C9  B0 74				MOV	AL, PIT_CW <1, 11B, 2>	; Control Word: Counter 1 
										;   Format: R/W low/high byte: 11b 
										;   Mode: 2 Rate Gen, BCD: 0 
 E0CB  BA 0041				MOV	DX, LOW PIT_CH1		; DX = PIT channel 1 
						ENDIF 
 E0CE  E6 43				OUT	PIT_CTRL, AL		; set Counter mode 
 E0D0  EE				OUT	DX, AL			; set low byte (any value) 
 E0D1  BE 07F8				MOV	SI, 0FFH SHL 3		; flag bits 10-3 for 1 check 
 E0D4  BF F807				MOV	DI, NOT 0FFH SHL 3	; flag bits 10-3 for 0 check 
 E0D7  EE				OUT	DX, AL			; set high byte (any value) 
 E0D8				INIT_PIT1_TEST: 
 E0D8  85 FF				TEST	DI, DI			; have all bits flipped to 0? 
 E0DA  75 04				JNZ	INIT_PIT1_TEST_READ	; if not, keep reading PIT 
 E0DC  46				INC	SI				; have all bits flipped to 1? 
 E0DD  74 13				JZ	INIT_PIT1_TEST_DONE	; if so, success 
 E0DF  4E				DEC	SI				; if not, undo INC and keep reading PIT 
 E0E0				INIT_PIT1_TEST_READ: 
						IF DRAM_REFRESH GT 0	; is DRAM refresh enabled? 
 E0E0  B0 40				MOV	AL, PIT_CW <1,0>		; latch Counter 1 command 
						ENDIF 
 E0E2  E6 43				OUT	PIT_CTRL, AL		; write command to CTC 
 E0E4  EC				IN	AL, DX			; read timer LSB 
 E0E5  8A E0				MOV	AH, AL			; save LSB 
 E0E7  EC				IN	AL, DX			; read timer MSB 
 E0E8  23 F8				AND	DI, AX			; clear all lines read as 0 
 E0EA  0B F0				OR	SI, AX			; set all lines read as 1 
 E0EC  E2 EA				LOOP	INIT_PIT1_TEST		; loop until timeout 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-53


 E0EE  B3 32				MOV	BL, BEEP_SL <3,2>		; beep pattern (3 short, 2 long) 
 E0F0				HALT_ERROR: 
 E0F0  EB 63				JMP	SHORT HALT_BEEP_1		; NEAR jump for POST errors 
							ENDIF 
				 
 E0F2				INIT_PIT1_TEST_DONE: 
				 
				;----------------------------------------------------------------------------; 
				; [9B] 8253 PIT Programmable Interval Timer Initialization Channel 1 
				;----------------------------------------------------------------------------; 
				; Counter 1 - DRAM Refresh 
				;----------------------------------------------------------------------------; 
 E0F2				INIT_PIT1: 
							ELSE 
				;----------------------------------------------------------------------------; 
				; Program PIT with single byte 
				; 
 E0F2  B0 54				MOV	AL, PIT_CW <1, 01B, 2>	; Control Word: Select Counter(SC): 1 
										;   Format(RW): 01b (R/W byte LE) 
										;   Mode(M): 2 (Rate Gen), BCD: 0 (Binary) 
 E0F4  E6 43				OUT	PIT_CTRL, AL		; set Counter mode 
				 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; [12] Reset, Clear and test DMA Offset and Block Size Registers 
				;----------------------------------------------------------------------------; 
				; - Master Reset of DMA controller 
				; - Test 8237 DMA Address/Count Register channels 0-3 
				;----------------------------------------------------------------------------; 
 E0F6  E6 0D				OUT	DMA_RESET, AL 		; Master Reset (send any value of AL) 
				 
							IF POST_TEST_DMA EQ 1 
 E0F8  B4 08				MOV	AH, 8				; test 8 ports 
 E0FA  99				CWD					; starting at port 00H 
					CALL_NS  PORT_TEST		; ZF and CX = 0 if pass, NZ if failed 
 E0FB  BC E101 R             1		MOV	SP, OFFSET ??0001 
			     1				ELSE 
 E0FE  E9 E7EB R             1		JMP	PORT_TEST 
			     1				ENDIF 
 E101                        1	??0001: 
 E101  E103 R                1		DW	OFFSET ??0002 
 E103                        1	??0002: 
 E103  B3 42				MOV	BL, BEEP_SL <4,2>		; beep pattern (4 short, 2 long) 
 E105  75 E9				JNZ	HALT_ERROR 
 E107				DMA_PASS: 
 E107  E6 0D				OUT	DMA_RESET, AL 		; master reset of DMA again 
							ENDIF			; POST_TEST_DMA 
				 
							IF DRAM_REFRESH GT 0 
				;----------------------------------------------------------------------------; 
				; [13] Set Counter DMA Channel 0 for memory refresh 
				;----------------------------------------------------------------------------; 
				; https://www.reenigne.org/blog/how-to-get-away-with-disabling-dram-refresh/ 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-54


 E109  B0 FF				MOV	AL, 0FFH			; Memory refresh counter (16-bit) is 0FFFFH 
 E10B  E6 01				OUT	DMA_0_C, AL			; write low order bits 
 E10D  90				NOP					; very short I/O delay 
 E10E  E6 01				OUT	DMA_0_C, AL			; write high order bits 
				 
				;----------------------------------------------------------------------------; 
				; [13] Set Mode DMA Channel 0 
				;----------------------------------------------------------------------------; 
				; 01 			; Mode 1 (Single) 
				;   0 		; INC: address decrement 
				;    1 		; Auto-initialization 
				;     10 		; type: Read from memory (2) 
				;       00 		; Channel 0 
				;----------------------------------------------------------------------------; 
 E110  B0 58				MOV	AL, DMA_MR <1,0,1,2,0> 
 E112  E6 0B				OUT	DMA_MODE, AL		; write to DMA Mode Register 
				 
				;----------------------------------------------------------------------------; 
				; [13B] 8253 Timer set channel #1 for DMA/DRAM refresh 
				;----------------------------------------------------------------------------; 
 E114  B0 12				MOV	AL, LOW DRAM_REFRESH	; set low byte of divisor 
 E116  E6 41				OUT	PIT_CH1, AL			;  
								ENDIF 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; [13C] Enable DMA and clear mask register on Channels 0-3 
				;----------------------------------------------------------------------------; 
 E118  B0 00				MOV	AL, DMA_CR <>		; Set Controller Enable bit 
 E11A  E6 08				OUT	DMA_CMD, AL 		; write to DMA Command Register 
 E11C  B1 03				MOV	CL, 3				; Set mode on Channels 1-3 for [13D] 
										;  (and I/O delay between OUTs) 
 E11E  E6 0A				OUT	DMA_MASK, AL		; clear mask (enable) on all channels 
				 
				;----------------------------------------------------------------------------; 
				; [13D] Set default Mode for DMA Channels 1-3 
				;----------------------------------------------------------------------------; 
				; 01 			; Mode 1 (Single) 
				;   0 		; INC: address decrement 
				;    0 		; No Auto-initialization 
				;     00 		; type: Verify (0) 
				;       xx 		; Channels 1-3 
				; 
				; Input: CL = 3 (from [13C]), CH = 0 (from CALL_NS in [12]) 
				;----------------------------------------------------------------------------; 
 E120  B0 41				MOV	AL, DMA_MR <1,0,0,0,1>	; start with channel 1 
 E122				DMA_SETUP_CH: 
 E122  E6 0B				OUT	DMA_MODE, AL		; write to DMA Mode Register 
 E124  40				INC	AX				; next channel 
 E125  E2 FB				LOOP	DMA_SETUP_CH		; (delay 13-17 clocks between OUTs) 
				 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; [15] Test and zero first 16KB of RAM 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-55


				;----------------------------------------------------------------------------; 
				; This is necessary to utilize the BIOS Data Area and a usable stack 
				; 
				; Parity bits are in an indeterminate state on power up so parity check must 
				; be disabled until memory is written once. 
				; 
				; On failure: 
				; - Read/Write Error: 1 short, 3 long beeps 
				; - Parity Error: 1 short, 4 long beeps 
				; 
				; Input: CX = 0 from [13D] 
				;----------------------------------------------------------------------------; 
							ASSUME DS:_BDA_ABS, ES:_IVT 
 E127				BASE_RAM_TEST: 
 E127  E4 61				IN	AL, PPI_B 				; AL = PB0 flags 
 E129  0C 30				OR	AL, MASK PBIO OR MASK PBPC	; disable RAM parity and I/O ch. flags 
 E12B  E6 61				OUT	PPI_B, AL 
 E12D  91				XCHG	AX, CX				; AX = 0 = MEM_CHECK pattern and 
 E12E  8E D8				MOV	DS, AX				; DS and ES = IVT segment 0000 
 E130  BE 0472 R			MOV	SI, OFFSET WARM_FLAG_ABS	; SI = warm boot flag offset 
 E133  8B 14				MOV	DX, [SI]				; save warm boot flag 
					CALL_NS  MEM_CHECK			; clear memory and parity bits 
 E135  BC E13B R             1		MOV	SP, OFFSET ??0003 
			     1				ELSE 
 E138  E9 E671 R             1		JMP	MEM_CHECK 
			     1				ENDIF 
 E13B                        1	??0003: 
 E13B  E13D R                1		DW	OFFSET ??0004 
 E13D                        1	??0004: 
 E13D  75 14				JNZ	BASE_RAM_ERROR 
 E13F  E4 61				IN	AL, PPI_B				; read PPI channel B 
 E141  0C 10				OR	AL, MASK PBPC 			; clear MB RAM parity flag only 
 E143  E6 61				OUT	PPI_B, AL 
 E145  24 EF				AND	AL, NOT MASK PBPC 		; enable MB RAM parity for test 
 E147  E6 61				OUT	PPI_B, AL 
					CALL_NS  MEM_ADDR_TEST			; test address lines 
 E149  BC E14F R             1		MOV	SP, OFFSET ??0005 
			     1				ELSE 
 E14C  E9 E640 R             1		JMP	MEM_ADDR_TEST 
			     1				ENDIF 
 E14F                        1	??0005: 
 E14F  E151 R                1		DW	OFFSET ??0006 
 E151                        1	??0006: 
 E151  74 05				JZ	BASE_RAM_ZERO			; continue if no errors 
 E153				BASE_RAM_ERROR: 
 E153  B3 13				MOV	BL, BEEP_SL <1,3>			; on failure, 1 short and 3 long beeps 
 E155				HALT_BEEP_1: 
 E155  E9 E874 R			JMP	HALT_BEEP				; NEAR jump to HALT BEEP PROC 
 E158				BASE_RAM_ZERO: 
 E158  B8 731D				MOV	AX, RAM_TEST			; test pattern 
					CALL_NS  MEM_CHECK			; write and verify test pattern 
 E15B  BC E161 R             1		MOV	SP, OFFSET ??0007 
			     1				ELSE 
 E15E  E9 E671 R             1		JMP	MEM_CHECK 
			     1				ENDIF 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-56


 E161                        1	??0007: 
 E161  E163 R                1		DW	OFFSET ??0008 
 E163                        1	??0008: 
 E163  75 EE				JNZ	BASE_RAM_ERROR			; ZF and AX = 0 if okay 
					CALL_NS  MEM_CHECK			; write and verify zeros 
 E165  BC E16B R             1		MOV	SP, OFFSET ??0009 
			     1				ELSE 
 E168  E9 E671 R             1		JMP	MEM_CHECK 
			     1				ENDIF 
 E16B                        1	??0009: 
 E16B  E16D R                1		DW	OFFSET ??000A 
 E16D                        1	??000A: 
 E16D  75 E4				JNZ	BASE_RAM_ERROR 
 E16F  87 14				XCHG	[SI], DX				; restore warm boot flag, DX = 0 
 E171  40				INC	AX					; AL = 1 
 E172  A2 0440 R			MOV	FD_MOTOR_CT_ABS, AL 		; set motor to turn off on next tick 
							IF RAM_PARITY EQ 1 
 E175  E4 62				IN	AL, PPI_C				; read PPI channel C 
 E177  24 80				AND	AL, MASK PCPE			; check MB RAM parity flag 
 E179  74 04				JZ	BASE_RAM_TEST_DONE		; either set? 
 E17B  B3 14				MOV	BL, BEEP_SL <1,4>			; Halt with 1 short beep, 4 long beeps 
 E17D  EB D6				JMP	SHORT HALT_BEEP_1 
 E17F				BASE_RAM_TEST_DONE: 
 E17F  E4 61				IN	AL, PPI_B 
 E181  0C 30				OR	AL, MASK PBIO OR MASK PBPC	; disable RAM parity and I/O ch. flags 
 E183  E6 61				OUT	PPI_B, AL 
							ENDIF				; END RAM_PARITY EQ 1 
				 
				;----------------------------------------------------------------------------; 
				; 
				; YAY! It's now okay to use the first 16KB of RAM: 0000:0000-0000:1FFF 
				; 
				;----------------------------------------------------------------------------; 
				 
				;----------------------------------------------------------------------------; 
				; [18] Setup BOOT R/W stack memory segment 
				;----------------------------------------------------------------------------; 
							ASSUME SS:_BOOT_STACK 
 E185  B8 ---- R			MOV	AX, SEG STACK_TOP 		; SS:SP to temp boot stack 0030:0100 
 E188  8E D0				MOV	SS, AX 
 E18A  BC 0100 R			MOV	SP, OFFSET STACK_TOP 
				 
				;----------------------------------------------------------------------------; 
				; [19] 8259A PIC Interrupt controller Initialization 
				;----------------------------------------------------------------------------; 
				; PIC chip Initialization as follows: 
				; 
				; ICW1: 
				;     1 		- D4:   1 = ICW1 (and Port 0) 
				;      0 		- LTIM: 0 = Edge Triggered Mode (low to high TTL transition) 
				;       0 		- ADI:  0 = Call Address Interval of 8 
				;        1 		- SNGL: 1 = Single mode (no cascading PICs or ICW3) 
				;         1		- IC4:  1 = ICW4 Needed 
				;----------------------------------------------------------------------------; 
				; ICW2: 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-57


				;  00001 		- T7-T3: Interrupt Vector Address: 
				;				INT = INT | 8 -> IRQ 0-7 to CPU INT 8-15 
				;       000 	- D2-D0: unused on 8086 mode 
				;----------------------------------------------------------------------------; 
				; ICW4: 
				;     0		- SFNM: 0 = Not Special Fully Nested Mode 
				;      10		- BUF:  2 = Buffered Mode/Slave 
				;        0		- AEOI: 0 = normal EOI 
				;         1		- uPM:  1 = 8086 system 
				;----------------------------------------------------------------------------; 
 E18D  B2 20				MOV	DL, LOW INT_P0		; DX = PIC Port 0 
 E18F  B0 13				MOV	AL, ICW1 <1,0,0,1,1>	; AL = ICW1 - Port 0 
 E191  EE				OUT	DX, AL 
 E192  42				INC	DX				; DX = PIC Port 1 
 E193  B8 0108				MOV	AX, DBW <1,ICW2 <1>> 	; AL = ICW2 - Port 1, AH = PORT_TEST count 
 E196  EE				OUT	DX, AL 
 E197  40				INC	AX				; AL = ICW4 <0,2,0,1> - Port 1 
 E198  EE				OUT	DX, AL 
				 
							IF POST_TEST_PIC_REG EQ 1 
				;----------------------------------------------------------------------------; 
				; [22] 8259A PIC Test 
				;----------------------------------------------------------------------------; 
				; - Read and write registers (IMR) and verify result 
				;----------------------------------------------------------------------------; 
 E199  E8 E7EB R			CALL	PORT_TEST			; test of PIC IMR register 
 E19C  B3 52				MOV	BL, BEEP_SL <5,2>		; beep error 5 short, 2 long 
 E19E  74 02				JZ	PIC_REG_PASS 
 E1A0				PIC_INT_FAIL: 
 E1A0  EB B3				JMP	SHORT HALT_BEEP_1 
 E1A2				PIC_REG_PASS: 
 E1A2  4A				DEC	DX				; DX = Port 1 (0021h) 
							ENDIF			; IF POST_TEST_PIC_REG EQ 1 
				 
 E1A3  B0 FF				MOV	AL, OCW1 <1,1,1,1,1,1,1,1> ; OCW1 - mask all interrupts (for now) 
 E1A5  EE				OUT	DX, AL			; write IMR to PIC 
				 
							IF POST_TEST_PIC_INT EQ 1 
				;----------------------------------------------------------------------------; 
				; - Set up test interrupt handler for all interrupts 
				; 
 E1A6				PIC_INT_TEST: 
 E1A6  B1 1F				MOV	CL, 1FH			; 0 - 1EH BIOS vectors (LOW L_VECTOR_TABLE) 
 E1A8  33 FF				XOR	DI, DI			; DI = beginning to IVT 
 E1AA				PIC_VECT_TMP_LOOP: 
 E1AA  B8 FF23 R			MOV	AX, OFFSET INT_IRQ	; offset for handler 
 E1AD  AB				STOSW					; write to IVT (ES=0000 from CPU_REG_TEST) 
 E1AE  8C C8				MOV	AX, CS			; segment for handler (BIOS) 
 E1B0  AB				STOSW					; write to IVT 
 E1B1  E2 F7				LOOP	PIC_VECT_TMP_LOOP 
				 
				;----------------------------------------------------------------------------; 
				; - Mask all interrupts and ensure none are received 
				; Input: AL = 0 (from MOV AX, CS) 
				; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-58


 E1B3  BF 046B R			MOV	DI, OFFSET INT_LAST_ABS 
 E1B6  88 05				MOV	[DI], AL			; clear last interrupt flag 
 E1B8  FB				STI					; enable interrupts 
					IO_DELAY				; wait for it... 
 E1B9                        1	??000B: 
 E1B9  E2 FE                 1		LOOP	??000B					; long delay for I/O 
 E1BB  FA				CLI 
 E1BC  43				INC	BX				; beep error 5 short, 3 long 
 E1BD  08 05				OR	[DI], AL			; did any interrupts happen? 
				 
							IF POST_TEST_PIC_REG EQ 1 
 E1BF  75 DF				JNZ	PIC_INT_FAIL 
							ENDIF			; IF POST_TEST_PIC_REG EQ 1 
							ENDIF			; IF POST_TEST_PIC_INT EQ 1 
				 
 E1C1  B0 FE				MOV	AL, NOT MASK IRQ0		; OCW1 - unmask timer 
 E1C3  EE				OUT	DX, AL			; write IMR to PIC 
				 
 E1C4				PIC_INT_PASS: 
				 
				;----------------------------------------------------------------------------; 
				; [23] Setup Channel #0 on 8253 timer chip. 
				;----------------------------------------------------------------------------; 
				; Control Word Counter 0 (port 43H) - System Timer: 
				;  00 		- SC: Select Counter 0 
				;    11		- RW: Read/Write 2xR/2xW 
				;      011		- M:  Mode 3, Square Wave 
				;         0		- BCD: 0 
				;----------------------------------------------------------------------------; 
 E1C4  B0 36				MOV	AL, PIT_CW <0, 11B, 3>	; Control Word: Select Counter(SC): 1 
										;   Format(RW): 11b (Read/Write 2xR/2xW) 
										;   Mode(M): 2 (Rate Gen), BCD: 0 (Binary) 
 E1C6  E6 43				OUT	PIT_CTRL, AL 
 E1C8  0E				PUSH	CS				; I/O delay and set up for DS = CS below 
				 
				;----------------------------------------------------------------------------; 
				; This is what generates IRQ 0 (system timer). 
				; Timer set channel #0 output to a square wave of approx. 18.2 Hz based on 
				;	f = 1,193,181.81 / 10000H = ~ 18.2Hz 
				; Reload counter to WORD (0) to port 40H 
				; 
 E1C9  32 C0				XOR	AL, AL			; reload counter is 2^16 (0) ~ 18.2Hz 
 E1CB  E6 40				OUT	PIT_CH0, AL	  		; send low byte 
 E1CD  1F				POP	DS				; I/O delay and set DS = CS 
 E1CE  E6 40				OUT	PIT_CH0, AL 		; send high byte 
				 
				;----------------------------------------------------------------------------; 
				; [25] Setup default BIOS interrupt vectors (00h - 01Eh) 
				;----------------------------------------------------------------------------; 
				; All segments are set to BIOS (CS) segment by default. 
				; INT 1Fh is skipped and left as 0000:0000. 
				; Exceptions (such as ROM BASIC) are reset below. 
				; Input: ES = 0000 from CPU_REG_TEST 
				;----------------------------------------------------------------------------; 
							ASSUME DS:BIOS, ES:_IVT 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-59


 E1D0				INIT_SW_INT_VECTORS: 
 E1D0  8C C8				MOV	AX, CS 			; AX to BIOS segment 
 E1D2  B1 1F				MOV	CL, 1FH			; 0 - 1EH BIOS vectors (LOW L_VECTOR_TABLE) 
 E1D4  33 FF				XOR	DI, DI			; DI = beginning to IVT 
 E1D6  BE FEE3 R			MOV	SI, OFFSET VECTOR_TABLE 
 E1D9				BIOS_INT_VECTORS_LOOP: 
 E1D9  A5				MOVSW 				; copy vector offset to IVT 
 E1DA  AB				STOSW 				; write BIOS/CS segment 
 E1DB  E2 FC				LOOP	BIOS_INT_VECTORS_LOOP	; loop and set CX = 0 
				 
							IF BASIC_ROM EQ 1 
				;----------------------------------------------------------------------------; 
				; Check for valid BASIC ROMs and set INT 18H vector if detected 
				;----------------------------------------------------------------------------; 
				; - Scan 4 x 8K ROMs starting at seg 0F600h. 
				; - BASIC dectected if for all ROMs, all of the folowing are true: 
				; 	- first two bytes not option ROM (0AAFFh) 
				;	- first two bytes not the same as the previous ROM (this checks to 
				;		 make sure are not all 0000 or FFFF) 
				;	- 8K ROM block has a valid checksum at offset 1FFE 
				;----------------------------------------------------------------------------; 
							ASSUME DS:_BASIC 
 E1DD				INIT_ROM_BASIC_SEG: 
 E1DD  BB ---- R			MOV	BX, SEG _BASIC 			; BX = BASIC SEG in ROM 
 E1E0  8B F3				MOV	SI, BX				; SI = save first BASIC SEG 
 E1E2  BF AA55				MOV	DI, MAGIC_WORD			; start with a negative check result 
 E1E5  B1 04				MOV	CL, 4					; checksum 4 x 8K ROMs 
 E1E7				CHECK_BASIC_ROM: 
 E1E7  8E DB				MOV	DS, BX				; set DS to current segment 
 E1E9  A1 0000 R			MOV	AX, BASIC_TOP			; AX = first two bytes of ROM 
 E1EC  3D AA55				CMP	AX, MAGIC_WORD			; is an option ROM? 
 E1EF  74 18				JE	INIT_ROM_BASIC_DONE		; if so, not ROM BASIC 
 E1F1  97				XCHG	AX, DI				; save last ROM's header to DI 
 E1F2  3B C7				CMP	AX, DI				; is same as last ROM? 
 E1F4  74 13				JE	INIT_ROM_BASIC_DONE		; if so, valid ROM not present 
 E1F6  B0 10				MOV	AL, KB < 8 > / 512 		; 8K ROM size (in 512B blocks) 
 E1F8  80 C7 02				ADD	BH, HIGH KBP < 8 >		; BX = next BASIC 8K ROM segment 
 E1FB  E8 E588 R			CALL	ROM_CHECKSUM 			; checksum ROM at DS:0, size AL 
 E1FE  E1 E7				LOOPZ	CHECK_BASIC_ROM			; loop 4 ROMs or checksum fail 
 E200  75 07				JNZ	INIT_ROM_BASIC_DONE		; if NZ, checksum failed 
				 
				;----------------------------------------------------------------------------; 
				; BASIC ROM detected - set as INT 18h in IVT 
				; 
 E202  BF 0060 R			MOV	DI, OFFSET IVT_18			; DI = BASIC offset in IVT 
 E205  91				XCHG	AX, CX				; AX = vector offset 0000 
 E206  AB				STOSW 					; write to IVT 
 E207  96				XCHG	AX, SI 				; AX = BASIC SEG 
 E208  AB				STOSW						; write to IVT 
 E209				INIT_ROM_BASIC_DONE: 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; [18] Setup DS and ES to BDA segment 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-60


							ASSUME DS:_BDA, ES:_BDA 
 E209  B8 ---- R			MOV	AX, SEG _BDA 			; DS and ES to BDA 
 E20C  8E D8				MOV	DS, AX 
 E20E  8E C0				MOV	ES, AX 
				 
				;----------------------------------------------------------------------------; 
				; Check CPU type 
				;----------------------------------------------------------------------------; 
				; If V20 is build target but V20 not detected - beep 1 long, 4 short 
				;----------------------------------------------------------------------------; 
 E210				CPU_IS_V20: 
 E210  B8 0101				MOV	AX, DBW <1,1>			; Attempt to pack bytes into nibbles 
					AAD_I	10H					; result is 11 if V20, 11H if x86 
 E213  D5 10                 1		DB	0D5H, 10H			; AAD	imm 
 E215  3C 0B				CMP	AL, 11				; ZF = 1 if V20, ZF = 0 if 8088 
 E217  75 05				JNE	CPU_TYPE_8088			; jump if not V20 
					SET_GFLAG	V20				; set V20 flag 
			     1				ENDIF 
 E219  80 0E 0012 R 04       1		OR	GB_FLAGS, MASK V20		; set flag(s) 
							ELSE 
 E21E				CPU_TYPE_8088: 
							ENDIF 
 E21E				CPU_TYPE_DONE: 
				 
				;----------------------------------------------------------------------------; 
				; [14] Read DIP switch settings and init proper EQUIP_FLAGS 
				;----------------------------------------------------------------------------; 
				; 
				; https://sites.google.com/site/pcdosretro/biosdata 
				; https://stanislavs.org/helppc/int_11.html 
				; 
				; 5150 Sense Switches: 
				;  Port A - when Port B bit 7 = 1 
				;     High| Low 
				; 	00  |			; Disk Drives (00=1, 01=2, 10=3, 11=4) 
				; 	  00| 		; Video (00=EGA/VGA, 01=CGA 40, 10=CGA 80, 11=MDA) 
				;	    |00		; MB RAM (00=16KB, 01=32K, 10=48K, 11=64K) 
				;	    |  0		; FPU installed ("Reserved") 
				; 	    |   0		; IPL Floppy Disk Drive (0=floppy drive installed) 
				;  Port C - I/O RAM (x 32KB) 
				;	High| Low 
				;	    |4321		; RAM size bits 1-4   when Port B bit 2 = 1 
				;	     4325		; RAM size bits 5,2-4 when Port B bit 2 = 0 
				;----------------------------------------------------------------------------; 
				; 5160 Sense Switches: 
				;  Port C 
				;	High| Low 
				; 	00  |			; Disk Drives (00=1, 01=2, 10=3, 11=4) 
				; 	  00| 		; Video (00=EGA/VGA, 01=CGA 40, 10=CGA 80, 11=MDA) 
				;	    |00		; MB RAM Banks (00=Bank 0, Bank 0/1, 10=0/1/2, 11=0/1/2/3) 
				;	    |  0		; FPU installed 
				; 	    |   0		; Test Loop (always 0) 
				; 
				; EQUIP_FLAGS: LPT:2,X1:1,GAM:1,COM:3,DMA:1,FLP:2,VID:2,MBRAM:2,FPU:1,IPL:1 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-61


 E21E				GET_SW_SETTINGS: 
 E21E  E4 61				IN	AL, PPI_B 				; read Port B register 
 E220  50				PUSH	AX					; save original switches, AH = 0 
				 
						ELSE 
						ELSE                          ; not ARCH_5150 OR ARCH_FE2010 
						ELSE 
				;----------------------------------------------------------------------------; 
				; Is a 5160 or standard PPI 
				; 
 E221				SETTINGS_5160: 
 E221  24 F7				AND	AL, NOT MASK PBSW			; set bit 3 = 0 for low switch select 
 E223  E6 61				OUT	PPI_B, AL 
 E225  50				PUSH	AX		 			; save port settings 
 E226  E4 62				IN	AL, PPI_C 				; get low switches 
							ELSE 
 E228  24 0F				AND	AL, MASK MBRAM OR MASK FPU OR MASK IPL ; isolate MB RAM and FPU bits 
 E22A  8A E8				MOV	CH, AL				; save to CH 
							ENDIF 
 E22C  58				POP	AX 					; get port settings 
 E22D  0C 08				OR	AL, MASK PBSW 			; set bit 3 = 1 for high switch select 
 E22F  E6 61				OUT	PPI_B, AL 
 E231  E4 62				IN	AL, PPI_C 				; get high switches 
							ELSE 
 E233  B1 04				MOV	CL, 4 
 E235  D2 E0				SHL	AL, CL				; shift drives and video to high nibble 
 E237  0A C5				OR	AL, CH				; combine RAM, FPU with drives and vid 
							ENDIF 
				 
							ENDIF 
				 
						ENDIF					; not ARCH_TYPE EQ ARCH_EHB 
						ENDIF					; not ARCH_TYPE EQ ARCH_FE2010 
						ENDIF					; not ARCH_TYPE EQ ARCH_5150 
				 
 E239				SETTINGS_DONE: 
				;----------------------------------------------------------------------------; 
				; If set on MB DIP SW1, test and verify FPU. If not detected, disable in BDA. 
				; 
 E239  A8 02				TEST	AL, MASK FPU			; is FPU set? 
 E23B  74 07				JZ	SETTINGS_SAVE			; if not, skip to save flags 
 E23D  E8 FFC3 R			CALL	HAS_FPU				; check FPU, ZF=0 if not detected 
 E240  74 02				JZ	SETTINGS_SAVE			; if detected, save flags 
							ELSE 
 E242  24 FD				AND	AL, NOT MASK FPU			; otherwise clear FPU flag 
							ENDIF 
 E244				SETTINGS_SAVE: 
 E244  A2 0010 R			MOV	BYTE PTR EQUIP_FLAGS, AL	; set to low byte of EQUIP_FLAGS 
				 
							ENDIF 
				 
 E247  92				XCHG	AX, DX				; save EQUIP_FLAGS to DL for later 
 E248  58				POP	AX					; AL = original settings, AH = 0 
 E249  E6 61				OUT	PPI_B, AL				; restore original settings 
				 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-62


							ENDIF 
				 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; [21] Video BIOS Option ROM scan 
				;----------------------------------------------------------------------------; 
				; Scan 0C000H - 0C800H for video option ROMs (EGA, VGA, etc) 
				; 
				; A video option ROM should set the BDA video type flag to a non-zero value 
				; If the flag is still 0 afterwards, no ROMs loaded succesfully. 
				;----------------------------------------------------------------------------; 
 E24B  B8 ---- R			MOV	AX, SEG _VID_BIOS			; starting segment (C000H) 
 E24E  BF ---- R			MOV	DI, SEG _OPT_ROM			; ending segment (C800H) 
 E251  52				PUSH	DX					; save EQUIP_FLAGS for below 
 E252  E8 E545 R			CALL	BIOS_ROM_SCAN			; scan segments AX to DI for ROMs 
 E255  5A				POP	DX					; restore EQUIP_FLAGS 
				 
				;----------------------------------------------------------------------------; 
				; Check for a valid video mode in BDA: 
				;  - If BDA video mode is 0, video option ROM was not loaded. Beep and halt 
				;  - If MB video switch is 0 (option ROM), skip reset 
				;  - If not 0, determine correct 6845 video mode and do INT 10H reset 
				;----------------------------------------------------------------------------; 
					GET_EFLAG  VID				; AX = 00=error(ZF), 01=CGA 40, 10=CGA 80, 11=MDA 
			     1				ENDIF 
			     1	;----------------------------------------------------------------------------; 
			     1	; Shift if flag is in high byte to low for byte operations 
			     1	; 
			     1				IF VID LT 8		; is in low byte? 
 = 0030                      1	??000C	= MASK VID 
 = 0004                      1	??000D	= VID AND 0111B 
 = 0010                      1	??000E	= EQUIP_FLAGS[0]			; low BDA flags byte 
			     1					ENDIF 
			     1				ENDIF 
 E256  A0 0010 R             1		MOV	AL, BYTE PTR ??000E		; AL = equipment flag byte 
 E259  25 0030               1		AND	AX, ??000C			; isolate bits, clear AH 
			     1	;----------------------------------------------------------------------------; 
			     1	; Determine optimal number of shifts based on bit position and shift 
			     1	; right or left depending on fewest. 
			     1	; 
			     1				ELSE 
			     1					ELSE			; optimal to roll right 
			     1						IF ??000D GT 2 
 E25C  B1 04                 1		MOV	CL, ??000D			; CL = bit(s) position of record 
 E25E  D2 C8                 1		ROR	AL, CL				; shift value into position 
			     1						ENDIF 
			     1					ENDIF 
			     1				ENDIF 
			     1				ENDIF 
 E260  75 05				JNZ	VID_MODE_OK				; jump if mode valid or video option ROM loa
				ded 
 E262  B3 33				MOV	BL, BEEP_SL <3,3>			; Beep 3 long, 3 short 
 E264				HALT_BEEP_2: 
 E264  E9 E874 R			JMP	HALT_BEEP				; NEAR jump to beep 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-63


 E267				VID_MODE_OK: 
 E267  F6 C2 30				TEST	DL, MASK VID			; is SW1 mode 00? 
 E26A  74 07				JZ	RESET_VIDEO_DONE			; if custom video ROM, skip reset 
 E26C  BB E82A R			MOV	BX, OFFSET VID_MODE_TBL[-1]	; AL = BDA video type, BX = mode table 
 E26F  2E: D7				XLAT	CS:[BX]				; AL = INT 10H video mode 
				 
				;----------------------------------------------------------------------------; 
				; Clear screen and reset the video display 
				; 
 E271				RESET_VIDEO: 
 E271  CD 10				INT	10H					; AH = 0 - Set Video Mode 
 E273				RESET_VIDEO_DONE: 
				 
							IF POST_BANNER EQ 1 
				;----------------------------------------------------------------------------; 
				; Hello Computer ("just use the keyboard") 
				;----------------------------------------------------------------------------; 
 E273				HELLO_WORLD: 
							IF RANDOM_TAGLINE EQ 1 
 E273  E8 F8C7 R			CALL	HELLO_RAND_TAGLINE		; display banner and random tagline 
							ENDIF 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Save the initial cursor mode to BDA for hot key and POST display 
				; 
 E276  33 DB				XOR	BX, BX				; BH = video page 0 
 E278  B4 03				MOV	AH, 3					; get cursor: CX = power-on cursor 
 E27A  CD 10				INT	10H					;  DX = position 
 E27C  89 0E 00E8 R			MOV	CURSOR_DEFAULT, CX		; save to BDA for Turbo toggle 
				 
							IF POST_BANNER EQ 1 
				;----------------------------------------------------------------------------; 
				; Display VERSION notice in bottom left 
				; 
 E280  52				PUSH	DX					; save cursor position 
 E281  BA 1800				MOV	DX, DBW <24, 0> 			; bottom left row = 24, col = 0 
 E284  B4 02				MOV	AH, 2 				; set bottom cursor position  
 E286  CD 10				INT	10H 					; row = DH, column = DL 
					PRINT_SZ  VER				; display version 
			     1			ENDIF 
			     1			IFDIFI <VER>,<SI>			; if SZ is not SI 
 E288  BE FFE0 R             1		MOV	SI, OFFSET VER 
			     1			ENDIF 
 E28B  E8 F79F R             1		CALL	OUT_SZ 
			     1			ENDIF 
					PRINT_SZ  REL_DATE			; display build date 
			     1			ENDIF 
			     1			IFDIFI <REL_DATE>,<SI>			; if SZ is not SI 
 E28E  BE FFF5 R             1		MOV	SI, OFFSET REL_DATE 
			     1			ENDIF 
 E291  E8 F79F R             1		CALL	OUT_SZ 
			     1			ENDIF 
 E294  5A				POP	DX					; restore previous cursor 
 E295  B4 02				MOV	AH, 2 				; reset cursor position 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-64


 E297  CD 10				INT	10H 					; row = DH, column = DL 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Jump over INT 02h fixed ORG to continue... 
				; 
 E299  EB 48 90				JMP	NEAR PTR POST_DETECT_PORTS 
				 
				 
							IF IS_TURBO 
				;----------------------------------------------------------------------------; 
				; Toggle Turbo mode on/off 
				;----------------------------------------------------------------------------; 
				; Note: for standard PPI-based systems, some references state that flipping 
				; both bit 2 and 3 (0Ch) are required, and some only bit 2 (04h). Flipping  
				; only bit 2 seems to work fine however. 
				; 
				; Clobbers AX, CX, DX 
				;----------------------------------------------------------------------------; 
 E29C				TOGGLE_TURBO PROC 
							ASSUME DS:_BDA 
 E29C  FA				CLI						; interrupts off 
				 
						ELSE					; NOT ARCH_TD3300 
				 
				;----------------------------------------------------------------------------; 
				; VTech Laser Turbo XT switch 
				; Only bit 7 is used, 0 for standard speed and 1 for turbo speed 
				; 
							ELSE				; NOT ARCH_TD3300 OR ARCH_LASER 
				 
				;----------------------------------------------------------------------------; 
				; Standard PPI B Turbo switch 
				; 
 E29D  E4 61				IN	AL, PPI_B				; read PPI 
 E29F  34 04				XOR	AL, MASK PBTB			; flip turbo bit 
 E2A1  E6 61				OUT	PPI_B, AL 
				 
								ENDIF			; ARCH_FE2010 
				 
								ENDIF			; ARCH_UM82 
				 
								ENDIF 
				 
								ENDIF			; ARCH_EHB 
				 
								ELSE			; NOT ARCH_MIST AND NOT ARCH_TD3300 
				 
				;----------------------------------------------------------------------------; 
				; NZ if turbo bit set, ZF if not turbo 
				; 
				;					IF ARCH_TYPE EQ ARCH_FE2010 
				;	TEST	AL, MASK FSPD			; speed low? 
				;					ELSE 
 E2A3  A8 04				TEST	AL, MASK PBTB			; standard turbo bit set? 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-65


				;					ENDIF 
								ENDIF			; ARCH_MIST 
							ENDIF				; ARCH_LASER 
						ENDIF					; ARCH_TD3300 
				 
 E2A5  8B 0E 00E8 R			MOV	CX, CURSOR_DEFAULT		; original power-on cursor (fast) 
 E2A9  75 02				JNZ	TOGGLE_TURBO_CURSOR		; Jump if turbo, use original cursor 
 E2AB  32 ED				XOR	CH, CH 				; starting scan line 0 ("big cursor") 
 E2AD				TOGGLE_TURBO_CURSOR: 
 E2AD  E8 F03E R			CALL	SET_CURSOR				; Video set cursor 
				 
 E2B0				TOGGLE_TURBO_DONE: 
 E2B0  FB				STI						; Enable interrupts 
 E2B1  C3				RET 
 E2B2				TOGGLE_TURBO ENDP 
							ENDIF				; IF IS_TURBO 
				 
							ENDIF 
				 
							ENDIF 
				 
							ENDIF 
				 
							ENDIF 
				 
							ENDIF 
				 
				; 
				; 1 BYTES HERE 
				; 
				BYTES_HERE	INT_02 
 = 0011                      1	BYTES_HERE_INT_02 = INT_02-$ 
			     1			IFDEF BYTES_HERE_INT_02 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 2 - NMI  
				;----------------------------------------------------------------------------; 
				; If NMI / IRQ 2 occurs (a parity or I/O exception), display error type and 
				; halt. Exit if it was an 8087 exception as that should be intercepted by  
				; a user coprocessor exception handler. 
				;----------------------------------------------------------------------------; 
 E2C3						ORG 0E2C3H 
 E2C3				INT_02 PROC 
 E2C3  50				PUSH	AX 
 E2C4  E4 62				IN	AL, PPI_C 				; get PC0 register 
 E2C6  A8 C0				TEST	AL, MASK PCPE OR MASK PCIE	; parity or I/O error? 
 E2C8  75 02				JNZ	INT_02_NMI_PAR 			; first, check parity 
 E2CA  58				POP	AX					; if neither, exit 
 E2CB  CF				IRET						; must have been an 8087 NMI 
 E2CC				INT_02_NMI_PAR: 
 E2CC  BE E53D R			MOV	SI, OFFSET NMI_ERR_PAR 		; Parity error string 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-66


 E2CF  A8 80				TEST	AL, MASK PCPE			; parity error? 
 E2D1  75 02				JNZ	INT_02_NMI_HALT 
 E2D3  4E				DEC	SI					; otherwise is I/O error 
 E2D4  4E				DEC	SI					; decrement to NMI_ERR_IO 
 E2D5				INT_02_NMI_HALT: 
							ENDIF 
 E2D5  33 C0				XOR	AX, AX				; reset video, clear screen 
 E2D7  E6 A0				OUT	NMI_R0, AL				; mask the unmaskable 
 E2D9  CD 10				INT	10H					; switch to text video mode 
 E2DB  E8 F79F R			CALL	OUT_SZ 				; display string in CS:SI 
 E2DE  E8 E680 R			CALL	NMI_RESET				; clear NMI/parity flags 
 E2E1  FA				CLI						; ensure interrupts off 
 E2E2  F4				HLT						; halt CPU 
 E2E3				INT_02 ENDP 
				 
 E2E3				POST_DETECT_PORTS PROC 
				;----------------------------------------------------------------------------; 
				; [37] Setup LPT/COM default timeouts 
				;----------------------------------------------------------------------------; 
							ASSUME ES:_BDA 
 E2E3  BF 0078 R			MOV	DI, OFFSET LPT_TIME 
 E2E6  B8 1414				MOV	AX, DBW <LPT_TO, LPT_TO>	; LPT timeout values 
 E2E9  AB				STOSW						; write x 4 to BDA 
 E2EA  AB				STOSW 
 E2EB  B8 0101				MOV	AX, DBW <COM_TO, COM_TO>	; COM timeout values 
 E2EE  AB				STOSW 
 E2EF  AB				STOSW 
				 
 E2F0  BB 0011 R			MOV	BX, OFFSET EQUIP_FLAGS[1]	; BX = high byte of EQUIP_FLAGS 
				 
				;----------------------------------------------------------------------------; 
				; [38] Detect and enable Game port 
				;----------------------------------------------------------------------------; 
				; Port 201H 
				; Input:  
				;	BX = high byte of EQUIP_FLAGS 
				; 
				; Equipment Bit is set if the lower nibble of an I/O port 201h read is zero 
				; http://www.minuszerodegrees.net/5150_5160/post/IBM%205150%20and%205160%20-%20Bit%2012%20of%20Equip
				ment%20Flag.htm 
				;----------------------------------------------------------------------------; 
 E2F3				POST_DETECT_GAM: 
 E2F3  BA 0201				MOV	DX, GAME_CTRL 
 E2F6  EC				IN	AL, DX 				; will be 0FFH if no port 
 E2F7  A8 0F				TEST	AL, 0FH 
 E2F9  75 03				JNZ	NO_GAME_PORT 
 E2FB  80 0F 10				OR	BYTE PTR [BX], HIGH MASK GAM	; enable Game Port bit 
 E2FE				NO_GAME_PORT: 
				 
				;----------------------------------------------------------------------------; 
				; [37] Detect and enable COM ports 1-4 
				;----------------------------------------------------------------------------; 
				; Ports 3F8H, 2F8H, 3E8H, 2E8H 
				; Input: 
				;	BX = high byte of EQUIP_FLAGS 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-67


				;	ES, DS = BDA segment 
				;----------------------------------------------------------------------------; 
 E2FE				POST_DETECT_COM: 
 E2FE  B9 0004				MOV	CX, 4					; four COM ports 
 E301  33 FF				XOR	DI, DI 				; 00H BDA COM1-4 base addresses 
 E303  BA 03FA				MOV	DX, COM1_IIR			; 3FAH: COM1 Interrupt Ident Reg 
 E306				COM_DETECT_LOOP: 
 E306  32 C0				XOR	AL, AL				; AL = 0 
 E308  EE				OUT	DX, AL				; clear FIFO Control Register (FCR) 
 E309  EC				IN	AL, DX 				; read IIR to clear DMA flags 
 E30A  EC				IN	AL, DX 				; read IIR again 
 E30B  4A				DEC	DX 
 E30C  4A				DEC	DX					; DX = base port 
 E30D  A8 F0				TEST	AL, 11110000B 			; check if any high 4 bits are set 
 E30F  92				XCHG	AX, DX				; AX = detected port 
 E310  75 04				JNZ	NO_COM_PORT				; if so, not a valid port 
 E312  AB				STOSW 					; write I/O port to COM BDA table 
 E313  80 07 02				ADD	BYTE PTR[BX], HIGH(1 SHL COM)	; INC COM port count in flags 
 E316				NO_COM_PORT: 
 E316  2D 00FE				SUB	AX, COM1_DATA-COM2_IIR		; base port to next IIR port 
 E319  92				XCHG	AX, DX				; DX = next IIR port 
 E31A  80 F9 03				CMP	CL, 3 				; is COM2 (COM3 next)? 
 E31D  75 03				JNE	NEXT_COM_PORT			; if not, next 
 E31F  BA 03EA				MOV	DX, COM3_IIR			; restart at 3EAH: COM3 IIR 
 E322				NEXT_COM_PORT: 
 E322  E2 E2				LOOP	COM_DETECT_LOOP 
				 
				;----------------------------------------------------------------------------; 
				; [36] Detect and enable LPT ports 
				;----------------------------------------------------------------------------; 
				; Ports 3BCH, 378H, 278H 
				; Input:  
				;	BX = high byte of EQUIP_FLAGS 
				;	CH = 0 
				;----------------------------------------------------------------------------; 
 E324				POST_DETECT_LPT: 
 E324  B1 03				MOV	CL, 3					; three LPT ports 
 E326  BF 0008 R			MOV	DI, OFFSET LPT_ADDR		; 08H BDA LPT1-3 base addresses 
 E329  BA 03BC				MOV	DX, LPT_MDA				; start with MDA printer base 
 E32C				LPT_DETECT_LOOP: 
 E32C  B0 0B				MOV	AL, MASK LCDR OR MASK LCINI-1	; use init byte - 1 as test data 
 E32E  EE				OUT	DX, AL				; send to LPT data port 
 E32F  42				INC	DX 
 E330  42				INC	DX					; DX = control port 
 E331  40				INC	AX					; AL = Strobe off / init (1100b) 
 E332  EE				OUT	DX, AL				; send to LPT control port 
 E333  4A				DEC	DX 
 E334  4A				DEC	DX					; DX = data port 
 E335  EC				IN	AL, DX				; read from LPT data port 
 E336  34 0B				XOR	AL, MASK LCDR OR MASK LCINI-1	; valid port if same test data 
 E338  75 06				JNZ	NO_LPT_PORT				; if not, not a valid port 
 E33A  92				XCHG	AX, DX				; AX = detected port 
 E33B  AB				STOSW 					; store to LPT BDA table 
 E33C  92				XCHG	AX, DX 
 E33D  80 07 40				ADD	BYTE PTR[BX], HIGH(1 SHL LPT)	; INC LPT port count in flags 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-68


 E340				NO_LPT_PORT: 
 E340  FE CE				DEC	DH 					; DX = DX - 100H (LPT1-LPT2) 
 E342  80 F9 03				CMP	CL, 3 				; is 3BCH (LPT1 next)? 
 E345  75 03				JNE	NEXT_LPT_PORT			; if not, next 
 E347  BA 0378				MOV	DX, LPT1				; restart at 378H: LPT1 data port 
 E34A				NEXT_LPT_PORT: 
 E34A  E2 E0				LOOP	LPT_DETECT_LOOP 
				 
 E34C				POST_DETECT_PORTS ENDP 
				 
						ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Reset Keyboard Interface 
				;----------------------------------------------------------------------------; 
				; http://minuszerodegrees.net/5160/keyboard/5160_keyboard_startup.jpg 
				; 
				; KB Status Port 61h high bits: 
				; 01 - normal operation. wait for keypress, when one comes in, 
				;		force data line low (forcing keyboard to buffer additional 
				;		keypresses) and raise IRQ1 high 
				; 11 - stop forcing data line low. lower IRQ1 and don't raise it again. 
				;		drop all incoming keypresses on the floor. 
				; 10 - lower IRQ1 and force clock line low, resetting keyboard 
				; 00 - force clock line low, resetting keyboard, but on a 01->00 transition, 
				;		IRQ1 would remain high 
				;----------------------------------------------------------------------------; 
 E34C				POST_KB_RESET PROC 
 E34C  BA 0061				MOV	DX, PPI_B 				; DX = PPI port B (61H) 
 E34F  EC				IN	AL, DX 
 E350  24 3F				AND	AL, NOT (MASK PBKB OR MASK PBKC) ; keyboard clock hold LOW and enable 
 E352  EE				OUT	DX, AL				; send to PPI port B 
 E353  96				XCHG	AX, SI				; save modified PPI port B 
				 
				;----------------------------------------------------------------------------; 
				; [31] - Set up and clear keyboard buffer 
				;----------------------------------------------------------------------------; 
 E354  B8 001E R			MOV	AX, OFFSET KB_BUF 		; AX = initial start of buffer 
 E357  BF 001A R			MOV	DI, OFFSET KB_BUF_HD 		; DI = buffer head 
 E35A  AB				STOSW 					; write to head pointer 
 E35B  AB				STOSW 					; write to tail pointer 
 E35C  BF 0080 R			MOV	DI, OFFSET KB_BUF_ST 		; setup buffer start and end 
 E35F  AB				STOSW 
 E360  B0 3E				MOV	AL, KB_BUF_END_B			; (AH already 00) 
 E362  AB				STOSW						; DI = KB_BUF_ST + 4 
				 
				;----------------------------------------------------------------------------; 
				; Hold clock low 20+ ms to signal keyboard to reset. Clear and re-enable. 
				; 
 E363  B0 1E				MOV	AL, 30				; I/O delay for at least 20ms 
 E365  E8 E68F R			CALL	IO_DELAY_MS 
 E368  96				XCHG	AX, SI				; restore modified PPI port B 
				 
 E369  0C C0				OR	AL, MASK PBKB OR MASK PBKC	; keyboard enable clock and clear 
 E36B  EE				OUT	DX, AL				; send to PPI port B 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-69


 E36C  51				PUSH	CX					; give a little more time 
 E36D  24 7F				AND	AL, NOT MASK PBKB			; keyboard enable (clear low) 
 E36F  EE				OUT	DX, AL				; send to PPI port B 
				 
				;----------------------------------------------------------------------------; 
				; Unmask KB interrupt IRQ1 
				; 
 E370  E4 21				IN	AL, INT_IMR 			; get PIC Port 1 INT mask 
 E372  96				XCHG	AX, SI 				; SI = save previous INT mask 
 E373  B0 FD				MOV	AL, NOT MASK IRQ1			; unmask only keyboard interrupt 
 E375  E6 21				OUT	INT_IMR, AL 
				 
				;----------------------------------------------------------------------------; 
				; Check if reset scan code was received 
				; 
				; Temporary INT_09_POST interrupt will set 4000H flag on BP 
				; when IRQ1 is received with successful reset code of 0AAh 
				; 
							IF POST_TEST_KB NE 0 
 E377  FB				STI 						; enable interrupts 
 E378				KB_RESET_TEST: 
					IO_DELAY_SHORT				; give a little more time 
			     1				IF ARCH_TYPE NE ARCH_EMU 
 E378  EB 00                 1		JMP	SHORT ??0010 
 E37A                        1	??0010: 
			     1				ENDIF 
					POST_FLAG_TEST  PKI			; KB test flag yet? 
			     1				ELSE 
 E37A  F7 C5 4000            1		TEST	BP, MASK PKI			; Is FLAG set? 
			     1				ENDIF 
 E37E  E1 F8				LOOPZ	KB_RESET_TEST			; Loop until KB flag OR CX is 0 (timeout) 
 E380  FA				CLI 						; disable interrupts again 
					POST_FLAG_FLIP  PKI			; invert PKI flag: 1 = error, 0 = success 
			     1				ELSE 
 E381  81 F5 4000            1		XOR	BP, MASK PKI			; Invert flag 
			     1				ENDIF 
							ENDIF 
					IO_DELAY_LONG 				; additional delay, CX = 0 
			     1				IF ARCH_TYPE NE ARCH_EMU 
 E385  33 C9                 1		XOR	CX, CX 				; delay 65535 LOOPs 
			     1		IO_DELAY 
 E387                        2	??0011: 
 E387  E2 FE                 2		LOOP	??0011					; long delay for I/O 
			     1				ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Ack scan code, clear keyboard again and check that no scan codes were received 
				; 
 E389  EC				IN	AL, DX				; read PPI port B 
 E38A  0C C0				OR	AL, MASK PBKB OR MASK PBKC	; keyboard enable clock and clear 
 E38C  EE				OUT	DX, AL				; send to PPI port B 
 E38D  59				POP	CX					; give a little more time 
 E38E  24 7F				AND	AL, NOT MASK PBKB			; keyboard enable (clear low) 
 E390  EE				OUT	DX, AL				; send to PPI port B 
					IO_DELAY					; delay for KBC, CX = 0 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-70


 E391                        1	??0012: 
 E391  E2 FE                 1		LOOP	??0012					; long delay for I/O 
 E393  E4 60				IN	AL, PPI_A 				; check KB for extraneous key 
							IF POST_TEST_KB NE 0	; all KB tests enabled? 
							IF POST_TEST_KEY NE 0	; Key Stuck test enabled? 
 E395  84 C0				TEST	AL, AL				; AL should be 0 
 E397  74 04				JZ	KB_HAPPY				; if so, KB is ready 
					POST_FLAG_SET  PKEY			; otherwise set flag for keyboard error 
			     1				ELSE 
 E399  81 CD 2000            1		OR	BP, MASK PKEY			; Set FLAG 
			     1				ENDIF 
							ENDIF				; end Key Stuck test 
							ENDIF 
				 
 E39D				KB_HAPPY: 
				;----------------------------------------------------------------------------; 
				; Disable keyboard for rest of POST 
				; 
 E39D  EC				IN	AL, DX 
 E39E  0C C0				OR	AL, MASK PBKB OR MASK PBKC	; keyboard enable clock and clear 
 E3A0  EE				OUT	DX, AL				; send to PPI port B 
				 
 E3A1  96				XCHG	AX, SI 				; restore interrupt mask register 
 E3A2  E6 21				OUT	INT_IMR, AL 
				 
				;----------------------------------------------------------------------------; 
				; Set up the real INT 09H keyboard interrupt handler 
				; 
							ASSUME ES:_IVT 
 E3A4  8E C1				MOV	ES, CX 				; ES = IVT seg (CX is 0 from above) 
 E3A6  BF 0024 R			MOV	DI, OFFSET IVT_09 		; DI = INT 9H offset in IVT (24H) 
 E3A9  B8 E987 R			MOV	AX, OFFSET INT_09 		; Vector offset 
 E3AC  AB				STOSW 					; replace in IVT 
				 
 E3AD				POST_KB_RESET ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Begin Hardware POST Test Results 
				;----------------------------------------------------------------------------; 
 E3AD  E8 F03B R			CALL	HIDE_CURSOR				; cursor movement is distracting 
				 
							IF POST_WARM_COLD EQ 1 
				;----------------------------------------------------------------------------; 
				; Display "WARM" or "COLD" boot 
				;----------------------------------------------------------------------------; 
				; Size: 38 bytes 
				;----------------------------------------------------------------------------; 
 E3B0				POST_BOOT_TYPE PROC 
 E3B0  BE E8F6 R			MOV	SI, OFFSET POST_BOOT		; BOOT string 
 E3B3  B3 04				MOV	BL, POST_CLR_WARM			; attribute to warm color 
 E3B5  E8 F746 R			CALL	POST_START_COL_1			; display column label 
											;  CX=POST_TAB_COL_I, SI=WARM string 
					JWB	POST_BOOT_TYPE_OUT		; jump if warm boot 
			     1				IF WARM_ENABLE EQ 1 
 E3B8  85 ED                 1		TEST	BP, BP				; is warm boot? 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-71


 E3BA  78 05                 1		JS	POST_BOOT_TYPE_OUT					; jump if so 
			     1				ENDIF 
 E3BC  B3 09				MOV	BL, POST_CLR_COLD			; attribute to cold color 
 E3BE  BE E900 R			MOV	SI, OFFSET POST_COLD		; COLD string 
 E3C1				POST_BOOT_TYPE_OUT: 
 E3C1  E8 F78D R			CALL	OUT_SZ_ATTR				; write string with attribute 
 E3C4  E8 F77F R			CALL	POST_END_COL_NL			; end of column with NL and RET 
				 
 E3C7				POST_BOOT_TYPE ENDP 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; [17] Detect and test conventional memory 
				;----------------------------------------------------------------------------; 
 E3C7  E8 E59C R			CALL	DETECT_MEMORY			; detect and display memory count 
							ASSUME ES:NOTHING		; ES clobbered by DETECT_MEMORY 
				 
							IF POST_TEST_DMA_TC0 EQ 1 
				;----------------------------------------------------------------------------; 
				; [27B] Verify that the 8237 DMA Channel 0 Terminal Count (TC 0) status bit  
				; is on. This test is only done on a cold boot. 
				;----------------------------------------------------------------------------; 
					JWB	DMA_STATUS_OK			; skip on warm boot 
			     1				IF WARM_ENABLE EQ 1 
 E3CA  85 ED                 1		TEST	BP, BP				; is warm boot? 
 E3CC  78 0A                 1		JS	DMA_STATUS_OK					; jump if so 
			     1				ENDIF 
 E3CE  E4 08				IN	AL, DMA_CMD				; verify DMA status register 
 E3D0  A8 01				TEST	AL, MASK TC0			; Channel 0 TC 
 E3D2  75 04				JNZ	DMA_STATUS_OK			; jump if zero reached 
					POST_FLAG_SET  PDMA			; else mark in POST error flags 
			     1				ELSE 
 E3D4  81 CD 0400            1		OR	BP, MASK PDMA			; Set FLAG 
			     1				ENDIF 
 E3D8				DMA_STATUS_OK: 
							ENDIF 
				 
							IF POST_CONFIG EQ 1 
				;----------------------------------------------------------------------------; 
				; Display Additional Configuration Items such as COM/LPT, CPU, FPU, etc 
				;----------------------------------------------------------------------------; 
 E3D8  E8 F680 R			CALL	POST_SYS_CONFIG			; show CPU, FPU and ports 
							ENDIF 
				 
 E3DB  E8 F032 R			CALL	CRLF_SHOW_CURSOR			; CRLF and re-enable cursor 
				 
				;----------------------------------------------------------------------------; 
				; Unmask IRQs for Timer (IRQ0), Keyboard (IRQ1) and Floppy (IRQ6) 
				;----------------------------------------------------------------------------; 
 E3DE  E4 21				IN	AL, INT_IMR 			; get current OCW1/IMR register 
 E3E0  24 BC				AND	AL, NOT (MASK IRQ6 OR MASK IRQ1 OR MASK IRQ0) ; unmask IR6, IR1, IR0 
 E3E2  E6 21				OUT	INT_IMR, AL 			; send to A1 (Port 1) 
				 
				;----------------------------------------------------------------------------; 
				; [28] Option ROM scan for other ROMs (storage, etc) 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-72


				;----------------------------------------------------------------------------; 
 E3E4  B8 ---- R			MOV	AX, SEG _OPT_ROM			; start at 0C800H 
 E3E7  BF FE00				MOV	DI, OPT_ROM_END			; end below 0FE00H 
 E3EA  E8 E545 R			CALL	BIOS_ROM_SCAN			; scan for option ROMs, AL = 0 
				 
				;----------------------------------------------------------------------------; 
				; [31] Enable interrupts 
				;----------------------------------------------------------------------------; 
 E3ED  FB				STI 						; Interrupts now enabled 
				 
							IF FDC_ENABLE EQ 1 
				;----------------------------------------------------------------------------; 
				; [30] Recalibrate and test seek the floppy drive 
				;----------------------------------------------------------------------------; 
 E3EE				FDC_POST PROC 
 E3EE  98				CBW						; AH = reset (0) 
 E3EF  99				CWD						; DL = start at drive 0 
							ENDIF 
 E3F0  CD 13				INT	13H					; Reset the controller 
 E3F2  72 1F				JC	FDC_POST_CT_ERR			; jump if controller reset failed 
					GET_EFLAG  FLP				; AX = # of floppy drives (0 based) 
			     1				ENDIF 
			     1	;----------------------------------------------------------------------------; 
			     1	; Shift if flag is in high byte to low for byte operations 
			     1	; 
			     1				IF FLP LT 8		; is in low byte? 
 = 00C0                      1	??0013	= MASK FLP 
 = 0006                      1	??0014	= FLP AND 0111B 
 = 0010                      1	??0015	= EQUIP_FLAGS[0]			; low BDA flags byte 
			     1					ENDIF 
			     1				ENDIF 
 E3F4  A0 0010 R             1		MOV	AL, BYTE PTR ??0015		; AL = equipment flag byte 
 E3F7  25 00C0               1		AND	AX, ??0013			; isolate bits, clear AH 
			     1	;----------------------------------------------------------------------------; 
			     1	; Determine optimal number of shifts based on bit position and shift 
			     1	; right or left depending on fewest. 
			     1	; 
			     1				ELSE 
			     1					IF ??0014 GT 4	; optimal to roll left 
 = 0002                      1						??0014 = 8-??0014 
			     1						ELSE		; 0-2 shifts use single op(s) 
			     1							REPT ??0014 
			     1		ROL	AL, 1					; shift value into position 
			     1							ENDM 
 E3FA  D0 C0                 2		ROL	AL, 1					; shift value into position 
 E3FC  D0 C0                 2		ROL	AL, 1					; shift value into position 
			     1						ENDIF 
			     1					ENDIF 
			     1				ENDIF 
			     1				ENDIF 
 E3FE  40				INC	AX					; fixup for 1 based drive count 
				 
							IF POST_TEST_FD EQ 1 
				;----------------------------------------------------------------------------; 
				; Test FDC drives - seek on cold boot, recal on warm boot 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-73


				; 
 E3FF  91				XCHG	AX, CX				; CX = number of floppy drives 
 E400				FDC_POST_TESTS_DRV: 
 E400  BF 0041 R			MOV	DI, OFFSET FD_LAST_OP		; DI = FD_LAST_OP to use INT 13h PROCs 
								IF POST_TEST_SEEK EQ 1 
 E403  E8 EF8F R			CALL	FDC_RECAL_SEEK_TEST		; recal and seek test 
								ENDIF 
 E406  72 05				JC	FDC_POST_DRV_ERR			; jump if error 
 E408  42				INC	DX					; DL = next drive 
 E409  E2 F5				LOOP	FDC_POST_TESTS_DRV 
 E40B  EB 0C				JMP	SHORT FDC_POST_TESTS_DONE	; tests successful 
 E40D				FDC_POST_DRV_ERR:					; POST: drive seek error 
								IF FD_AUTO_DETECT EQ 0 
					POST_FLAG_SET  PFSK			; mark in POST error flags 
			     1				ELSE 
 E40D  81 CD 0800            1		OR	BP, MASK PFSK			; Set FLAG 
			     1				ENDIF 
								ENDIF 
 E411  EB 06				JMP	SHORT FDC_POST_TESTS_DONE	; end POST test at failed drive 
					;LOOP	FDC_POST_TESTS_DRV		;  or continue to next drive 
				 
							ENDIF				; /POST_TEST_FD EQ 1 
				 
 E413				FDC_POST_CT_ERR:					; POST: controller error 
					POST_FLAG_SET  PFDC			; mark in POST error flags 
			     1				ELSE 
 E413  81 CD 1000            1		OR	BP, MASK PFDC			; Set FLAG 
			     1				ENDIF 
				 
							IF POST_TEST_FD EQ 1 
 E417  33 D2				XOR	DX, DX				; DX = 0 drives detected 
 E419				FDC_POST_TESTS_DONE: 
 E419  92				XCHG	AX, DX				; AX = drive count 
				 
								ENDIF			; /FD_AUTO_DETECT EQ 1 
				 
							ENDIF				; /POST_TEST_FD EQ 1 
				 
 E41A				FDC_POST_TESTS_COL: 
								IF POST_FD_COUNT EQ 1 
				;----------------------------------------------------------------------------; 
				; Display FDC POST drive count column in AX 
				; TODO: re-arrange to display counts after drive list 
				; 
					POST_COL_1  POST_FDD, POST_CLR_VAL2	; display FDC column label 
			     1			ENDIF 
			     1			ELSE 
 E41A  B3 0E                 1		MOV	BL, LOW POST_CLR_VAL2		; BL = attribute 
			     1			ENDIF 
 E41C  BE E52C R             1		MOV	SI, OFFSET POST_FDD 
 E41F  E8 F746 R             1		CALL	POST_START_COL_1 
			     1			ENDIF 
 E422  E8 F810 R			CALL	NIB_HEX				; display drive count value in AL 
					POST_COL_END				;  NIB_HEX returns AL <= 46h 
			     1			ENDIF 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-74


 E425  E8 F784 R             1		CALL	POST_END_COL 
			     1			ENDIF 
								ENDIF 
				 
 E428				FDC_POST ENDP 
							ENDIF				; IF FDC_ENABLE 
				 
				;----------------------------------------------------------------------------; 
				; Detect and show hard drive info 
				;----------------------------------------------------------------------------; 
 E428				HDD_POST PROC 
							IF POST_HD_CHECK EQ 1 
 E428  98				CBW						; AH = 0 reset 
 E429  B2 80				MOV	DL, 80H				; reset C: (80H) 
 E42B  CD 13				INT	13H 
 E42D  72 24				JC	HDD_POST_NONE			; if CF, no HD or reset failure 
				 
 E42F  B2 80				MOV	DL, 80H 
 E431  E8 E71E R			CALL	GET_DISK_PARAMS			; return # HD's in DX 
 E434  72 1D				JC	HDD_POST_NONE 
				 
							IF POST_HD_COUNT EQ 1 
				;----------------------------------------------------------------------------; 
				; Display HDD POST drive count column 
				; 
							IF FDC_ENABLE EQ 1 
					POST_COL_2	POST_HDD, POST_CLR_VAL2	; display HDD column label 
			     1			ENDIF 
			     1			ELSE 
 E436  B3 0E                 1		MOV	BL, LOW POST_CLR_VAL2		; BL = attribute 
			     1			ENDIF 
 E438  BE E530 R             1		MOV	SI, OFFSET POST_HDD 
 E43B  E8 F76D R             1		CALL	POST_START_COL_2 
			     1			ENDIF 
							ENDIF 
				 
 E43E  52				PUSH	DX					; save drive count 
 E43F  92				XCHG	AX, DX				; AL = drive count 
 E440  E8 F810 R			CALL	NIB_HEX				; write as hex to console (clobs AX) 
					POST_COL_END_NL				; end column 
			     1			ENDIF 
 E443  E8 F77F R             1		CALL	POST_END_COL_NL 
			     1			ENDIF 
 E446  59				POP	CX					; CX = drive count 
 E447  E3 0D				JCXZ	HDD_POST_DONE			; reset passed but 0 drives 
				 
							IF POST_HD_PARMS EQ 1 
				;----------------------------------------------------------------------------; 
				; Display HDD drive letter(s) and size(s) 
				;	 
 E449  B2 80				MOV	DL, 80H				; start with drive 80H (C:) 
 E44B				HDD_POST_SHOW_LOOP: 
 E44B  E8 F863 R			CALL	SHOW_DISK_PARAMS			; show drive letter and geometry 
 E44E  42				INC	DX					; move to next drive 
 E44F  E2 FA				LOOP	HDD_POST_SHOW_LOOP 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-75


 E451  EB 03				JMP	SHORT HDD_POST_DONE 
							ENDIF				; ENDIF POST_HD_PARMS EQ 1 
							ENDIF				; ENDIF POST_HD_COUNT EQ 1 
 E453				HDD_POST_NONE: 
							ENDIF				; ENDIF POST_HD_CHECK EQ 1 
 E453  E8 F7C8 R			CALL	CRLF 
 E456				HDD_POST_DONE: 
 E456				HDD_POST ENDP 
				 
				;----------------------------------------------------------------------------; 
				; [39] Clear and enable I/O and parity NMIs 
				;----------------------------------------------------------------------------; 
 E456  E8 E680 R			CALL	NMI_RESET				; reset NMI flags 
				 
							IF RAM_PARITY EQ 1 
 E459				ENABLE_NMI: 
 E459  B0 80				MOV	AL, NMI <1>				; AL = enable NMI 
 E45B  E6 A0				OUT	NMI_R0, AL				; write to controller 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Enable keyboard 
				; 
 E45D  E8 E95F R			CALL	KB_BUF_CLEAR			; clear any stray keys in buffer 
 E460  E4 61				IN	AL, PPI_B 				; AL = PB0 flags 
 E462  24 7F				AND	AL, NOT MASK PBKB			; keyboard clear LOW (enable KB) 
					IO_DELAY_SHORT 
			     1				IF ARCH_TYPE NE ARCH_EMU 
 E464  EB 00                 1		JMP	SHORT ??0016 
 E466                        1	??0016: 
			     1				ENDIF 
 E466  E6 61				OUT	PPI_B, AL				; send to PPI port B 
				 
				;----------------------------------------------------------------------------; 
				; Check for POST errors and clear warm boot flag 
				; 
 E468  33 C0				XOR	AX, AX				; AX = 0 
 E46A  A3 0072 R			MOV	WARM_FLAG, AX			; clear warm boot flag in BDA 
					POST_FLAG_CLR  WARM, 1			; remove warm boot flag, NZ if error 
			     1				IFNB <1> 
 = 0000                      1	??0017	EQU	0				; use AND instruction instead 
			     1				ENDIF 
			     1				ELSE 
 E46D  81 E5 7FFF            1		AND	BP, NOT MASK WARM			; Clear flag 
			     1				ENDIF 
 E471  74 20				JZ	POST_OK				; if no errors, go ahead and boot 
				 
				;----------------------------------------------------------------------------; 
				; Display any POST errors 
				; 
 E473				POST_ERROR: 
					PRINT_SZ  POST_ERR			; display "Post Error" 
			     1			ENDIF 
			     1			IFDIFI <POST_ERR>,<SI>			; if SZ is not SI 
 E473  BE E905 R             1		MOV	SI, OFFSET POST_ERR 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-76


			     1			ENDIF 
 E476  E8 F79F R             1		CALL	OUT_SZ 
			     1			ENDIF 
 E479  8B C5				MOV	AX, BP				; AX = POST error flags 
 E47B  E8 F7FC R			CALL	WORD_HEX				; display POST error value 
 E47E  E8 F7C8 R			CALL	CRLF 
 E481  E8 E92E R			CALL	POST_ERROR_MSG			; display POST error messages, BP=0 
				 
							IF POST_ERR_WAIT GT 0 
				;----------------------------------------------------------------------------; 
				; Wait for the Any Key if there was an error 
				; 
 E484  E8 E8C3 R			CALL	MEEPMEEP				; alert that there was an error, CX=0 
					PRINT_SZ  NL_ANY_KEY			; "Any key" string 
			     1			ENDIF 
			     1			IFDIFI <NL_ANY_KEY>,<SI>			; if SZ is not SI 
 E487  BE E4E3 R             1		MOV	SI, OFFSET NL_ANY_KEY 
			     1			ENDIF 
 E48A  E8 F79F R             1		CALL	OUT_SZ 
			     1			ENDIF 
 E48D  91				XCHG	AX, CX				; wait for key press (AH=0) 
 E48E  CD 16				INT	16H 
 E490  E8 F7C8 R			CALL	CRLF					; move to next line 
							ENDIF 
				 
 E493				POST_OK: 
				;----------------------------------------------------------------------------; 
				; Clear screen (partially or completely) and attempt boot 
				; 
 E493				CLEAR_POST_SCREEN: 
 E493  B7 07				MOV	BH, 7					; attribute fill for on blank line 
							ELSE				; clear only the lower two rows 
 E495  B8 0702				MOV	AX, DBW <7, 2>			; AH = 7, scroll down 2 lines 
 E498  B9 1700				MOV	CX, DBW <23, 0>			; upper left row 23, column 0 
							ENDIF 
				 
 E49B  BA 1950				MOV	DX, DBW <25, 80>			; lower right row 25, column 80 
 E49E  CD 10				INT	10H 
				 
							ENDIF 
				 
 E4A0  E8 E8AE R			CALL	BEEP 					; beep to signify POST test is done 
							ELSE 
 E4A3  E8 F7C8 R			CALL	CRLF 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; [40] DO BOOTSTRAP! 
				;----------------------------------------------------------------------------; 
				 
				;----------------------------------------------------------------------------; 
				; Attempt to IPL three times. If failure, call INT 18h / ROM BASIC. 
				; If INT_19_BOOT_HD is 1, BIOS will also attempt to IPL from 80h (C:) 
				; 
				 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-77


 E4A6  99				CWD						; start IPL from drive 00h (A:) 
 E4A7				BOOT_DEVICE: 
 E4A7  B9 0003				MOV	CX, 3 				; retry three times 
 E4AA				BOOT_RETRY: 
 E4AA  51				PUSH	CX					; save retry counter 
							ENDIF 
 E4AB  CD 19				INT	19H 
					IO_DELAY_LONG				; delay between attempts 
			     1				IF ARCH_TYPE NE ARCH_EMU 
 E4AD  33 C9                 1		XOR	CX, CX 				; delay 65535 LOOPs 
			     1		IO_DELAY 
 E4AF                        2	??0018: 
 E4AF  E2 FE                 2		LOOP	??0018					; long delay for I/O 
			     1				ENDIF 
							ENDIF 
 E4B1  59				POP	CX					; restore retry counter 
 E4B2  E2 F6				LOOP	BOOT_RETRY 
							ENDIF 
				 
 E4B4				TRY_INT_18: 
 E4B4  CD 18				INT	18H					; Try vectored ROM BASIC or boot failure 
											; INT 18h should never return... 
											;  fall through just in case 
				 
				;----------------------------------------------------------------------------; 
				; INT 18 - Unbootable IPL 
				;----------------------------------------------------------------------------; 
				; Display a disk boot failure message and wait for a key to cold reboot. 
				; 
				; This may be re-vectored to ROM BASIC, if present. 
				; 
				; Size: 18 bytes 
				;----------------------------------------------------------------------------; 
 E4B6				INT_18 PROC 
					PRINT_SZ  BOOT_FAIL			; print boot failure string 
			     1			ENDIF 
			     1			IFDIFI <BOOT_FAIL>,<SI>			; if SZ is not SI 
 E4B6  BE E4C6 R             1		MOV	SI, OFFSET BOOT_FAIL 
			     1			ENDIF 
 E4B9  E8 F79F R             1		CALL	OUT_SZ 
			     1			ENDIF 
 E4BC  33 C0				XOR	AX, AX				; AH = 0 (wait for key) 
 E4BE  CD 16				INT	16H					; wait for key press 
 E4C0  E9 E05B R			JMP	BOOT					; reboot 
 E4C3				INT_18 ENDP 
				 
 E4C3				BOOT ENDP 
				 
				;----------------------------------------------------------------------------; 
				; 
				; END OF BIOS POST/BOOTSTRAP 
				; 
				;----------------------------------------------------------------------------; 
				 
						ASSUME DS:_BDA 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-78


 E4C3				STRINGS PROC 
				 
 E4C3				BANNER_STRINGS PROC 
				;----------------------------------------------------------------------------; 
				; Banner Strings 
				; 
									ENDIF 
 E4C3  0D 0A 00			NL_Z			DB	CR, LF, 0			; one NL, null term'd 
 E4C6  44 69 73 6B 20 42 6F	BOOT_FAIL		DB	'Disk Boot Fail.' 
       6F 74 20 46 61 69 6C	
       2E			
 E4D5  20 59 6F 75 20 6D 6F				DB	' You monster.' 
       6E 73 74 65 72 2E	
 E4E2  0A			NL2_ANY_KEY		DB	LF 
 E4E3  0D 0A			NL_ANY_KEY		DB	CR, LF 
 E4E5  50 72 65 73 73 20 74	ANY_KEY		DB	'Press the Any Key...' 
       68 65 20 41 6E 79 20	
       4B 65 79 2E 2E 2E	
 E4F9  00						DB	 0 
 E4FA				BANNER_STRINGS ENDP 
				 
 E4FA				POST_STRINGS PROC 
				;----------------------------------------------------------------------------; 
				; POST Test Strings 
				; 
 E4FA  43 50 55 00		POST_CPU		DB	'CPU',  0			; 'CPU' followed by default 
 E4FE  38 30 38 38 00					DB	'8088', 0			;  *must be after POST_CPU 
 E503  46 50 55 00		POST_FPU		DB	'FPU',  0			; 'FPU' followed by default 
 E507  38 30 38 37 00					DB	'8087', 0			;  *must be after POST_FPU 
 E50C  3A 00			POST_HD		DB	':',    0			; HD size letter display 
 E50E  20 4D 42						DB	' ', POST_M_UNIT		;  MB or MiB units display 
 E511  00						DB	0				;  *must be after POST_HD 
 E512  52 41 4D 00		POST_MEMORY		DB	'RAM',  0			; RAM Memory test 
									ENDIF 
 E516  30 30 30 20 4B 42				DB	'000 ', POST_K_UNIT	;  and KB or KiB 
 E51C  20 4F 4B 00					DB	' OK',  0 
 E520  56 32 30			POST_V20		DB	'V20' 
									ENDIF 
 E523  00						DB	0 
 E524  4C 50 54 00		POST_LPT		DB	'LPT',  0 
 E528  43 4F 4D 00		POST_COM		DB	'COM',  0 
 E52C  46 44 44 00		POST_FDD		DB	'FDD',  0 
 E530  48 44 44 00		POST_HDD		DB	'HDD',  0 
 E534  20 5B 20 00		POST_LSEP		DB	POST_L, 0 
 E538  20 5D 00			POST_RSEP		DB	POST_R, 0 
				 
				;----------------------------------------------------------------------------; 
				; NMI strings - these must be contiguous 
				; 
 E53B  49 4F			NMI_ERR_IO		DB	'IO'				; NMI I/O Error string 
 E53D  20 50 41 52 49 54 59	NMI_ERR_PAR		DB	' PARITY', 0		; NMI Parity Error 
       00			
				 
 E545				POST_STRINGS ENDP 
				 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-79


 E545				STRINGS ENDP 
				 
				;============================================================================; 
				; 
				;		        * * *   P R O C s  &  I N T s  * * * 
				; 
				;============================================================================; 
				 
				;----------------------------------------------------------------------------; 
				; Scan, checksum and call BIOS ROM init procedures 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AX = starting segment 
				;	DI = ending segment 
				; Output: 
				;	AX, DI = ending segment 
				;	DF = 0 
				; 
				; Clobbers: AX, BX, SI (anything else the ROM might, except for DS, ES and BP) 
				; Size: 67 bytes 
				;----------------------------------------------------------------------------; 
 E545				BIOS_ROM_SCAN PROC 
					PUSHX	BP, DS, ES				; call preserve these registers 
			     1				IFNB <BP>			; exit if last reg 
 E545  55                    1		PUSH	BP 					; push register and repeat 
			     1		PUSHX	DS, ES, , , , ,  
			     2				IFNB <DS>			; exit if last reg 
 E546  1E                    2		PUSH	DS 					; push register and repeat 
			     2		PUSHX	ES, , , , , ,  
			     3				IFNB <ES>			; exit if last reg 
 E547  06                    3		PUSH	ES 					; push register and repeat 
			     3		PUSHX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 E548				CHECK_ROM: 
 E548  8E D8				MOV	DS, AX 				; DS = starting segment 
 E54A  93				XCHG	AX, BX				; BX = current DS segment 
 E54B  B8 0080				MOV	AX, KBP < 2 >			; next 2K segment boundary length 
 E54E  50				PUSH	AX					; save for use if no ROM found 
 E54F  33 F6				XOR	SI, SI 				; ROM offset to 0 
 E551  AD				LODSW 					; AX = first word (must be 0AA55H) 
 E552  3D AA55				CMP	AX, MAGIC_WORD			; is it an extension ROM? 
 E555  75 26				JNE	NEXT_ROM 				; if not, check next 2K block 
 E557				FOUND_ROM: 
 E557  AC				LODSB						; AL = ROM size in 512B blocks 
 E558  3C 00				CMP	AL, 0					; is size "reasonable"? 
 E55A  7E 21				JLE	NEXT_ROM				; if not 1-127, skip it 
 E55C  E8 E588 R			CALL	ROM_CHECKSUM 			; checksum ROM at DS:0, AX=bytes read 
							IF POST_OPT_ROM 
 E55F  E8 F936 R			CALL	ROM_SCAN_POST			; show ROM offset, size and errors 
							ENDIF 
 E562  75 19				JNZ	NEXT_ROM				; if NZ, checksum failed, skip it 
 E564  5D				POP	BP					; discard previous boundary size 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-80


							ELSE 
 E565  B1 04				MOV	CL, 4					; 8088: 512 byte blocks to paragraph 
 E567  D3 E8				SHR	AX, CL 
							ENDIF 
 E569  50				PUSH	AX					; replace next boundary with ROM size 
				 
				;----------------------------------------------------------------------------; 
				; Call Option ROM's BIOS init routine 
				; 
				; Note: ROM init's can clobber any or all registers so important to save 
				; any that are used here between calls. 
				; 
 E56A  E4 21				IN	AL, INT_IMR 			; get current OCW1/IMR register 
 E56C  50				PUSH	AX					; save IMR 
 E56D  57				PUSH	DI					; save ROM scan ending segment 
 E56E  1E				PUSH	DS					; ROM init segment 
 E56F  56				PUSH	SI					; ROM init offset (always 03H) 
 E570  8B EC				MOV	BP, SP				; DS:BP = FAR pointer to ROM init 
 E572  FF 5E 00				CALL	DWORD PTR [BP]			; FAR CALL to option ROM init 
 E575  FA				CLI						; ensure interrupts are still disabled 
 E576  5B				POP	BX					; rebalance stack 
 E577  5B				POP	BX					; restore current DS segment 
 E578  5F				POP	DI					; restore ROM scan ending segment 
 E579  58				POP	AX					; restore IMR 
 E57A  E6 21				OUT	INT_IMR, AL				; reset IMR 
 E57C  FC				CLD						; ensure direction flag forward 
 E57D				NEXT_ROM: 
 E57D  58				POP	AX					; restore next boundary size 
 E57E  03 C3				ADD	AX, BX				; next boundary 
 E580  3B C7				CMP	AX, DI 				; end of extension ROM regions? 
 E582  72 C4				JB	CHECK_ROM 				; if not, check next 
 E584				ROM_SCAN_DONE: 
					POPX	ES, DS, BP				; restore regs 
			     1				IFNB <ES>			; exit if last reg 
 E584  07                    1		POP	ES 					; pop register and repeat 
			     1		POPX	DS, BP, , , , ,  
			     2				IFNB <DS>			; exit if last reg 
 E585  1F                    2		POP	DS 					; pop register and repeat 
			     2		POPX	BP, , , , , ,  
			     3				IFNB <BP>			; exit if last reg 
 E586  5D                    3		POP	BP 					; pop register and repeat 
			     3		POPX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 E587  C3				RET 
 E588				BIOS_ROM_SCAN ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Perform 8 bit Checksum on a ROM at DS:0000 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	DS = segment for ROM 
				;	AL = ROM size in 512k blocks (1-127) 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-81


				; Output: 
				;	ZF if checksum is valid 
				;	AX = number of bytes read 
				;	DX = 8 bit checksum remainder 
				; 
				; Size: 20 bytes 
				;----------------------------------------------------------------------------; 
 E588				ROM_CHECKSUM PROC 
							ASSUME DS:NOTHING 
 E588  51				PUSH	CX 
 E589  56				PUSH	SI 
 E58A  98				CBW					; AH = 0 
 E58B  99				CWD					; DL = 0 (accumulator for sum) 
 E58C  8B F2				MOV	SI, DX			; start at offset 0 
 E58E  86 C4				XCHG	AL, AH			; convert 512 byte blocks to 16 bit words 
 E590  91				XCHG	AX, CX			; CX = size in 2 byte WORDs 
 E591				CHECKSUM_LOOP: 
 E591  AD				LODSW					; next two bytes into AL and AH 
 E592  02 D0				ADD	DL, AL			; add both to sum 
 E594  02 D4				ADD	DL, AH			; ZF if sum is 0 
 E596  E2 F9				LOOP	CHECKSUM_LOOP		; loop through entire ROM 
 E598  96				XCHG	AX, SI			; AX = bytes read 
 E599  5E				POP	SI 
 E59A  59				POP	CX 
 E59B  C3				RET 
 E59C				ROM_CHECKSUM ENDP 
				 
				;----------------------------------------------------------------------------; 
				; DETECT_MEMORY - Detect, test and clear RAM 
				;----------------------------------------------------------------------------; 
				; Attempt to determine how much RAM is installed using MEM_ADDR_TEST for  
				; more reliable memory detection. 
				; 
				; Output: Memory count to console 
				; Clobbers: Everything except DS 
				; 
				; NOTE: Testing first two bytes of each block is problematic: 
				; http://minuszerodegrees.net/5160/problems/5160_known_problems_issues.htm 
				; http://minuszerodegrees.net/5160/problems/5160_ram_size_flaw.htm 
				;----------------------------------------------------------------------------; 
 E59C				DETECT_MEMORY PROC 
							ASSUME DS:_BDA, ES:NOTHING 
 E59C  1E				PUSH	DS 
 E59D  B8 ---- R			MOV	AX, SEG _BDA 
 E5A0  8E D8				MOV	DS, AX 
				 
				;----------------------------------------------------------------------------; 
				; 5150 or MAX_RAM_AUTO: get MAX RAM from MEM_SZ_PC 
				; 
							ELSE 
								ELSE 
				;----------------------------------------------------------------------------; 
				; Otherwise, use default for MAX_RAM and detect 
				; 
 E5A2  B9 0027				MOV	CX, MAX_RAM / 16 - 1		; Max number of 16KB RAM blocks 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-82


											; after the first 16K block 
											; (ex: 640K / 16K - 1 = 39) 
								ENDIF 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Detect RAM size in 16K blocks 
				; 
 E5A5  BA 0400				MOV	DX, KBP < 16 >			; Start at second 16KB block para 
 E5A8  8E C2				MOV	ES, DX				; ES = seg 0400H 
 E5AA				BLOCK_LOOP: 
 E5AA  E8 E640 R			CALL	MEM_ADDR_TEST			; address test on 16KB RAM block at ES 
 E5AD  75 07				JNZ	BLOCK_LOOP_DONE			; exit loop if test failed 
 E5AF  80 C6 04				ADD	DH, HIGH KBP < 16 >		; add 400h paras (16 KB) 
 E5B2  8E C2				MOV	ES, DX 
 E5B4  E2 F4				LOOP	BLOCK_LOOP				; loop until MAX_RAM 
 E5B6				BLOCK_LOOP_DONE: 
				 
				;----------------------------------------------------------------------------; 
				; Test and clear RAM, show memory count 
				; 
				; Input: 
				;	ES/DX = highest memory segment detected 
				; 
							ENDIF 
				 
							ELSE 
 E5B6  B1 06				MOV	CL, 6					; 8088: shift right 6 times to get K 
 E5B8  D3 EA				SHR	DX, CL 
							ENDIF 
 E5BA  89 16 0013 R			MOV	MEM_SZ_KB, DX 			; save to BDA 
 E5BE  8C C2				MOV	DX, ES				; DX = highest RAM segment detected 
				 
				;----------------------------------------------------------------------------; 
				; Display RAM row 
				; 
					POST_COL_1	POST_MEMORY, POST_CLR_VAL1 ; display RAM column, SI returned 
			     1			ENDIF 
			     1			ELSE 
 E5C0  B3 0A                 1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute 
			     1			ENDIF 
 E5C2  BE E512 R             1		MOV	SI, OFFSET POST_MEMORY 
 E5C5  E8 F746 R             1		CALL	POST_START_COL_1 
			     1			ENDIF 
											;  as POST_KB_OK (next string) 
 E5C8  E8 F79F R			CALL	OUT_SZ				; display '000 KB OK' 
					POST_COL_END				; end post column 
			     1			ENDIF 
 E5CB  E8 F784 R             1		CALL	POST_END_COL 
			     1			ENDIF 
 E5CE  33 DB				XOR	BX, BX				; BX = 0, memory test counter 
 E5D0  8E C3				MOV	ES, BX				; start at segment 0000 
 E5D2				ZERO_ALL_RAM: 
 E5D2  33 C0				XOR	AX, AX				; zero AX 
 E5D4  83 C3 10				ADD	BX, 16				; increment memory count value 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-83


 E5D7  83 FB 64				CMP	BX, 100				; CF if two digit number 
 E5DA  14 09				ADC	AL, POST_COL_VT			; space inner column for 2 or 3 digits 
							ENDIF 
 E5DC  E8 F7AE R			CALL	MOVE_COL				; move to start of inner column 
 E5DF  53				PUSH	BX					; save RAM size 
 E5E0  93				XCHG	AX, BX				; move RAM size to AX for display 
 E5E1  E8 F7D9 R			CALL	OUT_DECU				; display AX as decimal 
 E5E4  5B				POP	BX					; restore RAM size 
 E5E5  8C C0				MOV	AX, ES				; AX = last segment tested 
 E5E7  05 0400				ADD	AX, KBP < 16 >			; move to next 16K segment/block 
 E5EA  3B C2				CMP	AX, DX				; is last segment of RAM? 
 E5EC  73 21				JNB	DONE_ZERO_ALL_RAM			; exit if end 
 E5EE				ZERO_ALL_RAM_1: 
 E5EE  8E C0				MOV	ES, AX				; ES = last segment tested 
				 
							IF RAM_TEST_LONG EQ 1 
					JWB	ZERO_ALL_START			; skip long tests on warm boot 
			     1				IF WARM_ENABLE EQ 1 
 E5F0  85 ED                 1		TEST	BP, BP				; is warm boot? 
 E5F2  78 10                 1		JS	ZERO_ALL_START					; jump if so 
			     1				ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Perform memory checks on this block 
				; 
 E5F4				TEST_MEM_LONG: 
 E5F4  E8 E680 R			CALL	NMI_RESET				; clear NMI/parity flags 
 E5F7  E8 E666 R			CALL	MEM_TEST				; read/write test on 16KB RAM block at ES 
 E5FA  75 15				JNZ	DETECT_MEMORY_ERR 
				 
							IF RAM_PARITY EQ 1 
 E5FC  92				XCHG	AX, DX				; save AX 
 E5FD  E4 62				IN	AL, PPI_C				; read PPI Port C 
 E5FF  24 C0				AND	AL, MASK PCPE OR MASK PCIE	; was there parity or NMI error? 
 E601  92				XCHG	AX, DX				; DL = parity error flag(s) 
 E602  75 0D				JNZ	DETECT_MEMORY_ERR			; jump if parity error 
							ENDIF				; END RAM_PARITY EQ 1 
							ENDIF				; END RAM_TEST_LONG EQ 1 
				 
				;----------------------------------------------------------------------------; 
				; Write 0's to all memory in this block 
				; 
 E604				ZERO_ALL_START: 
 E604  33 C0				XOR	AX, AX 				; write zeros 
 E606  B9 2000				MOV	CX, KBW < 16 >			; loop 16KB in WORDs 
 E609  8B F8				MOV	DI, AX				; DI = beginning of segment 
 E60B  F3/ AB				REP	STOSW 				; write zero to next 16KB 
 E60D  EB C3				JMP	SHORT ZERO_ALL_RAM 
 E60F				DONE_ZERO_ALL_RAM: 
				 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Done with DETECT_MEMORY 
				; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-84


 E60F  1F				POP	DS 
 E610  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; Compare the result read from memory to the expected results to determine 
				; which bit(s) did not match. 
				; 
				; Error will be displayed as SEG:OFF BBBB. 
				; 
				; - SEG: location/bank in memory of the failed IC, which can be calculated 
				;   using the following: 
				;   http://minuszerodegrees.net/5160/ram/5160_ram_201_error_breakdown.jpg 
				; - OFF: offset where the failure occurred 
				; - BBBB: bit pattern difference between what was expected and what was  
				;   read. This should reveal which IC in that bank failed. 
				;----------------------------------------------------------------------------; 
				; Input: 
				; 	DL = 0 if no parity error, bit 7 or 6 set if error 
				; 
 E611				DETECT_MEMORY_ERR: 
							ENDIF 
					POST_FLAG_SET  PMEM			; set POST Memory error flag 
			     1				ELSE 
 E611  81 CD 0200            1		OR	BP, MASK PMEM			; Set FLAG 
			     1				ENDIF 
 E615  E8 F7C8 R			CALL	CRLF					; start on new line 
					POST_COL_1	POST_ERR_ERR, RED 
			     1			ENDIF 
			     1			ELSE 
 E618  B3 0C                 1		MOV	BL, LOW RED		; BL = attribute 
			     1			ENDIF 
 E61A  BE E90C R             1		MOV	SI, OFFSET POST_ERR_ERR 
 E61D  E8 F746 R             1		CALL	POST_START_COL_1 
			     1			ENDIF 
 E620  4F				DEC	DI					; move back to last address 
 E621  4F				DEC	DI 
 E622  26: 33 05			XOR	AX, ES:[DI]				; determine incorrect bit(s) 
 E625  97				XCHG	AX, DI				; DI = bit pattern, AX = err offset 
 E626  8C C3				MOV	BX, ES				; segment of error 
 E628  E8 F7F0 R			CALL	DWORD_HEX				; write address 
 E62B  84 D2				TEST	DL, DL				; was there a parity error? 
 E62D  74 08				JZ	DETECT_MEMORY_ERR_2		; jump if not 
					PRINT_SZ  NMI_ERR_PAR			; print 'PARITY' 
			     1			ENDIF 
			     1			IFDIFI <NMI_ERR_PAR>,<SI>			; if SZ is not SI 
 E62F  BE E53D R             1		MOV	SI, OFFSET NMI_ERR_PAR 
			     1			ENDIF 
 E632  E8 F79F R             1		CALL	OUT_SZ 
			     1			ENDIF 
 E635  EB 04				JMP	SHORT DETECT_MEMORY_ERR_DONE 
 E637				DETECT_MEMORY_ERR_2: 
 E637  97				XCHG	AX, DI				; restore failed bit pattern 
 E638  E8 F7FC R			CALL	WORD_HEX 
 E63B				DETECT_MEMORY_ERR_DONE: 
					POST_COL_END 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-85


			     1			ENDIF 
 E63B  E8 F784 R             1		CALL	POST_END_COL 
			     1			ENDIF 
							ENDIF 
 E63E  EB CF				JMP	SHORT DONE_ZERO_ALL_RAM 
 E640				DETECT_MEMORY ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Test Memory Address Lines on a 16KB block 
				;----------------------------------------------------------------------------; 
				; Write a byte to the first address in a segment and write a different 
				; value with one address line toggled. Read back the values to ensure 
				; they are both correct. Repeat 8 times for each starting bit. 
				; 
				; Input: 
				;	ES = segment to test 
				; Output: 
				;	ZF if okay, NZ if fail 
				;	BX = offset of failed byte/line, DI 
				; 
				; Clobbers AL 
				; 
				; Inspired by: 
				; http://www.ganssle.com/testingram.htm 
				; http://www.paul.de/tips/ramtest.htm 
				; https://www.memtest86.com/tech_memtest-algoritm.html 
				; Size: 38 bytes 
				;----------------------------------------------------------------------------; 
 E640				MEM_ADDR_TEST PROC 
 E640  B0 01				MOV	AL, 1					; pattern to rotate 
 E642  33 DB				XOR	BX, BX				; base address 
 E644  BF 2000				MOV	DI, 2000H				; highest address in 16KB segment 
 E647				MEM_ADDR_LOOP: 
 E647  26: 88 07			MOV	ES:[BX], AL				; write to base address 
 E64A  F6 D0				NOT	AL					; invert value 
 E64C  26: 88 05			MOV	ES:[DI], AL				; write inverted value 
 E64F  F6 D0				NOT	AL					; revert value 
 E651  26: 38 07			CMP	ES:[BX], AL				; is base value the same? 
 E654  75 0F				JNZ	MEM_ADDR_ERR			; jump if not 
 E656  F6 D0				NOT	AL					; invert value again 
 E658  26: 38 05			CMP	ES:[DI], AL				; is second value the same? 
 E65B  75 08				JNZ	MEM_ADDR_ERR			; jump if not 
 E65D  F6 D0				NOT	AL					; revert value again 
 E65F  D0 C0				ROL	AL, 1					; walk test value 
 E661  D1 EF				SHR	DI, 1					; move to next address line 
 E663  75 E2				JNZ	MEM_ADDR_LOOP			; loop until offset is 0 
 E665				MEM_ADDR_ERR: 
 E665  C3				RET 
 E666				MEM_ADDR_TEST ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Test a 16KB block of Memory at ES:0000 
				;----------------------------------------------------------------------------; 
				; Trivial read/write test - Write pattern RAM_TEST and reads it back, then  
				; repeat with inverse RAM_TEST. If NMI is on, this could trigger a parity 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-86


				; error. 
				; 
				; Input: 
				; 	ES = segment to test 
				; Output: 
				;	ZF and AX = 0 if pass, NZ if fail 
				; 
				; Clobbers: AX, CX, DI 
				; 
				; Size: 26 bytes 
				;----------------------------------------------------------------------------; 
 E666				MEM_TEST PROC 
 E666  B8 731D				MOV	AX, RAM_TEST			; test pattern 
 E669  E8 E671 R			CALL	MEM_CHECK				; write and verify pattern 
 E66C  75 F7				JNZ	MEM_ADDR_ERR			; return if error 
 E66E  B8 8CE2				MOV	AX, NOT RAM_TEST			; inverted test pattern 
				 
				;----------------------------------------------------------------------------; 
				; Write and verify a 16KB block of Memory at ES:0000 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AX = pattern to write 
				; 	ES = segment for test 
				; Output: 
				;	ZF and AX = 0 if pass, NZ if fail 
				; 
				; Clobbers: AX, CX, DI 
				;----------------------------------------------------------------------------;	 
 E671				MEM_CHECK PROC 
 E671  B9 2000				MOV	CX, KBW < 16 >			; loop 16KB in WORDs 
 E674  33 FF				XOR	DI, DI 				; start at offset 0 
 E676  F3/ AB				REP	STOSW 				; write test pattern 
 E678				MEM_TEST_VERIFY: 
 E678  B5 20				MOV	CH, HIGH KBW < 16 >		; restart loop 16KB in WORDs 
 E67A  33 FF				XOR	DI, DI 				; start at offset 0 
 E67C  F3/ AF				REPZ	SCASW 				; loop until CX = 0 OR WORD is not AX 
 E67E  91				XCHG	AX, CX				; AX = 0 if success 
 E67F  C3				RET 
 E680				MEM_CHECK ENDP 
 E680				MEM_TEST ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Reset NMI enable flags 
				;----------------------------------------------------------------------------; 
				; Output: 
				;	AL = current PPI B flags 
				; 
				; Size: 11 bytes 
				;----------------------------------------------------------------------------; 
 E680				NMI_RESET PROC 
 E680  E4 61				IN	AL, PPI_B				; read current flags 
 E682  0C 30				OR	AL, MASK PBIO OR MASK PBPC	; parity, I/O flags high (disable) 
 E684  E6 61				OUT	PPI_B, AL				; write to PPI 
 E686  34 30				XOR	AL, MASK PBIO OR MASK PBPC	; flags low (enable) 
 E688  E6 61				OUT	PPI_B, AL				; write to PPI 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-87


 E68A  C3				RET 
 E68B				NMI_RESET ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Delay using PIT counter increments of 125 ms 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AL = wait in 125 ms increments 
				; 
				; AX clobbered 
				; Size: 53 bytes 
				;----------------------------------------------------------------------------; 
 E68B				IO_WAIT_MS_125 PROC 
 E68B  B4 7D				MOV	AH, 125 
 E68D  F6 E4				MUL	AH				; AX = wait in 1 ms 
				 
				;----------------------------------------------------------------------------; 
				; Delay using PIT counter increments of 1 ms 
				;----------------------------------------------------------------------------; 
				; - Calculate the total number of PIT ticks necessary (where 1,193,182 = 1s) 
				; - Latch the PIT and draw down the countdown total on each read. 
				; - Exit when countdown underflows. 
				; 
				; Note: Mode 3 (Square Wave) decements the readable counter by 2, so the 
				; effective frequency of the counter is actually 2,386,364 Hz. 
				; 
				; Input: 
				;	AX = wait in number of ms (clobbered) 
				; 
				; Based on contribution by @Raffzahn (under CC BY-SA 4.0): 
				; https://retrocomputing.stackexchange.com/a/24874/21323 
				; 
				; https://stanislavs.org/helppc/8253.html 
				;----------------------------------------------------------------------------; 
 E68F				IO_DELAY_MS PROC 
 E68F  53				PUSH	BX 
 E690  BB 0952				MOV	BX, 1193 * 2		; 1,193,182 / 1000 ms * 2 = 2,386 ticks/ms 
				 
				;----------------------------------------------------------------------------; 
				; Delay using PIT counter DX:AX number of ticks 
				;----------------------------------------------------------------------------; 
 E693				IO_DELAY_TICK PROC 
 E693  51				PUSH	CX 
 E694  52				PUSH	DX 
 E695  F7 E3				MUL	BX				; DX:AX = countdown of PIT ticks to wait 
 E697  93				XCHG	AX, BX			; DX:BX = countdown ticks 
 E698  E8 E6AD R			CALL	IO_WAIT_LATCH		; AX = start read 
 E69B				IO_WAIT_MS_LOOP: 
 E69B  8B C8				MOV	CX, AX			; CX = last read 
 E69D  E8 E6AD R			CALL	IO_WAIT_LATCH		; AX = current counter reading 
 E6A0  2B C8				SUB	CX, AX			; CX = # of ticks elapsed since last reading 
 E6A2  2B D9				SUB	BX, CX			; subtract change in ticks from countdown 
 E6A4  83 DA 00				SBB	DX, 0				; borrow out of high word (if necessary) 
 E6A7  73 F2				JAE	IO_WAIT_MS_LOOP		; loop while countdown >= 0 
 E6A9  5A				POP	DX 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-88


 E6AA  59				POP	CX 
 E6AB  5B				POP	BX 
 E6AC				IO_WAIT_MS_DONE: 
 E6AC  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; Latch PIT 0 and read counter to AX 
				;----------------------------------------------------------------------------; 
				; Output: AX = current counter 
				; Time: 123 clock cycles (including CALL) 
				;----------------------------------------------------------------------------; 
 E6AD				IO_WAIT_LATCH PROC 
 E6AD  B0 00				MOV	AL, PIT_CW <0, 0>		; Counter 0, Latch (00b) 
 E6AF  9C				PUSHF					; save current IF 
 E6B0  FA				CLI					; disable interrupts 
 E6B1  E6 43				OUT	PIT_CTRL, AL		; Write command to CTC 
 E6B3  E4 40				IN	AL, PIT_CH0			; Read low byte of Counter 0 latch 
 E6B5  8A E0				MOV	AH, AL			; Save it 
 E6B7  E4 40				IN	AL, PIT_CH0			; Read high byte of Counter 0 latch 
 E6B9  9D				POPF					; restore IF state 
 E6BA  86 C4				XCHG	AL, AH			; convert endian 
 E6BC  C3				RET 
 E6BD				IO_WAIT_LATCH ENDP 
 E6BD				IO_DELAY_TICK ENDP 
 E6BD				IO_DELAY_MS ENDP 
 E6BD				IO_WAIT_MS_125 ENDP 
				 
						ELSE 
 =				IO_DELAY_MS_FDC	EQU IO_DELAY_MS 
						ENDIF 
				 
							ENDIF 
				 
				; 
				; 40 BYTES HERE / 6 BYTES HERE 5150 
				; 
				BYTES_HERE	INT_19 
 = 0035                      1	BYTES_HERE_INT_19 = INT_19-$ 
			     1			IFDEF BYTES_HERE_INT_19 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 19 - Bootstrap Loader 
				;----------------------------------------------------------------------------; 
				; IPL: track 0, sector 1 is loaded into address 0:7C00 and control  
				; is transferred. 
				; 
				; Input: 
				; 	DL = physical drive where boot sector is located (00=A:,80h=C:) 
				; Output: 
				;	Transfer control to bootable MBR if success 
				;	IRET if failure 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-89


				; 
				; Clobbers AX, BX, CX, DH, DI, DS, ES 
				;----------------------------------------------------------------------------; 
 E6F2						ORG 0E6F2H 
 E6F2				INT_19 PROC 
						ASSUME DS:_IPL_SEG, ES:_IPL_SEG 
 E6F2  FB				STI						; enable interrupts 
 E6F3  FC				CLD						; clear direction for STOS 
 E6F4  33 C9				XOR	CX, CX				; CX = 0 
 E6F6  8E D9				MOV	DS, CX				; DS = IPL Segment (0000) 
 E6F8  8E C1				MOV	ES, CX				; ES = IPL Segment (0000) 
 E6FA  BF 0078 R			MOV	DI, OFFSET IVT_1E			; INT 1E vector table address 
 E6FD  B8 EFC7 R			MOV	AX, OFFSET INT_1E 		; INT 1E DBT address 
 E700  AB				STOSW 
 E701  8C C8				MOV	AX, CS				; INT 1E DBT segment 
 E703  AB				STOSW 
 E704				INT_19_READ_MBR: 
 E704  91				XCHG	AX, CX				; AH = 0 (reset) 
 E705  CD 13				INT	13H					; reset disk 0 
 E707  72 14				JC	INT_19_IPL_FAIL			; exit if error 
 E709  B8 0201				MOV	AX, DBW <2, 1>			; AH = 2 (read), AL = 1 sector 
 E70C  BB 7C00 R			MOV	BX, OFFSET IPL_TOP		; ES:BX = IPL boot sector offset 
 E70F  B9 0001				MOV	CX, DBW <0, 1>			; CH = cyl 0, CL = sec 1 
 E712  8A F5				MOV	DH, CH 				; DH = head 0, DL = drive # 
 E714  CD 13				INT	13H					; read 1 sector into ES:BX 
 E716  72 05				JC	INT_19_IPL_FAIL			; exit if error 
							ENDIF 
 E718  EA 7C00 ---- R			JMP 	FAR PTR IPL_TOP 			; jump to IPL segment and boot! 
 E71D				INT_19_IPL_FAIL: 
 E71D  CF				IRET 
						ASSUME DS:NOTHING, ES:NOTHING 
 E71E				INT_19 ENDP 
				 
						IF POST_HD_CHECK EQ 1 
				;----------------------------------------------------------------------------; 
				;  Get Hard Drive Parameters 
				;----------------------------------------------------------------------------; 
				;  Input: 
				;	DL = drive number 
				;  Output: 
				; 	CF if Error 
				;	AL = number of heads (AX if no error) 
				; 	AH = return code 
				;	BX = last cylinder 
				; 	CX = logical last index of sectors/track 
				;	DX = number of hard disk drives (all) 
				;----------------------------------------------------------------------------; 
 E71E				GET_DISK_PARAMS PROC 
 E71E  B4 08				MOV	AH, 8 			; Get Drive in DL Parameters:  
 E720  CD 13				INT	13H				;  CH = Last cyl, CL = # cylinders 
										;  DH = heads, DL = # drives 
										;  ES:DI = drive table 
 E722  72 14				JC	GET_DISK_PARAMS_ERR 	; if error, exit 
 E724  8B D9				MOV	BX, CX 			; BX = last cylinder 
 E726  86 FB				XCHG	BH, BL 			; swap bytes 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-90


 E728  D0 C7				ROL	BH, 1 			; rotate high two bits into low bits 
 E72A  D0 C7				ROL	BH, 1 
 E72C  80 E7 03				AND	BH, 11B			; BX = cylinder (10 bits) 
 E72F  83 E1 3F				AND	CX, 00111111B		; CX = logical last index of sectors/track 
 E732  8A C6				MOV	AL, DH 
 E734  40				INC	AX				; convert heads to 1 index (count) 
 E735  43				INC	BX				; convert cylinders to 1 index 
 E736  32 F6				XOR	DH, DH			; clear high byte of DX, CF = 0 
 E738				GET_DISK_PARAMS_ERR: 
 E738  C3				RET 
 E739				GET_DISK_PARAMS ENDP 
						ENDIF 
				 
				; 
				; 0 BYTES HERE 
				; 
				BYTES_HERE	INT_14 
 = 0000                      1	BYTES_HERE_INT_14 = INT_14-$ 
			     1			IFDEF BYTES_HERE_INT_14 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 14 - BIOS COM Port Services 
				;----------------------------------------------------------------------------; 
				;	INT 14,0  Initialize serial port parameters 
				;	INT 14,1  Send/write character in AL 
				;	INT 14,2  Receive/read character in AL 
				;	INT 14,3  Get Serial port status 
				; 
				; All functions have: 
				;	  AH = function number (bounds not checked) 
				;	  AL = character to send or receive 
				;	  DX = zero based RS232 card number 
				; 
				; All registers call-preserved (except AX) 
				;----------------------------------------------------------------------------; 
				; Ref: 
				; https://stanislavs.org/helppc/int_14.html 
				;----------------------------------------------------------------------------; 
 E739						ORG 0E739H 
 E739				INT_14 PROC 
							ASSUME DS:_BDA 
 E739  FB				STI 					; enable interrupts 
 E73A  51				PUSH	CX 				; call-preserve CX 
 E73B  B9 0003				MOV	CX, 3 			; will use this 3 in multiple places 
 E73E  3B D1				CMP	DX, CX			; is port number valid? 
 E740  77 53				JA	INT_14_EXIT 		; exit if port is > 3 
					PUSHX	DI, BX, DX, DS		; call-preserve registers 
			     1				IFNB <DI>			; exit if last reg 
 E742  57                    1		PUSH	DI 					; push register and repeat 
			     1		PUSHX	BX, DX, DS, , , ,  
			     2				IFNB <BX>			; exit if last reg 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-91


 E743  53                    2		PUSH	BX 					; push register and repeat 
			     2		PUSHX	DX, DS, , , , ,  
			     3				IFNB <DX>			; exit if last reg 
 E744  52                    3		PUSH	DX 					; push register and repeat 
			     3		PUSHX	DS, , , , , ,  
			     4				IFNB <DS>			; exit if last reg 
 E745  1E                    4		PUSH	DS 					; push register and repeat 
			     4		PUSHX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 E746  BF ---- R			MOV	DI, SEG _BDA 		; DS = BDA 
 E749  8E DF				MOV	DS, DI 
 E74B  8B FA				MOV	DI, DX 			; DI = COM port index (0-3) 
 E74D  8B DF				MOV	BX, DI			; convert to word index 
 E74F  99				CWD					; DX = 0 
 E750  03 11				ADD	DX, [BX][DI]		; DX = 3F8/2F8 base port address 
 E752  74 3D				JZ	INT_14_DONE 		; is port index valid (detected)? 
 E754  3A E1				CMP	AH, CL			; check function number (CL = 3) 
 E756  77 39				JA	INT_14_DONE			; > 3? Not valid 
 E758  74 2D				JZ 	INT_14_3	 		; = 3 then status 
 E75A  80 FC 01				CMP	AH, 1				; check remaining functions 
 E75D  77 56				JA	INT_14_2 			; = 2 then read 
 E75F  74 36				JZ	INT_14_1 			; = 1 then write 
										; = 0 fall through to init 
				 
				;----------------------------------------------------------------------------; 
				; INT 14,0  Initialize serial port parameters 
				;----------------------------------------------------------------------------; 
				; https://stanislavs.org/helppc/int_14-0.html 
				; https://stanislavs.org/helppc/8250.html 
				;----------------------------------------------------------------------------; 
				; Baud rate divisor table: 
				;	0 (000) = 110 baud -> 417H	|	4 (100) = 1200 baud -> 60H 
				;	1 (001) = 150 baud -> 300H	|	5 (101) = 2400 baud -> 30H 
				;	2 (010) = 300 baud -> 180H	|	6 (110) = 4800 baud -> 18H 
				;	3 (011) = 600 baud -> 0C0H	|	7 (111) = 9600 baud -> 0CH 
				; 
				; Formula: 
				;	if (baud == 110) then 
				; 		divisor = 417H 
				;	else 
				;		divisor = 600H >> index 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	DX = base port address 
				;	AL = port params, AH = 0 
				;	CX = 3 (from earlier) 
				;----------------------------------------------------------------------------; 
				 
 E761				INT_14_0 PROC 
				;----------------------------------------------------------------------------; 
				; Set baud rate 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-92


				; 
 E761  8B FA				MOV	DI, DX 			; DX = 3F8/2F8 base port 
 E763  03 D1				ADD	DX, CX			; DX = 3FB/2FB Line Control Register (LCR), CX = 3 
 E765  93				XCHG	AX, BX			; save port params to BL 
 E766  B0 80				MOV	AL, MASK DLAB 		; set baud rate divisor (DLAB); 0 = RBR, THR or IER 
 E768  EE				OUT	DX, AL 			; write to 3FB/2FB (LCR) 
 E769  D3 E3				SHL	BX, CL 			; BH = baud rate, CL = 3 
 E76B  D2 EB				SHR	BL, CL 			; BL = flags 
 E76D  B8 0417				MOV	AX, 417H 			; divisor for 110 baud 
 E770  8A CF				MOV	CL, BH 			; CL = shift counter or 0 for 110 baud (CH = 0) 
 E772  E3 05				JCXZ	INT_14_0_SET_BAUD		; Jump if 110 baud 
 E774  B8 0600				MOV	AX, 600H 			; AX = divisor base (see above formula) 
 E777  D3 E8				SHR	AX, CL			; divisor = 600H >> CL 
 E779				INT_14_0_SET_BAUD: 
 E779  87 D7				XCHG	DX, DI 			; DX = 3F8/2F8, DI = 3FB/2FB (4) 
										; AL = Divisor LSB, AH = Divisor MSB (4) 
 E77B  EF				OUT	DX, AX			; write LSB, then MSB to ports 3F8/3F9 
				;----------------------------------------------------------------------------; 
				; Set parity, stop and word bits 
				;  
 E77C				INT_14_0_SET_PSW: 
 E77C  93				XCHG	AX, BX 			; AL = parity, stop and word bits (4) 
 E77D  87 D7				XCHG	DX, DI 			; DX = 3FB/2FB, DI = 3F8/2F8 (4) 
 E77F  EE				OUT	DX, AL			; set LCR parity, stop and word bits 
 E780  87 D7				XCHG	DX, DI 			; DX = 3F8/2F8, DI = 3FB/2FB (4) 
				;----------------------------------------------------------------------------; 
				; Disable IER 
				; 
 E782  33 C0				XOR	AX, AX 			; AL = 0 (3) 
 E784  42				INC	DX 				; DX = 3F9/2F9 (3) 
 E785  EE				OUT	DX, AL			; DX = 3F9 - Interrupt Enable Register (IER) disabled 
 E786  4A				DEC	DX 				; DX = 3F8 (3) 
										; fall through to get status 
				 
				;----------------------------------------------------------------------------; 
				; INT 14,3  Get Serial port status 
				;----------------------------------------------------------------------------; 
				; Input: 
				; 	DX = base port address 
				; Output: 
				;	AH = port status 
				;	AL = modem status 
				;----------------------------------------------------------------------------; 
 E787				INT_14_3 PROC 
 E787  83 C2 05				ADD	DX, COM1_LSR-COM1_DATA	; DX = 3FD/2FD LSR - Line Status Register 
 E78A  53				PUSH	BX				; delay for I/O 
 E78B  EC				IN	AL, DX 			; get line/port status  
 E78C  86 E0				XCHG	AH, AL 			; save to AH 
 E78E  42				INC	DX 				; DX = 3FE/2FE MSR - Modem Status Register 
 E78F  5B				POP	BX 				; delay for I/O 
 E790  EC				IN	AL, DX 			; get modem status  
 E791				INT_14_3 ENDP 
				 
 E791				INT_14_DONE PROC 
					POPX	DS, DX, BX, DI		; restore all registers 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-93


			     1				IFNB <DS>			; exit if last reg 
 E791  1F                    1		POP	DS 					; pop register and repeat 
			     1		POPX	DX, BX, DI, , , ,  
			     2				IFNB <DX>			; exit if last reg 
 E792  5A                    2		POP	DX 					; pop register and repeat 
			     2		POPX	BX, DI, , , , ,  
			     3				IFNB <BX>			; exit if last reg 
 E793  5B                    3		POP	BX 					; pop register and repeat 
			     3		POPX	DI, , , , , ,  
			     4				IFNB <DI>			; exit if last reg 
 E794  5F                    4		POP	DI 					; pop register and repeat 
			     4		POPX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
				 
 E795				INT_14_EXIT: 
 E795  59				POP	CX 
 E796  CF				IRET 
 E797				INT_14_DONE ENDP 
				 
 E797				INT_14_0 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 14, 1 - Send/write character in AL 
				;----------------------------------------------------------------------------; 
				; Input: 
				; 	DX = base port address 
				;	BL = port timeout 
				;----------------------------------------------------------------------------; 
 E797				INT_14_1 PROC 
 E797  52				PUSH	DX 					; save base port 
 E798  50				PUSH	AX 
 E799  83 C2 04				ADD	DX, COM1_MCR-COM1_DATA		; DX = 3FC/2FC - Modem Control Register 
 E79C  B0 03				MOV	AL, MASK RTS OR MASK DTR	; activate DTR & RTS 
 E79E  EE				OUT	DX, AL				; set DTR or RTS 
 E79F  42				INC	DX 
 E7A0  42				INC	DX 					; DX = 3FE - Modem Status Register 
 E7A1  BB 3020				MOV	BX, DBW <MASK THRE OR MASK LBI, MASK MDSR> ; BH = line (THRE) 
											;  BL = modem (DSR/CTS) 
 E7A4  E8 E7CB R			CALL	INT_14_POLL 			; poll both registers, AH = status 
 E7A7  5B				POP	BX 
 E7A8  8A C3				MOV	AL, BL 				; AL = output char 
 E7AA  5A				POP	DX 					; restore base port 
 E7AB  75 03				JNZ	INT_14_RW_ERR			; Jump if port timeout 
 E7AD  EE				OUT	DX, AL 
 E7AE  EB E1				JMP	SHORT INT_14_DONE 
 E7B0				INT_14_RW_ERR: 
 E7B0  80 CC 80				OR	AH, 10000000B			; set error bit 
 E7B3  EB DC				JMP	SHORT INT_14_DONE 
 E7B5				INT_14_1 ENDP 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-94


				; INT 14, 2 - Receive/read character in AL 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	DX = base port address 
				;	BL = port timeout 
				; Output: 
				;	AH = port status 
				;	AL = character read 
				;	NZ = timeout or failure occurred 
				; 
				; Clobbers: BX 
				;----------------------------------------------------------------------------; 
 E7B5				INT_14_2 PROC 
 E7B5  52				PUSH	DX 					; save base port 
 E7B6  83 C2 04				ADD	DX, COM1_MCR-COM1_DATA		; DX = 3FC/2FC - Modem Control Register 
 E7B9  B0 01				MOV	AL, MASK DTR			; activate DTR 
 E7BB  EE				OUT	DX, AL				; set DTR 
 E7BC  42				INC	DX 
 E7BD  42				INC	DX 					; DX = 3FE/2FE - Modem Status Register 
 E7BE  BB 2001				MOV	BX, DBW <MASK MDSR, MASK LDR>	; BH = modem (DSR), BL = line (data ready) 
 E7C1  E8 E7CB R			CALL	INT_14_POLL 			; poll both registers, AH = status 
 E7C4  5A				POP	DX 					; restore base port 
 E7C5  80 E4 1E				AND	AH, MASK LBI OR MASK LFE OR MASK LPE OR MASK LOE ; include only  
											;  error bits in port status 
 E7C8  EC				IN	AL, DX				; read char from buffer 
 E7C9  EB C6				JMP	SHORT INT_14_DONE 
 E7CB				INT_14_2 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 14 - Poll line then modem status registers 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	DI = port index (0 based byte) 
				; 	DX = 3FE Modem Status Register 
				;	BL = line status expected masked 
				;	BH = modem status expected masked 
				; Output: 
				;	AH = port status 
				;	DX = 3FD Line Status Register 
				;	NZ = timeout or failure occurred 
				; 
				; Clobbers: AX, CX 
				;----------------------------------------------------------------------------; 
 E7CB				INT_14_POLL PROC 
 E7CB  E8 E7D3 R			CALL	INT_14_POLL_PORT 		; first poll modem status 
 E7CE  75 1A				JNZ	INT_14_POLL_RET  		; jump if ZF = 0, timeout or failure occurred 
 E7D0  86 FB				XCHG	BH, BL 			; BH = line status 
 E7D2  4A				DEC	DX				; DX = 3FD Line Status Register (LSR) 
				 
				;----------------------------------------------------------------------------; 
				; INT 14 - Poll status register in DX 
				;----------------------------------------------------------------------------; 
 E7D3				INT_14_POLL_PORT PROC 
 E7D3  56				PUSH	SI 				; call-preserve SI 
 E7D4  33 C9				XOR	CX, CX			; reset poll loop counter 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-95


 E7D6  8A 45 7C				MOV	AL, COM_TIME_B[DI]	; AL = port timeout (< 127) 
 E7D9  98				CBW					; zero extend AX 
 E7DA  96				XCHG	AX, SI 			; SI = port timeout 
 E7DB				INT_14_POLL_LOOP: 
 E7DB  EC				IN	AL, DX 			; check port status 
 E7DC  8A E0				MOV	AH, AL 			; save to AH 
 E7DE  32 C7				XOR	AL, BH 			; mask result bits 
 E7E0  84 C7				TEST	AL, BH 			; did it match expected result? 
 E7E2  74 05				JZ	INT_14_POLL_DONE 
 E7E4  E2 F5				LOOP	INT_14_POLL_LOOP		; poll port 65,535 * timeout times 
 E7E6  4E				DEC	SI 				; 
 E7E7  75 F2				JNZ	INT_14_POLL_LOOP		; Jump if timeout not expired 
 E7E9				INT_14_POLL_DONE: 
 E7E9  5E				POP	SI 
 E7EA				INT_14_POLL_RET: 
 E7EA  C3				RET 
 E7EB				INT_14_POLL_PORT ENDP 
 E7EB				INT_14_POLL ENDP 
				 
 E7EB				INT_14 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; I/O port register test 
				;----------------------------------------------------------------------------; 
				; Do a Walking Bit/March test on I/O port registers. 
				; 
				; Input: 
				;	DX = starting port 
				;	AH = number of sequential ports to test 
				; Output: 
				;	ZF and CX = 0 if success 
				;	NZ if failed 
				; 
				; Adapted from: 
				; https://barrgroup.com/embedded-systems/how-to/memory-test-suite-c 
				; https://www.edaboard.com/threads/walking-1-0-test-for-memory-bist.241278/ 
				; 
				; Size: 47 bytes 
				; Clobbers AX, BX, CX, DX, DI 
				;----------------------------------------------------------------------------; 
 E7EB				PORT_TEST PROC 
 E7EB  B7 01				MOV	BH, 1				; start with low order bit 
 E7ED  33 C9				XOR	CX, CX			; clear counter 
 E7EF  8B FA				MOV	DI, DX			; save starting port 
				 
				;----------------------------------------------------------------------------; 
				; Write a single 1 bit to a different position in each register 
				; 
 E7F1				WB_WRITE_1: 
 E7F1  8A CC				MOV	CL, AH			; register counter 
 E7F3  8B D7				MOV	DX, DI 			; start at first register 
 E7F5  8A C7				MOV	AL, BH			; AL = starting bit to write 
 E7F7				WB_WRITE_LOOP: 
 E7F7  EE				OUT	DX, AL			; write to low byte 
					IO_DELAY_SHORT 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-96


			     1				IF ARCH_TYPE NE ARCH_EMU 
 E7F8  EB 00                 1		JMP	SHORT ??001B 
 E7FA                        1	??001B: 
			     1				ENDIF 
 E7FA  EE				OUT	DX, AL			; write to high byte 
 E7FB  42				INC	DX				; next register/port 
 E7FC  D0 C0				ROL	AL, 1				; walk bit to next position 
 E7FE  E2 F7				LOOP	WB_WRITE_LOOP 
				 
				;----------------------------------------------------------------------------; 
				; Read back bit pattern from each register 
				; 
 E800  8A CC				MOV	CL, AH			; register counter 
 E802  8B D7				MOV	DX, DI 			; start at first register 
 E804  8A DF				MOV	BL, BH			; BL = starting bit to compare 
 E806				WB_READ_LOOP: 
 E806  EC				IN	AL, DX			; read low byte 
 E807  3A C3				CMP	AL, BL			; compare to correct bit 
 E809  75 0E				JNZ	PORT_TEST_DONE		; jump if not okay 
 E80B				WB_LOW_CHECK_OK: 
 E80B  EC				IN	AL, DX			; read high byte 
 E80C  3A C3				CMP	AL, BL			; compare to correct bit 
 E80E  75 09				JNZ	PORT_TEST_DONE		; jump if not okay 
 E810  42				INC	DX				; next register/port 
 E811  D0 C3				ROL	BL, 1				; rotate for next register/bit 
 E813  E2 F1				LOOP	WB_READ_LOOP		; loop all eight registers 
 E815  D0 E7				SHL	BH, 1				; rotate to next starting bit 
 E817  75 D8				JNZ	WB_WRITE_1			; loop until BH = 0 
 E819				PORT_TEST_DONE: 
 E819  C3				RET 
 E81A				PORT_TEST ENDP 
							IF POST_VIDEO_TYPE EQ 1 
				;----------------------------------------------------------------------------; 
				; POST Video Adapter Type Strings 
				; 17 bytes 
				; 
 E81A  56 47 41 00		POST_VGA		DB	'VGA', 0 
 E81E  45 47 41 00		POST_EGA		DB	'EGA', 0 
 E822  43 47 41 00		POST_CGA		DB	'CGA', 0 
 E826  4D 6F 6E 6F 00		POST_MDA		DB	'Mono', 0 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; POST Initial INT 10H Video Mode to BIOS video equipment type 
				; 
 E82B  01 03 07			VID_MODE_TBL	DB	1, 3, 7	; Color 40x25, Color 80x25, Mono 80x25 
				 
				; 
				; 0 BYTES HERE 
				; 
				BYTES_HERE	INT_16 
 = 0000                      1	BYTES_HERE_INT_16 = INT_16-$ 
			     1			IFDEF BYTES_HERE_INT_16 
			     1			IF2 
			     1			ENDIF 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-97


			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 16 - Keyboard BIOS Services 
				;----------------------------------------------------------------------------; 
				;	INT 16,0	Wait for keystroke and read 
				;	INT 16,1	Get keystroke status 
				;	INT 16,2	Get shift status 
				; Enhanced: 
				;	INT 16,5	Keyboard buffer write 
				;	INT 16,10	Wait for keystroke and read 
				;	INT 16,11	Get keystroke status 
				;	INT 16,12	Get shift status 
				;----------------------------------------------------------------------------; 
 E82E						ORG 0E82EH 
 E82E				INT_16 PROC 
						ASSUME DS:_BDA 
 E82E  FB				STI					; necessary? 
 E82F  FC				CLD 
 E830  1E				PUSH	DS 
 E831  56				PUSH	SI 
 E832  BE ---- R			MOV	SI, SEG _BDA 
 E835  8E DE				MOV	DS, SI 			; DS = BDA segment 
 E837  80 FC 02				CMP	AH, 2 
 E83A  74 33				JE	KB_SHIFT_STATUS 		; AH = 2 - Get Shift Status 
 E83C  77 2E				JA	INT_16_DONE			; AH > 2 - Not valid, exit 
 E83E  7B 15				JNP	KB_WAIT_READ_1		; AH = 0 - Wait for keystroke and read 
										; AH = 1 - Get keystroke (fall through) 
				 
				;----------------------------------------------------------------------------; 
				; AH = 1 - Get keystroke status 
				;----------------------------------------------------------------------------; 
				; Check if a key press is in buffer and return. Does not wait or remove. 
				; Output: 
				;	ZF = 0 if a key pressed (even Ctrl-Break) 
				;	AH = scan code 
				;	AL = ASCII character or zero if special function key 
				;----------------------------------------------------------------------------; 
				;	KB_BUF_HD (1Ah) = "head" next character stored in keyboard buffer 
				;	KB_BUF_TL (1Ch) = "tail" next spot available in keyboard buffer 
				;----------------------------------------------------------------------------; 
 E840				KB_KEY_STATUS PROC 
 E840  BE 001A R			MOV	SI, OFFSET KB_BUF_HD 	; SI = head ptr 
 E843  FA				CLI 					; disable interrupts (already off) 
 E844  AD				LODSW 				; AX = head, SI = tail ptr 
 E845  3B 04				CMP	AX, [SI]	 		; head == tail? 
 E847  75 06				JNE	KB_BUF_HAS_KEY 		; if not, buffer has a key 
 E849				KB_KEY_STATUS_DONE: 
 E849  FB				STI					; re-enable interrupts 
 E84A  5E				POP	SI 
 E84B  1F				POP	DS 
					IRET_F				; IRET with current flags 
 E84C  CA 0002               1		RETF	2 
 E84F				KB_BUF_HAS_KEY: 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-98


 E84F  96				XCHG	AX, SI 			; SI = head 
 E850  AD				LODSW 				; AX = buffer[head], SI = next 
 E851  EB F6				JMP	KB_KEY_STATUS_DONE 
 E853				KB_KEY_STATUS ENDP 
				 
				;----------------------------------------------------------------------------; 
				; AH = 0 - Wait for keystroke and read 
				;----------------------------------------------------------------------------; 
				; Wait until keystroke is in buffer. Key press is removed from buffer. 
				; Output: 
				;	AH = scan code 
				;	AL = ASCII code 
				;----------------------------------------------------------------------------; 
 E853				KB_WAIT_READ PROC 
 E853  FB				STI					; enable interrupts 
						IF KB_HLT_WAIT EQ 1 
 E854  F4				HLT					; wait for keystroke interrupt 
						ENDIF 
 E855				KB_WAIT_READ_1: 
 E855  BE 001A R			MOV	SI, OFFSET KB_BUF_HD 	; SI = head ptr 
 E858  FA				CLI 					; disable interrupts again 
 E859  AD				LODSW 				; AX = head, SI = tail ptr 
 E85A  3B 04				CMP	AX, [SI] 			; head == tail? 
 E85C  74 F5				JE	KB_WAIT_READ 		; if so, buffer is empty 
 E85E  96				XCHG	AX, SI 			; SI = tail 
 E85F  AD				LODSW 				; AX = buffer[tail], SI = next 
 E860  83 FE 3E				CMP	SI, KB_BUF_END_B		; is next >= end of buffer? 
 E863  72 03				JB	KB_GET_READ 		; if not, get tail value 
 E865  BE 001E R			MOV	SI, OFFSET KB_BUF 	; otherwise, wrap next to buffer top 
 E868				KB_GET_READ: 
 E868  89 36 001A R			MOV	KB_BUF_HD, SI 		; head ptr = next 
 E86C				INT_16_DONE: 
 E86C  5E				POP	SI 
 E86D  1F				POP	DS 
 E86E  CF				IRET 
 E86F				KB_WAIT_READ ENDP 
				 
				;----------------------------------------------------------------------------; 
				; AH = 2 - Get shift status 
				;----------------------------------------------------------------------------; 
				; Read Keyboard Flags 
				; Output: 
				;	AL = BIOS keyboard flags (from BDA 0040:0017) 
				;----------------------------------------------------------------------------; 
 E86F				KB_SHIFT_STATUS PROC 
 E86F  A0 0017 R			MOV	AL, KB_FLAGS1 
 E872  EB F8				JMP	SHORT INT_16_DONE 
 E874				KB_SHIFT_STATUS ENDP 
				 
 E874				INT_16 ENDP 
				 
 E874				BEEP_PROC PROC 
				 
				;----------------------------------------------------------------------------; 
				; Repeats LONG_BEEPs then SHORT_BEEPs indefinetly 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-99


				;----------------------------------------------------------------------------; 
				; Input: 
				;	BL low nibble = long beeps 
				;	BL high nibble = short beeps 
				; 
				; Note: must use LOOP for beep since BEEP could occur if PIT is not working 
				;  (then how does the speaker work?) 
				; Note 2: cannot use stack since HALT_BEEP could occur before stack 
				; 
				; Size: 60 bytes 
				;----------------------------------------------------------------------------; 
 E874				HALT_BEEP PROC 
 E874  8C CA				MOV	DX, CS 				; SS to CS 
 E876  8E D2				MOV	SS, DX				; for CALL_NS 
 E878  93				XCHG	AX, BX				; beep pattern to AL 
					POST_CODE					; optionally display beep code on POST card 
			     1			ENDIF 
					AAM_I	10H					; split nibbles 
 E879  D4 10                 1		DB	0D4H, 10H			; AAM	imm 
 E87B  95				XCHG	AX, BP				; BP(H) = short beeps, BP(L) = long beeps 
 E87C				HALT_BEEP_START: 
 E87C  8B D5				MOV	DX, BP 				; restore original beep pattern 
 E87E  BE 08E8				MOV	SI, BEEP_ERR_LOW			; low C5 
 E881  33 C9				XOR	CX, CX				; low beep on 100% 
 E883				HALT_BEEP_START_ODD: 
 E883  8B F9				MOV	DI, CX				; save counter length 
 E885				HALT_BEEP_REP: 
 E885  8B C6				MOV	AX, SI				; restore beep tone 
					CALL_NS  BEEP_ON_P, 1			; turn on speaker / beep 
 E887  BC E88C R             1		MOV	SP, OFFSET ??001D 
			     1				IFNB <1> 
 E88A  EB 50                 1		JMP	SHORT BEEP_ON_P 
			     1				ENDIF 
 E88C                        1	??001D: 
 E88C  E88E R                1		DW	OFFSET ??001E 
 E88E                        1	??001E: 
 E88E  8B CF				MOV	CX, DI				; reset counter 
					IO_DELAY					; delay for beep 
 E890                        1	??001F: 
 E890  E2 FE                 1		LOOP	??001F					; long delay for I/O 
					CALL_NS  BEEP_OFF_P, 1			; turn off speaker 
 E892  BC E897 R             1		MOV	SP, OFFSET ??0020 
			     1				IFNB <1> 
 E895  EB 5A                 1		JMP	SHORT BEEP_OFF_P 
			     1				ENDIF 
 E897                        1	??0020: 
 E897  E899 R                1		DW	OFFSET ??0021 
 E899                        1	??0021: 
 E899  2B CF				SUB	CX, DI				; set for remainder of counter 
					IO_DELAY					; delay for silence 
 E89B                        1	??0022: 
 E89B  E2 FE                 1		LOOP	??0022					; long delay for I/O 
 E89D  FE CA				DEC	DL					; dec beep repeat count 
 E89F  75 E4				JNZ	HALT_BEEP_REP			; jump if more of this length 
 E8A1  86 D6				XCHG	DL, DH				; swap beep counts 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-100


 E8A3  85 D2				TEST	DX, DX				; both cycles done? 
 E8A5  74 D5				JZ	HALT_BEEP_START			; if so, restart beep pattern 
 E8A7  B5 55				MOV	CH, 100H * 1/3			; else, short beep on 33% 
 E8A9  BE 06AC				MOV	SI, BEEP_ERR_HIGH			; high F5 
 E8AC  EB D5				JMP	SHORT HALT_BEEP_START_ODD	; start short cycle 
 E8AE				HALT_BEEP ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Make a beepin' beep 
				;----------------------------------------------------------------------------; 
				; Play a (correctly pitched) A6 for 250ms 
				;----------------------------------------------------------------------------; 
 E8AE				BEEP PROC 
 E8AE  50				PUSH	AX 
 E8AF  53				PUSH	BX 
					BEEP_ON 
			     1			ELSE 
 E8B0  B8 054C               1		MOV	AX, BEEP_DEFAULT 
			     1			ENDIF 
 E8B3  E8 E8DC R             1		CALL	BEEP_ON_P 
 E8B6  B0 02				MOV	AL, 2				; 1/4 second pause 
 E8B8  E8 E68B R			CALL	IO_WAIT_MS_125 
					BEEP_OFF 
 E8BB  E8 E8F1 R             1		CALL	BEEP_OFF_P 
 E8BE  5B				POP	BX 
 E8BF  58				POP	AX 
 E8C0  C3				RET 
 E8C1				BEEP ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Two very short beeps if ZF, one short if NZ 
				;----------------------------------------------------------------------------; 
 E8C1				MEEPMEEP_Z PROC 
 E8C1  75 03				JNZ	MEEP				; if ZF=0, skip first meep 
				 
				;----------------------------------------------------------------------------; 
				; Two very short beeps 
				; Size: 27 bytes 
				; Output: CX = 0 
				;----------------------------------------------------------------------------; 
							IF IS_TURBO 
 = 0040				MEEP_DELAY	EQU	40H 
							ENDIF 
 E8C3				MEEPMEEP PROC 
 E8C3  E8 E8C6 R			CALL MEEP				; first meep 
				 
				;----------------------------------------------------------------------------; 
				; One very short beep 
				;----------------------------------------------------------------------------; 
 E8C6				MEEP PROC 
 E8C6  50				PUSH	AX 
 E8C7  53				PUSH	BX 
					BEEP_ON 
			     1			ELSE 
 E8C8  B8 054C               1		MOV	AX, BEEP_DEFAULT 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-101


			     1			ENDIF 
 E8CB  E8 E8DC R             1		CALL	BEEP_ON_P 
 E8CE  B5 40				MOV	CH, MEEP_DELAY 
					IO_DELAY				; delay while meeping 
 E8D0                        1	??0023: 
 E8D0  E2 FE                 1		LOOP	??0023					; long delay for I/O 
					BEEP_OFF 
 E8D2  E8 E8F1 R             1		CALL	BEEP_OFF_P 
 E8D5  B5 40				MOV	CH, MEEP_DELAY 
					IO_DELAY				; delay between beeps 
 E8D7                        1	??0024: 
 E8D7  E2 FE                 1		LOOP	??0024					; long delay for I/O 
 E8D9  5B				POP	BX 
 E8DA  58				POP	AX 
 E8DB  C3				RET 
 E8DC				MEEP ENDP 
 E8DC				MEEPMEEP ENDP 
 E8DC				MEEPMEEP_Z ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Turn on speaker at given tone 
				;----------------------------------------------------------------------------; 
				; Input: 
				; 	AX = TONE 
				; Output: 
				;	BL = previous PPI state 
				; 
				; http://www.cs.binghamton.edu/~reckert/220/8254_timer.html 
				; 
				; Clobbers BL, AL 
				; Cannot use stack since this could be called before it is working. 
				;----------------------------------------------------------------------------; 
 E8DC				BEEP_ON_P PROC 
 E8DC  93				XCHG	AX, BX				; save tone to BX 
 E8DD  B0 B6				MOV	AL, PIT_CW <2, 11B, 3>		; Select Timer 2, LE, Mode 3 (square) 
 E8DF  E6 43				OUT	PIT_CTRL, AL			; Send to PIT control word (43H) 
 E8E1  93				XCHG	AX, BX				; restore tone 
 E8E2				BEEP_ON_1 PROC 
 E8E2  E6 42				OUT	PIT_CH2, AL				; send low byte to timer 
 E8E4  8A C4				MOV	AL, AH 				; select high byte 
 E8E6  E6 42				OUT	PIT_CH2, AL				; send high byte to timer 
 E8E8  E4 61				IN	AL, PPI_B				; read current PPI port B status 
 E8EA  8A D8				MOV	BL, AL				; save original PPI state 
 E8EC  0C 03				OR	AL, MASK PBSP OR MASK PBST	; enable speaker and time gates 
 E8EE  E6 61				OUT	PPI_B, AL				; write back to port B 
 E8F0  C3				RET 
 E8F1				BEEP_ON_1 ENDP 
 E8F1				BEEP_ON_P ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Turn off speaker 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	BL = original (speaker off) PPI state 
				; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-102


				; Clobbers: AL 
				;----------------------------------------------------------------------------; 
 E8F1				BEEP_OFF_P PROC 
 E8F1  8A C3				MOV	AL, BL				; restore original PPI state 
 E8F3  E6 61				OUT	PPI_B, AL				; write back to port B 
 E8F5  C3				RET 
 E8F6				BEEP_OFF_P ENDP 
				 
 E8F6				BEEP_PROC ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Additional POST messages 
				;----------------------------------------------------------------------------; 
								IF POST_WARM_COLD EQ 1 
 E8F6  42 6F 6F 74 00		POST_BOOT		DB	'Boot', 0 
 E8FB  57 41 52 4D 00		POST_WARM		DB	'WARM', 0 
 E900  43 4F 4C 44 00		POST_COLD		DB	'COLD', 0 
								ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Display all POST messages 
				;----------------------------------------------------------------------------; 
				; See PFLAGS 
				; Output: BP (high byte) = 0 
				; Clobbers: AX, CX, SI 
				; Size: 63 bytes 
				;----------------------------------------------------------------------------; 
 E905				POST_ERR_MSG PROC 
				 
				;----------------------------------------------------------------------------; 
				; POST Error Strings 
				; 
 E905  0D 0A 50 4F 53 54 20	POST_ERR		DB	CR, LF, 'POST '	; POST Error 
 E90C  45 72 72 6F 72 20 00	POST_ERR_ERR	DB	'Error ', 0		; Error 
 E913  4B 42 00			POST_ERR_PKI	DB	'KB',   0		; Reset returned non-success "301" 
 E916  4B 65 79 00		POST_ERR_PKEY	DB	'Key',  0		; Reset did not clear KBC 
 E91A  46 44 43 00		POST_ERR_PFDC	DB	'FDC',  0		; General FD init failure 
 E91E  44 4D 41 00		POST_ERR_PDMA	DB	'DMA',  0		; DMA TC0 error 
				 
				;----------------------------------------------------------------------------; 
				; POST String Vectors - indexed by PFLAGS 
				; 
 E922				POST_ERRORS LABEL WORD 
 E922  E913 R				DW	OFFSET POST_ERR_PKI		; PKI  : Keyboard Interrupt Error 
 E924  E916 R				DW	OFFSET POST_ERR_PKEY		; PKEY : Keyboard Key Stuck 
 E926  E91A R				DW	OFFSET POST_ERR_PFDC		; PFDC : FDC Init Failure 
 E928  E52C R				DW	OFFSET POST_FDD			; PFSK : FDC Seek Test Failure 
 E92A  E91E R				DW	OFFSET POST_ERR_PDMA		; PDMA : DMA TC0 Error 
 E92C  E512 R				DW	OFFSET POST_MEMORY		; PMEM : RAM Error 
 = 0006				L_POST_ERRORS	EQU	($-POST_ERRORS)/SIZE POST_ERRORS 
				 
 E92E				POST_ERROR_MSG PROC 
 E92E  B9 0007				MOV	CX, L_POST_ERRORS+1		; # of available POST error messages 
 E931  BE E920 R			MOV	SI, OFFSET POST_ERRORS-2	; SI = string table pointer 
											;  add one LOOP for WARM BOOT flag 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-103


 E934				POST_ERROR_MSG_LOOP: 
 E934  2E: AD				LODS	WORD PTR CS:[SI]			; AX = next message offset 
 E936  D1 E5				SHL	BP, 1					; CF = POST error flag 
 E938  73 07				JNC	POST_ERROR_MSG_NEXT		; no flag? 
 E93A  9C				PUSHF						; save BP ZF 
 E93B  96				XCHG	AX, SI				; SI = error string 
					PRINTLN_SZ  SI				; write string with CRLF 
			     1			ENDIF 
			     1			ENDIF 
 E93C  E8 F7C5 R             1		CALL	OUTLN_SZ 
			     1			ENDIF 
 E93F  96				XCHG	AX, SI				; SI = string table pointer 
 E940  9D				POPF 
 E941				POST_ERROR_MSG_NEXT: 
 E941  E0 F1				LOOPNZ  POST_ERROR_MSG_LOOP		; loop until end of strings or flags 
 E943				POST_ERROR_MSG_EXIT: 
 E943  C3				RET 
 E944				POST_ERROR_MSG ENDP 
				 
 E944				POST_ERR_MSG ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Additional INT 9h - Keyboard Code 
				;----------------------------------------------------------------------------; 
				 
				;----------------------------------------------------------------------------; 
				; INT 9 - Test keyboard during POST 
				; Size: 27 bytes 
				;----------------------------------------------------------------------------; 
 E944				INT_09_POST PROC 
 E944  50				PUSH	AX 
					POST_FLAG_CLR PKI				; clear POST test int flag 
			     1				ELSE 
 = 0001                      1	??0025	EQU	1				; use CLR1 (ZF unaffected) 
			     1				ENDIF 
			     1				ELSE 
 E945  81 E5 BFFF            1		AND	BP, NOT MASK PKI			; Clear flag 
			     1				ENDIF 
 E949  E4 60				IN	AL, PPI_A				; read keyboard scan from PPI 
 E94B  3C AA				CMP	AL, 0AAH 
 E94D  75 04				JNE	INT_09_POST_DONE			; jump if not expected AAh 
					POST_FLAG_SET PKI				; set POST keyboard test pass flag 
			     1				ELSE 
 E94F  81 CD 4000            1		OR	BP, MASK PKI			; Set FLAG 
			     1				ENDIF 
 E953				INT_09_POST_DONE: 
 E953  E4 61				IN	AL, PPI_B				; read keyboard status 
 E955  0C C0				OR	AL, MASK PBKB OR MASK PBKC	; set clear keyboard and enable clock 
 E957  E6 61				OUT	PPI_B, AL				; write to PPI Control Port B 
 E959  B0 20				MOV	AL, EOI				; Send End of Interrupt 
 E95B  E6 20				OUT	INT_P0, AL 
 E95D  58				POP	AX 
 E95E  CF				IRET 
 E95F				INT_09_POST ENDP 
				 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-104


				;----------------------------------------------------------------------------; 
				; Clear keyboard circular buffer 
				;----------------------------------------------------------------------------; 
				; Clear/init circular buffer at KB_BUF 
				; Clobbers AX, DI 
				; 
				; Size: 16 bytes 
				;----------------------------------------------------------------------------; 
 E95F				KB_BUF_CLEAR PROC 
						ASSUME ES:_BDA_ABS 
 E95F  06				PUSH	ES 					; save ES 
 E960  33 C0				XOR	AX, AX 
 E962  8E C0				MOV	ES, AX 
 E964  26: A1 0480 R			MOV	AX, ES:KB_BUF_ST_ABS 		; AX = original start of buffer 
 E968  BF 041A R			MOV	DI, OFFSET KB_BUF_HD_ABS	; DI = buffer head 
 E96B  AB				STOSW 					; write to head pointer 
 E96C  AB				STOSW 					; write to tail pointer 
 E96D  07				POP	ES 
 E96E  C3				RET 
						ASSUME ES:NOTHING 
 E96F				KB_BUF_CLEAR ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 9 - Keyboard Additional Data Tables 
				;----------------------------------------------------------------------------; 
				; When CTRL held, modify ASCII codes for these scan codes (10 bytes) 
				; 
 E96F				INT_KB_CTRL_ASC_TBL LABEL BYTE 
 E96F  00 03				DB	00H, 03H				; Ctrl 2	-> ASCII 0 
 E971  1E 07				DB	1EH, 07H				; Ctrl 6	-> ASCII 1EH 
 E973  1F 0C				DB	1FH, 0CH				; Ctrl '-'	-> ASCII 1FH 
 E975  7F 0E				DB	7FH, 0EH				; Ctrl BS 	-> ASCII 07FH 
 E977  0A 1C				DB	0AH, 1CH				; Ctrl Enter -> ASCII 0AH 
				 
				;----------------------------------------------------------------------------; 
				; When CTRL held, modify scan codes for these scan codes (14 bytes) 
				; 
 E979				INT_KB_CTRL_SCAN_TBL LABEL BYTE 
 E979  77 47				DB	77H, 47H 				; Ctrl Home 
 E97B  84 49				DB	84H, 49H 				; Ctrl PgUp 
 E97D  73 4B				DB	73H, 4BH 				; Ctrl Left Arrow 
 E97F  74 4D				DB	74H, 4DH 				; Ctrl Right Arrow 
 E981  75 4F				DB	75H, 4FH 				; Ctrl End 
 E983  76 51				DB	76H, 51H 				; Ctrl PgDn 
 E985  72 37				DB	72H, 37H				; Keypad * / PrtSc 
				 
 = 000C				L_INT_KB_CTRL_ASC_TBL	EQU ($-INT_KB_CTRL_ASC_TBL)/2		; 12 total 
 = 0006				L_INT_KB_CTRL_SCAN_TBL	EQU ($-INT_KB_CTRL_SCAN_TBL)/2-1	; 6 
				 
				; 
				; 0 BYTES HERE 
				; 
				BYTES_HERE	INT_09 
 = 0000                      1	BYTES_HERE_INT_09 = INT_09-$ 
			     1			IFDEF BYTES_HERE_INT_09 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-105


			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 9 - Keyboard Interrupt IRQ1 (Hardware Handler) 
				;----------------------------------------------------------------------------; 
				; Handles hardware Interrupt generated by the KBC connected to IRQ 1. The  
				; scan code that is received is translated to all of the behaviors and key 
				; combinations used by the PC. 
				; 
				;----------------------------------------------------------------------------; 
				; References: 
				;  https://stanislavs.org/helppc/scan_codes.html 
				;  https://stanislavs.org/helppc/make_codes.html 
				;  https://stanislavs.org/helppc/keyboard_commands.html 
				;  https://stanislavs.org/helppc/8042.html 
				;  http://www.techhelpmanual.com/106-int_09h__keyboard_interrupt.html 
				;  https://www.phatcode.net/res/223/files/html/Chapter_20/CH20-1.html 
				; 
				; KBFLAGS1 RECORD	K1IN:1,K1CL:1,K1NL:1,K1SL:1,K1AL:1,K1CT:1,K1LS:1,K1RS:1 
				; KBFLAGS2 RECORD	K2IN:1,K2CL:1,K2NL:1,K2SL:1,K2PA:1,K2SY:1,K2LA:1,K2LC:1 
				;----------------------------------------------------------------------------; 
				; Things you must do: 
				; - Check for a scan code from the KBC via PPI Port A (60h) 
				; - Clear and Enable the keyboard bit (7) on PPI Port B 
				; - Examine the Make or Break system scan code 
				; - If a toggle key (Shift, Alt, Ctrl, Caps Lock, Num Lock or Scroll Lock), 
				;	update that flag in the BDA (17-18h) 
				; - Determine if the scan code is altered by an active shift or toggle state 
				; - If Ctrl-Alt-Del is pressed, do a warm reboot of the system 
				; - If Print Screen is pressed, call INT 05h 
				; - If Pause/Ctrl-NumLock is pressed, enter pause/hold state 
				; - If Ctrl-Break is pressed, call INT 1Bh 
				; - Handle any special, non-standard translations 
				; - Translate printable chars to their ASCII/CP-437 value 
				; 
				; In short, it needs to do this: 
				;    https://stanislavs.org/helppc/scan_codes.html 
				;----------------------------------------------------------------------------; 
 E987						ORG 0E987H 
 E987				INT_09 PROC 
							ASSUME DS:_BDA 
 E987  50				PUSH	AX						; save AX first 
 E988  E4 60				IN	AL, PPI_A 					; read scan code from PPI Port A 
 E98A  8A E0				MOV	AH, AL					; save scan code to AH 
 E98C  E4 61				IN	AL, PPI_B 					; read Control Port B 
 E98E  50				PUSH	AX						; save status, and I/O delay 
 E98F  0C 80				OR	AL, MASK PBKB				; set clear keyboard bit 
 E991  E6 61				OUT	PPI_B, AL 					; write to Control Port B 
 E993  58				POP	AX						; restore status, and I/O delay 
 E994  E6 61				OUT	PPI_B, AL 					; write to Control Port B 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-106


				; Send non-specific EOI to PIC 
				; 
 E996  B0 20				MOV	AL, EOI 					; End of Interrupt OCW 
 E998  E6 20				OUT	INT_P0, AL					; write EOI to port 0 
 E99A  FB				STI							; enable interrupts 
 E99B  FC				CLD							; string functions increment 
							ELSE 
					PUSHX	BX, CX, DX, DI, SI			; save working registers 
			     1				IFNB <BX>			; exit if last reg 
 E99C  53                    1		PUSH	BX 					; push register and repeat 
			     1		PUSHX	CX, DX, DI, SI, , ,  
			     2				IFNB <CX>			; exit if last reg 
 E99D  51                    2		PUSH	CX 					; push register and repeat 
			     2		PUSHX	DX, DI, SI, , , ,  
			     3				IFNB <DX>			; exit if last reg 
 E99E  52                    3		PUSH	DX 					; push register and repeat 
			     3		PUSHX	DI, SI, , , , ,  
			     4				IFNB <DI>			; exit if last reg 
 E99F  57                    4		PUSH	DI 					; push register and repeat 
			     4		PUSHX	SI, , , , , ,  
			     5				IFNB <SI>			; exit if last reg 
 E9A0  56                    5		PUSH	SI 					; push register and repeat 
			     5		PUSHX	, , , , , ,  
			     6				ENDIF 
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
							ENDIF 
					PUSHX	DS, ES					; save segment registers 
			     1				IFNB <DS>			; exit if last reg 
 E9A1  1E                    1		PUSH	DS 					; push register and repeat 
			     1		PUSHX	ES, , , , , ,  
			     2				IFNB <ES>			; exit if last reg 
 E9A2  06                    2		PUSH	ES 					; push register and repeat 
			     2		PUSHX	, , , , , ,  
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 E9A3  B9 ---- R			MOV	CX, SEG _BDA 				; CX = BIOS Data Area, CH = 0 
 E9A6  8A C4				MOV	AL, AH					; AL = original scan code 
 E9A8  3C FF				CMP	AL, 0FFH 					; check for Detection Error/Overrun 
 E9AA  74 79				JZ	INT_KB_MEEP_DONE				; if overrun, meep and exit 
 E9AC  8E D9				MOV	DS, CX					; DS = BIOS Data Area 
 E9AE  8C CA				MOV	DX, CS					; ES = BIOS code segment 
 E9B0  8E C2				MOV	ES, DX 
 E9B2  8B 16 0017 R			MOV	DX, KB_FLAGS				; DL=KB_FLAGS1, DH=KB_FLAGS2 
				 
				;----------------------------------------------------------------------------; 
				; 1. Is a function key? 
				; Function keys have different scan codes based on shift, ALT or CTRL state 
				; 
 E9B6				KB_INT_CHECK_FN_KEY: 
 E9B6  3C 44				CMP	AL, 044H					; is above F10 scan code? 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-107


 E9B8  77 21				JA	KB_INT_CHECK_FN_KEY_DONE 
 E9BA  3C 3B				CMP	AL, 03BH					; is below F1 scan code? 
 E9BC  72 1D				JB	KB_INT_CHECK_FN_KEY_DONE 
 E9BE  B0 00				MOV	AL, 0						; ASCII always 0 on F-keys 
				 
				;----------------------------------------------------------------------------; 
				; Is a Function key. Check if shift, ALT or Ctrl is held? 
				; 
 E9C0  F6 C2 0F				TEST	DL, MASK K1AL OR MASK K1CT OR MASK K1LS OR MASK K1RS 
 E9C3  74 16				JZ	KB_INT_CHECK_FN_KEY_DONE		; no control keys held 
 E9C5  80 C4 2D				ADD	AH, 2DH					; adjust to ALT 
 E9C8  F6 C2 08				TEST	DL, MASK K1AL				; is it ALT? 
 E9CB  75 0B				JNZ	KB_INT_PUT_BUFFER_2			; if so, put in buffer 
 E9CD  80 EC 0A				SUB	AH, 2DH-23H					; adjust to CTRL 
 E9D0  F6 C2 04				TEST	DL, MASK K1CT				; is CTRL? 
 E9D3  75 03				JNZ	KB_INT_PUT_BUFFER_2			; if so, put in buffer 
 E9D5  80 EC 0A				SUB	AH, 23H-19H					; adjust to shift 
 E9D8				KB_INT_PUT_BUFFER_2:					; fit short jumps above 
 E9D8  E9 EA7D R			JMP	KB_INT_PUT_BUFFER 
				 
 E9DB				KB_INT_CHECK_FN_KEY_DONE:				; not a function key 
				 
				;----------------------------------------------------------------------------; 
				; 2. Handle "early" Ctrl such as Ctrl-Break and Ctrl-NumLock 
				; 
 E9DB  F6 C2 04				TEST	DL, MASK K1CT				; is Ctrl held? 
 E9DE  74 14				JZ	KB_INT_IS_NUM				; if not, skip to IS_NUM 
				 
				;----------------------------------------------------------------------------; 
				; Is Ctrl-Break? 
				; 
 E9E0  3C 46				CMP	AL, 46H					; Scroll Lock (Break) 
 E9E2  75 0C				JNZ	INT_KB_CHECK_CTRL_NUM			; jump if not Break 
				 
 E9E4				INT_KB_CTRL_BREAK: 
 E9E4  E8 E95F R			CALL	KB_BUF_CLEAR				; clear keyboard buffer 
 E9E7  C6 06 0071 R 80			MOV	BIOS_BREAK, KBBRK <1>			; BIOS break flag 
 E9EC  CD 1B				INT	1BH						; call BIOS Break handler 
 E9EE  EB 33				JMP	SHORT INT_KB_DONE_2 
				 
				;----------------------------------------------------------------------------; 
				; Is Ctrl-NumLock (Pause)? 
				; 
 E9F0				INT_KB_CHECK_CTRL_NUM: 
 E9F0  3C 45				CMP	AL, 45H					; is Num Lock key? 
					;CMP	AL, 35H					; key pad / (for testing) 
 E9F2  74 16				JZ	INT_KB_SET_PAUSE				; if not, put in Pause 
				 
				;----------------------------------------------------------------------------; 
				; 3. Handle numeric keypad entry according to the following: 
				; 
				;	Num	Shift	ASCII	Scan 
				; 	0	0	0	52h	5230 0020 
				;	0	1	'0'	52h	5200 80A2 
				;	1	0	'0'	52h	5200 8000 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-108


				;	1	1	0	52h	5200 8080 
				; 
 E9F4				KB_INT_IS_NUM: 
 E9F4  F6 C2 20				TEST	DL, MASK K1NL				; is NUM LOCK on? 
 E9F7  74 31				JZ	KB_INT_IS_NUM_DONE			; if not, do nothing 
 E9F9  3C 53				CMP	AL, 53H					; is higher than Del key? 
 E9FB  77 2D				JA	KB_INT_IS_NUM_DONE 
 E9FD  3C 47				CMP	AL, 47H					; is lower than Home/7 key? 
 E9FF  72 29				JB	KB_INT_IS_NUM_DONE 
				 
				;----------------------------------------------------------------------------; 
				; Keypad number pressed and Num Lock is on, so invert shift behavior. 
				; 
 EA01  D0 E0				SHL	AL, 1						; invert NumLock and Shift 
 EA03  F6 C2 03				TEST	DL, MASK K1LS OR MASK K1RS		;  behavior and jump ahead 
 EA06  74 2A				JZ	KB_INT_UC					; jump if no shift held 
 EA08  EB 27				JMP	SHORT KB_INT_SHIFT 
				 
				;----------------------------------------------------------------------------; 
				; KB Ctrl-NumLock Screen Pause 
				;----------------------------------------------------------------------------; 
 EA0A				INT_KB_SET_PAUSE: 
 EA0A  BB 0018 R			MOV	BX, OFFSET KB_FLAGS2			; (-1 byte to use indirect) 
 EA0D  80 0F 08				OR	BYTE PTR [BX], MASK K2PA		; set PAUSE flag 
				 
								IF CGA_SNOW_REMOVE GT 0 
				;----------------------------------------------------------------------------; 
				; Make sure CGA is not currently being blanked 
				; 
 EA10  E8 F090 R			CALL	INT_10_IS_CGA80				; ZF = 1 if CGA 80 col 
 EA13  75 07				JNZ	INT_KB_PAUSE_LOOP				; jump if not CGA 80 col 
 EA15  A0 0065 R			MOV	AL, VID_MODE_REG				; get default CGA control reg 
 EA18  BA 03D8				MOV	DX, CGA_CTRL				; DX = CGA control port 03D8h 
 EA1B  EE				OUT	DX, AL					; enable video signal 
								ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Loop until Pause flag is cleared 
				; 
 EA1C				INT_KB_PAUSE_LOOP: 
 EA1C  F4				HLT							; be a good neighbor 
 EA1D  90				NOP							; let another interrupt happen 
 EA1E  F6 07 08				TEST	BYTE PTR [BX], MASK K2PA		; check the Pause flag 
 EA21  75 F9				JNZ	INT_KB_PAUSE_LOOP				; loop until clear 
 EA23				INT_KB_DONE_2: 
 EA23  EB 73				JMP	SHORT INT_KB_DONE				; exit INT 
				 
				;----------------------------------------------------------------------------; 
				; Emit a feeble meep and exit 
				; 
 EA25				INT_KB_MEEP_DONE: 
 EA25  E8 E8C6 R			CALL	MEEP 
 EA28  EB 6E				JMP	SHORT INT_KB_DONE				; exit INT 
				 
 EA2A				KB_INT_IS_NUM_DONE: 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-109


				 
				;----------------------------------------------------------------------------; 
				; 4. Do scan code to ASCII translation 
				;----------------------------------------------------------------------------; 
 EA2A				KB_INT_CHAR:						; is a regular key ? 
 EA2A  D0 E0				SHL	AL, 1						; align index for table 
							ENDIF 
 EA2C  F6 C2 0B				TEST	DL, MASK K1LS OR MASK K1RS OR MASK K1AL	; is either shift key or ALT already pressed
				? 
 EA2F  75 01				JNZ	KB_INT_UC					; if so, use uppercase table 
 EA31				KB_INT_SHIFT: 
 EA31  40				INC	AX 						; if not shifted, increment 
 EA32				KB_INT_UC:							;  one to use lower case 
 EA32  BB EBA8 R			MOV	BX, OFFSET KEY_SCAN_TBL 
 EA35  2E: D7				XLAT	CS:[BX]					; ASCII key in AL = CS:BX[AL] 
 EA37  84 C0				TEST	AL, AL					; a is flag key code? 
 EA39  79 03				JNS	KB_INT_NOT_FLAG 
 EA3B  E9 EB45 R			JMP	INT_KB_IS_FLAG 
 EA3E				KB_INT_NOT_FLAG: 
 EA3E  84 E4				TEST	AH, AH					; test high bit of scan code 
 EA40  78 56				JS	INT_KB_DONE					; if set, it is an unhandled break c
				ode 
 EA42				KB_INT_IS_CAPS: 
 EA42  F6 C2 40				TEST	DL, MASK K1CL				; is CAPS LOCK on? 
 EA45  74 0F				JZ	KB_INT_IS_CAPS_DONE 
 EA47				IS_ALPHA:							; CF if AL is not [A-Za-z] 
 EA47  50				PUSH	AX						; save original AL 
 EA48  0C 20				OR	AL, 'a'-'A'					; lowercase it for comparison 
 EA4A  3C 61				CMP	AL, 'a'					; is less than 'a'? 
 EA4C  72 03				JB	IS_ALPHA_DONE				; CF if not alpha 
 EA4E  3C 7B				CMP	AL, 'z'+1					; is greater than 'z'? 
 EA50  F5				CMC							; CF if not alpha 
 EA51				IS_ALPHA_DONE: 
 EA51  58				POP	AX						; restore original AL 
 EA52  72 02				JC	KB_INT_IS_CAPS_DONE			; jump if not alpha 
 EA54  34 20				XOR	AL, 'a'-'A'					; otherwise, toggle case 
				 
 EA56				KB_INT_IS_CAPS_DONE: 
				;----------------------------------------------------------------------------; 
				; 5. Handle ALT chars that require ASCII translation 
				; 
 EA56				KB_INT_IS_ALT: 
 EA56  F6 C2 08				TEST	DL, MASK K1AL				; is ALT currently held? 
 EA59  75 46				JNZ	INT_KB_ALT 
				 
				;----------------------------------------------------------------------------; 
				; 6. Handle additional Non-ALT special case chars 
				; 
 EA5B  3D 3700				CMP	AX, 3700H					; is Shift-PrtSc? 
 EA5E  74 0D				JZ	KB_INT_PRTSC				; jump if so 
 EA60  3D 4C00				CMP	AX, 4C00H					; Numeric 5 key (unshifted) 
 EA63  74 33				JZ	INT_KB_DONE					; discard and exit 
				 
 EA65				KB_INT_IS_ALT_DONE: 
				 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-110


				;----------------------------------------------------------------------------; 
				; 7. Handle CTRL chars 
				; 
 EA65				KB_INT_IS_CTRL: 
 EA65  F6 C2 04				TEST	DL, MASK K1CT				; is CTRL currently held? 
 EA68  74 07				JZ	KB_INT_IS_CTRL_DONE			; jump if not 
 EA6A  E9 EB1E R			JMP	INT_KB_CTRL					; otherwise, CTRL is held 
				 
				;----------------------------------------------------------------------------; 
				; Handle Shift-PrtSc 
				; 
 EA6D				KB_INT_PRTSC: 
 EA6D  CD 05				INT	5H						; call print screen handler 
 EA6F  EB 27				JMP	SHORT INT_KB_DONE 
				 
 EA71				KB_INT_IS_CTRL_DONE: 
				;----------------------------------------------------------------------------; 
				; Test if in Ctrl-NumLock PAUSE 
				; If in Pause, any remaining key will exit and be discarded 
				; 
 EA71				KB_INT_IS_PAUSE: 
 EA71  F6 C6 08				TEST	DH, MASK K2PA				; is in pause? 
 EA74  74 07				JZ	KB_INT_PUT_BUFFER 
 EA76  80 26 0018 R F7			AND	KB_FLAGS2, NOT MASK K2PA		; clear pause flag 
 EA7B  EB 1B				JMP	SHORT INT_KB_DONE				; discard key and exit int 
				 
				;----------------------------------------------------------------------------; 
				; All special cases have been handled 
				; Store AX in keyboard buffer 
				; 
 EA7D				KB_INT_PUT_BUFFER: 
 EA7D  8B 3E 001C R			MOV	DI, KB_BUF_TL 				; DI = tail ptr 
 EA81  8D 75 02				LEA	SI, [DI][2]					; SI = next (maybe) 
 EA84  83 FE 3E				CMP	SI, KB_BUF_END_B				; is next >= end of buffer? 
 EA87  72 03				JB	KB_INT_CHECK_FULL 			; if not, check if buffer is full 
 EA89  BE 001E R			MOV	SI, OFFSET KB_BUF 			; otherwise, wrap to first address 
 EA8C				KB_INT_CHECK_FULL: 
 EA8C  3B 36 001A R			CMP	SI, KB_BUF_HD 				; next == head? 
 EA90  74 93				JE	INT_KB_MEEP_DONE				; Beep if ZF - buffer is full 
 EA92  89 05				MOV	[DI], AX 					; buffer[head] = AX 
 EA94  89 36 001C R			MOV	KB_BUF_TL, SI 				; tail = next 
				 
				;----------------------------------------------------------------------------; 
				; Restore registers and exit 
				; 
 EA98				INT_KB_DONE: 
					POPX	ES, DS 
			     1				IFNB <ES>			; exit if last reg 
 EA98  07                    1		POP	ES 					; pop register and repeat 
			     1		POPX	DS, , , , , ,  
			     2				IFNB <DS>			; exit if last reg 
 EA99  1F                    2		POP	DS 					; pop register and repeat 
			     2		POPX	, , , , , ,  
			     3				ENDIF 
			     2				ENDIF 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-111


			     1				ENDIF 
							ELSE 
					POPX	SI, DI, DX, CX, BX			; restore used registers 
			     1				IFNB <SI>			; exit if last reg 
 EA9A  5E                    1		POP	SI 					; pop register and repeat 
			     1		POPX	DI, DX, CX, BX, , ,  
			     2				IFNB <DI>			; exit if last reg 
 EA9B  5F                    2		POP	DI 					; pop register and repeat 
			     2		POPX	DX, CX, BX, , , ,  
			     3				IFNB <DX>			; exit if last reg 
 EA9C  5A                    3		POP	DX 					; pop register and repeat 
			     3		POPX	CX, BX, , , , ,  
			     4				IFNB <CX>			; exit if last reg 
 EA9D  59                    4		POP	CX 					; pop register and repeat 
			     4		POPX	BX, , , , , ,  
			     5				IFNB <BX>			; exit if last reg 
 EA9E  5B                    5		POP	BX 					; pop register and repeat 
			     5		POPX	, , , , , ,  
			     6				ENDIF 
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
							ENDIF 
 EA9F  58				POP	AX 
 EAA0  CF				IRET 
				 
				;----------------------------------------------------------------------------; 
				; 6. Only ALT key is held (no CTRL) 
				; 
				; Space bar is the only key that returns the same scan code and ASCII code  
				; when ALT is held. 
				; 
 EAA1				INT_KB_ALT PROC 
 EAA1  80 FC 39				CMP	AH, 39H					; is space bar? 
 EAA4  74 BF				JZ	KB_INT_IS_ALT_DONE			; continue 
 EAA6  8B D8				MOV	BX, AX 
 EAA8  B0 00				MOV	AL, 0						; AL will be 0 for any others 
				 
 EAAA				CHECK_TOP_ROW_NUM: 
 EAAA  80 FC 0D				CMP	AH, 0DH					; is above '=' scan code? 
 EAAD  77 0A				JA	CHECK_ALT_ON 
 EAAF  80 FC 02				CMP	AH, 2 
 EAB2  72 05				JB	CHECK_ALT_ON 
 EAB4  80 C4 76				ADD	AH, 76H 
 EAB7  EB C4				JMP	SHORT KB_INT_PUT_BUFFER 
				 
				;----------------------------------------------------------------------------; 
				; 7. Check for ALT + 000 numeric entry 
				; Alt held, and number is valid numeric keypad 
				; Note: AH must be preserved 
				; 
 EAB9				CHECK_ALT_ON: 
 EAB9  80 EB 30				SUB	BL, '0'					; ASCII convert and test 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-112


 EABC  72 12				JB	INT_KB_NOT_ALT_000			; jump if less than 0 
 EABE  80 FB 09				CMP	BL, 9 
 EAC1  77 0D				JA	INT_KB_NOT_ALT_000			; jump if above 9 
				 
 EAC3				INT_KB_IS_ALT_000: 
 EAC3  93				XCHG	AX, BX					; AL = input byte, save AX 
 EAC4  8A 26 0019 R			MOV	AH, KB_ALT					; AH = partial working byte 
 EAC8  D5 0A				AAD							; AL = AL + ( AH * 10 ) 
 EACA  A2 0019 R			MOV	KB_ALT, AL					; save new working byte to BDA 
 EACD  93				XCHG	AX, BX					; restore AH, AL = 0 
 EACE  EB C8				JMP	SHORT INT_KB_DONE				; interrupt complete 
				 
				;----------------------------------------------------------------------------; 
				; 8. Check for ALT modified chars that are skipped 
				; Uses table INT_KB_ALT_SKIP 
				; 
 EAD0				INT_KB_NOT_ALT_000: 
 EAD0  BF EC26 R			MOV	DI, OFFSET INT_KB_ALT_SKIP 
 EAD3  B1 0A				MOV	CL, 10					; L_INT_KB_ALT_SKIP 
 EAD5  86 E0				XCHG	AH, AL 
 EAD7  F2/ AE				REPNE SCASB						; is in table? 
 EAD9  86 E0				XCHG	AH, AL 
 EADB  75 88				JNZ	KB_INT_IS_ALT_DONE			; if not found, continue 
 EADD				INT_KB_DONE_1: 
 EADD  EB B9				JMP	SHORT INT_KB_DONE				; if found, skip 
				 
 EADF				INT_KB_ALT ENDP 
				 
				;----------------------------------------------------------------------------; 
				; 9. Only CTRL key is held (no ALT) 
				;----------------------------------------------------------------------------; 
 EADF				INT_KB_CTRL_NO_ALT PROC 
				 
				;----------------------------------------------------------------------------; 
				; Handle CTRL exceptions after ASCII or scan code is modified. These require 
				; a lookup table since they do not follow a predictable pattern. 
				; 
 EADF  93				XCHG	AX, BX					; BH = scan code, BL = ASCII 
 EAE0  B1 0C				MOV	CL, L_INT_KB_CTRL_ASC_TBL		; length of table 
 EAE2  BE E96F R			MOV	SI, OFFSET INT_KB_CTRL_ASC_TBL 
 EAE5				INT_KB_CTRL_ASC_TBL_LOOP: 
 EAE5  2E: AD				LODS	WORD PTR CS:[SI]				; AH = scan code, AL = new ASCII 
 EAE7  3A E7				CMP	AH, BH					; scan code match? 
 EAE9  E0 FA				LOOPNE INT_KB_CTRL_ASC_TBL_LOOP		; if not keep looping until end 
 EAEB  75 0C				JNZ	INT_KB_CTRL_ASC_TBL_DONE		; no matches, restore AX and continue 
 EAED  80 F9 06				CMP	CL, L_INT_KB_CTRL_SCAN_TBL		; was first list segment? 
 EAF0  7F 04				JG	INT_KB_CTRL_NO_DONE			; if so, match found and AX is set, exit 
 EAF2  B4 00				MOV	AH, 0						; ASCII code 0 
 EAF4  86 C4				XCHG	AL, AH					; AH = scan code, AL = 0 
 EAF6				INT_KB_CTRL_NO_DONE: 
 EAF6  E9 EA71 R			JMP	KB_INT_IS_CTRL_DONE			; AX set, exit 
 EAF9				INT_KB_CTRL_ASC_TBL_DONE: 
 EAF9  93				XCHG	AX, BX					; restore AX 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-113


				; Skip ; ' ` 
				; 
 EAFA  80 FC 27				CMP	AH, 27H					; pass < 27 
 EAFD  72 05				JB	INT_KB_CTRL_ALPHA 
 EAFF  80 FC 29				CMP	AH, 29H					; pass > 29 
 EB02  76 94				JNA	INT_KB_DONE					; skip 27-29 
				 
				;----------------------------------------------------------------------------; 
				; For scan codes 10H-32H return only low 5 bits of ASCII code when CTRL is held 
				; 
 EB04				INT_KB_CTRL_ALPHA: 
 EB04  80 FC 10				CMP	AH, 10H 
 EB07  72 09				JB	INT_KB_CTRL_NO_ALT_1 
 EB09  80 FC 32				CMP	AH, 32H 
 EB0C  77 04				JA	INT_KB_CTRL_NO_ALT_1 
 EB0E  24 1F				AND	AL, 00011111B				; adjust ASCII value 
 EB10  EB E4				JMP	SHORT INT_KB_CTRL_NO_DONE 
 EB12				INT_KB_CTRL_NO_ALT_1: 
				 
				;----------------------------------------------------------------------------; 
				; If scan code between 02H-35H and hasn't been modified yet, return nothing 
				; 
 EB12  80 FC 02				CMP	AH, 2 
 EB15  72 DF				JB	INT_KB_CTRL_NO_DONE			; pass < 2 
 EB17  80 FC 35				CMP	AH, 35H 
 EB1A  77 DA				JA	INT_KB_CTRL_NO_DONE			; pass > 35 
 EB1C  EB BF				JMP	SHORT INT_KB_DONE_1			; don't return 2-35? 
				 
 EB1E				INT_KB_CTRL_NO_ALT ENDP 
				 
				;----------------------------------------------------------------------------; 
				; 8. Ctrl key is held 
				;----------------------------------------------------------------------------; 
 EB1E				INT_KB_CTRL: 
 EB1E  F6 C2 08				TEST	DL, MASK K1AL				; is ALT also currently held? 
 EB21  74 BC				JZ	INT_KB_CTRL_NO_ALT			; jump if no ALT 
				 
				;----------------------------------------------------------------------------; 
				; 9. Ctrl-Alt keys are held 
				;----------------------------------------------------------------------------; 
 EB23				INT_KB_CTRL_ALT: 
 EB23  80 FC 53				CMP	AH, 53H					; is Ctrl-Alt-Del? 
							IF IS_TURBO 
 EB26  75 0C				JNZ	INT_KB_CTRL_ALT_1				; if not check for turbo hotkey 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Handle Ctrl-Alt-Del (Warm reboot) 
				; 
 EB28				INT_KB_CTRL_ALT_DEL: 
 EB28  E8 E8AE R			CALL	BEEP						; BEEP on ctrl-alt-del 
							IF WARM_ENABLE EQ 1 
 EB2B  C7 06 0072 R 1234		MOV	WARM_FLAG, WARM_BOOT			; set warm boot flag 
							ENDIF 
 EB31  E9 E05B R			JMP	BOOT						; warm reboot 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-114


				 
							IF IS_TURBO 
				;----------------------------------------------------------------------------; 
				; 10. Handle Ctrl-Alt but not Del (only Turbo hotkey) 
				; 
 EB34				INT_KB_CTRL_ALT_1: 
				 
				;----------------------------------------------------------------------------; 
				; Is Turbo speed toggle Ctrl-Alt-+ hotkey? 
				; 
 EB34  80 FC 4E				CMP	AH, 4EH					; numeric pad + key 
 EB37  75 BD				JNZ	INT_KB_CTRL_NO_DONE 
				 
				;	;CMP	AH, 4AH					; numeric pad - key 
				;	;JZ	INT_KB_TURBO_MINUS 
				 
				;----------------------------------------------------------------------------; 
				; Handle Turbo speed mode toggle 
				; 
 EB39				INT_KB_TOGGLE_TURBO PROC 
							ELSE 
								ELSE 
 EB39  E4 61				IN	AL, PPI_B					; read standard PPI register 
								ENDIF				; /IF ARCH_TYPE EQ INIT_V40 
 EB3B  A8 04				TEST	AL, MASK PBTB				; is in Turbo mode? 
							ENDIF					; /IF ARCH_TYPE EQ ARCH_TD3300 
 EB3D  E8 E8C1 R			CALL	MEEPMEEP_Z					; two meeps if to high (ZF) 
												; one meep if to low (NZ) 
 EB40  E8 E29C R			CALL	TOGGLE_TURBO				; toggle speed setting 
 EB43  EB 32				JMP	SHORT INT_KB_DONE_3			; done with keyboard 
 EB45				INT_KB_TOGGLE_TURBO ENDP 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; 5. Is a flag key? 
				;----------------------------------------------------------------------------; 
				;  40:18	Keyboard Flags Byte 2 (High) 
				; 84218421 
				; 7 	    |			- K2IN	insert key is depressed 
				;  6 	    |			- K2CL	caps-lock key is depressed 
				;   5	    |			- K2NL	num-lock key is depressed 
				;    4    |			- K2SL	scroll lock key is depressed 
				;     3   |			- K2PA	suspend key has been toggled 
				;      2  |			- K2SY	system key depressed and held 
				;       1 |			- K2LA	left ALT key depressed 
				;        0|			- K2LC	left CTRL key depressed 
				;----------------------------------------------------------------------------; 
 =				_KB_FLAGS2	EQU	BYTE PTR[BX]			; Use index addressing 
 =				_KB_FLAGS1	EQU	_KB_FLAGS2[-1]			;  for byte savings 
				 
 EB45				INT_KB_IS_FLAG PROC 
 EB45  BB 0018 R			MOV	BX, OFFSET KB_FLAGS2			; BX = KB_FLAGS2 
 EB48  BF EC1E R			MOV	DI, OFFSET KEY_FLAG_ON_TBL 
 EB4B  8A C4				MOV	AL, AH					; AL = original scan code 
 EB4D  24 7F				AND	AL, 01111111B				; clear high bit for search 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-115


 EB4F  B1 01				MOV	CL, 1						; set up bit mask counter 
 EB51				INT_KB_FLAG_LOOP: 
 EB51  AE				SCASB 						; look for scan code 
 EB52  74 07				JZ	INT_KB_FLAG_FOUND 
 EB54  D0 E1				SHL	CL, 1 					; CL will contain bit mask 
 EB56  75 F9				JNZ	INT_KB_FLAG_LOOP				; CF if not found too 
 EB58  E9 EA3E R			JMP	KB_INT_NOT_FLAG 
 EB5B				INT_KB_FLAG_FOUND: 
 EB5B  FA				CLI 
 EB5C  8A C1				MOV	AL, CL					; move to AL for work 
				 
				;----------------------------------------------------------------------------; 
				; Ins, Caps, Num, Scrl send break codes, but state is kept by BIOS so ignore those. 
				; 
 EB5E  A8 F0				TEST	AL, MASK K1IN OR MASK K1CL OR MASK K1NL OR MASK K1SL 
 EB60  74 18				JZ	INT_KB_NOT_ICNS				; don't clear on break code on these 
 EB62  84 E4				TEST	AH, AH					; is Ins, Caps, Num, Scrl break code? 
 EB64  79 06				JNS	INT_KB_ICNS_MAKE				; if not, jump to make 
				 
				;----------------------------------------------------------------------------; 
				; Handle KB_FLAGS2 for Ins, Caps, Num, Scroll Lock for both make and break 
				; 
 EB66				INT_KB_ICNS_BREAK: 
 EB66  F6 D0				NOT	AL 
 EB68  20 07				AND	_KB_FLAGS2, AL 
 EB6A  EB 0B				JMP	SHORT	INT_KB_DONE_3 
 EB6C				INT_KB_ICNS_MAKE: 
 EB6C  08 07				OR	_KB_FLAGS2, AL				; set flag in KB_FLAGS2 
				 
				;----------------------------------------------------------------------------; 
				; Otherwise toggle the flag for Ins, Caps, Num, Scrl. 
				; 
				; Note: The Ins key is treated as a key press with code 5200H. 
				; 
 EB6E				INT_KB_FLAG_TOGGLE: 
 EB6E  30 47 FF				XOR	_KB_FLAGS1, AL				; toggle flag 
 EB71  A8 80				TEST	AL, MASK K1IN				; is insert key? 
 EB73  B0 00				MOV	AL, 0 
 EB75  75 2E				JNZ	INT_KB_PUT_BUFFER_2			; pass through as a key if so 
 EB77				INT_KB_DONE_3: 
 EB77  E9 EA98 R			JMP	INT_KB_DONE 
				 
				;----------------------------------------------------------------------------; 
				; Scan code for Alt, Ctrl, Left or Right Shift 
				; On make code, set flag.  On break code, clear flag. 
				; 
 EB7A				INT_KB_NOT_ICNS: 
				 
				;----------------------------------------------------------------------------; 
				; Handle KB_FLAGS2 for Ctrl or Alt 
				; 
 EB7A  A8 0C				TEST	AL, MASK K1AL OR MASK K1CT		; is Alt or Ctrl? 
 EB7C  74 08				JZ	INT_KB_NOT_ICNS_1				; jump if not 
 EB7E  D0 E8				SHR	AL, 1						; adjust for KB_FLAGS2 
 EB80  D0 E8				SHR	AL, 1 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-116


 EB82  30 07				XOR	_KB_FLAGS2, AL				; toggle flag 
 EB84  8A C1				MOV	AL, CL					; restore AL 
				 
 EB86				INT_KB_NOT_ICNS_1: 
 EB86  4B				DEC	BX						; _KB_FLAGS2 = KB_FLAGS1 
 EB87  84 E4				TEST	AH, AH					; is a break code? 
 EB89  78 04				JS	INT_KB_FLAG_CLEAR				; if so, clear flag 
 EB8B  08 07				OR	_KB_FLAGS2, AL				; set flag 
 EB8D  EB E8				JMP	SHORT INT_KB_DONE_3			; done 
				 
 EB8F				INT_KB_FLAG_CLEAR: 
 EB8F  F6 D0				NOT	AL						; invert mask 
 EB91  20 07				AND	_KB_FLAGS2, AL				; clear flag 
 EB93  80 F9 08				CMP	CL, MASK K1AL				; was it ALT key? 
 EB96  75 DF				JNZ	INT_KB_DONE_3				; if not, done 
				 
 EB98				INT_KB_IS_FLAG ENDP 
				 
				;----------------------------------------------------------------------------; 
				; ALT has just been released 
				;----------------------------------------------------------------------------; 
				; Check if there a partial value of ALT+000 (ALT-GR) numpad entry work byte? 
				; 
 EB98				INT_KB_ALT_BREAK: 
 EB98  A0 0019 R			MOV	AL, KB_ALT 
 EB9B  84 C0				TEST	AL, AL					; is ALT working sum 0? 
 EB9D  74 D8				JZ	INT_KB_DONE_3				; if so, end 
 EB9F  B4 00				MOV	AH, 0						; Scan code is 0 
 EBA1  88 26 0019 R			MOV	KB_ALT, AH					; clear ALT byte working sum 
 EBA5				INT_KB_PUT_BUFFER_2: 
 EBA5  E9 EA7D R			JMP	KB_INT_PUT_BUFFER				; use value as output char 
				 
				;----------------------------------------------------------------------------; 
				; Keyboard scancode mapping tables 
				;----------------------------------------------------------------------------; 
				; For each scan code this table contains ASCII characters. The first byte is 
				; the shifted (shift held) ASCII char, followed by the non-shifted ASCII char. 
				; 
				; Flag chars (noted by *) return their scan code with most sig bit set  
				; (also their break code). 
				;----------------------------------------------------------------------------; 
 EBA8				KEY_SCAN_TBL	LABEL BYTE 
 EBA8  0002[				DB	2 DUP(0), 2 DUP(1BH) 		; 00-01H	None, Escape 
	   00			
			 ]	
       0002[			
	   1B			
			 ]	
				
 EBAC  21 31 40 32 23 33 24		DB	'!1@2#3$4%5^6' 			; 02-		(Top row keys) 
       34 25 35 5E 36		
 EBB8  26 37 2A 38 28 39 29		DB	'&7*8(9)0_-+='			;   -0DH 
       30 5F 2D 2B 3D		
 EBC4  08 08 00 09			DB	8, 8, 0, 9 				; 0E-0FH	Backspace, Tab 
 EBC8  51 71 57 77 45 65 52		DB	'QqWwEeRrTtYy' 			; 10-		(Second row keys) 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-117


       72 54 74 59 79		
 EBD4  55 75 49 69 4F 6F 50		DB	'UuIiOoPp{[}]' 			;    1BH 
       70 7B 5B 7D 5D		
 EBE0  0002[				DB	2 DUP(0DH) 				; 1C		Enter 
	   0D			
			 ]	
				
 EBE2  0002[				DB	2 DUP(01DH OR 80H) 		; 1D		*Ctrl 
	   9D			
			 ]	
				
 EBE4  41 61 53 73 44 64 46		DB	'AaSsDdFfGgHh'			; 1E-		(Third row keys) 
       66 47 67 48 68		
 EBF0  4A 6A 4B 6B 4C 6C 3A		DB	'JjKkLl:;"', "'", '~`'		;   -29H 
       3B 22 27 7E 60		
 EBFC  0002[				DB	2 DUP(02AH OR 80H)  		; 2A		*Left shift 
	   AA			
			 ]	
				
 EBFE  7C 5C 5A 7A 58 78 43		DB	'|\ZzXxCcVvBb' 			; 2B-		(Fourth row keys) 
       63 56 76 42 62		
 EC0A  4E 6E 4D 6D 3C 2C 3E		DB	'NnMm<,>.?/' 			;   -35H 
       2E 3F 2F			
 EC14  0002[				DB	2 DUP(36H OR 80H)			; 36H		*Right Shift 
	   B6			
			 ]	
				
 EC16  00 2A				DB	0, '*' 				; 37H		PrtSc/'*' 
 EC18  0002[				DB	2 DUP(38H OR 80H)			; 38H		*Alt 
	   B8			
			 ]	
				
 EC1A  0002[				DB	2 DUP(' ')				; 39H		Space 
	   20			
			 ]	
				
 EC1C  0002[				DB	2 DUP(3AH OR 80H) 		; 3AH		*Caps Lock 
	   BA			
			 ]	
				
				 
				;----------------------------------------------------------------------------; 
				; IMPORTANT NOTE: these next two tables are placed here to fill the "hole" 
				; for the F1-F10 keys since those scan codes are handled separately. 
				; This space can be used as long as exactly 20 bytes is left to maintain the 
				; table index. Left commented-out below for reference: 
				;	DW	10 DUP(0) 				; 3B-44H	F1-F10 
				 
				;----------------------------------------------------------------------------; 
				; Table for scan codes that are keys that set flags. 
				; The byte's index corresponds to the flag bit position in BDA's KB_FLAGS1. 
				; Length: 8 bytes 
				; 
 EC1E				KEY_FLAG_ON_TBL	LABEL BYTE	;                            ICNSATLR 
 EC1E  36				DB	36H			; Right shift on	0110110 -> 00000001 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-118


 EC1F  2A				DB	2AH			; Left shift on	0101010 -> 00000010 
 EC20  1D				DB	1DH			; cTrl on		0011101 -> 00000100 
 EC21  38				DB	38H			; Alt on		0111000 -> 00001000 
 EC22  46				DB	46H			; Scroll lock on 	1000110 -> 00010000 
 EC23  45				DB	45H			; Num lock on	1000101 -> 00100000 
 EC24  3A				DB	3AH			; Caps lock on	0111010 -> 01000000 
 EC25  52				DB	52H			; Insert on		1010010 -> 10000000 
 = 0008				L_KEY_FLAG_ON_TBL	EQU $-KEY_FLAG_ON_TBL 
				 
				;----------------------------------------------------------------------------; 
				; Alt keys that are "skipped" and return no scan codes 
				; Length: 10 bytes 
				; 
 EC26				INT_KB_ALT_SKIP	LABEL BYTE 
 EC26  0F				DB	0FH					; Tab 
 EC27  1C				DB	1CH					; Enter 
 EC28  27				DB	27H					; ; 
 EC29  28				DB	28H					; ' 
 EC2A  29				DB	29H					; ` 
 EC2B  2B				DB	2BH					; \ 
 EC2C  33				DB	33H					; , 
 EC2D  34				DB	34H					; . 
 EC2E  35				DB	35H					; / 
 EC2F  37				DB	37H					; * PrcSc 
 = 000A				L_INT_KB_ALT_SKIP	EQU $-INT_KB_ALT_SKIP 
				 
				;----------------------------------------------------------------------------; 
				; Resume scancode table at 45H (word aligned) 
				; 
 EC32						ORG	KEY_SCAN_TBL + 45H * 2 
 EC32				KEY_SCAN_TBL_HIGH	LABEL BYTE 
 EC32  0002[				DB	2 DUP(45H OR 80H)			; 45H		*Num Lock 
	   C5			
			 ]	
				
 EC34  0002[				DB	2 DUP(46H OR 80H)			; 46H		*Scroll Lock 
	   C6			
			 ]	
				
 EC36  37 00				DB	'7', 0				; 47H		Home/7 
 EC38  38 00				DB	'8', 0				; 48H		Up/8 
 EC3A  39 00				DB	'9', 0				; 49H		PgUp/9 
 EC3C  0002[				DB	2 DUP('-')				; 4AH		Keypad '-' 
	   2D			
			 ]	
				
 EC3E  34 00				DB	'4', 0				; 4BH		Left/4 
 EC40  35 00				DB	'5', 0				; 4CH		Center/5 
 EC42  36 00				DB	'6', 0				; 4DH		Right/6 
 EC44  0002[				DB	2 DUP('+')				; 4EH		Keypad '+' 
	   2B			
			 ]	
				
 EC46  31 00				DB	'1', 0				; 4FH		End/1 
 EC48  32 00				DB	'2', 0				; 50H		Down/2 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-119


 EC4A  33 00				DB	'3', 0				; 51H		PgDn/3 
 EC4C  30 D2				DB	'0', 52H OR 80H			; 52H		*Ins/0 
 EC4E  2E 00				DB	'.', 0				; 53H		Del 
 EC50  0002[				DB	2 DUP(0)				; 54H		SysReq 
	   00			
			 ]	
				
 = 00AA				L_KEY_SCAN_TBL EQU $-KEY_SCAN_TBL 
				 
 EC52				INT_09 ENDP 
				 
							ENDIF 
				 
				; 
				; 7 BYTES HERE / 6 BYTES HERE 5150 
				; 
				BYTES_HERE	INT_13 
 = 0007                      1	BYTES_HERE_INT_13 = INT_13-$ 
			     1			IFDEF BYTES_HERE_INT_13 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 13H - Diskette BIOS Services 
				;----------------------------------------------------------------------------; 
				;	INT 13,0  Reset disk system 
				;	INT 13,1  Get disk status 
				;	INT 13,2  Read disk sectors 
				;	INT 13,3  Write disk sectors 
				;	INT 13,4  Verify disk sectors 
				;	INT 13,5  Format disk track 
				; 
				;  Typical params: 
				;	AH = function request number 
				;	AL = number of sectors	(1-128) 
				;	CH = cylinder number	(0-1023) 
				;	CL = sector number	(1-17) 
				;	DH = head number		(0-15) 
				;	DL = drive number		(0=A:, 1=B:, 80H=C:, 81H=D:) (for AH=2-5) 
				;	ES:BX = address of user buffer 
				; 
				;  Output: 
				;	CF = 0 if successful 
				;	   = 1 if error 
				;	AH = status of operation (https://stanislavs.org/helppc/int_13-1.html) 
				; 
				;----------------------------------------------------------------------------; 
				;  All functions: 
				;	- return FD_LAST_OP ([41H]) in AH 
				;	- set CF if error 
				;	- reset motor shutoff counter 
				; 
				;  Reference: 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-120


				;	https://stanislavs.org/helppc/int_13.html 
				;	https://stanislavs.org/helppc/765.html 
				;	NEC Microcomputers, Inc. PD765C Application Note 8 (Mar 1979) 
				; 
				;  Ports: 
				;	3F0-3F7 Floppy disk controller (except PCjr) 
				;	3F0 Diskette controller status A 
				;	3F1 Diskette controller status B 
				;	3F2 controller control port 
				;	3F4 controller status register 
				;	3F5 data register (write 1-9 byte command, see INT 13) 
				;	3F6 Diskette controller data 
				;	3F7 Diskette digital input 
				; 
				;----------------------------------------------------------------------------; 
				 
				;----------------------------------------------------------------------------; 
				; Use indexed addressing to DI = FD_LAST_OP for byte savings. 
				; 
 =				_FD_LAST_OP		EQU	BYTE PTR [DI]				; FD_LAST_OP 
 =				_FD_MOTOR_ST	EQU	_FD_LAST_OP[FD_MOTOR_ST-FD_LAST_OP]	; FD_MOTOR_ST 
 =				_FD_CAL_ST		EQU	_FD_LAST_OP[FD_CAL_ST-FD_LAST_OP]	; FD_CAL_ST 
 =				_FD_TRACK		EQU	_FD_LAST_OP[FD_TRACK-FD_LAST_OP]	; FD_TRACK 
 =				_FD_MEDIA_ST	EQU	_FD_LAST_OP[FD_MEDIA_ST-FD_LAST_OP]	; FD_MEDIA_ST 
 =				_FD_TIMER		EQU	_FD_LAST_OP[TIMER-FD_LAST_OP]		; TIMER 
 =				_FDC_LAST_ST	EQU	[DI][FDC_LAST_ST-FD_LAST_OP]		; FDC_LAST_ST 
				 
 EC59						ORG 0EC59H 
 EC59				INT_13 PROC 
						ASSUME DS:_BDA 
 EC59  FB				STI 						; enable interrupts 
 EC5A  FC				CLD 
					PUSHX	DS, DI				; save caller registers 
			     1				IFNB <DS>			; exit if last reg 
 EC5B  1E                    1		PUSH	DS 					; push register and repeat 
			     1		PUSHX	DI, , , , , ,  
			     2				IFNB <DI>			; exit if last reg 
 EC5C  57                    2		PUSH	DI 					; push register and repeat 
			     2		PUSHX	, , , , , ,  
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 EC5D  BF ---- R			MOV	DI, SEG _BDA			; DS = BDA 
 EC60  8E DF				MOV	DS, DI 
 EC62  47				INC	DI					; DI = FD_LAST_OP throughout 
 EC63  80 65 FE 7F			AND	_FD_MOTOR_ST, NOT MASK FWRT	; clear write operation flag 
 EC67  80 FC 01				CMP	AH, 1 				; AH = 1? 
 EC6A  74 77				JE	INT_13_1 				; AH = 1, jump to Status 
					PUSHX	DX, CX, BX				; save caller registers 
			     1				IFNB <DX>			; exit if last reg 
 EC6C  52                    1		PUSH	DX 					; push register and repeat 
			     1		PUSHX	CX, BX, , , , ,  
			     2				IFNB <CX>			; exit if last reg 
 EC6D  51                    2		PUSH	CX 					; push register and repeat 
			     2		PUSHX	BX, , , , , ,  
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-121


			     3				IFNB <BX>			; exit if last reg 
 EC6E  53                    3		PUSH	BX 					; push register and repeat 
			     3		PUSHX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 EC6F  C6 05 00				MOV	_FD_LAST_OP, FDC_ST_OK		; clear last operation 
 EC72  72 24				JB	INT_13_0 				; AH = 0, jump to Reset 
 EC74  80 FA 03				CMP	DL, 3 				; is drive number > 3? 
 EC77  77 05				JA	INT_13_BAD_CMD 			; if so, exit 
 EC79  80 FC 06				CMP	AH, 6 				; AH = 2 through 5? 
 EC7C  72 71				JB	INT_13_2_5 				; jump to FDC RWVF command 
 EC7E				INT_13_BAD_CMD: 
 EC7E  FE 05				INC	_FD_LAST_OP				; otherwise return "bad command" (1) 
 EC80				INT_13_DONE: 
 EC80  8A 25				MOV	AH, _FD_LAST_OP 			; AH = last operation status 
 EC82				INT_13_SET_MOTOR_CT: 
 EC82  93				XCHG	AX, BX				; save AL 
 EC83  B0 02				MOV	AL, DBT.FMCT 			; INT_1E[2] = motor shutoff counter 
 EC85  E8 EF48 R			CALL	INT_1E_PARAM 			; AL = shutoff counter value (37) 
 EC88  A2 0040 R			MOV	FD_MOTOR_CT, AL 			; update in BDA 
 EC8B  93				XCHG	AX, BX				; restore AL 
 EC8C				INT_13_EXIT: 
					POPX	BX, CX, DX				; restore caller registers 
			     1				IFNB <BX>			; exit if last reg 
 EC8C  5B                    1		POP	BX 					; pop register and repeat 
			     1		POPX	CX, DX, , , , ,  
			     2				IFNB <CX>			; exit if last reg 
 EC8D  59                    2		POP	CX 					; pop register and repeat 
			     2		POPX	DX, , , , , ,  
			     3				IFNB <DX>			; exit if last reg 
 EC8E  5A                    3		POP	DX 					; pop register and repeat 
			     3		POPX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 EC8F				INT_13_EXIT_1: 
					POPX	DI, DS				; restore caller registers 
			     1				IFNB <DI>			; exit if last reg 
 EC8F  5F                    1		POP	DI 					; pop register and repeat 
			     1		POPX	DS, , , , , ,  
			     2				IFNB <DS>			; exit if last reg 
 EC90  1F                    2		POP	DS 					; pop register and repeat 
			     2		POPX	, , , , , ,  
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 EC91  80 FC 01				CMP	AH, FDC_ST_OK+1			; check AH for error (CF = AH < 1) 
 EC94  F5				CMC   					; invert CF for return (CF = ! CF) 
					IRET_F 					; return from int with current flags 
 EC95  CA 0002               1		RETF	2 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-122


				; INT 13, 0: Reset disk system 
				;----------------------------------------------------------------------------; 
				; Performs hard reset on FDC controller 
				; 
				; Input: 
				;	AH = 00 
				;	DL = drive number (0=A:, 1=2nd floppy, 80h=drive 0, 81h=drive 1) 
				;		(unused - drive is determined by BDA motor status) 
				; 
				; Output: 
				;	AH = disk operation status  (see INT 13,STATUS) 
				;	CF = 0 if successful 
				;	   = 1 if error 
				; 
				; To Convert FD_MOTOR_ST to FDC byte use the following table/formula: 
				;	Motors On 	Drive # 
				;	0 0 0 0	 	- 			AND with 1111, jump if AL = 0 
				;	1 x x x		3			TEST bit 1000, if non-zero then AL = 3 
				;	0 1 0 x		2 			Shift right once and AL will be correct 
				;	0 0 1 x		1 			" 
				;	0 0 0 x	 	0			" 
				; 
				;----------------------------------------------------------------------------; 
				; Things you must do: 
				; 
				;	- if a motor flag is on in BDA, turn it on in the FDC also 
				;	- clear reset flag in controller and pull heads to track 0 
				;	- set ALL disks need recalibration on next seek (Why all drives?) 
				;	- setting the controller reset flag causes the disk to recalibrate 
				;	  	on the next disk operation 
				;	- if bit 7 is set, the diskette drive indicated by the lower 7 bits 
				;		will reset then the hard disk will follow; return code in AH is 
				;		for the drive requested (this is done by HD BIOS) 
				;----------------------------------------------------------------------------; 
 EC98				INT_13_0 PROC 
 EC98  BA 03F2				MOV	DX, FDC_CTRL			; port 3F2H, FDC Digital Output 
 EC9B  FA				CLI 						; disable interrupts 
 EC9C  A0 003F R			MOV	AL, FD_MOTOR_ST 			; 3FH - Diskette motor status 
 EC9F  8A E8				MOV	CH, AL 				; save to CH 
 ECA1  24 0F				AND	AL, MASK FMOT			; isolate motor status flags 
 ECA3  74 0E				JZ	INT_13_0_2				; jump if no motors are on, default to 0 
				 
				;----------------------------------------------------------------------------; 
				; One motor is on (according to BDA). Convert motor run flags to binary number 
				; since FDC requires a drive index for the reset. 
				; 
 ECA5  D0 E8				SHR	AL, 1					; disregard low bit (will be 0 either way) 
 ECA7  A8 04				TEST	AL, MASK FMOT3 SHR 1		; test for drive 3? 
 ECA9  74 02				JZ	INT_13_0_1				; if not drive 3, AL is now correct 
 ECAB  B0 03				MOV	AL, 3 				; otherwise set AL to drive 3 
 ECAD				INT_13_0_1: 
							ELSE 
 ECAD  B1 04				MOV	CL, 4 				; move low nibble of FD_MOTOR_ST 
 ECAF  D2 E5				SHL	CH, CL				;  into high nibble of CH 
 ECB1  0A C5				OR	AL, CH 				; combine nibbles with AL 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-123


							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Reset the controller by holding FDC reset (bit 2) at 0. 
				; Perform the following memory operations here to satisfy reset timing for FDC: 
				; - Flag all drives for recalibration (not just the drive in DL) 
				; 
 ECB3				INT_13_0_2: 
 ECB3  0C 08				OR	AL, MASK FDDMA			; enable DMA & I/O interface, FDC reset 
 ECB5  EE				OUT	DX, AL				; send to FDC 
 ECB6  88 65 FD				MOV	_FD_CAL_ST, AH 			; flag all drives for recalibration 
				 
				;----------------------------------------------------------------------------; 
				; Re-enable FDC by setting bit 2 to 1. 
				; Wait for Interrupt (WIF) from FDC 
				; 
 ECB9  0C 04				OR	AL, MASK FDCEN			; set FDC enable 
 ECBB  EE				OUT	DX, AL				; send to FDC 
 ECBC  FB				STI 						; enable interrupts 
 ECBD  E8 EEDD R			CALL	FDC_WAIT_SENSE			; wait for FDC to signal interrupt 
 ECC0  72 04				JC	INT_13_0_RESET_BAD		; jump if FDC read/sense error 
 ECC2  3C C0				CMP	AL, FDC_ST0 < 11B >		; was successful reset? 
 ECC4  74 02				JZ	INT_13_0_RESET_DONE		; jump if success, AH = 0 
 ECC6				INT_13_0_RESET_BAD: 
 ECC6  B4 20				MOV	AH, FDC_ST_ERR_FDC		; otherwise, controller failure 
 ECC8				INT_13_0_RESET_DONE: 
 ECC8  88 25				MOV	_FD_LAST_OP, AH			; set last result 
 ECCA  75 B6				JNZ	INT_13_SET_MOTOR_CT		; exit on error with AH already set 
				 
				;----------------------------------------------------------------------------; 
				; (Re)send Specify bytes to FDC 
				; 
 ECCC  B0 03				MOV	AL, FDC_CMD_SPEC 			; [0] FDC Specify command 
 ECCE  E8 EE9A R			CALL	FDC_SEND 				; send command in AL, CF if error 
 ECD1  72 0C				JC	INT_13_0_DONE 
 ECD3  B0 00				MOV	AL, DBT.SRT				; [1] step rate time, head unload time 
 ECD5  E8 EE97 R			CALL	FDC_SEND_PARAM 
 ECD8  72 05				JC	INT_13_0_DONE 
 ECDA  B0 01				MOV	AL, DBT.HLT_ND			; [2] head load time (01H), DMA mode (ND) 
 ECDC  E8 EE97 R			CALL	FDC_SEND_PARAM 
				 
				;----------------------------------------------------------------------------; 
				; Exit and return with AL = 0 
				; 
 ECDF				INT_13_0_DONE: 
 ECDF  B0 00				MOV	AL, 0					; 0 sectors read 
 ECE1  EB 9D				JMP	SHORT INT_13_DONE 
 ECE3				INT_13_0 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 13, 1: Get disk status 
				;----------------------------------------------------------------------------; 
				; Output: AL and AH = status of last operation 
				;----------------------------------------------------------------------------; 
 ECE3				INT_13_1 PROC 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-124


 ECE3  8A 05				MOV	AL, _FD_LAST_OP 			; AL = last operation status 
 ECE5  8A E0				MOV	AH, AL				; AH = last operation status 
 ECE7  EB A6				JMP	SHORT INT_13_EXIT_1 
 ECE9				INT_13_1 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; DMA page boundary overrun 
				; 
 ECE9				FDC_DMA_BOUND: 
 ECE9  80 0D 09				OR	_FD_LAST_OP, FDC_ST_DMA_64K	; DMA boundary error 
 ECEC  F9				STC						; re-set CF 
 ECED  EB 5E				JMP	SHORT FDC_INIT_DMA_EXIT		; rebalance stack and exit 
				 
				;----------------------------------------------------------------------------; 
				; INT 13, AH=2-5: FDC read/write operations 
				;----------------------------------------------------------------------------; 
				; All commands: 
				; 
				; 	AL = number of sectors to read  (1-128 dec.) 
				;	AH = function number 
				;	CH = track/cylinder number  (0-1023 dec., see below) 
				;	CL = sector number  (1-17 dec.) 
				;	DH = head number  (0-15 dec.) 
				;	DL = drive number (0=A:, 1=2nd floppy, 80h=drive 0, 81h=drive 1) 
				;	ES:BX = pointer to buffer 
				;----------------------------------------------------------------------------; 
				; Things you must do: 
				; 
				;	1. Set FD_MOTOR_ST read/write flag for operation 
				;	2. Motor ON (update BDA) 
				;		- is motor already on? Skip wait for spin up 
				;		- wait only for writes? 
				;		- check if recalibration is necessary 
				;	3. Set up DMA 
				;	4. seek drive DL to cylinder CH, head DH 
				; 	5. send command 
				;	6. wait for interrupt 
				;	7. fetch results 
				;	8. Check FDC status bytes for result 
				; 
				; Things you should do: 
				;	- Check if drive is valid? Check if exists in BDA and not a hard drive 
				;----------------------------------------------------------------------------; 
 ECEF				INT_13_2_5 PROC 
 ECEF  86 C4				XCHG	AL, AH				; AL = function, AH = sectors to read 
 ECF1  50				PUSH	AX					; save function, sector count 
 ECF2  52				PUSH	DX					; save head, drive 
 ECF3  B6 46				MOV	DH, DMA_MR <1,0,0,1,2> 		; set DMA read mode 1 (AH = 2) 
 ECF5  3C 02				CMP	AL, 2					; is read? 
 ECF7  74 0C				JE	INT_13_2_5_SETUP_DMA		; if so, proceed to setup 
 ECF9  B6 42				MOV	DH, DMA_MR <1,0,0,0,2> 		; set DMA verify mode 0 (AH = 4) 
 ECFB  3C 04				CMP	AL, 4					; is verify? 
 ECFD  74 06				JE	INT_13_2_5_SETUP_DMA		; if so, proceed to setup 
 ECFF  B6 4A				MOV	DH, DMA_MR <1,0,0,2,2> 		; else DMA write/format mode 2 (AH = 3,5) 
 ED01  80 4D FE 80			OR	_FD_MOTOR_ST, MASK FWRT		; turn on write flag 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-125


 ED05				INT_13_2_5_SETUP_DMA: 
 ED05  8A C6				MOV	AL, DH				; AL = DMA mode, AH = sectors to read 
 ED07  E8 EDE8 R			CALL	FDC_SEEK 				; Turn on motor, CH = track, DL = drive 
 ED0A  72 42				JC	INT_13_2_5_SEEK_ERR		; exit if seek error 
											; fall through to set up DMA 
				 
				;----------------------------------------------------------------------------; 
				; FDC_INIT_DMA: Configure DMA channel 2 for FDC operation 
				;----------------------------------------------------------------------------; 
				; Input: 
				;  AH = sectors to read 
				;  AL = DMA mode: 
				;	01000110 (46H) - Read 
				;	01000010 (42H) - Verify 
				;	01001010 (4AH) - Write 
				; 	01 			; Mode: Single mode select 
				; 	  0  			; Address increment 
				;	   0 			; Auto-initialization disable 
				;	    xx		; 00=verify, 01=write, 10=read, 11=unused 
				;	      10		; Channel 2 select 
				;  ES:BX = pointer to buffer 
				; 
				; Output: 
				;  CF = 0 success, 1 if error DMA exceeds segment 
				;----------------------------------------------------------------------------; 
				; Things you must do: 
				;	- Calculate # of bytes to transfer by multiplying AL (sectors) by 
				;		sector size in INT 1E Disk Base Table. 
				;	- Calculate physical memory address from ES:BX and normalize to 
				;		Paragraph:Offset (P:FFFFH). 
				;	- Verify that Offset + Byte Count does not exceed the remaining 
				;		space in that paragraph. The DMA controller can only select one 
				;		paragraph bank at a time, so writes will NOT wrap to next para. 
				;		Exit with DMA Boundary error if segment is exceeded. 
				;	- Reset the high/low byte flip-flop (send any value to I/O port 0CH) 
				;	- Set DMA mode for Channel 2 to either Verify, Read or Write/Format 
				;	- Disable interrupts while programming DMA 
				;	- Set the DMA Page (memory paragraph) for DMA channel 2 (I/O port 81H) 
				;	- Set the DMA Byte Counter to size of transfer minus 1 (since 
				;		DMA's counter is 0-indexed) 
				;	- Set the DMA Address register to beginning of DMA buffer from ES:BX 
				;	- Enable interrupts and unmask DMA Channel 2 
				; 
				;----------------------------------------------------------------------------; 
				; References: 
				;  https://pdf1.alldatasheet.com/datasheet-pdf/view/127822/AMD/8237A.html 
				;  https://wiki.osdev.org/ISA_DMA#Floppy_Disk_DMA_Initialization 
				;  https://stackoverflow.com/questions/52396915/how-to-write-assembly-language-to-make-dma-works 
				;  https://userpages.umbc.edu/~squire/intel_book.pdf 
				;----------------------------------------------------------------------------; 
 ED0C				FDC_INIT_DMA: 
 ED0C  51				PUSH	CX					; save track / sector 
 ED0D  8C C2				MOV	DX, ES 				; get and shift ES by one nibble 
							ELSE 
 ED0F  B1 04				MOV	CL, 4					; DL = lowest and highest nibble of ES 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-126


 ED11  D3 C2				ROL	DX, CL				; DH = middle nibbles 
							ENDIF 
 ED13  E6 0B				OUT	DMA_MODE, AL			; write to DMA mode reg (port 0BH) 
 ED15  32 C0				XOR	AL, AL				; AX = sectors to read << 8 
 ED17  91				XCHG	AX, CX				; CX = sectors, AX = scratch 
 ED18  B0 03				MOV	AL, DBT.FBPS			; get bytes/sector param (0=128, 1=256, 2=512, 3=102
				4) 
 ED1A  E8 EF48 R			CALL	INT_1E_PARAM			; AL = shift count (default 2 => 512) 
 ED1D  91				XCHG	AX, CX				; AX = sectors, CL = bytes per sector shifts 
 ED1E  D1 E8				SHR	AX, 1					; adjust shift for bytes/sector * 128 
 ED20  D3 E0				SHL	AX, CL				; AX = bytes to transfer (AX * 2^CL) 
 ED22  48				DEC	AX					; AX = bytes to transfer - 1 
 ED23  91				XCHG	AX, CX				; CX = bytes to transfer - 1 
 ED24  8A C2				MOV	AL, DL				; AL = lowest and highest nibble of ES 
 ED26  24 0F				AND	AL, 0FH				; AL = only high nibble of ES 
 ED28  80 E2 F0				AND	DL, 0F0H				; DX = low three nibbles of ES (shifted left
				 1 nibble) 
 ED2B  03 DA				ADD	BX, DX				; BX = DMA start offset for transfer 
 ED2D  14 00				ADC	AL, 0					; AL = DMA page 
 ED2F  8B D3				MOV	DX, BX				; check that buffer offset + length does not exceed 
				segment 
 ED31  03 D1				ADD	DX, CX				; DX = DMA end offset, test for boundary overflow 
 ED33  72 B4				JC	FDC_DMA_BOUND			; error if DMA access across 64k boundary 
 ED35  FA				CLI						; Disable interrupts 
 ED36  E6 0C				OUT	DMA_FF, AL				; DMA clear flip-flop (port 0CH) (any value)
				 
 ED38  E6 81				OUT	DMA_P_C2, AL 			; set DMA Channel 2 Page Address Register (port 81H)
				 
 ED3A  93				XCHG	AX, BX				; AL = address low byte, AH = high byte 
 ED3B  E6 04				OUT	DMA_2_A, AL				; 
 ED3D  86 C4				XCHG	AL, AH 				; AH = address low byte, AL = high byte 
 ED3F  E6 04				OUT	DMA_2_A, AL				; 
 ED41  91				XCHG	AX, CX				; AL = byte/count low byte, AH = high byte 
 ED42  E6 05				OUT	DMA_2_C, AL				; 
 ED44  86 C4				XCHG	AL, AH				; AH = byte/count low byte, AL = high byte 
 ED46  E6 05				OUT	DMA_2_C, AL 
 ED48  FB				STI						; Enable interrupts 
 ED49  B0 02				MOV	AL, DMA_SMR <0, 2>		; DMA clear single channel 2 mask bit 
 ED4B  E6 0A				OUT	DMA_MASK, AL			; Unmask DMA Channel 2 (port 0AH) 
 ED4D				FDC_INIT_DMA_EXIT: 
 ED4D  59				POP	CX					; CL = sector, CH = track 
 ED4E				INT_13_2_5_SEEK_ERR: 
 ED4E  5A				POP	DX 					; DL = drive, DH = head 
 ED4F  58				POP	AX					; AL = function, AH = sectors to read 
 ED50  72 8D				JC	INT_13_0_DONE			; exit if DMA error with AL = 0 
				 
				;----------------------------------------------------------------------------; 
				; Set FDC command byte 
				; 
 ED52  B3 C5				MOV	BL, FDC_CB <1,,0,FDC_CMD_WR>	; FDC Write Data - Multi-Track, MFM 
 ED54  3C 03				CMP	AL, 3 				; is write (AH=3)? 
 ED56  74 08				JE	FDC_RWVF				; jump if write 
 ED58  B3 4D				MOV	BL, FDC_CB <0,,0,FDC_CMD_FMT>	; FDC Format Track - Single-Track, MFM 
 ED5A  3C 05				CMP	AL, 5 				; is format (AH=5)? 
 ED5C  74 02				JE	FDC_RWVF 				; jump if format 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-127


 ED5E  B3 E6				MOV	BL, FDC_CB <1,,1,FDC_CMD_RD>	; FDC Read/Verify - MT, MFM, Skip deleted 
											; else read (AH=2,4) 
 ED60				FDC_RWVF: 
 ED60  93				XCHG	AX, BX				; AL = FDC cmd byte, BL = function 
				 
				;----------------------------------------------------------------------------; 
				; FDC_RWVF: read, write, verify or format sectors 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AL = FDC command byte 
				;	BL = INT 13h function number 
				;	BH = sectors to read 
				;	DL = drive (0-3) 
				;	DH = head (0-1) 
				;----------------------------------------------------------------------------; 
 ED61  E8 EE9A R			CALL	FDC_SEND 				; [0] send command in AL, CF if error 
 ED64  72 64				JC	FDC_RWV_ERR 
 ED66  8A C6				MOV	AL, DH				; AL/DH = head, DL=drive 
 ED68  D0 E0				SHL	AL, 1					; [1] head / drive byte:  
 ED6A  D0 E0				SHL	AL, 1					;  xxxxx     ; unused 
 ED6C  0A C2				OR	AL, DL 				;       h    ; head number (bit 3) 
 ED6E  24 07				AND	AL, MASK FC1HD OR MASK FC1DS	;        dd  ; drive number (bit 1,2) 
 ED70  E8 EE9A R			CALL	FDC_SEND 				; send command in AL, CF if error 
 ED73  72 55				JC	FDC_RWV_ERR 
 ED75  80 FB 05				CMP	BL, 5					; is format? 
 ED78  74 53				JE	FDC_FORMAT 
				 
				;----------------------------------------------------------------------------; 
				; FDC_RWV: read, write or verify sectors 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	CH = track/cylinder number (0-39) 
				;	CL = sector number (1-17) 
				;	DH = head number (0-1) (bounds not checked) 
				; 
				; Output: 
				;	AL = number of sectors read, written or verified 
				;----------------------------------------------------------------------------; 
 ED7A				FDC_RWV PROC 
 ED7A  8A C5				MOV	AL, CH 				; [2] cylinder number 
 ED7C  E8 EE9A R			CALL	FDC_SEND 				; send command in AL, CF if error 
 ED7F  72 49				JC	FDC_RWV_ERR 
 ED81  8A C6				MOV	AL, DH 				; [3] head number 
 ED83  E8 EE9A R			CALL	FDC_SEND 				; send command in AL, CF if error 
 ED86  72 42				JC	FDC_RWV_ERR 
 ED88  8A C1				MOV	AL, CL 				; [4] sector number 
 ED8A  E8 EE9A R			CALL	FDC_SEND 				; send command in AL, CF if error 
 ED8D  72 3B				JC	FDC_RWV_ERR 
 ED8F  B0 03				MOV	AL, DBT.FBPS			; [5] bytes per sector 
 ED91  E8 EE97 R			CALL	FDC_SEND_PARAM			; 2 = 512 bytes 
 ED94  72 34				JC	FDC_RWV_ERR 
 ED96  B0 04				MOV	AL, DBT.SPT				; [6] end of track (last sector in track) 
 ED98  E8 EE97 R			CALL	FDC_SEND_PARAM 
 ED9B  72 2D				JC	FDC_RWV_ERR 
 ED9D  8A D8				MOV	BL, AL				; BL = sectors per track 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-128


 ED9F  B0 05				MOV	AL, DBT.SGAP			; [7] sector gap length 
 EDA1  E8 EE97 R			CALL	FDC_SEND_PARAM 
 EDA4  72 24				JC	FDC_RWV_ERR 
 EDA6  B0 06				MOV	AL, DBT.LSEC			; [8] data length (if cmd byte 5==0) 
				 
				;----------------------------------------------------------------------------; 
				; Send last param and wait for status 
				; 
 EDA8				FDC_RWV_SEND_WAIT: 
 EDA8  E8 EE97 R			CALL	FDC_SEND_PARAM 
 EDAB  72 1D				JC	FDC_RWV_ERR 
 EDAD  E8 EF1B R			CALL	FDC_WAIT_STATUS			; wait for WIF and get status 
							IF FDC_ERR_SEC_CT NE 1 
 EDB0  72 18				JC	FDC_RWV_ERR				; if error, report 0 sectors read 
							ENDIF 
											; fall through for FDC SEC COUNT 
				 
				;----------------------------------------------------------------------------; 
				; FDC_SEC_COUNT: get the number of sectors read/verified/written 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	BL = sectors per track (1-9) 
				;	BH = number of sectors to read 
				;	CH = start track/cylinder number (0-39) 
				;	CL = start sector number (1-17) 
				;	DH = head number (0-1) 
				; Output: 
				;	AL = sectors transferred 
				;	AH = preserved 
				; 
				; Note: If the operation finishes at the last head/sector of a track,  
				;	FDC will report the head/track/sector position to be the beginning  
				;	of the next track. 
				;----------------------------------------------------------------------------; 
 EDB2				FDC_SEC_COUNT: 
 EDB2  A0 0047 R			MOV	AL, FDC_LAST_ST.SEC		; AL = FDC reported end sector 
 EDB5  8A D5				MOV	DL, CH				; DL = start track 
 EDB7  3B 55 04				CMP	DX, WORD PTR _FDC_LAST_ST.CYL	; rolled to next head or track? 
 EDBA  74 09				JE	FDC_SEC_COUNT_SAME		; if not, ended on the same head/track 
				 
				;----------------------------------------------------------------------------; 
				; Command has ended on a different head or track. Calculate the correct 
				; number of sectors spanned. 
				; 
 EDBC  3A 75 05				CMP	DH, _FDC_LAST_ST.HEAD		; end on same head but different track? 
 EDBF  75 02				JNE	FDC_SEC_COUNT_SAME_CYL		; if so, has spanned a full head 
 EDC1  02 C3				ADD	AL, BL				; add two tracks worth of sectors 
 EDC3				FDC_SEC_COUNT_SAME_CYL: 
 EDC3  02 C3				ADD	AL, BL				; add ending sector 
 EDC5				FDC_SEC_COUNT_SAME: 
 EDC5  2A C1				SUB	AL, CL				; AL = ending - starting = sec read 
					;CMP	AL, BH				; verify requested # of sectors was 
											; # actually read (not necessary). 
				 
 EDC7				FDC_RWV ENDP					; fall through for exit 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-129


				 
				;----------------------------------------------------------------------------; 
				; Done with all disk operations and return AL 
				; 
 EDC7				INT_13_2_5_EXIT: 
 EDC7  E9 EC80 R			JMP	INT_13_DONE 
				 
				;----------------------------------------------------------------------------; 
				; Clear AL and exit on any read/write error 
				; 
 EDCA				FDC_RWV_ERR: 
 EDCA				FDC_FORMAT_ERR: 
 EDCA  E9 ECDF R			JMP	INT_13_0_DONE			; on error: exit with sectors read = 0 
				 
				;----------------------------------------------------------------------------; 
				; INT 13, 5: Format Track 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AH = 05 
				;	AL = interleave value (XT only) / sectors per track 
				;	CX = track/cylinder number (see below for format) 
				;	DL = head number  (0-15 dec.) 
				;	ES:BX = pointer to block of "track address fields" (provided by DOS) 
				;----------------------------------------------------------------------------; 
 EDCD				FDC_FORMAT PROC 
 EDCD  B0 03				MOV	AL, DBT.FBPS			; [2] bytes per sector 
 EDCF  E8 EE97 R			CALL	FDC_SEND_PARAM 
 EDD2  72 F6				JC	FDC_FORMAT_ERR 
 EDD4  B0 04				MOV	AL, DBT.SPT				; [3] sectors per track 
 EDD6  E8 EE97 R			CALL	FDC_SEND_PARAM 
 EDD9  72 EF				JC	FDC_FORMAT_ERR 
 EDDB  B0 07				MOV	AL, DBT.FGAP			; [4] format gap length 
 EDDD  E8 EE97 R			CALL	FDC_SEND_PARAM 
 EDE0  72 E8				JC	FDC_FORMAT_ERR 
 EDE2  B0 08				MOV	AL, DBT.FFILL			; [5] format fill byte 
 EDE4  B1 01				MOV	CL, 1					; format always starts at sector 1 
 EDE6  EB C0				JMP	SHORT FDC_RWV_SEND_WAIT		; send, wait for WIF and get status 
 EDE8				FDC_FORMAT ENDP 
				 
 EDE8				INT_13_2_5 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; FDC_SEEK: Seek to track 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	CH = track 
				;	DL = drive (0-3) (bounds not checked) 
				;	DI = OFFSET FD_LAST_OP 
				;----------------------------------------------------------------------------; 
 EDE8				FDC_SEEK PROC 
 EDE8  50				PUSH	AX 
 EDE9  53				PUSH	BX 
 EDEA  E8 EE34 R			CALL	FDC_RECAL 				; recalibrate if needed 
 EDED  72 3F				JC	FDC_SEEK_RECAL_ERR		; exit if recal error 
				 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-130


							IF FDC_ADV_SEEK EQ 1 
				;----------------------------------------------------------------------------; 
				; If FDC_ADV_SEEK, the current track where the head is positioned is saved in 
				; the BDA so that a subsequent operation on the same track will not require 
				; another seek. This may result in performance improvements on sequential reads. 
				; 
 EDEF  75 04				JNZ	FDC_CHECK_SEEK			; recal not needed, check if seek 
				 
				;----------------------------------------------------------------------------; 
				; Recal was executed and now on track 0. Just do a head settle if it was 
				; the destination track. 
				; 
 EDF1  84 ED				TEST	CH, CH				; destination track 0? 
 EDF3  74 2C				JZ	FDC_SEEK_SETTLE			; if so, skip to head settle time 
				 
				;----------------------------------------------------------------------------; 
				; Check BDA to see if head is already positioned at the destination track. 
				; 
 EDF5				FDC_CHECK_SEEK: 
 EDF5  32 FF				XOR	BH, BH 
 EDF7  8A DA				MOV	BL, DL				; BX = drive # 
 EDF9  38 69 53				CMP	_FD_TRACK[BX], CH			; compare last track seek to dest 
 EDFC  74 2D				JE	FDC_SEEK_DONE			; already on track - nothing to do 
							ENDIF				; end IF FDC_ADV_SEEK 
				 
 EDFE  B0 0F				MOV	AL, FDC_CMD_SEEK			; seek command (0FH) 
 EE00  E8 EE9A R			CALL	FDC_SEND 				; send command, CF if error 
 EE03  72 29				JC	FDC_SEEK_ERR 
 EE05  8A C2				MOV	AL, DL 				; AL = drive number 
 EE07  E8 EE9A R			CALL	FDC_SEND 				; send command, CF if error 
 EE0A  72 22				JC	FDC_SEEK_ERR			; necessary? 
 EE0C  8A C5				MOV	AL, CH 				; AL = track number 
 EE0E  E8 EE9A R			CALL	FDC_SEND 				; send command, CF if error 
 EE11  72 1B				JC	FDC_SEEK_ERR 
 EE13  E8 EEDD R			CALL	FDC_WAIT_SENSE			; wait for WIF, sense and get status 
 EE16  72 16				JC	FDC_SEEK_ERR 
 EE18  34 60				XOR	AL, FDC_ST0 <01B, 1>		; select abnormal term, seek complete 
 EE1A  24 60				AND	AL, FDC_ST0 <01B, 1>		; ZF = abnormal term AND seek complete 
 EE1C  74 10				JZ	FDC_SEEK_ERR 
							IF FDC_ADV_SEEK EQ 1 
 EE1E  88 69 53				MOV	_FD_TRACK[BX], CH			; save last seeked track (BX = drv #) 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Allow time for heads to settle after seek. This may be skipped on emulators. 
				; 
 EE21				FDC_SEEK_SETTLE: 
							IF ARCH_TYPE NE ARCH_EMU 
 EE21  B8 0009				MOV	AX, DBT.HDST			; AH=0 JIC (AH=0 from FDC_WAIT_SENSE) 
 EE24  E8 EF48 R			CALL	INT_1E_PARAM			; AL = head settle time (ms) 
 EE27  E8 E68F R			CALL	IO_DELAY_MS_FDC			; delay AX ms 
							ENDIF 
 EE2A  F8				CLC						; no error 
 EE2B				FDC_SEEK_DONE: 
 EE2B  5B				POP	BX 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-131


 EE2C  58				POP	AX 
 EE2D  C3				RET 
				 
 EE2E				FDC_SEEK_RECAL_ERR: 
 EE2E				FDC_SEEK_ERR: 
 EE2E  80 0D 40				OR	_FD_LAST_OP, FDC_ST_ERR_SEEK 
 EE31  F9				STC 
 EE32  EB F7				JMP	SHORT FDC_SEEK_DONE 
 EE34				FDC_SEEK ENDP 
				 
				;----------------------------------------------------------------------------; 
				; FDC_RECAL: recalibrate drive, if necessary 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	DL = drive to recalibrate (0-3) (bounds not checked) 
				;	DI = OFFSET FD_LAST_OP 
				; Output: 
				;	CF if error 
				; 
				; Clobbers: AX, BX (if ADV_SEEK) 
				;----------------------------------------------------------------------------; 
 EE34				FDC_RECAL PROC 
 EE34  51				PUSH	CX 
				 
				;----------------------------------------------------------------------------; 
				; FDC_MOTOR_ON: Turn on motor 
				;----------------------------------------------------------------------------; 
				; Input: 
				; 	DL = drive number (0-3) (bounds not checked) 
				;----------------------------------------------------------------------------; 
				; Things you must do: 
				;	- is motor already on? Skip wait for spin up 
				;	- wait only for writes? 
				;	- check if recalibration is necessary 
				;----------------------------------------------------------------------------; 
 EE35				FDC_MOTOR_ON: 
 EE35  8A CA				MOV	CL, DL 				; move to CL for shift 
				 
				;----------------------------------------------------------------------------; 
				; Convert drive number to motor run format 
				; 
 EE37  B8 0110				MOV	AX, 110H 				; AH -> RUN_ST, AL -> FDC byte 
 EE3A  D3 E0				SHL	AX, CL 				; shift drive flags 
 EE3C  FA				CLI 						; disable interrupts 
 EE3D  8A 6D FE				MOV	CH, _FD_MOTOR_ST			; get current RUN_ST 
 EE40  84 EC				TEST	CH, AH 				; is drive already running? 
 EE42  75 21				JNZ	FDC_DRIVE_STARTED			; skip startup if so 
 EE44  0A C1				OR	AL, CL 				; combine drive number to FDC byte 
 EE46  0C 0C				OR	AL, MASK FDDMA OR MASK FDCEN	; set DMA and controller enable flags 
 EE48  52				PUSH	DX					; preserve DX 
 EE49  BA 03F2				MOV	DX, FDC_CTRL			; turn on motor 
 EE4C  EE				OUT	DX, AL				; port 3F2H, FDC Digital Output 
 EE4D  5A				POP	DX 
 EE4E  8A C5				MOV	AL, CH 				; AL = FD_MOTOR_ST 
 EE50  8A EC				MOV	CH, AH				; CH = RUN_ST drive bit field 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-132


 EE52  24 F0				AND	AL, NOT MASK FMOT 		; clear motor status of FD_MOTOR_ST 
 EE54  0A C4				OR	AL, AH				; combine nibbles, SF if write 
 EE56  98				CBW						; restart timer to max for operation 
 EE57  A3 003F R			MOV	WORD PTR FD_MOTOR_ST, AX	; write to motor status and timer 
 EE5A  79 09				JNS	FDC_DRIVE_STARTED 		; delay for motor spinup if write op 
				 
				;----------------------------------------------------------------------------; 
				; Delay using timer tick counter 
				; 
 EE5C  FB				STI 						; enable interrupts 
 EE5D  B0 0A				MOV	AL, DBT.FMST			; AL = INT_1E[10] 
 EE5F  E8 EF48 R			CALL	INT_1E_PARAM 			; AL = motor startup time (in 125ms) 
 EE62  E8 E68B R			CALL	IO_WAIT_MS_125			; wait AL * 125ms 
				 
 EE65				FDC_DRIVE_STARTED: 
 EE65  80 E5 0F				AND	CH, MASK FMOT			; isolate drives, remove write flag 
 EE68  FB				STI 						; ensure interrupts enabled 
				 
				;----------------------------------------------------------------------------; 
				; Calibrate drive if necessary 
				; 
 EE69  84 6D FD				TEST	CH, _FD_CAL_ST 			; 0 means drive is uncalibrated 
 EE6C  75 22				JNZ	FDC_RECAL_DONE 			; if drive is calibrated, exit 
 EE6E  B0 07				MOV	AL, FDC_CMD_RECAL 		; recalibrate command (07H) 
 EE70  E8 EE9A R			CALL	FDC_SEND 				; send command, CF if error 
 EE73  72 1B				JC	FDC_RECAL_ERR 
 EE75  8A C1				MOV	AL, CL 				; AL = drive number 
 EE77  E8 EE9A R			CALL	FDC_SEND 				; send command, CF if error 
					;JC	FDC_RECAL_ERR			; (necessary?) 
 EE7A  E8 EEDD R			CALL	FDC_WAIT_SENSE 			; wait for WIF, sense and get status in AL 
 EE7D  72 11				JC	FDC_RECAL_ERR 
 EE7F  34 60				XOR 	AL, FDC_ST0 <01B, 1>		; select abnormal term, seek complete 
 EE81  24 60				AND	AL, FDC_ST0 <01B, 1>		; ZF = abnormal term AND seek complete 
 EE83  F9				STC						; presume failure 
 EE84  74 0A				JZ	FDC_RECAL_ERR			; jump if error 
 EE86  08 6D FD				OR	_FD_CAL_ST, CH 			; mark drive as calibrated and CLC 
				 
							IF FDC_ADV_SEEK EQ 1 
				;----------------------------------------------------------------------------; 
				; Save track 0 to BDA FD_TRACK 
				; 
 EE89  32 FF				XOR	BH, BH				; track 0 and set ZF 
 EE8B  8A DA				MOV	BL, DL				; BX = drive index 
 EE8D  88 79 53				MOV	_FD_TRACK[BX], BH			; save last track seek 0 
							ENDIF 
				 
 EE90				FDC_RECAL_ERR: 
 EE90				FDC_RECAL_DONE: 
 EE90  59				POP	CX 
 EE91  C3				RET 
 EE92				FDC_RECAL ENDP 
				 
				;----------------------------------------------------------------------------; 
				; FDC_RECV: Wait for FDC ready to send and read next FDC Status byte into AL 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-133


				; Timeout is 5 timer ticks = ~275ms. 
				; 
				; Input: None 
				; Output: 
				;	AL = top of FDC status stack 
				;	AH = 80H if error, 0 if success 
				;	CF if timeout or error 
				;----------------------------------------------------------------------------; 
 EE92				FDC_RECV PROC 
 EE92  53				PUSH	BX 
 EE93  33 DB				XOR	BX, BX				; flag is 0 if RECV operation 
 EE95  EB 06				JMP	SHORT FDC_SEND_RECV 
				 
				;----------------------------------------------------------------------------; 
				; FDC_SEND_PARAM: Wait for FDC ready and send a floppy param in AL 
				;----------------------------------------------------------------------------; 
				; Same as below except AL input is INT_1E param index 
				;----------------------------------------------------------------------------; 
 EE97				FDC_SEND_PARAM PROC 
 EE97  E8 EF48 R			CALL	INT_1E_PARAM 			; AL = INT_1E[AL] param 
				 
				;----------------------------------------------------------------------------; 
				; FDC_SEND: Wait for FDC ready to receive and send a single command 
				;----------------------------------------------------------------------------; 
				; Timeout is 5 timer ticks = ~275ms. 
				; 
				; Input: 
				;	AL = byte to send to FDC 
				; 
				; Output: 
				;	AL = status register 
				;	AH = 80H if error, 0 if success 
				;	CF and ZF if error 
				;----------------------------------------------------------------------------; 
 EE9A				FDC_SEND PROC 
 EE9A  53				PUSH	BX 
 EE9B  B3 01				MOV	BL, 1					; flag is 1 if SEND operation 
				 
 EE9D				FDC_SEND_RECV: 
 EE9D  8A F8				MOV	BH, AL				; save byte to send 
 EE9F  51				PUSH	CX 
 EEA0  52				PUSH	DX 					; call-preserve used registers 
				 
				;----------------------------------------------------------------------------; 
				; Wait for FDC I/O direction = CPU to FDC and Data Reg Ready 
				; 
 EEA1  BA 03F4				MOV	DX, FDC_STAT 			; port 3F4H - FDC Main Status Register 
 EEA4  B9 0005				MOV	CX, 5					; CX = # of ticks to wait 
 EEA7  8A 26 006C R			MOV	AH, BYTE PTR TIMER.LW		; get starting tick counter low byte 
				 
 EEAB				FDC_SEND_WAIT_POLL: 
 EEAB  EC				IN	AL, DX				; AL = FDC status register 
 EEAC  84 C0				TEST	AL, AL				; is DRR = I/O to/from CPU? 
 EEAE  79 19				JNS	FDC_SEND_WAIT_TIMER		; if not, check if timeout has elapsed 
				 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-134


				;----------------------------------------------------------------------------; 
				; FDC is ready for I/O 
				; 
 EEB0  42				INC	DX 					; port 3F5H - FDC Command Status Register 
 EEB1  84 DB				TEST	BL, BL				; is send or receive? 
 EEB3  74 09				JZ	FDC_RECV_WAIT_POLL		; jump if receive 
				 
				;----------------------------------------------------------------------------; 
				; SEND operation 
				;----------------------------------------------------------------------------; 
 EEB5				FDC_SEND_WAIT_POLL_1: 
 EEB5  A8 40				TEST	AL, MASK FIOD			; is I/O direction = CPU to FDC (0)? 
 EEB7  75 10				JNZ	FDC_SEND_WAIT_TIMER		; if not, check if timeout has elapsed 
				 
				;----------------------------------------------------------------------------; 
				; Status is ready to send 
				; 
 EEB9				FDC_SEND_READY: 
 EEB9  8A C7				MOV	AL, BH				; restore AL byte to send 
 EEBB  EE				OUT	DX, AL				; send command 
 EEBC  EB 05				JMP	SHORT FDC_WAIT_DONE		; status = success (0), CF = 0 and done 
				 
				;----------------------------------------------------------------------------; 
				; RECEIVE operation 
				;----------------------------------------------------------------------------; 
 EEBE				FDC_RECV_WAIT_POLL: 
 EEBE  A8 40				TEST	AL, MASK FIOD			; is I/O direction = FDC to CPU (1)? 
 EEC0  74 07				JZ	FDC_SEND_WAIT_TIMER		; if not, check if timeout has elapsed 
				 
				;----------------------------------------------------------------------------; 
				; Data is ready to read 
				; 
 EEC2				FDC_RECV_READY: 
 EEC2  EC				IN	AL, DX				; read from FDC 
				 
				;----------------------------------------------------------------------------; 
				; Completed with success 
				; 
 EEC3				FDC_WAIT_DONE: 
 EEC3  32 E4				XOR	AH, AH 				; status = success (0), CF = 0 
				 
 EEC5				FDC_WAIT_EXIT: 
 EEC5  5A				POP	DX 
 EEC6  59				POP	CX 
 EEC7  5B				POP	BX 
 EEC8  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; Check if timeout has expired 
				; 
 EEC9				FDC_SEND_WAIT_TIMER: 
 EEC9  A0 006C R			MOV	AL, BYTE PTR TIMER.LW		; get current tick counter 
 EECC  3A C4				CMP	AL, AH				; still the same? 
 EECE  74 DB				JZ	FDC_SEND_WAIT_POLL		; loop if the same 
 EED0  8A E0				MOV	AH, AL				; otherwise, save new tick value to AH 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-135


 EED2  E0 D7				LOOPNZ FDC_SEND_WAIT_POLL		; loop until # of ticks (CX) has elapsed 
				 
 EED4				FDC_WAIT_TIMEOUT: 
 EED4  B4 80				MOV	AH, FDC_ST_TIMEOUT 		; time out, drive not ready error 
 EED6  08 26 0041 R			OR	FD_LAST_OP, AH			; set flag in BDA 
 EEDA  F9				STC						; set error 
 EEDB  EB E8				JMP	SHORT	FDC_WAIT_EXIT 
				 
 EEDD				FDC_SEND ENDP 
 EEDD				FDC_SEND_PARAM ENDP 
 EEDD				FDC_RECV ENDP 
				 
				;----------------------------------------------------------------------------; 
				; FDC_WAIT_SENSE: wait for WIF, sense status and get status bytes 
				;----------------------------------------------------------------------------; 
				; Output: 
				;	CF if FDC read/timeout error 
				;	NZ if result status error 
				;	AL = FDC_LAST_ST (BDA Floppy drive status) 
				;	AH = 0 if success, 80H if failure 
				;----------------------------------------------------------------------------; 
 EEDD				FDC_WAIT_SENSE PROC 
 EEDD  E8 EF6A R			CALL	FDC_WAIT_INT 			; wait for WIF 
 EEE0  72 2F				JC	FDC_WAIT_SENSE_EXIT 
 EEE2  B0 08				MOV	AL, FDC_CMD_SENSE			; sense Interrupt status 
 EEE4  E8 EE9A R			CALL	FDC_SEND 
				 
				;----------------------------------------------------------------------------; 
				; FDC_RECV_STATUS: 
				;----------------------------------------------------------------------------; 
				; Output: 
				;	CF if FDC read/timeout error 
				;	NZ if result status error 
				; 
				;	AL = FDC_LAST_ST (BDA Floppy drive status), if success 
				;	AH = 0 if success, 80H if failure 
				;----------------------------------------------------------------------------; 
 EEE7				FDC_RECV_STATUS PROC 
 EEE7  72 28				JC	FDC_WAIT_SENSE_EXIT		; return if timeout error 
											; fall through to FDC_RECV_ALL 
				 
				;----------------------------------------------------------------------------; 
				; FDC_RECV_ALL: Pop all status bytes from FDC to BDA 
				;----------------------------------------------------------------------------; 
				; Check for FDC errors and set FD_LAST_OP if necessary 
				; Input: DS = BDA (40H), DI = FD_LAST_OP (41H) 
				; Output: AH = 0 if success, 80H if failure 
				;----------------------------------------------------------------------------; 
 EEE9				FDC_RECV_ALL PROC 
 EEE9  06				PUSH	ES 
 EEEA  51				PUSH	CX 
 EEEB  57				PUSH	DI					; preserve DI (FD_LAST_OP) 
 EEEC  52				PUSH	DX 
 EEED  BA 03F4				MOV	DX, FDC_STAT 
 EEF0  1E				PUSH	DS					; ES = BDA segment 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-136


 EEF1  07				POP	ES 
 EEF2  47				INC	DI					; DI = FDC_LAST_ST (FDC Last Result) 
 EEF3  B9 0007				MOV	CX, 7					; loop up to 7 FDC bytes 
 EEF6				FDC_RECV_ALL_LOOP: 
 EEF6  E8 EE92 R			CALL	FDC_RECV				; AL = next byte, AH = 0 if success 
 EEF9  72 12				JC	FDC_RECV_ALL_DONE			; CF if failure 
 EEFB  AA				STOSB						; write to BDA 
				 
				;----------------------------------------------------------------------------; 
				; Additional delay for FDC to settle 
				; 
						IF IS_TURBO AND UNSAFE_FLOPPY NE 1 
 EEFC  B0 14				MOV	AL, 20				; delay 372 clocks (~31us at 12MHz, 
						ENDIF 
 EEFE				FDC_RECV_DELAY:					; [7+19(AX-1)] clocks 
 EEFE  48				DEC	AX					; [3] 
 EEFF  75 FD				JNZ	FDC_RECV_DELAY			; [4+16(AX-1)] 
				 
				;----------------------------------------------------------------------------; 
				; Check for additional bytes to be read from FDC registers 
				; 
 EF01  EC				IN	AL, DX				; DX = 03F4H 
 EF02  24 10				AND	AL, MASK FDRW 			; is FDC R/W command in progress flag? 
 EF04  E0 F0				LOOPNZ FDC_RECV_ALL_LOOP		; loop until no flag or 7 bytes read 
 EF06  75 0A				JNZ	FDC_RECV_FDC_ERR			; command still in progress? 
											; AL = 0 (no command in progress) or CX = 0 
						ENDIF 
 EF08				FDC_RECV_CHECK_ERR: 
 EF08  A0 0042 R			MOV	AL, FDC_LAST_ST.SB0 		; AL = last FDC status byte 0 
 EF0B  A8 C0				TEST	AL, MASK ST0CS			; check Last Command Status 
 EF0D				FDC_RECV_ALL_DONE: 
 EF0D  5A				POP	DX 
 EF0E  5F				POP	DI					; DI = FD_LAST_OP 
 EF0F  59				POP	CX 
 EF10  07				POP	ES 
 EF11				FDC_WAIT_SENSE_EXIT: 
 EF11  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; Command still in progress after reading 7 bytes. Return FDC error. 
				; 
 EF12				FDC_RECV_FDC_ERR: 
 EF12  B4 20				MOV	AH, FDC_ST_ERR_FDC		; controller still busy after 
 EF14  08 26 0041 R			OR	FD_LAST_OP, AH			;  reading max bytes 
 EF18  F9				STC 
 EF19  EB F2				JMP	SHORT FDC_RECV_ALL_DONE 
 EF1B				FDC_RECV_ALL ENDP 
 EF1B				FDC_RECV_STATUS ENDP 
 EF1B				FDC_WAIT_SENSE ENDP 
				 
				;----------------------------------------------------------------------------; 
				; FDC_WAIT_STATUS: Wait for WIF, get status bytes and check for error 
				;----------------------------------------------------------------------------; 
 EF1B				FDC_WAIT_STATUS PROC 
 EF1B  E8 EF6A R			CALL	FDC_WAIT_INT 			; wait for WIF 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-137


 EF1E  E8 EEE7 R			CALL	FDC_RECV_STATUS			; read FDC status into BDA 
											; CF if FDC error, NZ if status error 
 EF21  76 1C				JBE	FDC_WAIT_ERR_EXIT_OK		; exit if ZF or CF error 
				 
				;----------------------------------------------------------------------------; 
				; FDC_WAIT_STATUS_ERR: Map FDC Command Status Register 1 to BDA error codes 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AL = Last result from FDC_LAST_ST 
				; Output: 
				;	CF if error 
				;	AH/AL = BDA Floppy drive status 
				;----------------------------------------------------------------------------; 
 EF23				FDC_WAIT_STATUS_ERR PROC 
 EF23  A8 40				TEST	AL, FDC_ST0 < 01B >		; command terminated abnormally? 
 EF25  B0 20				MOV	AL, FDC_ST_ERR_FDC		; if not, FDC error 
 EF27  74 11				JZ	FDC_WAIT_STATUS_ERR_DONE 
 EF29  98				CBW						; AH = 0 
 EF2A  0A 65 02				OR	AH, _FDC_LAST_ST.SB1		; AH = last status byte 1, ZF if 0 
 EF2D  74 0B				JZ	FDC_WAIT_STATUS_ERR_DONE	; skip if AH = 0 
 EF2F  56				PUSH	SI 
 EF30  BE EF40 R			MOV	SI, OFFSET FDC_ERR1_MAP 
 EF33				FDC_ERR_MAP_LOOP: 
 EF33  2E: AC				LODS	BYTE PTR CS:[SI]			; fetch next error byte 
 EF35  D0 E4				SHL	AH, 1					; CF if this status flag 
 EF37  77 FA				JA	FDC_ERR_MAP_LOOP			; loop if NC (not this flag) 
 EF39  5E				POP	SI					;  and NZ (more flags to check) 
 EF3A				FDC_WAIT_STATUS_ERR_DONE: 
 EF3A  8A E0				MOV	AH, AL				; AH = last result 
 EF3C				FDC_WAIT_ERR_EXIT: 
 EF3C  08 25				OR	_FD_LAST_OP, AH			; BDA 40:41H 
 EF3E  F9				STC 
 EF3F				FDC_WAIT_ERR_EXIT_OK: 
 EF3F  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; FDC Status register to INT 13h error map 
				; Note: Must check from most sig bit to lowest since higher 
				; bits are more meaningful. 
				; 
 EF40				FDC_ERR1_MAP LABEL BYTE 
 EF40  04				DB	FDC_ST_ERR_SEC			; 80 end of cylinder 
 EF41  20				DB	FDC_ST_ERR_FDC			; 40 unused (always zero) 
 EF42  10				DB	FDC_ST_ERR_CRC			; 20 data error CRC 
 EF43  08				DB	FDC_ST_DMA_OVR			; 10 DMA timeout/overrun 
 EF44  20				DB	FDC_ST_ERR_FDC			; 08 unused (always zero) 
 EF45  04				DB	FDC_ST_ERR_SEC			; 04 Sector Not Found 
 EF46  03				DB	FDC_ST_ERR_WP			; 02 Write Protect 
 EF47  02				DB	FDC_ST_ERR_MARK			; 01 Address mark not found or bad sector 
				 
 EF48				FDC_WAIT_STATUS_ERR ENDP 
 EF48				FDC_WAIT_STATUS ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Retrieve a parameter value from the DBT by index 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-138


				;----------------------------------------------------------------------------; 
				; Input: 
				;	AL = parameter index (bounds not checked) 
				; Output: 
				;	AL = byte 
				; 
				; Size: 14 bytes 
				;----------------------------------------------------------------------------; 
 EF48				INT_1E_PARAM PROC 
 EF48  1E				PUSH	DS 
 EF49  53				PUSH	BX 
 EF4A  33 DB				XOR	BX, BX 				; BX = IVT 
 EF4C  8E DB				MOV	DS, BX 				; DS = IVT 
							ASSUME DS:_IVT 
 EF4E  C5 1E 0078 R			LDS	BX, IVT_1E				; DS:BX = INT 1EH in IVT 
 EF52  D7				XLAT 						; AL = byte 
 EF53  5B				POP	BX 
 EF54  1F				POP	DS 
							ASSUME DS:NOTHING 
 EF55  C3				RET 
 EF56				INT_1E_PARAM ENDP 
				 
				; 
				; 2 BYTES HERE 
				; 
				BYTES_HERE	INT_0E 
 = 0001                      1	BYTES_HERE_INT_0E = INT_0E-$ 
			     1			IFDEF BYTES_HERE_INT_0E 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 0EH - Floppy Disk Interrupt IRQ6 
				;----------------------------------------------------------------------------; 
				; This interrupt is issued upon floppy disk I/O completion and sets the 
				; floppy disk working interrupt flag at 40:3E, bit 7. 
				;----------------------------------------------------------------------------; 
 EF57						ORG 0EF57H 
 EF57				INT_0E PROC 
 EF57  FB				STI						; necessary? 
 EF58  50				PUSH	AX 
 EF59  1E				PUSH	DS 
 EF5A  33 C0				XOR	AX, AX				; DS = BDA_ABS segment 
 EF5C  8E D8				MOV	DS, AX 
							ASSUME DS:_BDA_ABS 
 EF5E  80 0E 043E R 80			OR	FD_CAL_ST_ABS, MASK FWIF	; turn on working interrupt flag 
 EF63  B0 20				MOV	AL, EOI 				; End of Interrupt OCW 
 EF65  E6 20				OUT	INT_P0, AL				; write EOI to port 0 
 EF67  1F				POP	DS 
							ASSUME DS:NOTHING 
 EF68  58				POP	AX 
 EF69  CF				IRET 
 EF6A				INT_0E ENDP 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-139


				 
				;----------------------------------------------------------------------------; 
				; FDC_WAIT_INT: Wait for BDA Working Interrupt Flag from FDC 
				;----------------------------------------------------------------------------; 
				; Input: DS = BDA, DI = FD_LAST_OP 
				; Output: CF if timeout 
				;----------------------------------------------------------------------------; 
 EF6A				FDC_WAIT_INT PROC 
							ASSUME DS:_BDA 
 EF6A  FB				STI						; ensure interrupts are on 
 EF6B  50				PUSH	AX 					; call preserve regs 
 EF6C  51				PUSH	CX 
 EF6D  B9 0025				MOV	CX, 2 * (1000/55) + 1		; timeout ~2 sec (37 ticks) 
 EF70				FDC_WAIT_INT_LOOP1: 
 EF70  A1 006C R			MOV	AX, TIMER.LW			; AX = time ticks 
 EF73				FDC_WAIT_INT_LOOP2: 
 EF73  F6 45 FD 80			TEST	_FD_CAL_ST, MASK FWIF 		; check for WIF in FD_CAL_ST (3EH) 
 EF77  75 0F				JNZ	FDC_WAIT_INT_OK			; if so, exit 
							IF FDC_HLT_WAIT GT 0 
 EF79  F4				HLT						; wait for any INT 
							ENDIF 
 EF7A  3B 06 006C R			CMP	AX, TIMER.LW			; has timer tick changed? 
 EF7E  74 F3				JZ	FDC_WAIT_INT_LOOP2		; if not, wait for next INT 
 EF80  E2 EE				LOOP	FDC_WAIT_INT_LOOP1		; decrement tick counter and resume loop 
 EF82  80 0D 80				OR	_FD_LAST_OP, FDC_ST_TIMEOUT 	; FDC result set time out, drive not ready 
 EF85  F9				STC 
 EF86  EB 04				JMP	SHORT FDC_WAIT_INT_DONE 
 EF88				FDC_WAIT_INT_OK: 
 EF88  80 65 FD 7F			AND	_FD_CAL_ST, NOT MASK FWIF 	; clear working interrupt flag 
 EF8C				FDC_WAIT_INT_DONE: 
 EF8C  59				POP	CX 
 EF8D  58				POP	AX 
 EF8E  C3				RET 
 EF8F				FDC_WAIT_INT ENDP 
				 
 EF8F				INT_13 ENDP 
				 
							IF POST_TEST_SEEK EQ 1 
				;----------------------------------------------------------------------------; 
				; FDC_RECAL_SEEK_TEST: Reset, Recalibrate and Seek test a floppy drive at POST 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	DL = drive # to test (0 = A:, 1 = B:, etc) (bounds not checked) 
				;	DI = OFFSET FD_LAST_OP 
				; Output: 
				;	CF if error 
				; Clobbers: DI, SI, AX, BX (if FDC_ADV_SEEK) 
				; 
				; Size: 36 bytes 
				;----------------------------------------------------------------------------; 
 EF8F				FDC_RECAL_SEEK_TEST PROC 
 EF8F  51				PUSH	CX 
 EF90  E8 EE34 R			CALL	FDC_RECAL				; Motor on, recal, DL = drive 
 EF93  72 18				JC	FDC_TEST_DRIVE_EXIT		; exit if error 
					JWB	FDC_TEST_DRIVE_DONE		; skip seek tests on warm boot 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-140


			     1				IF WARM_ENABLE EQ 1 
 EF95  85 ED                 1		TEST	BP, BP				; is warm boot? 
 EF97  78 10                 1		JS	FDC_TEST_DRIVE_DONE					; jump if so 
			     1				ENDIF 
					IO_DELAY					; short pause before seek, CX=0 
 EF99                        1	??0029: 
 EF99  E2 FE                 1		LOOP	??0029					; long delay for I/O 
 EF9B  BE EFAF R			MOV	SI, OFFSET FDC_SEEK_TRACKS 
 EF9E				FDC_TEST_DRIVE_SEEK: 
 EF9E  2E: AC				LODS	BYTE PTR CS:[SI]			; next track to seek 
 EFA0  8A E8				MOV	CH, AL				; CH = track 
 EFA2  E8 EDE8 R			CALL	FDC_SEEK				; CH = track, DL = drive 
 EFA5  E3 02				JCXZ	FDC_TEST_DRIVE_DONE		; exit if track = 0 
 EFA7  73 F5				JNC	FDC_TEST_DRIVE_SEEK		; loop unless error 
 EFA9				FDC_TEST_DRIVE_DONE: 
							IF IS_TURBO 
 EFA9  B5 80				MOV	CH, 80H				; longer delay for faster PCs 
							ENDIF 
					IO_DELAY					; delay between drives 
 EFAB                        1	??002A: 
 EFAB  E2 FE                 1		LOOP	??002A					; long delay for I/O 
 EFAD				FDC_TEST_DRIVE_EXIT: 
 EFAD  59				POP	CX 
 EFAE  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; Track pattern for POST seek test 
				; 
 EFAF  26 02 13 00		FDC_SEEK_TRACKS	DB	38, 2, 19, 0	; tracks (0 is end) 
				 
 EFB3				FDC_RECAL_SEEK_TEST ENDP 
							ENDIF 
				 
				; 
				; 20 BYTES HERE 
				; 
				BYTES_HERE	INT_1E 
 = 0014                      1	BYTES_HERE_INT_1E = INT_1E-$ 
			     1			IFDEF BYTES_HERE_INT_1E 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 1E - Disk Initialization Parameter Table Vector 
				;----------------------------------------------------------------------------; 
				; Provides a "pluggable" method to allow additional disk ROMs or DOS to  
				; replace this table. 
				; 
				;  00  Head Step Rate (SRT) = 0CH = 12ms 
				;      Head Unload Time (HUT) = 15 x (16ms increments) = 240ms(?) 
				;  01  Head Load Time = 2 (2ms increments) = 1, DMA flag (0 = use DMA) 
				;  02  timer ticks to wait before disk motor shutoff = 37 
				;  03  512 bytes per sector (0=128, 1=256, 2=512, 3=1024) = 2 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-141


				;  04  sectors per track (last sector number) = 8 
				;  05  inter-block gap length/gap between sectors (mills) 42 
				;  06  data length, if sector length not specified = 0FFH 
				;  07  gap length between sectors for format (mills) 80 
				;  08  fill byte for formatted sectors = 0F6H 
				;  09  head settle time in milliseconds = 25 
				;  0A  motor startup time in eighths of a second = 4 
				;  MFM = 2 
				; 
				; https://stanislavs.org/helppc/dbt.html 
				; https://stanislavs.org/helppc/765.html 
				; https://stanislavs.org/helppc/int_1e.html 
				;----------------------------------------------------------------------------; 
 EFC7						ORG 	0EFC7H 
 EFC7  CF			INT_1E	DBT 	<DNB <12, 15>, 0010B, 37, 2, 8, 42, 0FFH, 80, 0F6H, 25, 4> 
 EFC8  02			
 EFC9  25			
 EFCA  02			
 EFCB  08			
 EFCC  2A			
 EFCD  FF			
 EFCE  50			
 EFCF  F6			
 EFD0  19			
 EFD1  04			
				
				 
				;----------------------------------------------------------------------------; 
				; INT 17 - Printer BIOS Services 
				;----------------------------------------------------------------------------; 
				;	INT 17,0   Print character 
				;	INT 17,1   Initialize printer port 
				;	INT 17,2   Read printer port status 
				; 
				; https://www.stanislavs.org/helppc/ports.html 
				; https://en.wikipedia.org/wiki/Parallel_port#IBM_PC_implementation 
				; http://www.techhelpmanual.com/907-parallel_printer_adapter_ports.html 
				;----------------------------------------------------------------------------; 
				; Things you must do (on all calls): 
				; - Verify printer is within range 0-2. 
				; - Verify printer index is detected and get I/O address. 
				; - Return AH = 0 if any of the above are not met. 
				; - Do the function call 
				; - Get port status and return in AH for any valid calls. 
				;----------------------------------------------------------------------------; 
 EFD2						ORG 0EFD2H 
 EFD2				INT_17 PROC 
						ASSUME DS:_BDA 
 EFD2  FB				STI 						; enable interrupts 
 EFD3  83 FA 03				CMP	DX, LENGTH LPT_ADDR		; is port number valid? 
 EFD6  73 4A				JAE	INT_17_IRET 			; if not, exit 
					PUSHX	DX, DI, CX, AX, DS		; call-preserve working regs 
			     1				IFNB <DX>			; exit if last reg 
 EFD8  52                    1		PUSH	DX 					; push register and repeat 
			     1		PUSHX	DI, CX, AX, DS, , ,  
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-142


			     2				IFNB <DI>			; exit if last reg 
 EFD9  57                    2		PUSH	DI 					; push register and repeat 
			     2		PUSHX	CX, AX, DS, , , ,  
			     3				IFNB <CX>			; exit if last reg 
 EFDA  51                    3		PUSH	CX 					; push register and repeat 
			     3		PUSHX	AX, DS, , , , ,  
			     4				IFNB <AX>			; exit if last reg 
 EFDB  50                    4		PUSH	AX 					; push register and repeat 
			     4		PUSHX	DS, , , , , ,  
			     5				IFNB <DS>			; exit if last reg 
 EFDC  1E                    5		PUSH	DS 					; push register and repeat 
			     5		PUSHX	, , , , , ,  
			     6				ENDIF 
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 EFDD  B9 ---- R			MOV	CX, SEG _BDA 			; CH = 0, CL = 40H 
 EFE0  8E D9				MOV	DS, CX				; DS = BDA 
 EFE2  8B FA				MOV	DI, DX 				; DI = LPT port index (0-2) 
 EFE4  8A 4D 78				MOV	CL, LPT_TIME_B[DI]		; CX = port timeout 
 EFE7  D1 E7				SHL	DI, 1 				; convert to word-aligned index 
 EFE9  8B 55 08				MOV	DX, LPT_ADDR_B[DI]		; DX = data port address 
 EFEC  1F				POP	DS 					; restore DS 
 EFED  85 D2				TEST	DX, DX 				; is port index valid (detected)? 
 EFEF  74 2B				JZ	INT_17_DONE 			; if not, exit 
 EFF1  FE CC				DEC	AH 
 EFF3  74 2E				JZ	INT_17_1				; AH = 1 then init 
 EFF5  7F 1D				JG	INT_17_2	 			; AH = 2 then status 
											; AH = 0 fall through to print 
				 
				;----------------------------------------------------------------------------; 
				; AH = 0 - Print Character 
				;----------------------------------------------------------------------------; 
				; Write character and returns status 
				; 
				; Input: 
				;	AH = -1 (not 0) 
				;	AL = character to print 
				;	CX = timeout "value" (the number of 64k loops) 
				;	DX = LPT data port (278, 378, 3BC) 
				; 
				; Output: 
				;	AH = printer status, see AH = 2 
				; 
				;----------------------------------------------------------------------------; 
				; 765	    |			- LCX		unused 
				;    4    |			- LCIRQ	0 = IRQ disable, 1=IRQ enable for ACK 
				;     3   |			- LCDR	1 = printer reads output,  (pin 17) 
				;      2  |			- LCINI	0 = initialize printer,  (pin 16) 
				;       1 |			- LCLF	1 = auto line feed,  (pin 14) 
				;        0|			- LCOUT	1 = output data to printer,  (pin 1) 
				; PRN_CTRL RECORD	LCX:3,LCIRQ:1,LCDR:1,LCINI:1,LCLF:1,LCOUT:1 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-143


 EFF7				INT_17_0: 
 EFF7  EE				OUT	DX, AL			; write the character to data port 
 EFF8  42				INC	DX				; DX to status port 
 EFF9				INT_17_0_TIMEOUT_LOOP: 
 EFF9  33 FF				XOR	DI, DI			; set abitrary timeout counter 
 EFFB				INT_17_0_BUSY_LOOP: 
 EFFB  EC				IN	AL, DX			; read status port 
 EFFC  A8 80				TEST	AL, MASK LPBZ 		; printer busy? 
 EFFE  75 09				JNZ	INT_17_0_OK			; if not, toggle strobe pin and exit 
 F000  4F				DEC	DI 
 F001  75 F8				JNZ	INT_17_0_BUSY_LOOP 
 F003  E2 F4				LOOP	INT_17_0_TIMEOUT_LOOP 	; loop BDA/LPT timeout value 
 F005  0C 01				OR	AL, MASK LPTO		; printer timed out - set flag 
 F007  EB 0F				JMP	SHORT INT_17_2_STATUS_2	; exit with status in AL 
 F009				INT_17_0_OK: 
 F009  B0 0D				MOV	AL, MASK LCDR OR MASK LCINI OR MASK LCOUT ; /strobe pin HIGH 
 F00B  42				INC	DX 				; DX = control port 
 F00C  52				PUSH	DX				; I/O delay 
 F00D  EE				OUT	DX, AL 
 F00E  5A				POP	DX				; I/O delay 
 F00F  B0 0C				MOV	AL, MASK LCDR OR MASK LCINI	; /strobe pin LOW 
 F011  EE				OUT	DX, AL 
 F012  4A				DEC	DX 				; reset to data port 
 F013  4A				DEC	DX				; and fall through to status 
				 
				;----------------------------------------------------------------------------; 
				; AH = 2 - Read printer port status 
				;----------------------------------------------------------------------------; 
				; Return status of specified printer port 
				; 
				; Input: 
				;	AH = 1 (not 2) 
				;	DX = LPT data port (278, 378, 3BC) 
				; 
				; Output: 
				;	AH = status: 
				; 
				;		|7|6|5|4|3|2|1|0|  Printer status bits 
				;		 | | | | | | | `---- time out		(always 0) 
				;		 | | | | | `------- unused 
				;		 | | | | `-------- I/O error		Pin 15 
				;		 | | | `--------- selected		Pin 13 
				;		 | | `---------- out of paper		Pin 12 
				;		 | `----------- acknowledge		Pin 10 
				;		 `------------ not busy			/Pin 11 
				; 
				; PRN_STAT RECORD	LPBZ:1,LPACK:1,LPOP:1,LPSEL:1,LPIO:1,LPX:2,LPTO:1 
				;----------------------------------------------------------------------------; 
 F014				INT_17_2: 
 F014  42				INC	DX 				; DX to status port 
 F015				INT_17_2_STATUS: 
 F015  EC				IN	AL, DX			; AL = status 
 F016  24 F8				AND	AL, NOT (MASK LPX OR MASK LPTO)	; mask time-out pins 
 F018				INT_17_2_STATUS_2: 
 F018  34 48				XOR	AL, MASK LPACK OR MASK LPIO ; acknowledge and error are active low 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-144


 F01A  8A E8				MOV	CH, AL			; save status to CH so AL can be restored 
 F01C				INT_17_DONE: 
 F01C  58				POP	AX				; restore AL 
 F01D  8A E5				MOV	AH, CH			; AH = status 
 F01F  59				POP	CX 
 F020  5F				POP	DI 
 F021  5A				POP	DX 
 F022				INT_17_IRET: 
 F022  CF				IRET 
				 
				;----------------------------------------------------------------------------; 
				; AH = 1 - Initialize printer port 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AH = 0 (not 1) 
				;	DX = LPT data port (278, 378, 3BC) 
				; 
				; Output: 
				;	AH = status, see AH = 2 
				;----------------------------------------------------------------------------; 
 F023				INT_17_1: 
 F023  B0 08				MOV	AL, MASK LCDR		; printer reads output = 1 
 F025  42				INC	DX 
 F026  42				INC	DX				; DX = control port 
 F027  EE				OUT	DX, AL			; send to control port 
 F028  B5 08				MOV	CH, HIGH 800H		; delay 800H-ish loops 
					IO_DELAY 				; wait, then CX = 0 
 F02A                        1	??002C: 
 F02A  E2 FE                 1		LOOP	??002C					; long delay for I/O 
 F02C  0C 04				OR	AL, MASK LCINI		; initialize printer = 1 
 F02E  EE				OUT	DX, AL			; send to control port 
 F02F  4A				DEC	DX				; DX = status port 
 F030  EB E3				JMP	SHORT INT_17_2_STATUS	; small delay, read status and return 
 F032				INT_17 ENDP 
				 
 F032				CRLF_SHOW_CURSOR PROC 
				;----------------------------------------------------------------------------; 
				; CRLF then show cursor display (this exists to utilize the free bytes here) 
				;----------------------------------------------------------------------------; 
 F032  E8 F7C8 R			CALL	CRLF 
				 
				;----------------------------------------------------------------------------; 
				; Show cursor display - restores saved cursor in CURSOR_DEFAULT 
				;----------------------------------------------------------------------------; 
				; Input: 
				; 	DS = BDA 
				; Clobbers CX 
				;----------------------------------------------------------------------------; 
 F035				SHOW_CURSOR PROC 
							ASSUME DS:_BDA 
 F035  8B 0E 00E8 R			MOV	CX, CURSOR_DEFAULT	; reset to original 
 F039  EB 03				JMP	SHORT SET_CURSOR 
				 
				;----------------------------------------------------------------------------; 
				; Hide cursor display 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-145


				;----------------------------------------------------------------------------; 
				; Clobbers CX 
				;----------------------------------------------------------------------------; 
 F03B				HIDE_CURSOR PROC 
 F03B  B9 2000				MOV	CX, DBW < 00100000b >	; hide cursor (CH bit 5 = 1) 
				 
				;----------------------------------------------------------------------------; 
				; Set Video Cursor type 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	CX = cursor type 
				;----------------------------------------------------------------------------; 
 F03E				SET_CURSOR PROC 
 F03E  50				PUSH	AX				; (not necessary) 
 F03F  B4 01				MOV	AH, 1 
 F041  CD 10				INT	10H 
 F043  58				POP	AX 
 F044  C3				RET 
 F045				SET_CURSOR ENDP 
				 
 F045				HIDE_CURSOR ENDP 
 F045				SHOW_CURSOR ENDP 
 F045				CRLF_SHOW_CURSOR ENDP 
				 
				; 
				; 0 BYTES HERE 
				; 
				BYTES_HERE	INT_10_JMP 
 = 0000                      1	BYTES_HERE_INT_10_JMP = INT_10_JMP-$ 
			     1			IFDEF BYTES_HERE_INT_10_JMP 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 10h - Function Jump Table 
				;----------------------------------------------------------------------------; 
 F045						ORG 0F045H 
 F045				INT_10_JMP LABEL WORD 
 F045  F0E4 R				DW	OFFSET INT_10_0		; AH = 0 - Set video mode 
 F047  F1A0 R				DW	OFFSET INT_10_1		; AH = 1 - Set cursor type 
 F049  F1B6 R				DW	OFFSET INT_10_2		; AH = 2 - Set cursor position 
 F04B  F1FC R				DW	OFFSET INT_10_3		; AH = 3 - Read cursor position 
							IF LIGHT_PEN EQ 1 
 F04D  F99F R				DW	OFFSET INT_10_4		; AH = 4 - Read light pen 
							ENDIF 
 F04F  F20D R				DW	OFFSET INT_10_5		; AH = 5 - Select active display page 
 F051  F235 R				DW	OFFSET INT_10_6		; AH = 6 - Scroll active page up 
 F053  F234 R				DW	OFFSET INT_10_7		; AH = 7 - Scroll active page down 
 F055  F365 R				DW	OFFSET INT_10_8		; AH = 8 - Read character and attribute at cursor 
 F057  F41E R				DW	OFFSET INT_10_9		; AH = 9 - Write character and attribute at cursor 
 F059  F41E R				DW	OFFSET INT_10_A		; AH = A - Write character at current cursor 
 F05B  F546 R				DW	OFFSET INT_10_B		; AH = B - Set color palette 
 F05D  F571 R				DW	OFFSET INT_10_C		; AH = C - Write graphics pixel at coordinate 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-146


 F05F  F592 R				DW	OFFSET INT_10_D		; AH = D - Read graphics pixel at coordinate 
 F061  F5E2 R				DW	OFFSET INT_10_E		; AH = E - Write text in teletype mode 
 F063  F64C R				DW	OFFSET INT_10_F		; AH = F - Get current video state 
 = 0010				L_INT_10_JMP	EQU	($-INT_10_JMP)/2 
				 
				;----------------------------------------------------------------------------; 
				; INT 10h - Video BIOS Services 
				;----------------------------------------------------------------------------; 
				; BIOS Interface to CGA/MDA display adapters. 
				;----------------------------------------------------------------------------; 
				; References and Info Sources: 
				;  "PC System Programming", Tischer 
				;  "Programmer's Guide to PC Video Systems", Second Edition, Wilton 
				;  https://github.com/joncampbell123/dosbox-x/blob/master/src/ints/int10_char.cpp 
				;  https://github.com/joncampbell123/dosbox-x/issues/256 
				;  https://www.seasip.info/VintagePC/cga.html 
				;  https://www.reenigne.org/blog/crtc-emulation-for-mess/ 
				;  (many other posts and articles...) 
				; 
				; Thx to @Raffzahn for "clean room" specs for various display routines. 
				;----------------------------------------------------------------------------; 
 F065						ORG 0F065H 
 F065				INT_10 PROC 
 F065  FB				STI					; enable interrupts 
 F066  80 FC 0F				CMP	AH, L_INT_10_JMP-1	; function valid? 
 F069  77 19				JA	INT_10_IRET			; exit if function not valid 
					PUSHX	ES, DS, DI			; always preserve these registers 
			     1				IFNB <ES>			; exit if last reg 
 F06B  06                    1		PUSH	ES 					; push register and repeat 
			     1		PUSHX	DS, DI, , , , ,  
			     2				IFNB <DS>			; exit if last reg 
 F06C  1E                    2		PUSH	DS 					; push register and repeat 
			     2		PUSHX	DI, , , , , ,  
			     3				IFNB <DI>			; exit if last reg 
 F06D  57                    3		PUSH	DI 					; push register and repeat 
			     3		PUSHX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F06E  FC				CLD					; string instructions forward direction 
 F06F  BF ---- R			MOV	DI, SEG _BDA		; DS = BDA segment 
 F072  8E DF				MOV	DS, DI 
 F074  8B F8				MOV	DI, AX			; save AX 
 F076  86 E0				XCHG	AH, AL			; AL = function, AH = video mode 
 F078  D0 E0				SHL	AL, 1				; word align index 
 F07A  98				CBW					; AX = jump index 
 F07B  97				XCHG	AX, DI			; restore AX, DI = jump offset 
 F07C  2E: FF 95 F045 R			CALL	CS:INT_10_JMP[DI] 
 F081				INT_10_DONE: 
					POPX	DI, DS, ES 
			     1				IFNB <DI>			; exit if last reg 
 F081  5F                    1		POP	DI 					; pop register and repeat 
			     1		POPX	DS, ES, , , , ,  
			     2				IFNB <DS>			; exit if last reg 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-147


 F082  1F                    2		POP	DS 					; pop register and repeat 
			     2		POPX	ES, , , , , ,  
			     3				IFNB <ES>			; exit if last reg 
 F083  07                    3		POP	ES 					; pop register and repeat 
			     3		POPX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F084				INT_10_IRET: 
 F084  CF				IRET 
				 
				;----------------------------------------------------------------------------; 
				; Is Current video mode text or GFX? 
				;----------------------------------------------------------------------------; 
				; Input: 
				; 	DS = BDA (040h) 
				; Output: 
				;	AL = current video mode 
				; 	ZF = 0 if CGA GFX (modes 4-6) 
				;	ZF = 1 if CGA/MDA Text (modes 0-3 and 7) 
				;	CF = 1 if MDA 
				;----------------------------------------------------------------------------; 
 F085				INT_10_IS_TXT PROC 
 F085  A0 0049 R			MOV	AL, VID_MODE 
 F088  3C 07				CMP	AL, 7				; ZF if mode MDA 
 F08A  F5				CMC					; CF if MDA 
 F08B  74 02				JZ	INT_10_IS_TXT_DONE 
 F08D  A8 04				TEST	AL, 4 AND 5 AND 6		; NZ if GFX modes 4,5,6? 
 F08F				INT_10_IS_TXT_DONE: 
 F08F  C3				RET 
 F090				INT_10_IS_TXT ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Is Current video CGA 80 col? 
				;----------------------------------------------------------------------------; 
				; Output: 
				;	ZF = 1 if mode is 2 or 3 
				;	ZF = 0 all others 
				;----------------------------------------------------------------------------; 
 F090				INT_10_IS_CGA80 PROC 
 F090  50				PUSH	AX 
 F091  1E				PUSH	DS 
 F092  B8 ---- R			MOV	AX, SEG _BDA 
 F095  8E D8				MOV	DS, AX 
 F097  A0 0049 R			MOV	AL, VID_MODE 
 F09A  3C 02				CMP	AL, 2				; is mode 2? 
 F09C  74 02				JZ	INT_10_IS_CGA80_DONE 
 F09E  3C 03				CMP	AL, 3				; is mode 3? 
 F0A0				INT_10_IS_CGA80_DONE: 
 F0A0  1F				POP	DS 
 F0A1  58				POP	AX 
 F0A2  C3				RET 
 F0A3				INT_10_IS_CGA80 ENDP 
				 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-148


				; 
				; 1 BYTE HERE 
				; 
				BYTES_HERE	INT_1D 
 = 0001                      1	BYTES_HERE_INT_1D = INT_1D-$ 
			     1			IFDEF BYTES_HERE_INT_1D 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 1D - Video mode register value table  
				;----------------------------------------------------------------------------; 
				; https://stanislavs.org/helppc/6845.html 
				;----------------------------------------------------------------------------; 
 F0A4						ORG 0F0A4H					; 116 bytes 
 F0A4				INT_1D PROC 
				 
				; 40x25 CGA text 
 F0A4  38			INT_1D_40		CRTC	<38H,28H,2DH,0AH,1FH,06H,19H,1CH,02H,07H,06H,07H> 
 F0A5  28			
 F0A6  2D			
 F0A7  0A			
 F0A8  1F			
 F0A9  06			
 F0AA  19			
 F0AB  1C			
 F0AC  02			
 F0AD  07			
 F0AE  06			
 F0AF  07			
 F0B0  00			
 F0B1  00			
 F0B2  00			
 F0B3  00			
				
 = 0000				O_INT_1D_40		EQU	INT_1D_40-INT_1D		; 40x25 mode data offset 
				 
				; 80x25 CGA text 
						ELSE 
 F0B4  71			INT_1D_80		CRTC	<71H,50H,5AH,0AH,1FH,06H,19H,1CH,02H,07H,06H,07H> 
 F0B5  50			
 F0B6  5A			
 F0B7  0A			
 F0B8  1F			
 F0B9  06			
 F0BA  19			
 F0BB  1C			
 F0BC  02			
 F0BD  07			
 F0BE  06			
 F0BF  07			
 F0C0  00			
 F0C1  00			
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-149


 F0C2  00			
 F0C3  00			
				
						ENDIF 
 = 0010				O_INT_1D_80		EQU	INT_1D_80-INT_1D		; 80x25 mode data offset 
				 
				; 320x200 CGA graphics 
 F0C4  38			INT_1D_GFX		CRTC	<38H,28H,2DH,0AH,7FH,06H,64H,70H,02H,01H,06H,07H> 
 F0C5  28			
 F0C6  2D			
 F0C7  0A			
 F0C8  7F			
 F0C9  06			
 F0CA  64			
 F0CB  70			
 F0CC  02			
 F0CD  01			
 F0CE  06			
 F0CF  07			
 F0D0  00			
 F0D1  00			
 F0D2  00			
 F0D3  00			
				
 = 0020				O_INT_1D_GFX	EQU	INT_1D_GFX-INT_1D		; 320x200 mode data offset 
				 
				; MDA text 
 F0D4  61			INT_1D_MDA		CRTC	<61H,50H,52H,0FH,19H,06H,19H,19H,02H,0DH,0BH,0CH> 
 F0D5  50			
 F0D6  52			
 F0D7  0F			
 F0D8  19			
 F0D9  06			
 F0DA  19			
 F0DB  19			
 F0DC  02			
 F0DD  0D			
 F0DE  0B			
 F0DF  0C			
 F0E0  00			
 F0E1  00			
 F0E2  00			
 F0E3  00			
				
 = 0030				O_INT_1D_MDA	EQU	INT_1D_MDA-INT_1D		; MDA mode data offset 
				 
 F0E4				INT_1D ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,0 - Set video mode 
				;----------------------------------------------------------------------------; 
				; AL = video mode: 
				;   0000  00  M 40x25 B/W text (CGA) 
				;   0001  01  C 40x25 16 color text (CGA) 
				;   0010  02  M 80x25 16 shades of gray text (CGA) 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-150


				;   0011  03  C 80x25 16 color text (CGA) 
				;   0100  04  C 320x200 4 color graphics (CGA) 
				;   0101  05  C 320x200 4 color graphics (CGA) 
				;   0110  06  M 640x200 B/W graphics (CGA) 
				;   0111  07  M 80x25 Monochrome text (MDA,HERC) 
				; 
				; Clobbers: ES 
				;----------------------------------------------------------------------------; 
				; Things you must do: 
				; 	1. Check that the new video mode is valid: 0-7. For MDA, the mode 
				;		will always be 7. If CGA mode > 6, reset in current mode. 
				;	2. Clear the video BDA block data 
				;	3. Determine the type of adapter from motherboard switches 
				;	4. Disable the adapter to reprogram it. 
				;	5. Based on new input mode and MB switches, determine: 
				;		- Adapter base I/O port (03B4H for MDA, 03D4H for CGA) 
				;		- RAM base segment (0B000H for MDA, 0B800H for CGA) 
				;		- RAM size (16K for CGA gfx, 4K for 80x25 text, 2K for 40x25 text) 
				;		- RAM fill data (0 for gfx, space char with attribute 7 for text) 
				;		- Corresponding entry from INT 1DH CRTD table for new video mode 
				;		- Corresponding mode byte from CRT_MODE table 
				;	6. Clear regen RAM by filling with data from above 
				;	7. Write data from CRTD table to adapter registers to set mode 
				;	8. Write CGA palette register 
				;	9. Enable adapter with new mode byte 
				; 
				;----------------------------------------------------------------------------; 
 F0E4				INT_10_0 PROC 
							ELSE 
					PUSHX	BX, DX, BP, CX, SI 
			     1				IFNB <BX>			; exit if last reg 
 F0E4  53                    1		PUSH	BX 					; push register and repeat 
			     1		PUSHX	DX, BP, CX, SI, , ,  
			     2				IFNB <DX>			; exit if last reg 
 F0E5  52                    2		PUSH	DX 					; push register and repeat 
			     2		PUSHX	BP, CX, SI, , , ,  
			     3				IFNB <BP>			; exit if last reg 
 F0E6  55                    3		PUSH	BP 					; push register and repeat 
			     3		PUSHX	CX, SI, , , , ,  
			     4				IFNB <CX>			; exit if last reg 
 F0E7  51                    4		PUSH	CX 					; push register and repeat 
			     4		PUSHX	SI, , , , , ,  
			     5				IFNB <SI>			; exit if last reg 
 F0E8  56                    5		PUSH	SI 					; push register and repeat 
			     5		PUSHX	, , , , , ,  
			     6				ENDIF 
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
							ENDIF 
 F0E9  BF 0049 R			MOV	DI, OFFSET VID_MODE		; start with VID_MODE (49H) 
 F0EC  3C 07				CMP	AL, 7					; is new video mode > 7? 
 F0EE  72 02				JB	INT_10_0_1				; if not, is valid mode 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-151


 F0F0  8A 05				MOV	AL, [DI]				; otherwise use current mode 
 F0F2				INT_10_0_1: 
 F0F2  93				XCHG	AX, BX				; BL = new video mode 
				 
				;----------------------------------------------------------------------------; 
				; Clear all video data in BDA 
				; 
 F0F3  33 C0				XOR	AX, AX 
 F0F5  B9 000F				MOV	CX, L_VID_BDA / 2			; Video data in BDA (in WORDs) 
 F0F8  1E				PUSH	DS 
 F0F9  07				POP	ES					; ES = BDA 
 F0FA  F3/ AB				REP	STOSW					; clear data, set CX = 0 
				 
				;----------------------------------------------------------------------------; 
				; Determine video adapter type and new mode and re-program 6845 
				; 
					CMP_EFLAG VID, VID_MDA			; is switch MDA (ON, ON)? 
			     1				ENDIF 
			     1	;----------------------------------------------------------------------------; 
			     1	; Shift if flag is in high byte to low for byte operations 
			     1	; 
			     1				IF VID LT 8		; is in low byte? 
 = 0030                      1	??002F	= MASK VID 
 = 0004                      1	??0030	= VID AND 0111B 
 = 0010                      1	??0031	= EQUIP_FLAGS[0]			; low BDA flags byte 
			     1				ENDIF 
 F0FC  A0 0010 R             1		MOV	AL, BYTE PTR ??0031 
 F0FF  24 30                 1		AND	AL, ??002F 
 F101  3C 30                 1		CMP	AL, VID_MDA SHL ??0030 
			     1				ENDIF 
 F103  8A C1				MOV	AL, CL				; 0 = CGA disable video signal 
 F105  BE 0010				MOV	SI, O_INT_1D_80			; SI = CGA 80 CRTD offset 
 F108  B7 50				MOV	BH, VID_DEF_COLS			; default 80 columns 
 F10A  B5 10				MOV	CH, HIGH SIZE MDA_MEM		; Total MDA video memory = 1000H (4K) 
 F10C  8A E5				MOV	AH, CH				; MDA/CGA 80x25 page size = 1000H (4K) 
 F10E  BF 0720				MOV	DI, DBW <VID_ATTR<>, VID_SP>	; fill memory with attr and space 
 F111  75 0E				JNE	INT_10_0_IS_CGA			; jump if not MDA 
 F113  40				INC	AX					; 1 = MDA disable video signal value 
 F114  BD ---- R			MOV	BP, SEG _MDA_MEM			; BP = MDA memory segment (0B000H) 
 F117  BA 03B8				MOV	DX, MDA_CTRL			; MDA Mode Select Register (03B8H) 
 F11A  B3 07				MOV	BL, 7					; only valid MDA display mode is 7 
 F11C  BE 0030				MOV	SI, O_INT_1D_MDA			; SI = MDA CRTD offset 
 F11F  EB 26				JMP	SHORT INT_10_0_DETECT_DONE	; MDA mode selected, continue 
 F121				INT_10_0_IS_CGA: 
 F121  B5 40				MOV	CH, HIGH CGA_MEM_SZ		; Total CGA video memory = 4000H (16K) 
 F123  BA 03D8				MOV	DX, CGA_CTRL			; CGA Mode Select Register (3D8H) 
 F126  BD ---- R			MOV	BP, SEG _CGA_MEM			; BP = CGA memory segment (0B800H) 
 F129  F6 C3 04				TEST	BL, 0100B				; text or gfx mode? 
 F12C  74 0E				JZ	INT_10_0_IS_CGA_TEXT		; jump if text 
 F12E				INT_10_0_IS_CGA_GFX: 
 F12E  BE 0020				MOV	SI, O_INT_1D_GFX			; SI = CGA GFX CRTD offset 
 F131  B4 40				MOV	AH, HIGH CGA_MEM_SZ		; CGA gfx page size = 4000H (16K) 
 F133  33 FF				XOR	DI, DI				; DI = memory fill 0's 
 F135  F6 C3 02				TEST	BL, 0010B				; is 80 or 40 col text? 
 F138  75 0D				JNZ	INT_10_0_DETECT_DONE		; jump if 80 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-152


 F13A  EB 09				JMP	SHORT INT_10_0_IS_40_COL	; else set 40 columns 
 F13C				INT_10_0_IS_CGA_TEXT: 
 F13C  F6 C3 02				TEST	BL, 0010B				; is 80 or 40 col text? 
 F13F  75 06				JNZ	INT_10_0_DETECT_DONE		; jump if 80 
 F141  B4 08				MOV	AH, HIGH SIZE CGA_MEM_40	; CGA 40x25 page size = 800H (2K) 
 F143  33 F6				XOR	SI, SI				; SI = CGA 40 CRTD offset (00H) 
 F145				INT_10_0_IS_40_COL: 
 F145  D0 EF				SHR	BH, 1					; BH = 40 columns 
 F147				INT_10_0_DETECT_DONE: 
 F147  89 1E 0049 R			MOV	WORD PTR VID_MODE, BX		; write BDA video mode and columns 
 F14B  8E C5				MOV	ES, BP				; ES = video memory segment 
 F14D  89 2E 00EA R			MOV	VID_MEM_SEG, BP			; write video segment for later 
 F151  EE				OUT	DX, AL				; disable video 
 F152  88 26 004D R			MOV	BYTE PTR VID_BUF_SZ[1], AH	; write BDA video page size 
 F156  83 EA 04				SUB	DX, CGA_CTRL-CGA_IDX		; DX = 6845 index register port 
 F159  89 16 0063 R			MOV	VID_PORT, DX			; write BDA video I/O port 
 F15D  8B EB				MOV	BP, BX				; save video mode to BP 
				 
				;----------------------------------------------------------------------------; 
				; Fill video regen/memory 
				; 
 F15F  97				XCHG	AX, DI				; AX = fill byte 
 F160  33 FF				XOR	DI, DI				; start at offset 0 
 F162  D1 E9				SHR	CX, 1					; WORD size counter 
 F164  F3/ AB				REP	STOSW 
				 
				;----------------------------------------------------------------------------; 
				; Write CRTC data to 6845 registers 
				; 
 F166  1E				PUSH	DS					; save DS = BDA 
 F167  8B C1				MOV	AX, CX				; AX = 0 
 F169  A2 0062 R			MOV	VID_PAGE, AL			; video page 1 = 0 
 F16C  8E D8				MOV	DS, AX				; DS = IVT 
							ASSUME DS:_IVT 
 F16E  C5 1E 0074 R			LDS	BX, IVT_1D				; DS:BX = BIOS:INT_1D 
							ASSUME DS:NOTHING 
 F172  8B 78 0A				MOV	DI, WORD PTR [BX][SI].CSL	; DI = cursor type (start and end) 
 F175  B1 10				MOV	CL, SIZE CRTC			; size of CRTC data 
 F177				INT_10_0_CRTC_LOOP: 
 F177  8A 20				MOV	AH, [BX][SI]			; AH = next byte from table 
 F179  EF				OUT	DX, AX				; write AH to register index AL 
 F17A  40				INC	AX					; next register index 
 F17B  46				INC	SI					; next byte in table 
 F17C  E2 F9				LOOP	INT_10_0_CRTC_LOOP 
				 
				;----------------------------------------------------------------------------; 
				; Send mode and color bytes to display adapter 
				; 
 F17E  95				XCHG	AX, BP				; AL = new video mode 
 F17F  3C 06				CMP	AL, 6					; is CGA color gfx mode? 
 F181  B4 3F				MOV	AH, VID_CSGFX <>			; use for 640x200 mode 6 
 F183  74 02				JE	INT_10_0_COLOR_BYTE		; jump if so 
 F185  B4 30				MOV	AH, VID_CSTXT <>			; otherwise use for text/low gfx 
 F187				INT_10_0_COLOR_BYTE: 
 F187  BB F678 R			MOV	BX, OFFSET CRT_MODE 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-153


 F18A  2E: D7				XLAT	CS:[BX]				; AL = control byte data 
 F18C  1F				POP	DS					; DS = BDA 
							ASSUME DS:_BDA 
 F18D  83 C2 04				ADD	DX, CGA_CTRL-CGA_IDX		; DX = control reg port (3D8H) 
 F190  A3 0065 R			MOV	WORD PTR VID_MODE_REG, AX	; write mode and color to BDA 
 F193  EF				OUT	DX, AX				; write mode and color to adapter 
 F194  97				XCHG	AX, DI				; AX = cursor bytes from CRTC table 
 F195  86 E0				XCHG	AH, AL				; convert endian for cursor bytes 
 F197  A3 0060 R			MOV	VID_CURS_TYPE, AX			; write cursor type to BDA 
							ELSE 
					POPX	SI, CX, BP, DX, BX 
			     1				IFNB <SI>			; exit if last reg 
 F19A  5E                    1		POP	SI 					; pop register and repeat 
			     1		POPX	CX, BP, DX, BX, , ,  
			     2				IFNB <CX>			; exit if last reg 
 F19B  59                    2		POP	CX 					; pop register and repeat 
			     2		POPX	BP, DX, BX, , , ,  
			     3				IFNB <BP>			; exit if last reg 
 F19C  5D                    3		POP	BP 					; pop register and repeat 
			     3		POPX	DX, BX, , , , ,  
			     4				IFNB <DX>			; exit if last reg 
 F19D  5A                    4		POP	DX 					; pop register and repeat 
			     4		POPX	BX, , , , , ,  
			     5				IFNB <BX>			; exit if last reg 
 F19E  5B                    5		POP	BX 					; pop register and repeat 
			     5		POPX	, , , , , ,  
			     6				ENDIF 
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
							ENDIF 
 F19F				INT_10_RET: 
 F19F  C3				RET 
 F1A0				INT_10_0 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,1 - Set cursor type 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	CH = cursor starting scan line (cursor top) (low order 5 bits) 
				;	CL = cursor ending scan line (cursor bottom) (low order 5 bits) 
				;----------------------------------------------------------------------------; 
 F1A0				INT_10_1 PROC 
 F1A0  52				PUSH	DX 
 F1A1  97				XCHG	AX, DI			; save AX 
 F1A2  89 0E 0060 R			MOV	VID_CURS_TYPE, CX		; write new cursor to BDA 
 F1A6  B0 0A				MOV	AL, CRTC.CSL		; AL = cursor start index (scan line) 
 F1A8  8A E5				MOV	AH, CH			; CH = cursor starting scan line (top) 
 F1AA  8B 16 0063 R			MOV	DX, VID_PORT		; DX = 6845 index register port 
 F1AE  EF				OUT	DX, AX			; write AH to 6845 reg index in AL 
 F1AF  40				INC	AX				; AL = cursor end index (scan line) 
 F1B0  8A E1				MOV	AH, CL			; CL = cursor ending scan line (bottom) 
 F1B2  EF				OUT	DX, AX			; write AH to 6845 reg index in AL 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-154


 F1B3  97				XCHG	AX, DI			; restore AX 
 F1B4  5A				POP	DX 
 F1B5  C3				RET 
 F1B6				INT_10_1 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,2 - Set cursor position 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AH = 02 
				;	BH = page number (0 for graphics modes) 
				;	DH = row 
				;	DL = column 
				;----------------------------------------------------------------------------;	 
				; Things you must do: 
				;	1. Update the BDA Cursor position (50H-5FH) with the new video page 
				;		with the new cursor position 
				;	2. Calculate the memory address of the cursor's position, and set it 
				;		to the 6845 Cursor address register 
				; 
				; Things you should do: 
				;	- Make sure page number is valid for adapter type and current mode 
				; 
				;----------------------------------------------------------------------------;	 
 F1B6				INT_10_2 PROC 
 F1B6  50				PUSH	AX 
 F1B7  8A C7				MOV	AL, BH			; AL = new video page 
 F1B9  3C 07				CMP	AL, 7				; is new video page > 7? 
 F1BB  77 30				JA	INT_10_2_DONE		; if so, not valid, return 
				 
				;----------------------------------------------------------------------------; 
				; 1. Set cursor position in BDA 
				; 
 F1BD  98				CBW					; AX = page number 
 F1BE  97				XCHG	AX, DI			; DI = page number 
 F1BF  D1 E7				SHL	DI, 1				; word align index 
 F1C1  89 95 0050 R			MOV	VID_CURS_POS[DI], DX	; write to page cursor position in BDA 
 F1C5  38 3E 0062 R			CMP	VID_PAGE, BH		; is this the current page? 
 F1C9  75 22				JNE	INT_10_2_DONE		; if not, do nothing and exit 
 F1CB  53				PUSH	BX 
 F1CC  52				PUSH	DX 
				 
				;----------------------------------------------------------------------------; 
				; 2. Set cursor position in 6845 Cursor address register 
				; 
 F1CD				INT_10_SET_CUR_OFFSET: 
 F1CD  A0 004A R			MOV	AL, BYTE PTR VID_COLS	; AL = screen cols 
 F1D0  F6 E6				MUL	DH				; AX = row * screen cols 
 F1D2  32 F6				XOR	DH, DH			; DX = col 
 F1D4  03 C2				ADD	AX, DX			; AX = ( row * screen cols ) + col 
										; AX = byte offset for cursor position to page memor
				y 
 F1D6  8B 1E 004E R			MOV	BX, VID_SEG 
 F1DA  D1 EB				SHR	BX, 1				; byte align 
 F1DC  03 D8				ADD	BX, AX 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-155


 F1DE  B0 0E				MOV	AL, CRTC.CA_H		; 6845 Cursor address high reg (0EH) 
 F1E0  8A E7				MOV	AH, BH			; Cursor address (MSB) 
 F1E2  8B 16 0063 R			MOV	DX, VID_PORT 
 F1E6  EF				OUT	DX, AX			; write AH to index AL 
 F1E7  40				INC	AX				; AL = CA_L (0FH) 
 F1E8  8A E3				MOV	AH, BL			; Cursor address (LSB) 
 F1EA  EF				OUT	DX, AX			; write AH to index AL 
 F1EB  5A				POP	DX 
 F1EC  5B				POP	BX 
 F1ED				INT_10_2_DONE: 
 F1ED  58				POP	AX 
 F1EE  C3				RET 
 F1EF				INT_10_2 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,3 - Read cursor position and Size for current page 
				;----------------------------------------------------------------------------; 
				; Output: 
				;	ZF = 0 and BH = 0 if MDA/CGA GFX 
				;  	ZF = 1 and BH = VID_PAGE if CGA text 
				;----------------------------------------------------------------------------; 
 F1EF				INT_10_3_CUR_PAGE PROC 
 F1EF  32 FF				XOR	BH, BH			; BH = 0 
 F1F1  F6 06 0049 R 04			TEST	VID_MODE, 0100B		; is >= 4? 
 F1F6  75 04				JNZ	INT_10_3			; jump if not MDA or GFX 
 F1F8  8A 3E 0062 R			MOV	BH, VID_PAGE		; otherwise BH = VID_PAGE 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,3 - Read cursor position and Size 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AH = 03 
				;	BH = video page 
				; Output: 
				;	CH = cursor starting scan line (low order 5 bits) 
				;	CL = cursor ending scan line (low order 5 bits) 
				;	DH = row 
				;	DL = column 
				;----------------------------------------------------------------------------; 
 F1FC				INT_10_3 PROC 
 F1FC  50				PUSH	AX 
 F1FD  8A C7				MOV	AL, BH			; AL = video page 
 F1FF  98				CBW					; AX = video page 
 F200  97				XCHG	AX, DI			; DI = video page 
 F201  D1 E7				SHL	DI, 1				; word align index 
 F203  8B 95 0050 R			MOV	DX, VID_CURS_POS[DI] 
 F207  8B 0E 0060 R			MOV	CX, VID_CURS_TYPE 
 F20B  58				POP	AX 
 F20C  C3				RET 
 F20D				INT_10_3 ENDP 
 F20D				INT_10_3_CUR_PAGE ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,5 - Select active display page 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-156


				; Input: 
				;	AH = 05 
				;	AL = new page number 
				;----------------------------------------------------------------------------; 
				; Things you must do: 
				;	1. Write the new page number to BDA (40:62H) 
				;	2. Calculate new regen buffer page offset and update BDA and 
				;		6845 Start address register 
				;	3. Calculate the memory address of the cursor's position, and set it 
				;		to the 6845 Cursor address register 
				; 
				; Things you should do: 
				;	- Bounds check that page number is valid for adapter and current mode? 
				;----------------------------------------------------------------------------; 
 F20D				INT_10_5 PROC 
					PUSHX	AX, BX, DX			; call-preserve working registers 
			     1				IFNB <AX>			; exit if last reg 
 F20D  50                    1		PUSH	AX 					; push register and repeat 
			     1		PUSHX	BX, DX, , , , ,  
			     2				IFNB <BX>			; exit if last reg 
 F20E  53                    2		PUSH	BX 					; push register and repeat 
			     2		PUSHX	DX, , , , , ,  
			     3				IFNB <DX>			; exit if last reg 
 F20F  52                    3		PUSH	DX 					; push register and repeat 
			     3		PUSHX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; 1. Write the new page number to BDA (40:62H). 
				; 
 F210  A2 0062 R			MOV	VID_PAGE, AL 
 F213  98				CBW					; AX = video page 
 F214  97				XCHG	AX, DI			; DI = page number (save for later) 
				 
				;----------------------------------------------------------------------------; 
				; 2. Calculate new regen buffer page offset and update BDA and  
				;	6845 Start address register 
				; 
 F215  A1 004C R			MOV	AX, VID_BUF_SZ		; AX = Size of video regen buffer (bytes) 
 F218  F7 E7				MUL	DI				; AX = offset of start of page regen buffer 
 F21A  A3 004E R			MOV	VID_SEG, AX			; write to BDA 
 F21D  D1 E8				SHR	AX, 1				; video segment byte-indexed 
 F21F  8A D8				MOV	BL, AL			; AH = Start address (MSB), BL = (LSB) 
 F221  B0 0C				MOV	AL, CRTC.SA_H		; 6845 Start address register 
 F223  8B 16 0063 R			MOV	DX, VID_PORT		; 6845 I/O port address 
 F227  EF				OUT	DX, AX			; write AH (MSB) to index AL 
 F228  40				INC	AX				; AL = 0DH 
 F229  8A E3				MOV	AH, BL			; AH = Start address (LSB) 
 F22B  EF				OUT	DX, AX			; write AH (LSB) to index AL 
				 
				;----------------------------------------------------------------------------; 
				; 3. Set cursor position in 6845 Cursor address register 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-157


				; 
 F22C  D1 E7				SHL	DI, 1				; get the current cursor position 
 F22E  8B 95 0050 R			MOV	DX, VID_CURS_POS[DI]	; DH/DL = cursor position on current page 
 F232  EB 99				JMP	INT_10_SET_CUR_OFFSET	; write it to the new page's offset on 6845 
				 
 F234				INT_10_5 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,7 - Scroll active page down 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AL = number of lines to scroll, previous lines are 
				;	     blanked, if 0 or AL > screen size, window is blanked 
				;	BH = attribute to be used on blank line 
				;	CH = row of upper left corner of scroll window 
				;	CL = column of upper left corner of scroll window 
				;	DH = row of lower right corner of scroll window 
				;	DL = column of lower right corner of scroll window 
				;----------------------------------------------------------------------------; 
				; 
				;   0000  00  M 40x25 B/W text (CGA) 
				;   0001  01  C 40x25 16 color text (CGA) 
				;   0010  02  M 80x25 16 shades of gray text (CGA) 
				;   0011  03  C 80x25 16 color text (CGA) 
				;   0100  04  C 320x200 4 color graphics (CGA) 
				;   0101  05  C 320x200 4 color graphics (CGA) 
				;   0110  06  M 640x200 B/W graphics (CGA) 
				;   0111  07  M 80x25 Monochrome text (MDA) 
				;----------------------------------------------------------------------------; 
				; Things you must do: 
				; 	1. Calculate coordinates of existing rectangle and new rectangle. 
				;	2. Convert to memory video RAM addresses 
				;	3. If CGA 80 col, disable video during video RAM operations 
				;	4. If rows to scroll > 0, copy each row, starting at the left column. 
				;	   If scroll up, start from the top of the overlapping area and copy 
				;	   downward. If scroll down, start at the bottom and copy upward. 
				;	5. If rows to scroll > height of rectangle, fill the remaining rows 
				;	   with spaces. 
				; 
				;----------------------------------------------------------------------------; 
				; NOTE: The original XT BIOS (and maybe clones) appear to have a bug where 
				; if the lines to scroll (AL) is greater than the height of the rectangle 
				; it will scroll incorrectly. This behavior has been preserved. 
				;----------------------------------------------------------------------------; 
 F234				INT_10_7 PROC 
 F234  FD				STD					; Set direction flag 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,6 - Scroll active page up 
				;----------------------------------------------------------------------------; 
				; Input: same as INT 10,7 above 
				;----------------------------------------------------------------------------; 
 F235				INT_10_6 PROC 
					PUSHX	AX, BX, SI			; call-preserve these registers 
			     1				IFNB <AX>			; exit if last reg 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-158


 F235  50                    1		PUSH	AX 					; push register and repeat 
			     1		PUSHX	BX, SI, , , , ,  
			     2				IFNB <BX>			; exit if last reg 
 F236  53                    2		PUSH	BX 					; push register and repeat 
			     2		PUSHX	SI, , , , , ,  
			     3				IFNB <SI>			; exit if last reg 
 F237  56                    3		PUSH	SI 					; push register and repeat 
			     3		PUSHX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F238  C4 36 00E8 R			LES	SI, VID_MEM_SEG_DW	; ES = video/regen RAM segment (B800 or B000) 
 F23C  55				PUSH	BP 
				 
				;----------------------------------------------------------------------------; 
				; Register Check: 
				;	AH = saved flags - ZF if scroll up 
				;	AL = number of rows to scroll 
				;	BH = attribute to be used on blank line 
				;	BL = scratch 
				;	CH = row of upper left corner of scroll window 
				;	CL = column of upper left corner of scroll window 
				;	DH = row of lower right corner of scroll window 
				;	DL = column of lower right corner of scroll window 
				; 
 F23D  80 FC 06				CMP	AH, 6				; is scroll up? 
 F240  9F				LAHF					; save ZF if scroll up 
 F241  8B E8				MOV	BP, AX			; save original AL / AH flags 
 F243  8B FA				MOV	DI, DX			; save original DX 
 F245  75 02				JNZ	INT_10_CHECK_BOUNDS	; jump if scroll down 
				 
				;----------------------------------------------------------------------------; 
				; On scroll up, the new rectangle to scroll is above the old one so start the 
				; bottom left of the new rectangle at the top left of the old one. This  
				; will be later adjusted by the number of rows to scroll. 
				; 
 F247  8B D1				MOV	DX, CX			; if scroll up, DX becomes "top" 
				 
				;----------------------------------------------------------------------------; 
				; Make sure lower right column does not exceed screen width 
				; 
 F249				INT_10_CHECK_BOUNDS: 
 F249  A0 004A R			MOV	AL, BYTE PTR VID_COLS	; AL = video mode columns 
 F24C  3A D0				CMP	DL, AL			; is rect right column > screen columns? 
 F24E  72 03				JB	INT_10_BOUNDS_OK 
 F250  8A D0				MOV	DL, AL			; number of screen columns (80 or 40) 
 F252  4A				DEC	DX				; fixup for 0-based column index (0-79, etc) 
 F253				INT_10_BOUNDS_OK: 
 F253  F6 E6				MUL	DH				; AX = memory offset of col 0 of new bottom row 
 F255  8A F0				MOV	DH, AL			; save AL 
				 
				;----------------------------------------------------------------------------; 
				; Is graphics mode? 
				; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-159


 F257  E8 F085 R			CALL	INT_10_IS_TXT		; NZ if CGA GFX, ZR if CGA/MDA Text 
 F25A  8A C6				MOV	AL, DH			; restore AL 
 F25C  B6 00				MOV	DH, 0				; DX = lower right column position 
 F25E  1E				PUSH	DS				; save BDA data SEG 
 F25F  75 7E				JNZ	INT_10_SCR_GFX 
				 
				;----------------------------------------------------------------------------; 
				; Scroll in text mode 
				;----------------------------------------------------------------------------; 
				; To calculate scroll memory offsets: 
				; 
				;  rect_height = rect_height + 1 
				;  next_row = screen_cols - rect_width 
				; 
				;  if scroll down: 
				; 	rect_height = - rect_height 
				;	next_row = - next_row 
				; 
				;  new_top = old_top - rect_height 
				;  new_bottom = old_bottom - rect_height 
				; 
 F261				INT_10_SCR_TXT: 
 F261  03 D0				ADD	DX, AX			; DX = byte offset of new bottom row and col 
 F263  D1 E2				SHL	DX, 1				; WORD-align memory offset 
 F265  03 16 004E R			ADD	DX, VID_SEG			; DX = memory offset bottom row/col in video page 
 F269  8B F2				MOV	SI, DX			; SI = memory offset of new rect bottom (midpoint) 
 F26B  87 FA				XCHG	DI, DX			; DI = new rect bottom, DX = row/col pos. 
 F26D  2B D1				SUB	DX, CX			; DH = rect height (rows), DL = rect width (cols) 
 F26F  8B 0E 004A R			MOV	CX, VID_COLS		; CL = current video mode cols (80 or 40), CH = 0 
 F273  8C C0				MOV	AX, ES			; source and destination is video/regen RAM 
 F275  8E D8				MOV	DS, AX 
 F277  8B C5				MOV	AX, BP			; AL = # of rows to scroll 
 F279  D0 E1				SHL	CL, 1				; WORD-align bytes per full row (now 160 or 80) 
 F27B  F6 E1				MUL	CL				; AX = size in WORDs of full rows to scroll 
 F27D  95				XCHG	AX, BP			; AL = # rows, AH = func, BP = WORD size of rect. rows 
 F27E  42				INC	DX				; convert 0-based indexes to 1-based loop counters 
 F27F  FE C6				INC	DH 
 F281  9E				SAHF					; set ZF if scroll up 
 F282  8A E7				MOV	AH, BH			; AH = fill attribute byte 
 F284  9C				PUSHF					; save scroll direction flag (out of registers!) 
 F285  8B D9				MOV	BX, CX			; BX = WORD size of one screen row (80 or 160) 
 F287  8A CA				MOV	CL, DL			; CX = BYTE size of one rectangle row 
 F289  2B D9				SUB	BX, CX			; BX = WORD offset btwn end of rect. col and start col 
 F28B  2B D9				SUB	BX, CX			;  on next row (subtract twice to WORD align) 
 F28D  9D				POPF					; set ZF if scroll up 
 F28E  74 04				JZ	INT_10_CGA_CHECK		; jump if scroll up 
				 
				;----------------------------------------------------------------------------; 
				; On scroll down, subtract (instead of add) the difference between the end  
				; of the current rectangle and the next row start. 
				; 
				; The start address of source rectangle will also be above (instead of below) 
				; the destination rectangle. 
				; 
				; These offsets are then added the top/bottom of current rectangle to get the 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-160


				; new rectangle coords, either above or below depending on scroll direction. 
				; 
 F290  F7 DB				NEG	BX				; BX = - WORD size offset to start of next row 
 F292  F7 DD				NEG	BP				; BP = - WORD size of region of rows to scroll 
				 
 F294				INT_10_CGA_CHECK: 
								IF CGA_SNOW_REMOVE GT 0 
				;----------------------------------------------------------------------------; 
				; If CGA, blank video during memory writes to avoid "CGA snow" effect 
				; 
 F294  E8 F090 R			CALL	INT_10_IS_CGA80		; ZF if CGA 80, NZ if not 
 F297  9C				PUSHF					; save flags to use same result at end 
 F298  75 11				JNZ	INT_10_6_CHECK_CLS	; jump if not mode 2 or 3 CGA 80 col text 
				 
				;----------------------------------------------------------------------------; 
				; Blank CRTC video during memory writes to avoid "CGA snow" effect. 
				; 
 F29A				INT_10_CGA_DISABLE: 
 F29A  50				PUSH	AX 
 F29B  52				PUSH	DX 
 F29C  BA 03DA				MOV	DX, CGA_STAT		; CGA Status (3DAH) 
 F29F				INT_10_CGA_WAIT: 
 F29F  EC				IN	AL, DX			; get CRTC status register 
								IF CGA_SNOW_REMOVE EQ 3 
 F2A0  A8 09				TEST	AL, MASK VSVS OR MASK VSHS	; in HSYNC or VSYNC? 
								ENDIF 
 F2A2  74 FB				JZ	INT_10_CGA_WAIT		; loop until it is 
 F2A4  B2 D8				MOV	DL, LOW CGA_CTRL		; CGA Control (3D8H) 
 F2A6  B0 25				MOV	AL, 00100101B		; Mode 80x25 text, BW, disable video, blink 
 F2A8  EE				OUT	DX, AL			; disable video 
 F2A9  5A				POP	DX 
 F2AA  58				POP	AX 
								ENDIF 
				 
 F2AB				INT_10_6_CHECK_CLS: 
 F2AB  84 C0				TEST	AL, AL			; is number of lines to scroll 0? 
 F2AD  74 14				JZ	INT_10_6_TXT_CLR		; if so, skip move and only clear 
				 
				;----------------------------------------------------------------------------; 
				; Move scrolled window rectangle to new location in video memory  
				; 
 F2AF  2A F0				SUB	DH, AL			; DH = rect height - lines to scroll 
 F2B1  74 0E				JZ	INT_10_6_TXT_CLR_1	; is number of lines to move 0? 
 F2B3  03 F5				ADD	SI, BP			; SI = source row starting address 
 F2B5				INT_10_6_TXT_MOVE_LOOP: 
 F2B5  8A CA				MOV	CL, DL			; CX = number of columns (chars) to move 
 F2B7  F3/ A5				REP	MOVSW				; copy row from [DS:SI] to [ES:DI] 
 F2B9  03 FB				ADD	DI, BX			; move to start of next row 
 F2BB  03 F3				ADD	SI, BX 
 F2BD  FE CE				DEC	DH 
 F2BF  75 F4				JNZ	INT_10_6_TXT_MOVE_LOOP	; loop through all rows 
 F2C1				INT_10_6_TXT_CLR_1: 
 F2C1  8A F0				MOV	DH, AL			; DH = remaining lines to clear 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-161


				; Clear (fill with spaces) the newly cleared area 
				; 
 F2C3				INT_10_6_TXT_CLR: 
 F2C3  B0 20				MOV	AL, VID_SP			; fill blank lines with spaces 
 F2C5				INT_10_6_TXT_CLR_LOOP: 
 F2C5  8A CA				MOV	CL, DL			; write rect width number of blank chars 
 F2C7  F3/ AB				REP	STOSW				; write attribute and space to col 
 F2C9  03 FB				ADD	DI, BX			; move to start of next row 
 F2CB  FE CE				DEC	DH 
 F2CD  75 F6				JNZ	INT_10_6_TXT_CLR_LOOP	; loop through all rows 
								IF CGA_SNOW_REMOVE GT 0 
 F2CF  9D				POPF					; ZF if CGA/80, NZ if not 
								ENDIF 
 F2D0  1F				POP	DS				; restore BDA SEG 
				 
								IF CGA_SNOW_REMOVE GT 0 
 F2D1  75 07				JNZ	INT_10_6_DONE		; jump if not CGA/80 
				;----------------------------------------------------------------------------; 
				; If is CGA 80 column, re-enable the video signal 
				; 
 F2D3				INT_10_6_ENABLE_CGA: 
 F2D3  A0 0065 R			MOV	AL, VID_MODE_REG		; reload the current control register 
 F2D6  BA 03D8				MOV	DX, CGA_CTRL 
 F2D9  EE				OUT	DX, AL			; write to CGA Control Register 
								ENDIF 
				 
 F2DA				INT_10_6_DONE: 
					POPX	BP, SI, BX, AX 
			     1				IFNB <BP>			; exit if last reg 
 F2DA  5D                    1		POP	BP 					; pop register and repeat 
			     1		POPX	SI, BX, AX, , , ,  
			     2				IFNB <SI>			; exit if last reg 
 F2DB  5E                    2		POP	SI 					; pop register and repeat 
			     2		POPX	BX, AX, , , , ,  
			     3				IFNB <BX>			; exit if last reg 
 F2DC  5B                    3		POP	BX 					; pop register and repeat 
			     3		POPX	AX, , , , , ,  
			     4				IFNB <AX>			; exit if last reg 
 F2DD  58                    4		POP	AX 					; pop register and repeat 
			     4		POPX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F2DE  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,6/7 - Scroll up or down in graphics mode 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AX = memory offset of col 0 of new bottom row 
				;	BH = attribute to be used on blank line 
				;	BL = (scratch) 
				;	BP (high) = flags (ZF if scroll up, NZ if scroll down) 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-162


				;	CH = row/Y of upper left corner of scroll window 
				;	CL = column/X of upper left corner of scroll window 
				;	DX = lower right column/X position 
				;	DI = original row/column parameter 
				; 
				; Perform BitBlt operation within video RAM. 
				;----------------------------------------------------------------------------; 
 F2DF				INT_10_SCR_GFX PROC 
 F2DF  D1 E0				SHL	AX, 1				; BYTE (char) align memory offset for line 
 F2E1  D1 E0				SHL	AX, 1				;  (default for 640x200) 
 F2E3  03 D0				ADD	DX, AX 
 F2E5  87 D7				XCHG	DX, DI			; DI = memory offset of new rect bottom 
 F2E7  42				INC	DX				; DX = original row/col 
 F2E8  FE C6				INC	DH				; use 0-based indexes for 1-based counters 
 F2EA  2B D1				SUB	DX, CX			; DH = rect height, DL = rect width 
 F2EC  95				XCHG	AX, BP			; restore original AL / AH = func flag 
 F2ED  8A D8				MOV	BL, AL			; BL = lines to scroll 
 F2EF  BD 0050				MOV	BP, 80			; 1 scanline = 80 bytes 
 F2F2  B9 0002				MOV	CX, 2				; CL = 2, CH = 0 (needed later for counters) 
 F2F5  D2 E6				SHL	DH, CL			; rect height * char (row) height / 2 fields 
 F2F7  D2 E3				SHL	BL, CL			; lines to scroll * char height / 2 fields 
 F2F9  80 3E 0049 R 06			CMP	VID_MODE, 6			; is 640x200 mode? 
 F2FE  74 08				JZ	INT_10_SCR_GFX_2		; jump if so 
				 
				;----------------------------------------------------------------------------; 
				; is 320x200/4 color - adjust to 2 bits per pixel (16 bits per glyph) 
				; 
 F300  D1 E7				SHL	DI, 1				; WORD (char) align mem offset 
 F302  D0 E2				SHL	DL, 1				; WORD (char) align rect width 
 F304  9E				SAHF					; set ZF if scroll up 
 F305  74 0A				JZ	INT_10_SCR_GFX_RDY	; jump if scroll up 
				 
				;----------------------------------------------------------------------------; 
				; is 320x200 AND scroll down 
				; 
 F307  47				INC	DI				; fixup start address for last pixel 
				 
 F308				INT_10_SCR_GFX_2: 
 F308  9E				SAHF					; set ZF if scroll up 
 F309  74 06				JZ	INT_10_SCR_GFX_RDY	; jump if scroll up 
				 
				;----------------------------------------------------------------------------; 
				; is scroll down 
				; 
 F30B  81 C7 00F0			ADD	DI, 240			; fixup bottom row of new rect. 
 F30F  F7 DD				NEG	BP				; if scroll down, subtract offset instead 
				 
				;----------------------------------------------------------------------------; 
				; ready to begin 
				; 
 F311				INT_10_SCR_GFX_RDY: 
 F311  84 C0				TEST	AL, AL			; is number of lines to scroll 0? 
 F313  74 33				JZ	INT_10_SCR_GFX_CLR	; if so, skip move and only clear 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-163


				; Bit block transfer pixel data in video memory 
				; 
 F315  8B F7				MOV	SI, DI			; SI = mem offset of new rectangle 
 F317  8B C5				MOV	AX, BP			; AL = 1 scanline (80 if up, -80 if down) 
 F319  F6 EB				IMUL	BL				; AX = offset of lines to scroll * +/- 80 
 F31B  03 F0				ADD	SI, AX			; SI = mem offset of old rectangle 
 F31D  8C C0				MOV	AX, ES			; set DS to video regen segment 
 F31F  8E D8				MOV	DS, AX			;  for source (old) rectangle 
 F321  53				PUSH	BX				; save lines to clear and attribute 
 F322  2A F3				SUB	DH, BL			; DH = # of lines to write 
					;JZ	INT_10_SCR_GFX_CLR_1	; check that loop > 1 (necessary?) 
 F324  8B C6				MOV	AX, SI			; save source 
 F326  8B DF				MOV	BX, DI			; save destination 
 F328				INT_10_SCR_GFX_MOVE_LOOP: 
 F328  8A CA				MOV	CL, DL			; # of pixels to copy 
 F32A  F3/ A4				REP	MOVSB				; copy odd field 
 F32C  BE 2000				MOV	SI, CGA_MEM_FLD		; vid mem offset for interlaced field 
 F32F  8B FE				MOV	DI, SI 
 F331  03 F0				ADD	SI, AX			; add to line offset 
 F333  03 FB				ADD	DI, BX 
 F335  8A CA				MOV	CL, DL			; # of pixels to copy 
 F337  F3/ A4				REP	MOVSB				; copy even field 
 F339  03 C5				ADD	AX, BP			; move to next line 
 F33B  03 DD				ADD	BX, BP 
 F33D  8B F0				MOV	SI, AX			; reset source 
 F33F  8B FB				MOV	DI, BX			; reset dest 
 F341  FE CE				DEC	DH 
 F343  75 E3				JNZ	INT_10_SCR_GFX_MOVE_LOOP 
 F345  5B				POP	BX 
				 
				;----------------------------------------------------------------------------; 
				; Clear old window rectangle 
				; 
 F346				INT_10_SCR_GFX_CLR_1: 
 F346  8A F3				MOV	DH, BL			; # of lines to clear 
 F348				INT_10_SCR_GFX_CLR: 
 F348  8A C7				MOV	AL, BH			; AL = attribute/color byte to write 
 F34A  8B F7				MOV	SI, DI			; save destination 
 F34C				INT_10_SCR_GFX_CLR_LOOP: 
 F34C  8A CA				MOV	CL, DL			; # of pixels to clear 
 F34E  F3/ AA				REP	STOSB				; clear odd field 
 F350  BF 2000				MOV	DI, CGA_MEM_FLD		; vid mem offset for interlaced field 
 F353  03 FE				ADD	DI, SI 
 F355  8A CA				MOV	CL, DL			; # of pixels to clear 
 F357  F3/ AA				REP	STOSB				; clear even field 
 F359  03 F5				ADD	SI, BP			; move to next line 
 F35B  8B FE				MOV	DI, SI			; reset dest 
 F35D  FE CE				DEC	DH 
 F35F  75 EB				JNZ	INT_10_SCR_GFX_CLR_LOOP 
 F361  1F				POP	DS 
 F362  E9 F2DA R			JMP	INT_10_6_DONE 
				 
 F365				INT_10_SCR_GFX ENDP 
				 
 F365				INT_10_6 ENDP 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-164


 F365				INT_10_7 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,8 - Read character and attribute at cursor 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	BH = display page 
				; Output: 
				;	AH = attribute of character (alpha modes only) 
				;	AL = character at cursor position 
				; 
				; http://www.techhelpmanual.com/92-cga_video_snow_and_cls_flash.html 
				;----------------------------------------------------------------------------; 
 F365				INT_10_8 PROC 
 F365  E8 F654 R			CALL	INT_10_GET_CUR_ADDR	; ES:DI = video RAM offset of cursor 
 F368  A0 0049 R			MOV	AL, VID_MODE		; AL = current video mode (0-7) 
 F36B  3C 07				CMP	AL, 7				; is MDA mode 7? 
 F36D  75 04				JNZ	INT_10_8_CHK_CGA		; if not, jump to check CGA or gfx 
				 
				;----------------------------------------------------------------------------; 
				; Standard, fast routine 
				; 
 F36F				INT_10_8_FAST: 
 F36F  26: 8B 05			MOV	AX, ES:[DI]			; just read from memory and return 
 F372  C3				RET 
				 
 F373				INT_10_8_CHK_CGA: 
 F373  D0 E8				SHR	AL, 1				; Video modes: 0=40,1=80,2=low-gfx,3=hi-gfx 
 F375  3C 01				CMP	AL, 1				; is CGA modes 2,3? 
							IF CGA_SNOW_REMOVE GT 0 
 F377  75 1C				JNE	INT_10_8_NOT_CGA		; jump if not 
				 
				;----------------------------------------------------------------------------; 
				; CGA snow-removal routine. Wait for a blanking interval before read. 
				; 
 F379  52				PUSH	DX 
 F37A  BA 03DA				MOV	DX, CGA_STAT 
					CGA_WAIT_SYNC 
			     1				ENDIF 
 F37D                        1	??0032: 
			     1				IF CGA_SNOW_REMOVE GT 1 
 F37D  FB                    1		STI						; [2] enable interrupts 
 F37E  90                    1		NOP						; [3] handle pending interrupts 
 F37F  FA                    1		CLI						; [2] disable interrupts 
			     1				ENDIF 
 F380  EC                    1		IN	AL, DX				; [12] read CGA status register 
			     1				IF CGA_SNOW_REMOVE GT 1 
 F381  A8 08                 1		TEST	AL, MASK VSVS			; [5] in vertical? 
 F383  75 09                 1		JNZ	??0034				; [4/16] if so, do CGA I/O 
			     1				ENDIF 
 F385  D0 E8                 1		SHR	AL, 1					; [2] in horizontal? 
 F387  72 F4                 1		JC	??0032			; [4/16] if so, wait for next one 
 F389                        1	??0033: 
 F389  EC                    1		IN	AL, DX				; [12] read CGA status register 
			     1				IF CGA_SNOW_REMOVE GT 1 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-165


 F38A  A8 09                 1		TEST	AL, MASK VSVS OR MASK VSHS	; [5] in either sync? 
 F38C  74 FB                 1		JZ	??0033				; [4/16] 
			     1				ENDIF 
 F38E                        1	??0034: 
 F38E  26: 8B 05			MOV	AX, ES:[DI] 
 F391  FB				STI 
 F392  5A				POP	DX 
 F393  EB DA				JMP	SHORT INT_10_8_FAST 
				 
 F395				INT_10_8_NOT_CGA: 
							ENDIF 
				 
 F395  76 D8				JBE	INT_10_8_FAST		; if not GFX modes 4,5,6 jump to fast text 
										; fall through to graphics 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,8 - Read character and attribute at cursor in CGA graphic mode 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AL = 3 if high res, 2 if low-res 
				;	ES = video mem segment 
				; Output: 
				;	AH = 0 
				;	AL = character at cursor position, 0 if not found 
				;----------------------------------------------------------------------------; 
 F397				INT_10_8_MODE_GFX PROC 
					PUSHX	BX, CX, DX, SI 
			     1				IFNB <BX>			; exit if last reg 
 F397  53                    1		PUSH	BX 					; push register and repeat 
			     1		PUSHX	CX, DX, SI, , , ,  
			     2				IFNB <CX>			; exit if last reg 
 F398  51                    2		PUSH	CX 					; push register and repeat 
			     2		PUSHX	DX, SI, , , , ,  
			     3				IFNB <DX>			; exit if last reg 
 F399  52                    3		PUSH	DX 					; push register and repeat 
			     3		PUSHX	SI, , , , , ,  
			     4				IFNB <SI>			; exit if last reg 
 F39A  56                    4		PUSH	SI 					; push register and repeat 
			     4		PUSHX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F39B  83 EC 08				SUB	SP, 8				; reserve 8 bytes for target bitmap 
				 
				;----------------------------------------------------------------------------; 
				; Lookup page, calculate charpos and set up data segments 
				; 
 F39E  E8 F531 R			CALL	INT_10_GFX_CHARPOS	; DI = memory offset of curr. cursor 
 F3A1  8B F7				MOV	SI, DI			; SI = memory offset of curr. cursor 
 F3A3  8B FC				MOV	DI, SP			; DI = start of temp space 
 F3A5  06				PUSH	ES				; DS = ES 
 F3A6  1F				POP	DS 
 F3A7  16				PUSH	SS				; ES = SS 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-166


 F3A8  07				POP	ES 
 F3A9  B9 0004				MOV	CX, 4				; loop counter for high and low res 
 F3AC  BA 2000				MOV	DX, CGA_MEM_FLD		; CGA memory interlace field offset 
 F3AF  3C 03				CMP	AL, 3				; is high-res graphics mode? 
 F3B1  74 5D				JZ	INT_10_8_GFX_HIGH		; jump to handle high-res 1 bpp spacing 
				 
				;----------------------------------------------------------------------------; 
				; Low-res - Load and pack 8 character bytes from video mem into [DS:BP] 
				;----------------------------------------------------------------------------; 
 F3B3				INT_10_8_MODE_GFX_LOW: 
 F3B3  D1 E6				SHL	SI, 1				; align for two bytes/char in 320x200 
				 
 F3B5				INT_10_8_GFX_LOW_1: 
 F3B5  8B 04				MOV	AX, [SI]			; AX = next two chars from video mem 
 F3B7  86 C4				XCHG	AL, AH			; convert endian from WORD read 
				 
				;----------------------------------------------------------------------------; 
				; Shift and OR the color bits together so that non-zero value will produce 1 
				; 
 F3B9  8B D8				MOV	BX, AX			; copy bit pattern 
 F3BB  D1 E0				SHL	AX, 1				; shift low bit into high bit 
 F3BD  0B D8				OR	BX, AX			; make high bit a 1 if either bit is 1 
				 
				;----------------------------------------------------------------------------; 
				; Copy the only odd bits from the WORD value into a BYTE value. 
				; 
 F3BF  B4 08				MOV	AH, 8				; loop through the eight 2 bpp values 
 F3C1				INT_10_8_GFX_LOW_2: 
 F3C1  D1 E3				SHL	BX, 1				; even bit into CF 
 F3C3  12 C0				ADC	AL, AL			; shift CF onto low order bit 
 F3C5  D1 E3				SHL	BX, 1				; discard pixel odd bit 
 F3C7  FE CC				DEC	AH				; dec loop counter 
 F3C9  75 F6				JNZ	INT_10_8_GFX_LOW_2 
 F3CB  AA				STOSB					; save byte to local storage 
 F3CC  33 F2				XOR	SI, DX			; toggle video field memory offset 
 F3CE  85 F2				TEST	SI, DX			; is next field even? 
 F3D0  75 E3				JNZ	INT_10_8_GFX_LOW_1	; jump if next field is even 
 F3D2  83 C6 50				ADD	SI, 80			; if next field is odd, move to next line 
 F3D5  E2 DE				LOOP	INT_10_8_GFX_LOW_1	; loop all 8 bitmap bytes and fall through 
				 
				;----------------------------------------------------------------------------; 
				; Do a linear search (uh, time complexity anyone?) of ROM BIOS and INT 1Fh  
				; for the 8x8 1 bpp bitmap at the cursor position. 
				; 
 F3D7				INT_10_8_GFX_SEARCH: 
 F3D7  8B FC				MOV	DI, SP			; DI = char bitmap from video mem 
 F3D9  BE FA6E R			MOV	SI, OFFSET GFX_CHARSET	; SI = BIOS ROM table 
 F3DC  8C CB				MOV	BX, CS			; DS = CS 
 F3DE  8E DB				MOV	DS, BX 
 F3E0  33 C0				XOR	AX, AX			; start codepoint counter at 0 
 F3E2				INT_10_8_GFX_SEARCH_TBL: 
 F3E2  BB 0080				MOV	BX, 128			; loop counter for each charset table 
 F3E5				INT_10_8_GFX_SEARCH_CHR: 
 F3E5  56				PUSH	SI				; save target bitmap and ROM table offsets 
 F3E6  57				PUSH	DI 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-167


 F3E7  B1 04				MOV	CL, 4				; compare [CS:SI] (ROM table) to 
 F3E9  F3/ A7				REPE	CMPSW				;  [ES:DI] (char bitmap from vid mem) 
 F3EB  5F				POP	DI				; restart target bitmap at beginning  
 F3EC  5E				POP	SI				; ROM table always advanced by 8  
 F3ED  74 19				JE	INT_10_8_GFX_DONE		; end search if match found 
 F3EF  83 C6 08				ADD	SI, 8				; next char in table 
 F3F2  FE C0				INC	AL				; next codepoint to try 
 F3F4  74 12				JZ	INT_10_8_GFX_DONE		; if AL > 255, char not found 
 F3F6  4B				DEC	BX				; dec charset loop counter 
 F3F7  75 EC				JNZ	INT_10_8_GFX_SEARCH_CHR	; loop until end of table set 
				 
				;----------------------------------------------------------------------------; 
				; Search again in user charset at 0000:007C (INT 1Fh). 
				; 
 F3F9  99				CWD					; DX = 0000h 
 F3FA  8E DA				MOV	DS, DX			; DS = IVT 
							ASSUME DS:_IVT 
 F3FC  C5 36 007C R			LDS	SI, IVT_1F			; DS:SI = user charset 
							ASSUME DS:_BDA 
 F400  8C DA				MOV	DX, DS			; see if custom table has been vectored 
 F402  0B D6				OR	DX, SI			;  and not the default of 0000:0000 
 F404  75 DC				JNZ	INT_10_8_GFX_SEARCH_TBL	; if so, continue search 
 F406  33 C0				XOR	AX, AX			; otherwise return not found (0) 
 F408				INT_10_8_GFX_DONE: 
 F408  83 C4 08				ADD	SP, 8				; restore stack pointer 
					POPX	SI, DX, CX, BX 
			     1				IFNB <SI>			; exit if last reg 
 F40B  5E                    1		POP	SI 					; pop register and repeat 
			     1		POPX	DX, CX, BX, , , ,  
			     2				IFNB <DX>			; exit if last reg 
 F40C  5A                    2		POP	DX 					; pop register and repeat 
			     2		POPX	CX, BX, , , , ,  
			     3				IFNB <CX>			; exit if last reg 
 F40D  59                    3		POP	CX 					; pop register and repeat 
			     3		POPX	BX, , , , , ,  
			     4				IFNB <BX>			; exit if last reg 
 F40E  5B                    4		POP	BX 					; pop register and repeat 
			     4		POPX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F40F  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; High-res - Load 8 character bytes from video mem into [DS:BP] 
				;----------------------------------------------------------------------------; 
 F410				INT_10_8_GFX_HIGH: 
 F410  A4				MOVSB					; copy odd field 
 F411  4E				DEC	SI				; undo MOVSB source inc 
 F412  33 F2				XOR	SI, DX			; toggle video field memory offset 
 F414  A4				MOVSB					; copy even field 
 F415  33 F2				XOR	SI, DX			; toggle video field memory offset back 
 F417  83 C6 4F				ADD	SI, 80-1			; move to next line (undo MOVSB inc of SI) 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-168


 F41A  E2 F4				LOOP	INT_10_8_GFX_HIGH		; loop 8 times 
 F41C  EB B9				JMP	INT_10_8_GFX_SEARCH	; rejoin the search 
				 
 F41E				INT_10_8_MODE_GFX ENDP 
				 
 F41E				INT_10_8 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,9 - Write character and attribute at cursor 
				;----------------------------------------------------------------------------; 
				; INT 10,A - Write character at current cursor 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AH = 09 or 0A 
				;	AL = ASCII character to write 
				;	BH = display page  (or mode 13h, background pixel value) 
				;	BL = foreground color (graphics mode only) 
				;	CX = count of characters to write (CX >= 1) 
				; 
				; This code is performance sensitive, so jumps are prioritizied 
				; and some code is duplicated to avoid jumps. For example, AH=0AH is used  
				; far more frequently than 09H so it gets the fall through cases. 
				;----------------------------------------------------------------------------; 
 F41E				INT_10_9 PROC 
 F41E				INT_10_A PROC 
 F41E  51				PUSH	CX 
 F41F  50				PUSH	AX				; save AX 
 F420  E8 F654 R			CALL	INT_10_GET_CUR_ADDR	; ES:DI = video RAM offset of cursor 
 F423  A0 0049 R			MOV	AL, VID_MODE		; AL = current video mode (0-7) 
 F426  3C 07				CMP	AL, 7				; is MDA mode 7? 
 F428  75 12				JNZ	INT_10_CHK_CGA		; if not, jump to check CGA 
				 
				;----------------------------------------------------------------------------; 
				; Use standard, fast routine for direct video memory writes 
				; 
 F42A				INT_10_9A_FAST: 
 F42A  58				POP	AX				; restore AX 
 F42B  80 FC 09				CMP	AH, 9				; is function 9 (char + attribute)? 
 F42E  74 06				JZ	INT_10_9_FAST		; if so, jump 
				 
				;----------------------------------------------------------------------------; 
				; AH = 0AH: Write Character 
				; 
 F430				INT_10_A_FAST: 
 F430  AA				STOSB					; write char, skip attribute 
 F431  47				INC	DI 
 F432  E2 FC				LOOP	INT_10_A_FAST 
 F434  59				POP	CX 
 F435  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; AH = 09H: Write Character and Attribute 
				; 
 F436				INT_10_9_FAST: 
 F436  8A E3				MOV	AH, BL			; char attribute into high byte 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-169


 F438  F3/ AB				REP	STOSW				; write with attribute 
 F43A  59				POP	CX 
 F43B  C3				RET 
				 
 F43C				INT_10_CHK_CGA: 
 F43C  D0 E8				SHR	AL, 1				; group remaining video modes 
 F43E  3C 01				CMP	AL, 1				; is CGA modes 2,3? 
							IF CGA_SNOW_REMOVE GT 0 
 F440  75 42				JNE	INT_10_A_NOT_CGA		; jump if not 
				 
				;----------------------------------------------------------------------------; 
				; Use slower CGA-specific snow-removal routines for memory writes during 
				; screen blanking. 
				; 
 F442				INT_10_9A_CGA: 
 F442  58				POP	AX				; restore AX 
 F443  53				PUSH	BX				; save BX 
 F444  52				PUSH	DX 
 F445  BA 03DA				MOV	DX, CGA_STAT 
 F448  80 FC 09				CMP	AH, 9				; is function 9 (char + attribute)? 
 F44B  74 1C				JZ	INT_10_9_CGA 
				 
				;----------------------------------------------------------------------------; 
				; AH = 0AH: Write Character (CGA Text) 
				; 
 F44D				INT_10_A_CGA: 
 F44D  93				XCHG	AX, BX			; save AX 
					CGA_WAIT_SYNC			; wait for blanking to write memory 
			     1				ENDIF 
 F44E                        1	??0035: 
			     1				IF CGA_SNOW_REMOVE GT 1 
 F44E  FB                    1		STI						; [2] enable interrupts 
 F44F  90                    1		NOP						; [3] handle pending interrupts 
 F450  FA                    1		CLI						; [2] disable interrupts 
			     1				ENDIF 
 F451  EC                    1		IN	AL, DX				; [12] read CGA status register 
			     1				IF CGA_SNOW_REMOVE GT 1 
 F452  A8 08                 1		TEST	AL, MASK VSVS			; [5] in vertical? 
 F454  75 09                 1		JNZ	??0037				; [4/16] if so, do CGA I/O 
			     1				ENDIF 
 F456  D0 E8                 1		SHR	AL, 1					; [2] in horizontal? 
 F458  72 F4                 1		JC	??0035			; [4/16] if so, wait for next one 
 F45A                        1	??0036: 
 F45A  EC                    1		IN	AL, DX				; [12] read CGA status register 
			     1				IF CGA_SNOW_REMOVE GT 1 
 F45B  A8 09                 1		TEST	AL, MASK VSVS OR MASK VSHS	; [5] in either sync? 
 F45D  74 FB                 1		JZ	??0036				; [4/16] 
			     1				ENDIF 
 F45F                        1	??0037: 
 F45F  93				XCHG	AX, BX			; restore AX 
 F460  AA				STOSB					; write char, skip attribute 
 F461  FB				STI 
 F462  47				INC	DI 
 F463  E2 E8				LOOP	INT_10_A_CGA 
 F465				INT_10_A_CGA_DONE: 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-170


 F465  5A				POP	DX 
 F466  5B				POP	BX 
 F467  59				POP	CX 
 F468  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; AH = 09H: Write Character and Attribute (CGA Text) 
				; 
 F469				INT_10_9_CGA: 
 F469  8A E3				MOV	AH, BL			; char attribute into high byte 
 F46B				INT_10_9_CGA_LOOP: 
 F46B  93				XCHG	AX, BX			; save AX 
					CGA_WAIT_SYNC			; wait for blanking to write memory 
			     1				ENDIF 
 F46C                        1	??0038: 
			     1				IF CGA_SNOW_REMOVE GT 1 
 F46C  FB                    1		STI						; [2] enable interrupts 
 F46D  90                    1		NOP						; [3] handle pending interrupts 
 F46E  FA                    1		CLI						; [2] disable interrupts 
			     1				ENDIF 
 F46F  EC                    1		IN	AL, DX				; [12] read CGA status register 
			     1				IF CGA_SNOW_REMOVE GT 1 
 F470  A8 08                 1		TEST	AL, MASK VSVS			; [5] in vertical? 
 F472  75 09                 1		JNZ	??003A				; [4/16] if so, do CGA I/O 
			     1				ENDIF 
 F474  D0 E8                 1		SHR	AL, 1					; [2] in horizontal? 
 F476  72 F4                 1		JC	??0038			; [4/16] if so, wait for next one 
 F478                        1	??0039: 
 F478  EC                    1		IN	AL, DX				; [12] read CGA status register 
			     1				IF CGA_SNOW_REMOVE GT 1 
 F479  A8 09                 1		TEST	AL, MASK VSVS OR MASK VSHS	; [5] in either sync? 
 F47B  74 FB                 1		JZ	??0039				; [4/16] 
			     1				ENDIF 
 F47D                        1	??003A: 
 F47D  93				XCHG	AX, BX			; restore AX 
 F47E  AB				STOSW 
 F47F  FB				STI 
 F480  E2 E9				LOOP	INT_10_9_CGA_LOOP 
 F482  EB E1				JMP	SHORT INT_10_A_CGA_DONE 
 F484				INT_10_A_NOT_CGA: 
							ENDIF 
				 
 F484  76 A4				JBE	INT_10_9A_FAST		; is not GFX modes 4,5,6 jump to fast text 
 F486  58				POP	AX				; restore AX and fall through to graphics 
				 
				;----------------------------------------------------------------------------; 
				; INT 10, 9 and A - Write character in CGA graphics mode 
				;----------------------------------------------------------------------------; 
 F487				INT_10_9A_MODE_GFX PROC 
					PUSHX	AX, BX, DX, SI, DS 
			     1				IFNB <AX>			; exit if last reg 
 F487  50                    1		PUSH	AX 					; push register and repeat 
			     1		PUSHX	BX, DX, SI, DS, , ,  
			     2				IFNB <BX>			; exit if last reg 
 F488  53                    2		PUSH	BX 					; push register and repeat 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-171


			     2		PUSHX	DX, SI, DS, , , ,  
			     3				IFNB <DX>			; exit if last reg 
 F489  52                    3		PUSH	DX 					; push register and repeat 
			     3		PUSHX	SI, DS, , , , ,  
			     4				IFNB <SI>			; exit if last reg 
 F48A  56                    4		PUSH	SI 					; push register and repeat 
			     4		PUSHX	DS, , , , , ,  
			     5				IFNB <DS>			; exit if last reg 
 F48B  1E                    5		PUSH	DS 					; push register and repeat 
			     5		PUSHX	, , , , , ,  
			     6				ENDIF 
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F48C  8A 3E 0049 R			MOV	BH, VID_MODE		; BH = current video mode 
 F490  E8 F531 R			CALL	INT_10_GFX_CHARPOS	; DI = memory offset of curr. cursor 
				 
				;----------------------------------------------------------------------------; 
				; If extended ASCII, use custom table revectored at 1Fh 
				; 
 F493  BE FA6E R			MOV	SI, OFFSET GFX_CHARSET	; default to lower set using BIOS table 
 F496  8C CA				MOV	DX, CS			;  located in CS 
 F498  8E DA				MOV	DS, DX			; DS = CS 
 F49A  84 C0				TEST	AL, AL			; is extended (AL > 127)? 
 F49C  79 0A				JNS	INT_10_9A_GFX_2		; Jump if not 
 F49E  24 7F				AND	AL, 01111111b		; AL = low 7 bits of CP 
 F4A0  33 D2				XOR	DX, DX			; Set DS to IVT to load DS and SI from 
 F4A2  8E DA				MOV	DS, DX			; INT 1Fh 
							ASSUME DS:_IVT 
 F4A4  C5 36 007C R			LDS	SI, IVT_1F			; use custom font table 
				 
 F4A8				INT_10_9A_GFX_2: 
 F4A8  98				CBW					; AH = 0 
 F4A9  D1 E0				SHL	AX, 1				; AX = char * 8 
 F4AB  D1 E0				SHL	AX, 1 
 F4AD  D1 E0				SHL	AX, 1 
 F4AF  03 F0				ADD	SI, AX			; SI = offset in char table 
 F4B1  80 FF 06				CMP	BH, 6 
 F4B4  74 56				JE	INT_10_9A_GFX_HIGH	; jump if high res 
				 
				;----------------------------------------------------------------------------; 
				; Low-res (320x200) graphics modes 4-5 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AX = ASCII character to write * 8 bytes 
				;	BH = video mode 
				;	BL = foreground color 
				;	CX = number of times to repeat character 
				;	DS:SI = start of character offset in font bitmap table 
				;	ES:DI = cursor location in video RAM 
				;----------------------------------------------------------------------------; 
				; Things you must do: 
				;	1. Transform each BYTE of 1 bit glyph into 2 bpp color WORD 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-172


				;	2. If BL has high bit set, XOR new char with current char 
				;	3. Write new bitmap to CGA interlaced video memory 
				;----------------------------------------------------------------------------; 
 F4B6				INT_10_9A_GFX_LOW: 
 F4B6  8A D3				MOV	DL, BL			; DL = foreground color bits 
 F4B8  83 E2 03				AND	DX, 0011b			; zero extend 2 bit color 
				 
				;----------------------------------------------------------------------------; 
				; Repeat/expand 2 color bits in DL into into DX 
				; 
 F4BB				INT_10_9A_GFX_FG: 
 F4BB  0A F2				OR	DH, DL			; copy 2 bits 
 F4BD  D0 E2				SHL	DL, 1				; move color bits to next position 
 F4BF  D0 E2				SHL	DL, 1 
 F4C1  75 F8				JNZ	INT_10_9A_GFX_FG		; loop until DL = 0 
 F4C3  8A D6				MOV	DL, DH			; copy to both bytes of DX 
				 
				;----------------------------------------------------------------------------; 
				; Repeat for number of chars to write in CX to create color mask 
				; 
 F4C5  D1 E7				SHL	DI, 1				; align for two bytes/char in 320x200 
 F4C7				INT_10_9A_GFX_LOW_CHAR: 
 F4C7  56				PUSH	SI				; save char glyph start offset for each loop 
 F4C8  57				PUSH	DI				; start each char at first row of vid mem 
				 
				;----------------------------------------------------------------------------; 
				; Transform glyph bitmap to 2 bit color and move into video memory 
				; 
 F4C9  51				PUSH	CX				; save repeat counter 
 F4CA  B9 0008				MOV	CX, 8				; loop 8 bytes 
 F4CD				INT_10_9A_GFX_LOW_BYTE: 
 F4CD  AC				LODSB					; Load next byte 
				 
				;----------------------------------------------------------------------------; 
				; Parallel-deposit bits of input char and transform 1 bit pixel into 2 bpp 
				; 
 F4CE  53				PUSH	BX 
 F4CF  51				PUSH	CX				; save bitmap counter 
 F4D0  33 DB				XOR	BX, BX			; clear output 
 F4D2  B1 08				MOV	CL, 8				; loop 8 bits of input char 
 F4D4				INT_10_9A_GFX_LOW_PDEP: 
 F4D4  D0 E0				SHL	AL, 1				; CF = source pixel bit 
 F4D6  9F				LAHF					; save CF 
 F4D7  D1 D3				RCL	BX, 1				; shift CF into next bit 
 F4D9  9E				SAHF					; restore CF 
 F4DA  D1 D3				RCL	BX, 1				; shift CF into next bit again 
 F4DC  E2 F6				LOOP	INT_10_9A_GFX_LOW_PDEP 
 F4DE  93				XCHG	AX, BX			; AX = result 
 F4DF  86 C4				XCHG	AL, AH			; convert endian 
 F4E1  59				POP	CX 
 F4E2  5B				POP	BX 
 F4E3  23 C2				AND	AX, DX			; combine with color mask 
				 
				;----------------------------------------------------------------------------; 
				; In gfx mode, if BL bit 7=1 then value of BL is XOR'ed with the bg color 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-173


				; 
 F4E5  84 DB				TEST	BL, BL			; high bit set? 
 F4E7  79 03				JNS	INT_10_9A_GFX_LOW_WR	; jump if not 
 F4E9  26: 33 05			XOR	AX, ES:[DI]			; XOR byte for current field 
 F4EC				INT_10_9A_GFX_LOW_WR: 
 F4EC  26: 89 05			MOV	ES:[DI], AX			; write 2 bytes to video memory 
 F4EF  81 F7 2000			XOR	DI, CGA_MEM_FLD		; alternate video fields 
 F4F3  F7 C7 2000			TEST	DI, CGA_MEM_FLD		; is an even field next? 
 F4F7  75 03				JNZ	INT_10_9A_GFX_LOW_NEXT	; jump if even (use same offset for even) 
 F4F9  83 C7 50				ADD	DI, 80			; if next is odd, move to next bitmap row 
 F4FC				INT_10_9A_GFX_LOW_NEXT: 
 F4FC  E2 CF				LOOP	INT_10_9A_GFX_LOW_BYTE	; loop 8 glyph bytes/lines 
				 
 F4FE  59				POP	CX				; restore repeat counter 
 F4FF  5F				POP	DI 
 F500  5E				POP	SI 
 F501  47				INC	DI				; move to next video mem WORD offset 
 F502  47				INC	DI 
 F503  E2 C2				LOOP	INT_10_9A_GFX_LOW_CHAR	; repeat for CX number of chars 
				 
 F505				INT_10_9A_MODE_GFX_DONE: 
					POPX	DS, SI, DX, BX, AX 
			     1				IFNB <DS>			; exit if last reg 
 F505  1F                    1		POP	DS 					; pop register and repeat 
			     1		POPX	SI, DX, BX, AX, , ,  
			     2				IFNB <SI>			; exit if last reg 
 F506  5E                    2		POP	SI 					; pop register and repeat 
			     2		POPX	DX, BX, AX, , , ,  
			     3				IFNB <DX>			; exit if last reg 
 F507  5A                    3		POP	DX 					; pop register and repeat 
			     3		POPX	BX, AX, , , , ,  
			     4				IFNB <BX>			; exit if last reg 
 F508  5B                    4		POP	BX 					; pop register and repeat 
			     4		POPX	AX, , , , , ,  
			     5				IFNB <AX>			; exit if last reg 
 F509  58                    5		POP	AX 					; pop register and repeat 
			     5		POPX	, , , , , ,  
			     6				ENDIF 
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
				 
 F50A				INT_10_9A_MODE_GFX_EXIT: 
 F50A  59				POP	CX				; restore CX and rebalance stack 
 F50B  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; High-res (640x200) graphics mode 6 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AX = ASCII character to write * 8 bytes 
				;	BH = current video mode 
				;	BL = foreground color 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-174


				;	CX = number of times to repeat character 
				;	DS:SI = start of character offset in font bitmap table 
				;	ES:DI = cursor location in video RAM 
				;----------------------------------------------------------------------------; 
				; Things you must do: 
				;	1. If BL has high bit set, XOR new char with current char 
				;	2. Write new bitmap to CGA interlaced video memory 
				;----------------------------------------------------------------------------; 
				 
				;----------------------------------------------------------------------------; 
				; Repeat for number of chars to write in CX 
				; 
 F50C				INT_10_9A_GFX_HIGH: 
 F50C  56				PUSH	SI				; save char glyph start offset for each loop 
 F50D  57				PUSH	DI				; start each char at first row of vid mem 
				 
				;----------------------------------------------------------------------------; 
				; Copy glyph bitmap to interlaced video memory 
				; 
 F50E  B7 04				MOV	BH, 4				; loop 4 words (8 bytes) 
 F510				INT_10_9A_GFX_HIGH_WORD: 
 F510  AD				LODSW					; load next two glyph rows 
				 
				;----------------------------------------------------------------------------; 
				; In gfx mode, if BL bit 7=1 then value of BL is XOR'ed with the bg color 
				; 
 F511  84 DB				TEST	BL, BL			; high bit set? 
 F513  79 08				JNS	INT_10_9A_GFX_HIGH_WR	; jump if not 
 F515  26: 32 05			XOR	AL, ES:[DI]			; XOR byte on odd field 
 F518  26: 32 A5 2000			XOR	AH, ES:CGA_MEM_FLD[DI]	; and even field 
				 
				;----------------------------------------------------------------------------; 
				; Write next two bytes to each field 
				; 
 F51D				INT_10_9A_GFX_HIGH_WR: 
 F51D  AA				STOSB					; write odd field in AL 
 F51E  26: 88 A5 1FFF			MOV	ES:CGA_MEM_FLD[DI][-1], AH	; write even field in AH 
 F523  83 C7 4F				ADD	DI, 80-1			; move to next bitmap row 
 F526  FE CF				DEC	BH 
 F528  75 E6				JNZ	INT_10_9A_GFX_HIGH_WORD	; loop 4 words 
 F52A  5F				POP	DI				; restore video mem cursor offset 
 F52B  5E				POP	SI				; restore start of glyph 
 F52C  47				INC	DI				; move to next video mem BYTE offset  
 F52D  E2 DD				LOOP	INT_10_9A_GFX_HIGH	; repeat for CX number of chars 
 F52F  EB D4				JMP	INT_10_9A_MODE_GFX_DONE	; exit 
				 
				;----------------------------------------------------------------------------; 
				; Calculate graphics memory address for current current position 
				;----------------------------------------------------------------------------; 
				; Input: DS = BDA 
				; Output: 
				;	DI = Current cursor vid mem offset 
				; 
				; Clobbers DX 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-175


 F531				INT_10_GFX_CHARPOS PROC 
							ASSUME DS:_BDA 
 F531  8B F8				MOV	DI, AX			; save original AX 
 F533  A0 004A R			MOV	AL, BYTE PTR VID_COLS	; AL = screen mode cols (40 or 80) 
 F536  8B 16 0050 R			MOV	DX, VID_CURS_POS		; DH = cursor row pos, DL = column 
 F53A  F6 E6				MUL	DH				; AX = screen cols * current row 
 F53C  D1 E0				SHL	AX, 1				; AX = AX * 4 
 F53E  D1 E0				SHL	AX, 1				; (8 rows / 2 fields) 
 F540  92				XCHG	AX, DX			; AL = current column, DX = row offset 
 F541  98				CBW					; AX = current column 
 F542  03 C2				ADD	AX, DX			; AX = current row/column vid mem offset 
 F544  97				XCHG	AX, DI			; AX = original, DI = row/col vid mem offset 
 F545  C3				RET 
 F546				INT_10_GFX_CHARPOS ENDP 
				 
 F546				INT_10_9A_MODE_GFX ENDP 
				 
 F546				INT_10_A ENDP 
 F546				INT_10_9 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,B - Set color palette 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AH = 0B 
				;	BH = palette color ID 
				;	   = 0 to set background and border color 
				;	   = 1 to select 4 color palette 
				;	BL = color value (when BH = 0) 
				;	   = palette value (when BH = 1) 
				;----------------------------------------------------------------------------; 
				;	|7|6|5|4|3|2|1|0|  3D9 Color Select Register (Graphics) 
				;	 | | | | | `-------- RGB for background 
				;	 | | | | `--------- intensity 
				;	 | | | `---------- unused 
				;	 | | `----------- 1 = palette 1, 0=palette 0 (see below) 
				;	 `-------------- unused 
				;	  Palette 0 = green, red, brown 
				;	  Palette 1 = cyan, magenta, white 
				; 
				; VID_CSGFX	RECORD	CGPH:2=11B,CGPL:1,CGX:1,CGIN:1,CGBG:3 
				;----------------------------------------------------------------------------; 
 F546				INT_10_B PROC 
 F546  50				PUSH	AX 
 F547  A0 0066 R			MOV	AL, VID_COLOR			; get current color byte 
 F54A  84 FF				TEST	BH, BH				; set BG/border or palette? 
 F54C  75 07				JNZ	INT_10_B_SET_PAL			; jump if set palette 
 F54E				INT_10_B_SET_COL: 
 F54E  24 E0				AND	AL, MASK CGPH OR MASK CGPL	; isolate current palette 
 F550  80 E3 1F				AND	BL, 00011111B			; isolate color bits 
 F553  EB 0B				JMP	SHORT INT_10_B_DONE 
 F555				INT_10_B_SET_PAL: 
 F555  24 DF				AND	AL, NOT MASK CGPL			; clear palette bit 
 F557  80 E3 01				AND	BL, 00000001B			; isolate palette selector bit 
							ELSE 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-176


						REPT	3 
					ROR	BL, 1					; move low bit into bit 5 
						ENDM 
 F55A  D0 CB                 1		ROR	BL, 1					; move low bit into bit 5 
 F55C  D0 CB                 1		ROR	BL, 1					; move low bit into bit 5 
 F55E  D0 CB                 1		ROR	BL, 1					; move low bit into bit 5 
							ENDIF 
 F560				INT_10_B_DONE: 
 F560  0A C3				OR	AL, BL				; combine bytes 
 F562  A2 0066 R			MOV	VID_COLOR, AL			; save to BDA 
 F565  52				PUSH	DX 
 F566  8B 16 0063 R			MOV	DX, VID_PORT 
 F56A  83 C2 05				ADD	DX, CGA_COLOR-CGA_IDX		; DX = 6845 color select reg (3D9H) 
 F56D  EE				OUT	DX, AL				; send to CGA Color Select Register 
 F56E  5A				POP	DX 
 F56F  58				POP	AX 
 F570  C3				RET 
 F571				INT_10_B ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,C - Write graphics pixel at coordinate 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AL = color value (XOR'ed with current pixel if bit 7=1) 
				;	BH = page number, see VIDEO PAGES 
				;	CX = column number (zero based) 
				;	DX = row number (zero based) 
				;----------------------------------------------------------------------------; 
 F571				INT_10_C PROC 
 F571  50				PUSH	AX 
 F572  51				PUSH	CX 
 F573  E8 F59F R			CALL	INT_10_GFX_PIXEL		; ES:DI = memory offset, AH/CL mask/counter 
 F576  8A E8				MOV	CH, AL			; save original AL 
 F578  22 C4				AND	AL, AH			; mask only selected pixel 
 F57A  D2 E0				SHL	AL, CL			; shift into correct bit position 
 F57C  84 ED				TEST	CH, CH			; is high bit of color value set? 
 F57E  78 0D				JS	INT_10_C_XOR		; if so, XOR byte in memory 
 F580  D2 E4				SHL	AH, CL			; shift mask for pixel position 
 F582  F6 D4				NOT	AH				; invert mask to clear current pixel 
 F584  26: 22 25			AND	AH, ES:[DI]			; clear pixel bits 
 F587  0A C4				OR	AL, AH			; replace with new pixel value 
 F589  AA				STOSB					; write to video buffer 
 F58A				INT_10_C_DONE: 
 F58A  59				POP	CX 
 F58B  58				POP	AX 
 F58C  C3				RET 
 F58D				INT_10_C_XOR: 
 F58D  26: 30 05			XOR	ES:[DI], AL			; just XOR and 'XIT 
 F590  EB F8				JMP	SHORT INT_10_C_DONE 
 F592				INT_10_C ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,D - Read graphics pixel at coordinate 
				;----------------------------------------------------------------------------; 
				; Input: 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-177


				;	BH = page number 
				;	CX = X / column (zero based) 
				;	DX = Y / row (zero based) 
				; Output: 
				;	AL = color of pixel read 
				;	AH clobbered 
				;----------------------------------------------------------------------------; 
 F592				INT_10_D PROC 
 F592  51				PUSH	CX 
 F593  E8 F59F R			CALL	INT_10_GFX_PIXEL		; ES:DI = memory offset, AH/CL mask/counter 
 F596  26: 8A 05			MOV	AL, ES:[DI]			; read packed pixel byte 
 F599  D2 E8				SHR	AL, CL			; shift into low order bit(s) 
 F59B  22 C4				AND	AL, AH			; mask only selected pixel 
 F59D  59				POP	CX 
 F59E  C3				RET 
 F59F				INT_10_D ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Get Video Memory Pixel Offset and Pixel Byte Mask 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	CX = X / column (zero based) 
				;	DX = Y / row (zero based) 
				; 
				; Output 
				;	DI = pixel byte offset 
				;	AH = pixel data mask 
				;	CL = pixel right shift counter 
				;	CH = pixel index (big endian) 
				;	ES = VID_MEM_SEG 
				; 
				; Example of read: 
				;	MOV	AL, PIXEL_DAT 
				;	SHR	AL, CL 
				;	AND	AL, AH 
				; 
				; http://www.techhelpmanual.com/89-video_memory_layouts.html 
				;----------------------------------------------------------------------------; 
 F59F				INT_10_GFX_PIXEL PROC 
 F59F  C4 3E 00E8 R			LES	DI, VID_MEM_SEG_DW	; ES = video/regen RAM segment 
 F5A3  53				PUSH	BX 
 F5A4  52				PUSH	DX 
				 
				;----------------------------------------------------------------------------; 
				; Calculate X offset 
				; 
 F5A5  8B F9				MOV	DI, CX			; DI = X position (zero based) 
 F5A7  D1 EF				SHR	DI, 1 
 F5A9  D1 EF				SHR	DI, 1				; DI = DI / 4 (two bit alignment) 
				 
				;----------------------------------------------------------------------------; 
				; Unpack pixel bit(s) 
				; 
 F5AB  B4 03				MOV	AH, 0011B			; pixel mask = 0011B 
 F5AD  8A DC				MOV	BL, AH			; index mask = 0011B (bits 0-3) 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-178


 F5AF  8A E9				MOV	CH, CL			; save CH = CL 
 F5B1  B1 01				MOV	CL, 1				; ROL multiplier = 1 
 F5B3  80 3E 0049 R 06			CMP	VID_MODE, 6			; is 640x200 gfx mode? 
 F5B8  72 07				JB	NOT_HI_RES			; if low-res, skip 
				 
				;----------------------------------------------------------------------------; 
				; Is "high res" (640x200) 
				; 
 F5BA  D0 EC				SHR	AH, 1				; pixel mask = 0001B 
 F5BC  D0 D3				RCL	BL, 1				; index mask = 0111B (bits 0-7) 
 F5BE  49				DEC	CX				; ROL multiplier = 0 
 F5BF  D1 EF				SHR	DI, 1				; DI = DI / 8 (one bit alignment) 
 F5C1				NOT_HI_RES: 
				 
				;----------------------------------------------------------------------------; 
				; Calculate right-shift counter: 
				; - 640x200: CL = (7 - i) * 1 
				; - 320x200: CL = (3 - i) * 2 
				; 
 F5C1  22 EB				AND	CH, BL			; CH = packed pixel index 
 F5C3  2A DD				SUB	BL, CH			; calculate right-shift counter 
 F5C5  D2 E3				SHL	BL, CL			; multiply by 1 (high res) or 2 (low res) 
 F5C7  8A CB				MOV	CL, BL			; CL = shift count 
				 
				;----------------------------------------------------------------------------; 
				; Calculate Y offset 
				; 
				; Y offset = (DX / 2) * 80 + 2000H[DX is odd] 
				; 
 F5C9  D1 EA				SHR	DX, 1				; DX = DX / 2 
 F5CB  86 D6				XCHG	DL, DH			; DX = DX << 8 
 F5CD  73 04				JNC	FIELD_EVEN			; is odd or even field? 
 F5CF  81 C7 2000			ADD	DI, CGA_MEM_FLD		; odd field address offset 
 F5D3				FIELD_EVEN: 
 F5D3  D1 EA				SHR	DX, 1 
 F5D5  D1 EA				SHR	DX, 1 
 F5D7  03 FA				ADD	DI, DX			; DI += (DX / 2) * 16 
 F5D9  D1 EA				SHR	DX, 1 
 F5DB  D1 EA				SHR	DX, 1 
 F5DD  03 FA				ADD	DI, DX			; DI += (DX / 2) * 64 
 F5DF  5A				POP	DX 
 F5E0  5B				POP	BX 
 F5E1  C3				RET 
 F5E2				INT_10_GFX_PIXEL ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,E - Write text in teletype mode 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AH = 0E 
				;	AL = ASCII character to write 
				;	BH = page number (text modes) - override it with BDA value though 
				;	BL = foreground pixel color (graphics modes) 
				; 
				; Output: 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-179


				;	Character to console 
				;	All registers preserved 
				;----------------------------------------------------------------------------; 
				; Things you must do: 
				;	1. Get video page from BDA - ignore what was passed in BH (why?) 
				;	2. Get cursor location (INT 10,3) and keep it handy. 
				;	3. Check for the four special control codes: BELL(7), BS(8), LF(A), CR(D) 
				;		- BELL: beep and exit 
				;		- Backspace: if cursor column is 0, exit else DEC col and go to 6 
				;		- CR: set cursor to column 0 and go to step 6 
				;		- LF: increment row and go to step 5 to check if scroll is needed 
				;	4. Write the char to the current position (INT 10,A) 
				;	5. If new row > last row, scroll up 1 row (INT 10,8). 
				;	6. Update cursor position (INT 10,6) 
				; 
				;----------------------------------------------------------------------------; 
 F5E2				INT_10_E PROC 
					PUSHX	AX, BX, CX, DX 
			     1				IFNB <AX>			; exit if last reg 
 F5E2  50                    1		PUSH	AX 					; push register and repeat 
			     1		PUSHX	BX, CX, DX, , , ,  
			     2				IFNB <BX>			; exit if last reg 
 F5E3  53                    2		PUSH	BX 					; push register and repeat 
			     2		PUSHX	CX, DX, , , , ,  
			     3				IFNB <CX>			; exit if last reg 
 F5E4  51                    3		PUSH	CX 					; push register and repeat 
			     3		PUSHX	DX, , , , , ,  
			     4				IFNB <DX>			; exit if last reg 
 F5E5  52                    4		PUSH	DX 					; push register and repeat 
			     4		PUSHX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F5E6  E8 F1EF R			CALL	INT_10_3_CUR_PAGE		; Get cursor pos: DH = row, DL = column 
 F5E9  3C 0D				CMP	AL, CR			; is maybe a control code? 
 F5EB  76 3E				JBE	INT_10_E_CTRL		; if so, jump to handle it 
				 
				;----------------------------------------------------------------------------; 
				; Handle a regular char 
				; 
 F5ED				INT_10_E_CHAR: 
 F5ED  B9 0001				MOV	CX, 1				; repeat only once 
 F5F0  E8 F41E R			CALL	INT_10_A			; write char in AL at current row/col 
				 
				;----------------------------------------------------------------------------; 
				; Handle line wrap 
				; 
 F5F3  A0 004A R			MOV	AL, BYTE PTR VID_COLS	; get screen cols (80 or 40) 
 F5F6  48				DEC	AX				; fix 0 index (79 or 39) 
 F5F7  3A D0				CMP	DL, AL			; reached end of screen cols? 
 F5F9  72 02				JB	NEXT_COL			; jump if not 
 F5FB  B2 FF				MOV	DL, -1			; else move to first col and next row 
 F5FD				NEXT_COL: 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-180


 F5FD  42				INC	DX				; move to next column (and maybe row) 
				 
				;----------------------------------------------------------------------------; 
				; Scroll if necessary 
				; 
 F5FE				INT_10_E_SCROLL: 
 F5FE  80 FE 18				CMP	DH, VID_DEF_ROWS		; moved past last row? 
 F601  76 20				JBE	INT_10_E_CURS		; if not, no scroll necessary 
 F603  FE CE				DEC	DH				; undo row scroll 
 F605  E8 F085 R			CALL	INT_10_IS_TXT		; ZF = 1 if CGA/MDA Text, ZF = 0 if gfx 
 F608  98				CBW					; if gfx mode, attribute AH = 0 
 F609  75 03				JNZ	INT_10_E_SCROLL_UP	; jump if graphics 
 F60B  E8 F365 R			CALL	INT_10_8			; Read character: AH = attribute, AL = char 
				 
				;----------------------------------------------------------------------------; 
				; Scroll up one line 
				; 
 F60E				INT_10_E_SCROLL_UP: 
 F60E  53				PUSH	BX				; save video page (BH) 
 F60F  93				XCHG	AX, BX			; BH = attribute 
 F610  B8 0601				MOV	AX, DBW <6, 1>		; AH = 06H Scroll Window Up, AL = 1 line 
 F613  33 C9				XOR	CX, CX			; scroll top left: CH = row 0, CL = col 0 
 F615  52				PUSH	DX				; save cursor bottom 
 F616  8A 16 004A R			MOV	DL, BYTE PTR VID_COLS	; DL = right-most column (1-indexed) 
 F61A  B6 18				MOV	DH, VID_DEF_ROWS		; DH = bottom row (always 24) 
 F61C  4A				DEC	DX				; fixup 0-indexed column 
 F61D  FC				CLD 
 F61E  E8 F235 R			CALL	INT_10_6			; INT 10H, 06H Scroll Window Up 
 F621  5A				POP	DX				; restore cursor bottom 
 F622  5B				POP	BX				; restore video page (BH) 
				 
				;----------------------------------------------------------------------------; 
				; Set new cursor position 
				; 
 F623				INT_10_E_CURS: 
 F623  E8 F1B6 R			CALL	INT_10_2			; set cursor pos: BH = page, row = DH, col = DL 
				 
 F626				INT_10_E_DONE: 
					POPX	DX, CX, BX, AX		; restore caller registers 
			     1				IFNB <DX>			; exit if last reg 
 F626  5A                    1		POP	DX 					; pop register and repeat 
			     1		POPX	CX, BX, AX, , , ,  
			     2				IFNB <CX>			; exit if last reg 
 F627  59                    2		POP	CX 					; pop register and repeat 
			     2		POPX	BX, AX, , , , ,  
			     3				IFNB <BX>			; exit if last reg 
 F628  5B                    3		POP	BX 					; pop register and repeat 
			     3		POPX	AX, , , , , ,  
			     4				IFNB <AX>			; exit if last reg 
 F629  58                    4		POP	AX 					; pop register and repeat 
			     4		POPX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-181


			     1				ENDIF 
 F62A  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; Handle control codes 
				; 
 F62B				INT_10_E_CTRL: 
 F62B  74 11				JE	INT_10_E_CR			; is a CR? (from above) 
 F62D  3C 0A				CMP	AL, LF			; is an LF? 
 F62F  74 11				JE	INT_10_E_LF 
 F631  3C 08				CMP	AL, BS			; is a backspace? 
 F633  74 11				JE	INT_10_E_BS 
 F635  3C 07				CMP	AL, BELL			; Isabelle? 
 F637  75 B4				JNE	INT_10_E_CHAR		; otherwise, handle as a normal char 
 F639				INT_10_E_BELL: 
 F639  E8 E8AE R			CALL	BEEP				; beep for ^G 
 F63C  EB E8				JMP	INT_10_E_DONE		; exit 
 F63E				INT_10_E_CR: 
 F63E  32 D2				XOR	DL, DL			; move to column 0 
 F640  EB E1				JMP	INT_10_E_CURS		; update cursor 
 F642				INT_10_E_LF: 
 F642  FE C6				INC	DH				; move to next row 
 F644  EB B8				JMP	INT_10_E_SCROLL		; maybe scroll 
 F646				INT_10_E_BS: 
 F646  FE CA				DEC	DL				; back space one column 
 F648  78 DC				JS	INT_10_E_DONE		; if first column, do nothing and exit 
 F64A  EB D7				JMP	INT_10_E_CURS		; update cursor 
				 
 F64C				INT_10_E ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,F - Get current video state 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AH = 0F 
				; Output 
				;	AH = number of screen columns 
				;	AL = mode currently set 
				;	BH = current display page 
				;----------------------------------------------------------------------------; 
 F64C				INT_10_F PROC 
 F64C  A1 0049 R			MOV	AX, WORD PTR VID_MODE 
 F64F  8A 3E 0062 R			MOV	BH, VID_PAGE 
 F653  C3				RET 
 F654				INT_10_F ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Get video memory offset for current cursor position 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	BH = current video page 
				; Output: 
				;	DI = memory offset of current cursor in memory 
				;	ES = video RAM segment 
				; Clobbers: AX 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-182


				;----------------------------------------------------------------------------; 
 F654				INT_10_GET_CUR_ADDR PROC 
 F654  52				PUSH	DX 
 F655  8A C7				MOV	AL, BH			; AL = display page 
 F657  C4 3E 00E8 R			LES	DI, VID_MEM_SEG_DW	; ES = video RAM segment 
 F65B  98				CBW					; AX = page number 
 F65C  97				XCHG	AX, DI			; DI = page number 
 F65D  A1 004C R			MOV	AX, VID_BUF_SZ		; AX = VID_BUF_SZ 
 F660  F7 E7				MUL	DI				; AX = page size * page (base offset) 
 F662  D1 E7				SHL	DI, 1				; word align index 
 F664  8B 95 0050 R			MOV	DX, VID_CURS_POS[DI]	; DX = cursor position on page 
 F668  97				XCHG	AX, DI			; DI = page base offset 
 F669  A0 004A R			MOV	AL, BYTE PTR VID_COLS 
 F66C  F6 E6				MUL	DH				; AX = screen cols * current row 
 F66E  92				XCHG	AX, DX			; DX = rows offset, AL = current col 
 F66F  98				CBW					; AX = current col 
 F670  03 C2				ADD	AX, DX			; AX = page relative cursor offset 
 F672  D1 E0				SHL	AX, 1				; word align 
 F674  03 F8				ADD	DI, AX			; DI = memory offset of cursor 
 F676  5A				POP	DX 
 F677  C3				RET 
 F678				INT_10_GET_CUR_ADDR ENDP 
				 
				;----------------------------------------------------------------------------; 
				; 6845 CRT mode control register values 
				;----------------------------------------------------------------------------; 
				; CGA: 
				;	|7|6|5|4|3|2|1|0|  3D8H Mode Select Register 
				;	     | | | | | `---- 1 = 80x25 text, 0 = 40x25 text 
				;	     | | | | `----- 1 = 320x200 graphics, 0 = text (unused on MDA) 
				;	     | | | `------ 1 = B/W, 0 = color (unused on MDA) 
				;	     | | `------- 1 = enable video signal 
				;	     | `-------- 1 = 640x200 B/W graphics (unused on MDA) 
				;	     `--------- 1 = blink, 0 = no blink 
				; MDA: 
				;	|7|6|5|4|3|2|1|0|  3B8H CRT Control Port 
				;	     | | | | | `---- 1 = 80x25 text 
				;	     | | | `------- unused 
				;	     | | `-------- 1 = enable video signal 
				;	     | `--------- unused 
				;	     `---------- 1 = blinking on 
				; 
				; source: https://stanislavs.org/helppc/6845.html 
				;----------------------------------------------------------------------------; 
 F678  2C			CRT_MODE	DB	101100B	; 00: 40x25 B/W text (CGA) 
 F679  28					DB	101000B	; 01: 40x25 16 color text (CGA) 
 F67A  2D					DB 	101101B	; 02: 80x25 16 shades of gray text (CGA) 
 F67B  29					DB	101001B	; 03: 80x25 16 color text (CGA) 
 F67C  2A					DB	101010B	; 04: 320x200 4 color graphics (CGA) 
 F67D  2E					DB	101110B	; 05: 320x200 4 color graphics (CGA) 
 F67E  1E					DB	011110B	; 06: 640x200 B/W graphics (CGA) 
 F67F  29					DB	101001B	; 07: 80x25 Monochrome text (MDA, HERC) 
				 
 F680				INT_10 ENDP 
				 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-183


				;----------------------------------------------------------------------------; 
				; Display system hardware config 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	DS = BDA (0040) 
				; 
				; Clobbers: AX, BX, CX, SI 
				; Size: 193 bytes 
				;----------------------------------------------------------------------------; 
 F680				POST_SYS_CONFIG PROC 
							ASSUME DS:_BDA 
				 
							IF POST_VIDEO_TYPE EQ 1 
				;----------------------------------------------------------------------------; 
				; Display Video Type 
				;----------------------------------------------------------------------------; 
 F680				POST_SYS_VIDEO PROC 
					POST_COL_2	POST_VIDEO, POST_CLR_VAL1 ; display "Video" left column 
			     1			ENDIF 
			     1			ELSE 
 F680  B3 0A                 1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute 
			     1			ENDIF 
 F682  BE FF46 R             1		MOV	SI, OFFSET POST_VIDEO 
 F685  E8 F76D R             1		CALL	POST_START_COL_2 
			     1			ENDIF 
											; default to "None" 
				 
				;----------------------------------------------------------------------------; 
				; Check if INT 10 is using this BIOS. If so, must be CGA or MDA. 
				; 
 F688  1E				PUSH	DS 
 F689  33 C0				XOR	AX, AX				; AX = SEG _IVT 
 F68B  8E D8				MOV	DS, AX				; set IVT segment for LDS 
							ASSUME DS:_IVT 
 F68D  C5 06 0040 R			LDS	AX, DWORD PTR IVT_10		; if BIOS, DS = 0F000H, AX = 0F065H 
 F691  3D F065 R			CMP	AX, OFFSET INT_10			; is offset the BIOS IRR for INT 10? 
 F694  8C D8				MOV	AX, DS				; save for next compare 
 F696  1F				POP	DS					; restore DS 
							ASSUME DS:_BDA 
 F697  75 13				JNE	CHECK_VGA				; if not, jump to VGA check 
 F699  8C CB				MOV	BX, CS				; AX = BIOS code segment 
 F69B  3B C3				CMP	AX, BX				; is BIOS segment? 
 F69D  75 0D				JNE	CHECK_VGA				; if not, jump to VGA check 
				 
				;----------------------------------------------------------------------------; 
				; Read BDA for video type 
				; 
 F69F				BIOS_VIDEO: 
 F69F  E8 F085 R			CALL	INT_10_IS_TXT			; CF = 1 if MDA mode 7 
 F6A2  BE E826 R			MOV	SI, OFFSET POST_MDA		; default "MDA" 
 F6A5  72 21				JC	POST_SYS_VIDEO_DONE 
 F6A7  BE E822 R			MOV	SI, OFFSET POST_CGA		; otherwise "CGA" 
 F6AA  EB 1C				JMP	SHORT POST_SYS_VIDEO_DONE 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-184


				; Check if VGA 
				; stanislavs.org/helppc/int_10-1a.html 
				; 
 F6AC				CHECK_VGA: 
 F6AC  B8 1A00				MOV	AX, DBW <1AH, 0>			; AH = 1AH, get video display 
 F6AF  CD 10				INT	10H					; BL = display type 
 F6B1  3C 1A				CMP	AL, 1AH				; is VGA? 
 F6B3  75 05				JNE	CHECK_EGA				; jump if not VGA 
 F6B5  BE E81A R			MOV	SI, OFFSET POST_VGA		; is "VGA" 
 F6B8  EB 0E				JMP	SHORT POST_SYS_VIDEO_DONE 
				 
				;----------------------------------------------------------------------------; 
				; Check if EGA 
				; stanislavs.org/helppc/int_10-12.html 
				; 
 F6BA				CHECK_EGA: 
 F6BA  B4 12				MOV 	AH, 12H				; AH = 12H, get video configuration 
 F6BC  B3 10				MOV	BL, 10H				; configuration info 
 F6BE  CD 10				INT	10H 
 F6C0  80 FB 10				CMP	BL, 10H				; check if param hasn't changed 
 F6C3  74 03				JE	POST_SYS_VIDEO_DONE		; jump if not EGA 
 F6C5  BE E81E R			MOV	SI, OFFSET POST_EGA		; is "EGA" 
				 
 F6C8				POST_SYS_VIDEO_DONE: 
 F6C8  E8 F79F R			CALL	OUT_SZ				; display detected video adapter 
 F6CB  E8 F77F R			CALL	POST_END_COL_NL			; end of column with NL and RET 
				 
 F6CE				POST_SYS_VIDEO ENDP 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Display CPU type 
				; 
					POST_COL_1	POST_CPU, POST_CLR_VAL1	; display 'CPU' left column 
			     1			ENDIF 
			     1			ELSE 
 F6CE  B3 0A                 1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute 
			     1			ENDIF 
 F6D0  BE E4FA R             1		MOV	SI, OFFSET POST_CPU 
 F6D3  E8 F746 R             1		CALL	POST_START_COL_1 
			     1			ENDIF 
											;  SI now points to '8088' 
 F6D6				CPU_CHECK_TYPE_2: 
					TEST_GFLAG  V20				; ZF = 0 if V20, ZF = 1 if 8088 
 F6D6  F6 06 0012 R 04       1		TEST	GB_FLAGS, MASK V20 
 F6DB  74 03				JZ	CPU_CHECK_TYPE_2_DONE		; jump if 8088 
 F6DD  BE E520 R			MOV	SI, OFFSET POST_V20		; if not, is V20 
 F6E0				CPU_CHECK_TYPE_2_DONE: 
 F6E0  E8 F79F R			CALL	OUT_SZ				; write CPU type 
					POST_COL_END				; end first column 
			     1			ENDIF 
 F6E3  E8 F784 R             1		CALL	POST_END_COL 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-185


				; Display FPU/math co-processor 
				; 
 F6E6				FPU_CHECK: 
					POST_COL_2  POST_FPU, POST_CLR_VAL1	; display 'FPU', SI now '8087' 
			     1			ENDIF 
			     1			ELSE 
 F6E6  B3 0A                 1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute 
			     1			ENDIF 
 F6E8  BE E503 R             1		MOV	SI, OFFSET POST_FPU 
 F6EB  E8 F76D R             1		CALL	POST_START_COL_2 
			     1			ENDIF 
					TEST_EFLAG  FPU				; was FPU detected? 
			     1				IF FPU LT 8 
 F6EE  F6 06 0010 R 02       1		TEST	BYTE PTR EQUIP_FLAGS, LOW MASK FPU 
			     1				ENDIF 
 F6F3  75 03				JNZ	FPU_DISP_DONE			; jump to output if FPU 
 F6F5  BE FF4C R			MOV	SI, OFFSET POST_NONE		; otherwise 'None' 
 F6F8				FPU_DISP_DONE: 
 F6F8  E8 F79F R			CALL	OUT_SZ				; display string 
					POST_COL_END_NL				; end second column, move to NL 
			     1			ENDIF 
 F6FB  E8 F77F R             1		CALL	POST_END_COL_NL 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Display LPT ports 
				; 
					POST_COL_1	POST_LPT, POST_CLR_VAL2	; display 'LPT' in column 1 
			     1			ENDIF 
			     1			ELSE 
 F6FE  B3 0E                 1		MOV	BL, LOW POST_CLR_VAL2		; BL = attribute 
			     1			ENDIF 
 F700  BE E524 R             1		MOV	SI, OFFSET POST_LPT 
 F703  E8 F746 R             1		CALL	POST_START_COL_1 
			     1			ENDIF 
					GET_EFLAG   LPT				; AX = number of LPT ports 
			     1				ENDIF 
			     1	;----------------------------------------------------------------------------; 
			     1	; Shift if flag is in high byte to low for byte operations 
			     1	; 
			     1				ELSE				; is in high byte 
 = 00C0                      1	??003B	= HIGH MASK LPT 
 = 0006                      1	??003C	= (LPT - 8) AND 0111B 
 = 0011                      1	??003D	= EQUIP_FLAGS[1]			; high BDA flags byte 
			     1				ENDIF 
 F706  A0 0011 R             1		MOV	AL, BYTE PTR ??003D		; AL = equipment flag byte 
 F709  25 00C0               1		AND	AX, ??003B			; isolate bits, clear AH 
			     1	;----------------------------------------------------------------------------; 
			     1	; Determine optimal number of shifts based on bit position and shift 
			     1	; right or left depending on fewest. 
			     1	; 
			     1				ELSE 
			     1					IF ??003C GT 4	; optimal to roll left 
 = 0002                      1						??003C = 8-??003C 
			     1						ELSE		; 0-2 shifts use single op(s) 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-186


			     1							REPT ??003C 
			     1		ROL	AL, 1					; shift value into position 
			     1							ENDM 
 F70C  D0 C0                 2		ROL	AL, 1					; shift value into position 
 F70E  D0 C0                 2		ROL	AL, 1					; shift value into position 
			     1						ENDIF 
			     1					ENDIF 
			     1				ENDIF 
			     1				ENDIF 
 F710  91				XCHG	AX, CX				; CX = number of ports 
 F711  BE 0008 R			MOV	SI, OFFSET LPT_ADDR 
 F714  E8 F72A R			CALL	SHOW_PORT_COUNT 
				 
				;----------------------------------------------------------------------------; 
				; Display COM ports 
				; 
					POST_COL_2	POST_COM, POST_CLR_VAL2	; display 'COM' in column 2 
			     1			ENDIF 
			     1			ELSE 
 F717  B3 0E                 1		MOV	BL, LOW POST_CLR_VAL2		; BL = attribute 
			     1			ENDIF 
 F719  BE E528 R             1		MOV	SI, OFFSET POST_COM 
 F71C  E8 F76D R             1		CALL	POST_START_COL_2 
			     1			ENDIF 
					GET_EFLAG   COM				; AX = number of COM ports 
			     1				ENDIF 
			     1	;----------------------------------------------------------------------------; 
			     1	; Shift if flag is in high byte to low for byte operations 
			     1	; 
			     1				ELSE				; is in high byte 
 = 000E                      1	??003E	= HIGH MASK COM 
 = 0001                      1	??003F	= (COM - 8) AND 0111B 
 = 0011                      1	??0040	= EQUIP_FLAGS[1]			; high BDA flags byte 
			     1				ENDIF 
 F71F  A0 0011 R             1		MOV	AL, BYTE PTR ??0040		; AL = equipment flag byte 
 F722  25 000E               1		AND	AX, ??003E			; isolate bits, clear AH 
			     1	;----------------------------------------------------------------------------; 
			     1	; Determine optimal number of shifts based on bit position and shift 
			     1	; right or left depending on fewest. 
			     1	; 
			     1				ELSE 
			     1					ELSE			; optimal to roll right 
			     1						ELSE 
			     1							REPT ??003F 
			     1		ROR	AL, 1					; shift value into position 
			     1							ENDM 
 F725  D0 C8                 2		ROR	AL, 1					; shift value into position 
			     1						ENDIF 
			     1					ENDIF 
			     1				ENDIF 
			     1				ENDIF 
 F727  91				XCHG	AX, CX				; CX = number of ports 
 F728  33 F6				XOR	SI, SI				; OFFSET COM_ADDR = 0000H 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-187


				; Display I/O addresses of COM or LPT ports on POST 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	SI = WORD array of ports 
				;	CX = number of ports to show 
				;----------------------------------------------------------------------------; 
 F72A				SHOW_PORT_COUNT PROC 
 F72A  E3 0E				JCXZ	PORT_COUNT_NONE			; if no ports, display 'None' 
 F72C				PORT_COUNT_LOOP: 
 F72C  AD				LODSW	 
 F72D  E8 F7FC R			CALL	WORD_HEX				; display I/O address in hex 
 F730  E8 F7D1 R			CALL	SPACE					; separate ports with space 
 F733  E2 F7				LOOP	PORT_COUNT_LOOP 
 F735  BE E539 R			MOV	SI, OFFSET POST_RSEP[1]		; skip leading space in right sep. 
 F738  EB 4D				JMP	SHORT POST_END_COL_STR		; display end with sep. in SI and RET 
 F73A				PORT_COUNT_NONE: 
					PRINT_SZ  POST_NONE			; display 'None' 
			     1			ENDIF 
			     1			IFDIFI <POST_NONE>,<SI>			; if SZ is not SI 
 F73A  BE FF4C R             1		MOV	SI, OFFSET POST_NONE 
			     1			ENDIF 
 F73D  E8 F79F R             1		CALL	OUT_SZ 
			     1			ENDIF 
 F740  EB 42				JMP	SHORT POST_END_COL		; display end sep and RET 
 F742				SHOW_PORT_COUNT ENDP 
				 
 F742				POST_SYS_CONFIG ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Write POST column label and start separator  
				;----------------------------------------------------------------------------; 
				; - Start new line 
				; - display column name in color 1 
				; - display left separator in color 1 
				; - set color for inner text to be color 2 
				;----------------------------------------------------------------------------; 
				; Input: 
				; - SI: column name string 
				; - BL: inner text color/attribute 
				; 
				; Output: 
				; - SI: beginning of next adjacent string 
				; - CX: inner text color length = POST_TAB_COL_I 
				;----------------------------------------------------------------------------; 
 F742				POST_COL PROC 
				 
				;----------------------------------------------------------------------------; 
				; Handle 40 column mode - move to next line and fall through to col 1 
				; 
 F742				POST_START_COL_2_40: 
 F742  E8 F7C8 R			CALL	CRLF				; move to next line 
 F745  58				POP	AX				; rebalance stack 
 F746				POST_START_COL_1 PROC 
 F746  50				PUSH	AX 
 F747  B0 06				MOV	AL, POST_COL_W		; column 1 tab width 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-188


 F749				POST_START_COL_START: 
 F749  53				PUSH	BX				; save inner text color 
 F74A  8A E3				MOV	AH, BL			; save text color 
 F74C  B9 0009				MOV	CX, POST_COL_VT		; set attribute on next CX # of chars 
 F74F  BB 0003				MOV	BX, LOW POST_CLR_TXT	; set outer text color 
 F752  E8 F78D R			CALL	OUT_SZ_ATTR			; write SI string with attribute 
 F755  E8 F7AE R			CALL	MOVE_COL			; move cursor to separator column 
 F758  56				PUSH	SI				; save end of string 
 F759  BE E534 R			MOV	SI, OFFSET POST_LSEP	; write separator string with 
 F75C  E8 F79F R			CALL	OUT_SZ			;  existing attributes 
 F75F  8A DC				MOV	BL, AH			; restore text color 
 F761  4E				DEC	SI				; [SI] = previous null char 
 F762  B1 13				MOV	CL, POST_TAB_COL_I	; CX = repeat times 
 F764  51				PUSH	CX				; save for return 
 F765  E8 F78D R			CALL	OUT_SZ_ATTR			; set attributes, skip null string 
 F768  59				POP	CX				; CX = inner text color length 
 F769  5E				POP	SI				; restore string position 
 F76A  5B				POP	BX				; BL = attribute for next CX chars 
 F76B  58				POP	AX 
 F76C  C3				RET 
 F76D				POST_START_COL_1 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Same as POST_START_COL_1 except starts at column 2 
				;----------------------------------------------------------------------------; 
 F76D				POST_START_COL_2 PROC 
							ASSUME DS:_BDA 
 F76D  50				PUSH	AX 
 F76E  B4 0F				MOV	AH, 0FH			; get video mode 
 F770  CD 10				INT	10H				; AL = video mode 
 F772  3C 01				CMP	AL, 1				; is 40 column mode? 
 F774  7E CC				JLE	POST_START_COL_2_40 
 F776  B0 20				MOV	AL, POST_TAB_COL		; move to start of column 2 
 F778  E8 F7AE R			CALL	MOVE_COL 
 F77B  B0 26				MOV	AL, POST_TAB_COL+POST_COL_W	; set abs. position for column 2 tab 
 F77D  EB CA				JMP	POST_START_COL_START 
 F77F				POST_START_COL_2 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Same as POST_END_COL and displays a CRLF 
				;----------------------------------------------------------------------------; 
 F77F				POST_END_COL_NL PROC 
 F77F  E8 F784 R			CALL	POST_END_COL 
 F782  EB 44				JMP	SHORT CRLF			; write CRLF and RET 
 F784				POST_END_COL_NL ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Write POST column end separator  
				;----------------------------------------------------------------------------; 
				; Display right separator in color POST_CLR_TXT 
				; Clobbers: BX 
				;----------------------------------------------------------------------------; 
 F784				POST_END_COL PROC 
 F784  BE E538 R			MOV	SI, OFFSET POST_RSEP 
				 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-189


				;----------------------------------------------------------------------------; 
				; POST_END_COL_STR: Write POST column end separator 
				;----------------------------------------------------------------------------; 
				; Input: CS:SI 
				;----------------------------------------------------------------------------; 
 F787				POST_END_COL_STR PROC 
 F787  B9 0002				MOV	CX, 2 
 F78A  BB 0003				MOV	BX, LOW POST_CLR_TXT	; Fall through to OUT_SZ_ATTR and RET 
				 
				;----------------------------------------------------------------------------; 
				; Write a zero-terminated string to console with attributes, no cursor move 
				;----------------------------------------------------------------------------; 
				; Sets attribute in BL for the next CX number of characters, past end of string. 
				; 
				; Input: CS:SI = String, CX = length, BL = attribute, BH = video page 
				; Output: SI = end of string 
				;----------------------------------------------------------------------------; 
 F78D				OUT_SZ_ATTR PROC 
							IF POST_THEME NE 0	; enable color/attribute display 
 F78D  50				PUSH	AX 
				 
							IF MDA_ATTR LT 2	; filter MDA attributes 
				;----------------------------------------------------------------------------; 
				; Filter MDA attributes - display with intensity attribute only 
				; 
 F78E				MDA_COLOR_FIX: 
 F78E  E8 F085 R			CALL	INT_10_IS_TXT		; CF if MDA 
 F791  73 06				JNC	OUT_SZ_ATTR_SET		; skip if not MDA 
							IF MDA_ATTR EQ 1	; only intensity 
 F793  80 E3 0F				AND	BL, MASK MDIN OR MASK MDFG ; remove MDA blink and background attr 
 F796  80 CB 07				OR	BL, MASK MDFG		; remove MDA underline attr 
							ENDIF 
							ENDIF 
 F799				OUT_SZ_ATTR_SET: 
 F799  B8 0920				MOV	AX, DBW <9, VID_SP>	; write empty char with attr CX # of times 
 F79C  CD 10				INT	10H 
 F79E  58				POP	AX				; Fall through to OUT_SZ and RET 
							ENDIF			; POST_THEME NE 0 
				 
				;----------------------------------------------------------------------------; 
				; Display a zero-terminated string in BIOS at CS:[SI] 
				;----------------------------------------------------------------------------; 
				; Input: CS:SI = String, BH = video page 
				; Size: 24 bytes 
				;----------------------------------------------------------------------------; 
 F79F				OUT_SZ PROC 
 F79F  50				PUSH	AX 
 F7A0  B4 0E				MOV	AH, 0EH			; TTY output 
 F7A2				OUT_SZ_LOOP: 
 F7A2  2E: AC				LODS	BYTE PTR CS:[SI]		; AL = CS:[SI++] 
 F7A4  84 C0				TEST	AL, AL			; is zero terminator? 
 F7A6  74 04				JZ	OUT_SZ_DONE			; if so, exit 
 F7A8  CD 10				INT	10H 
 F7AA  EB F6				JMP	SHORT OUT_SZ_LOOP 
 F7AC				OUT_SZ_DONE: 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-190


 F7AC  58				POP	AX 
 F7AD  C3				RET 
 F7AE				OUT_SZ ENDP 
 F7AE				OUT_SZ_ATTR ENDP 
 F7AE				POST_END_COL_STR ENDP 
 F7AE				POST_END_COL ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Locate cursor to column on current line 
				;----------------------------------------------------------------------------; 
				; Input: 
				; - AL = new col 
				; 
				; Size: 23 bytes 
				;----------------------------------------------------------------------------; 
 F7AE				MOVE_COL PROC 
							ELSE 
					PUSHX	AX, BX, CX, DX		; must preserve all of these 
			     1				IFNB <AX>			; exit if last reg 
 F7AE  50                    1		PUSH	AX 					; push register and repeat 
			     1		PUSHX	BX, CX, DX, , , ,  
			     2				IFNB <BX>			; exit if last reg 
 F7AF  53                    2		PUSH	BX 					; push register and repeat 
			     2		PUSHX	CX, DX, , , , ,  
			     3				IFNB <CX>			; exit if last reg 
 F7B0  51                    3		PUSH	CX 					; push register and repeat 
			     3		PUSHX	DX, , , , , ,  
			     4				IFNB <DX>			; exit if last reg 
 F7B1  52                    4		PUSH	DX 					; push register and repeat 
			     4		PUSHX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
							ENDIF 
 F7B2  50				PUSH	AX				; preserve AL on INT 10H call 
 F7B3  B7 00				MOV	BH, 0 			; video page 0 (flags preserved) 
 F7B5  B4 03				MOV	AH, 3 			; get cursor position 
 F7B7  CD 10				INT	10H 				; DH = row, DL = column 
 F7B9  58				POP	AX 
 F7BA				MOVE_COL_SET: 
 F7BA  8A D0				MOV	DL, AL			; set new column 
 F7BC  B4 02				MOV	AH, 2 			; set cursor position 
 F7BE  CD 10				INT	10H 				; row = DH, column = DL 
							ELSE 
					POPX	DX, CX, BX, AX 
			     1				IFNB <DX>			; exit if last reg 
 F7C0  5A                    1		POP	DX 					; pop register and repeat 
			     1		POPX	CX, BX, AX, , , ,  
			     2				IFNB <CX>			; exit if last reg 
 F7C1  59                    2		POP	CX 					; pop register and repeat 
			     2		POPX	BX, AX, , , , ,  
			     3				IFNB <BX>			; exit if last reg 
 F7C2  5B                    3		POP	BX 					; pop register and repeat 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-191


			     3		POPX	AX, , , , , ,  
			     4				IFNB <AX>			; exit if last reg 
 F7C3  58                    4		POP	AX 					; pop register and repeat 
			     4		POPX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
							ENDIF 
 F7C4  C3				RET 
 F7C5				MOVE_COL ENDP 
 F7C5				POST_COL ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Display a zero-terminated string in BIOS at CS:[SI] with ending NL 
				;----------------------------------------------------------------------------; 
				; Input: CS:SI = String 
				; Size: 12 bytes 
				;----------------------------------------------------------------------------; 
 F7C5				OUTLN_SZ PROC 
 F7C5  E8 F79F R			CALL	OUT_SZ			; write original string in SI 
										; fall through to CRLF 
				 
				;----------------------------------------------------------------------------; 
				; Write a CRLF string to console 
				;----------------------------------------------------------------------------; 
 F7C8				CRLF PROC 
					PRINT_SZ  NL_Z, 1 
			     1			IFNB	<1> 
 F7C8  56                    1		PUSH	SI					; save SI 
			     1			ENDIF 
			     1			IFDIFI <NL_Z>,<SI>			; if SZ is not SI 
 F7C9  BE E4C3 R             1		MOV	SI, OFFSET NL_Z 
			     1			ENDIF 
 F7CC  E8 F79F R             1		CALL	OUT_SZ 
			     1			IFNB	<1> 
 F7CF  5E                    1		POP	SI 
			     1			ENDIF 
 F7D0  C3				RET 
 F7D1				CRLF ENDP 
				 
 F7D1				OUTLN_SZ ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Write a space char to console (8 bytes) 
				;----------------------------------------------------------------------------; 
 F7D1				SPACE PROC 
 F7D1  50				PUSH	AX				; no clobbery AX 
 F7D2  B8 0E20				MOV	AX, DBW <0EH, ' '>	; AH = 0Eh, AL = space char 
 F7D5  CD 10				INT	10H				; send to console 
 F7D7  58				POP	AX 
 F7D8  C3				RET 
 F7D9				SPACE ENDP 
				 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-192


				;----------------------------------------------------------------------------; 
				; Write Unsigned word as decimal to console 
				;----------------------------------------------------------------------------; 
				; Input: AX value 
				; Clobbers: AX, BX 
				; Size: 23 bytes 
				;----------------------------------------------------------------------------; 
 F7D9				OUT_DECU PROC 
 F7D9  BB 000A				MOV	BX, 10			; decimal divisor = 10 
 F7DC				OUT_DECU_R: 
 F7DC  52				PUSH	DX				; save remainder digit / caller DX 
 F7DD  33 D2				XOR	DX, DX 			; clear high word of dividend 
 F7DF  F7 F3				DIV	BX				; AX = DX:AX / 10, DX = DX:AX % 10 
 F7E1  85 C0				TEST	AX, AX			; is zero? 
 F7E3  74 03				JZ	OUT_DECU_DONE		; loop while AX > 0 
 F7E5  E8 F7DC R			CALL	OUT_DECU_R			; recursive call to next division 
 F7E8				OUT_DECU_DONE: 
 F7E8  92				XCHG	AX, DX			; AL = digit, AH = 0 
 F7E9  35 0E30				XOR	AX, DBW <0EH, '0'>	; ASCII convert digit, AH = 0EH 
 F7EC  CD 10				INT	10H				; write to console 
 F7EE  5A				POP	DX				; restore digit 
 F7EF  C3				RET 
 F7F0				OUT_DECU ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Write DWORD BX:AX as HEX to console 
				;----------------------------------------------------------------------------; 
				; Input: BX:AX - 32 bit value to write 
				; WORDS are separated by a colon ex: 1234:ABCD 
				; 
				; AX clobbered 
				; Size: 50 bytes 
				;----------------------------------------------------------------------------; 
 F7F0				DWORD_HEX PROC 
 F7F0  50				PUSH	AX 				; save AX 
 F7F1  8B C3				MOV	AX, BX 
 F7F3  E8 F7FC R			CALL	WORD_HEX 			; write AX to console as HEX 
 F7F6  B0 3A				MOV	AL, ':' 
 F7F8  E8 F817 R			CALL	OUT_CHAR			; Write char in AL to console 
 F7FB  58				POP	AX 				; restore AX 
				 
				;-------------------------------------------------------------------------- 
				; Write WORD AX as HEX to console 
				;-------------------------------------------------------------------------- 
 F7FC				WORD_HEX PROC 
 F7FC  50				PUSH	AX 				; save AX 
 F7FD  8A C4				MOV	AL, AH 			; move high byte into low byte 
 F7FF  E8 F803 R			CALL	BYTE_HEX 			; write byte as HEX to console 
 F802  58				POP	AX 				; restore AX 
				 
				;-------------------------------------------------------------------------- 
				; Write BYTE AL as HEX to console 
				;-------------------------------------------------------------------------- 
 F803				BYTE_HEX PROC 
 F803  50				PUSH	AX 				; save AL 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-193


							ELSE 
						REPT	4 
					SHR	AL, 1				; shift high nibble to low nibble 
						ENDM 
 F804  D0 E8                 1		SHR	AL, 1				; shift high nibble to low nibble 
 F806  D0 E8                 1		SHR	AL, 1				; shift high nibble to low nibble 
 F808  D0 E8                 1		SHR	AL, 1				; shift high nibble to low nibble 
 F80A  D0 E8                 1		SHR	AL, 1				; shift high nibble to low nibble 
							ENDIF 
 F80C  E8 F810 R			CALL	NIB_HEX 			; write low nibble of AL as HEX to console 
 F80F  58				POP	AX 				; restore AL 
				 
				;-------------------------------------------------------------------------- 
				; Write low nibble of AL as HEX to console 
				;-------------------------------------------------------------------------- 
 F810				NIB_HEX PROC 
 F810  24 0F				AND	AL, 0FH 			; isolate low nibble 
 F812  3C 0A				CMP	AL, 0AH 			; if < 0Ah, CF=1 and setup a -1 for ASCII 
										;  adjust since 'A'-'9' is 7 (not 6) 
 F814  1C 69				SBB	AL, -('0'+66H+1) 		; BCD bias for ASCII (30h + 66h + CF) 
										;  AF if AL < 0Ah, CF = 1 
										;  if > 9, high_nibble = 0Ah 
										;  if <=9, high_nibble = 09h 
 F816  2F				DAS					; BCD adjust to ASCII 
										;  if low_nibble < 0Ah, low_nibble -= 6 
										;  high_nibble -= 6 
				 
				;-------------------------------------------------------------------------- 
				; Write char in AL to console 
				;-------------------------------------------------------------------------- 
 F817				OUT_CHAR PROC 
 F817  50				PUSH	AX 
 F818  53				PUSH	BX 
 F819  B7 00				MOV	BH, 0				; video page = 0 (preserve flags) 
 F81B  B4 0E				MOV	AH, 0EH			; Write AL to screen tty mode 
 F81D  CD 10				INT	10H				; send to console 
 F81F  5B				POP	BX 
 F820  58				POP	AX 
 F821  C3				RET 
				 
 F822				OUT_CHAR ENDP 
 F822				NIB_HEX ENDP 
 F822				BYTE_HEX ENDP 
 F822				WORD_HEX ENDP 
 F822				DWORD_HEX ENDP 
				 
				; 
				; 31 BYTES HERE 
				; 
				BYTES_HERE	INT_12 
 = 001F                      1	BYTES_HERE_INT_12 = INT_12-$ 
			     1			IFDEF BYTES_HERE_INT_12 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-194


			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 12H - Memory Size Determination 
				;----------------------------------------------------------------------------; 
				; Output 
				;	AX = number of contiguous 1k memory blocks found at startup 
				;----------------------------------------------------------------------------; 
 F841						ORG 0F841H 
 F841				INT_12 PROC 
						ASSUME DS:_BDA 
 F841  FB				STI 					; interrupts on 
 F842  1E				PUSH	DS 				; save DS 
 F843  B8 ---- R			MOV	AX, SEG _BDA 
 F846  8E D8				MOV	DS, AX 			; DS = BDA 
 F848  A1 0013 R			MOV	AX, MEM_SZ_KB 		; AX = DS:[MEM_SZ_KB] 
 F84B  1F				POP	DS 
 F84C  CF				IRET 
 F84D				INT_12 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 11H - BIOS Equipment Determination / BIOS Equipment Flags 
				;----------------------------------------------------------------------------; 
				; Output 
				;	AX = data stored at BIOS Data Area location 0040:0010 
				;----------------------------------------------------------------------------; 
 F84D						ORG 0F84DH 
 F84D				INT_11 PROC 
						ASSUME DS:_BDA 
 F84D  FB				STI 					; interrupts on 
 F84E  1E				PUSH	DS 				; save DS 
 F84F  B8 ---- R			MOV	AX, SEG _BDA 
 F852  8E D8				MOV	DS, AX 			; DS = BDA 
 F854  A1 0010 R			MOV	AX, EQUIP_FLAGS 
 F857  1F				POP	DS 
 F858  CF				IRET 
 F859				INT_11 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 15 - System BIOS Services / Cassette 
				;----------------------------------------------------------------------------; 
				;	INT 15,0  Turn cassette motor on 
				;	INT 15,1  Turn cassette motor off 
				;	INT 15,2  Read blocks from cassette 
				;	INT 15,3  Write blocks to cassette 
				; 
				; Output: 
				;	CF = 1, AH = 86H (unsupported/no cassette present) 
				; 
				; https://stanislavs.org/helppc/int_15.html 
				; http://www.ctyme.com/intr/int-15.htm 
				; http://www.techhelpmanual.com/212-int_15h__at_extended_services___apm.html 
				;----------------------------------------------------------------------------; 
 F859						ORG 0F859H 
 F859				INT_15 PROC 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-195


 F859  FB				STI					; return with interrupts enabled 
							ENDIF 
				 
 F85A  B4 86				MOV	AH, 86H 			; return with unsupported function 
 F85C				INT_15_EXIT: 
 F85C  80 FC 01				CMP	AH, 1				; set CF if error (AH > 0) 
 F85F  F5				CMC 
					IRET_F				; IRET with current flags 
 F860  CA 0002               1		RETF	2 
				 
							ENDIF			; ENDIF CASSETTE EQ 1 
 F863				INT_15 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; 
				; Features not included in 5150/Cassette build go below: 
				; 
				;----------------------------------------------------------------------------; 
				 
						IF POST_HD_PARMS EQ 1 
				;----------------------------------------------------------------------------; 
				; Display Hard Drive Parameters 
				;----------------------------------------------------------------------------; 
				; Display info for POST in drive DL 
				; 
				; Input: 
				;	DL = drive # 
				; 
				; Clobbers: AX, BX 
				; 
				; Size: 100 bytes 
				;----------------------------------------------------------------------------; 
 F863				SHOW_DISK_PARAMS PROC 
					PUSHX	CX, DX				; call preserve working registers 
			     1				IFNB <CX>			; exit if last reg 
 F863  51                    1		PUSH	CX 					; push register and repeat 
			     1		PUSHX	DX, , , , , ,  
			     2				IFNB <DX>			; exit if last reg 
 F864  52                    2		PUSH	DX 					; push register and repeat 
			     2		PUSHX	, , , , , ,  
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F865  52				PUSH	DX					; save drive ID 
 F866  E8 E71E R			CALL	GET_DISK_PARAMS			; AL=heads, BX=cyl, CL=sec, DL=#drives 
 F869  5A				POP	DX					; restore drive ID 
 F86A  72 54				JC	SHOW_DISK_PARAMS_DONE		; exit if error getting drive 
 F86C  51				PUSH	CX					; save sectors/track for CHS display 
 F86D  50				PUSH	AX					; save heads 
 F86E  53				PUSH	BX					; save cylinders 
				 
				;----------------------------------------------------------------------------; 
				; Display Drive letter 
				; 
					SET_SZ_ATTR	 POST_CLR_TXT, 1, 1	; set next char to be text color 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-196


			     1				IF POST_THEME NE 0	; display color 
			     1			IFNB	<1> 
 F86F  50                    1		PUSH	AX 
 F870  53                    1		PUSH	BX 
 F871  51                    1		PUSH	CX 
			     1			ENDIF ; IFNB 
 F872  B8 0920               1		MOV	AX, DBW <9, VID_SP>	; AH = write char w/attr, AL = space 
			     1			IFDIFI <POST_CLR_TXT>,<BL>	; if ATTR is not BL 
 F875  BB 0003               1		MOV	BX, LOW POST_CLR_TXT		; BH = video page 0, BL = attribute 
			     1			ENDIF	; IFDIFI 
 F878  B9 0001               1		MOV	CX, 1			; CX = repeat times 
 F87B  CD 10                 1		INT	10H 
			     1			IFNB	<1> 
 F87D  59                    1		POP	CX 
 F87E  5B                    1		POP	BX 
 F87F  58                    1		POP	AX 
			     1			ENDIF	; IFNB 
			     1				ENDIF			; END display color 
 F880  92				XCHG	AX, DX				; AL = drive ID, DX = # of heads 
 F881  24 03				AND	AL, 0011B				; only drives 0-3 
 F883  04 43				ADD	AL, 'C'				; convert to drive letter 
 F885  E8 F817 R			CALL	OUT_CHAR 
				 
				;----------------------------------------------------------------------------; 
				; Display HD size: MiB = C*H*S*512/1024/1024 = C*H*S/2048 
				; 
 F888  92				XCHG	AX, DX				; AX = # of heads 
 F889  F6 E1				MUL	CL					; AX = heads * sectors 
 F88B  F7 E3				MUL	BX					; DX:AX = heads * sectors * cyl 
 F88D  B9 0800				MOV	CX, 1024 * (1024 / 512)		; AX = DX:AX / 2048 
 F890  F7 F1				DIV	CX					; (size in MB) 
					POST_COL_1	POST_HD, POST_CLR_VAL1	; start column 1, SI = POST_MB 
			     1			ENDIF 
			     1			ELSE 
 F892  B3 0A                 1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute 
			     1			ENDIF 
 F894  BE E50C R             1		MOV	SI, OFFSET POST_HD 
 F897  E8 F746 R             1		CALL	POST_START_COL_1 
			     1			ENDIF 
 F89A  E8 F7D9 R			CALL	OUT_DECU				; print size in MB 
 F89D  E8 F79F R			CALL	OUT_SZ				; 'MB' (SI = POST_MB from above) 
 F8A0  58				POP	AX					; AX = cylinders 
					POST_COL_END				; end column 1 
			     1			ENDIF 
 F8A1  E8 F784 R             1		CALL	POST_END_COL 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Display HD geometry: Cylinders Heads Sectors 
				; 
					POST_COL_2	POST_CHS, POST_CLR_VAL1 ; start column 2 
			     1			ENDIF 
			     1			ELSE 
 F8A4  B3 0A                 1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute 
			     1			ENDIF 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-197


 F8A6  BE F8C3 R             1		MOV	SI, OFFSET POST_CHS 
 F8A9  E8 F76D R             1		CALL	POST_START_COL_2 
			     1			ENDIF 
 F8AC  E8 F7D9 R			CALL	OUT_DECU				; print # cylinders 
 F8AF  E8 F7D1 R			CALL	SPACE 
 F8B2  58				POP	AX					; AX = heads 
 F8B3  E8 F7DC R			CALL	OUT_DECU_R				; print # heads 
 F8B6  E8 F7D1 R			CALL	SPACE 
 F8B9  58				POP	AX					; AX = sectors/track 
 F8BA  E8 F7DC R			CALL	OUT_DECU_R				; print sec/track 
					POST_COL_END_NL				; end column 2 
			     1			ENDIF 
 F8BD  E8 F77F R             1		CALL	POST_END_COL_NL 
			     1			ENDIF 
				 
 F8C0				SHOW_DISK_PARAMS_DONE: 
					POPX	DX, CX				; restore working registers 
			     1				IFNB <DX>			; exit if last reg 
 F8C0  5A                    1		POP	DX 					; pop register and repeat 
			     1		POPX	CX, , , , , ,  
			     2				IFNB <CX>			; exit if last reg 
 F8C1  59                    2		POP	CX 					; pop register and repeat 
			     2		POPX	, , , , , ,  
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F8C2  C3				RET 
				 
 F8C3  43 48 53 00		POST_CHS	DB	'CHS', 0			; CHS column 2 label 
				 
 F8C7				SHOW_DISK_PARAMS ENDP 
						ENDIF 
				 
						IF RANDOM_TAGLINE EQ 1 
				;----------------------------------------------------------------------------; 
				; Display BIOS name and random tagline 
				;----------------------------------------------------------------------------; 
				; String is chosen from low two bits of BP 
				; Clobbers: AX 
				; Size: 111 bytes 
				;----------------------------------------------------------------------------; 
 F8C7				HELLO_RAND_TAGLINE PROC 
					PRINT_SZ  TOP_BANNER		; display main banner 
			     1			ENDIF 
			     1			IFDIFI <TOP_BANNER>,<SI>			; if SZ is not SI 
 F8C7  BE E000 R             1		MOV	SI, OFFSET TOP_BANNER 
			     1			ENDIF 
 F8CA  E8 F79F R             1		CALL	OUT_SZ 
			     1			ENDIF 
 F8CD  8B C5				MOV	AX, BP			; get random bits from BP 
					POST_FLAG_CLR  GRND		; clear random bits from BP 
			     1				ELSE 
 = 0001                      1	??0042	EQU	1				; use CLR1 (ZF unaffected) 
			     1				ENDIF 
			     1				ELSE 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-198


 F8CF  83 E5 FC              1		AND	BP, NOT MASK GRND			; Clear flag 
			     1				ENDIF 
 F8D2  25 0003				AND	AX, MASK GRND		; only low 2 bits 
 F8D5  96				XCHG	AX, SI			; SI = string offset table 
 F8D6  D1 E6				SHL	SI, 1				; word align 
 F8D8  2E: 8B B4 F92E R			MOV	SI, CS:TAGS[SI]		; SI = chosen tagline offset 
					PRINT_SZ  SI			; display tagline 
			     1			ENDIF 
			     1			ENDIF 
 F8DD  E8 F79F R             1		CALL	OUT_SZ 
			     1			ENDIF 
 F8E0  BE E031 R			MOV	SI, OFFSET COPYRIGHT	; display copyright message 
 F8E3  E9 F7C5 R			JMP	NEAR PTR OUTLN_SZ		; write and RET 
				 
				;----------------------------------------------------------------------------; 
				; Three additional random taglines 
				; 
 F8E6  52 65 61 64 79 20 74	TAG1		DB	'Ready to believe you', 0 
       6F 20 62 65 6C 69 65	
       76 65 20 79 6F 75 00	
 F8FB  41 62 6F 72 74 2C 20	TAG2		DB	'Abort, Retry, Succeed', 0 
       52 65 74 72 79 2C 20	
       53 75 63 63 65 65 64	
       00			
 F911  57 68 65 6E 20 6C 69	TAG3		DB	'When life gives you lemonade', 0 
       66 65 20 67 69 76 65	
       73 20 79 6F 75 20 6C	
       65 6D 6F 6E 61 64 65	
       00			
				;		DB	'An Energy Star Foe', 0 
				;		DB	'Now 97% asbestos-free', 0 
				;		DB	'Ought to be enough for anybody', 0 
				 
				;----------------------------------------------------------------------------; 
				; Offset table for taglines 
				; 
 F92E  E00E R F8E6 R F8FB R	TAGS		DW	OFFSET TAG0, OFFSET TAG1, OFFSET TAG2, OFFSET TAG3 
       F911 R			
				 
 F936				HELLO_RAND_TAGLINE ENDP 
						ENDIF 
				 
						IF POST_OPT_ROM EQ 1 
				;----------------------------------------------------------------------------; 
				; ROM scan loading - display segment, size and checksum error 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AX = BIOS size in bytes 
				;	DI = Option ROM scan end segment 
				;	DL = ROM checksum value 
				; 
				; Clobbers: BX, DX 
				; 
				; Size: 105 bytes 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-199


 F936				ROM_SCAN_POST PROC 
 F936  50				PUSH	AX						; must call-preserve these 
 F937  56				PUSH	SI 
 F938  9C				PUSHF 
				 
				;----------------------------------------------------------------------------; 
				; Ensure this is not scanning a display option ROM - could crash if video 
				; ISR not is installed 
				; 
 F939  81 FF C800			CMP	DI, 0C800H					; is video ROM scan? 
 F93D  76 32				JBE	ROM_SCAN_POST_EXIT			; exit if so 
				 
				;----------------------------------------------------------------------------; 
				; Display ROM column 
				; 
 F93F  50				PUSH	AX						; save ROM size 
					POST_COL_1  S_OPT_ROM, POST_CLR_VAL2	; start ROM column label 
			     1			ENDIF 
			     1			ELSE 
 F940  B3 0E                 1		MOV	BL, LOW POST_CLR_VAL2		; BL = attribute 
			     1			ENDIF 
 F942  BE F98A R             1		MOV	SI, OFFSET S_OPT_ROM 
 F945  E8 F746 R             1		CALL	POST_START_COL_1 
			     1			ENDIF 
 F948  8C D8				MOV	AX, DS					; AX = ROM segment 
 F94A  E8 F7FC R			CALL	WORD_HEX					; display as hex 
					POST_COL_END					; end column 1 
			     1			ENDIF 
 F94D  E8 F784 R             1		CALL	POST_END_COL 
			     1			ENDIF 
 F950  58				POP	AX 
				 
				;----------------------------------------------------------------------------; 
				; Display Size or Checksum error column 
				; 
 F951  9D				POPF							; restore checksum flag 
 F952  9C				PUSHF							; re-save flag 
 F953  75 20				JNZ	ROM_SCAN_POST_CHK				; jump if checksum error 
 F955  50				PUSH	AX						; save ROM size again 
					POST_COL_2  S_OPT_SIZE, POST_CLR_VAL2	; start 'Size' column 2 
			     1			ENDIF 
			     1			ELSE 
 F956  B3 0E                 1		MOV	BL, LOW POST_CLR_VAL2		; BL = attribute 
			     1			ENDIF 
 F958  BE F98E R             1		MOV	SI, OFFSET S_OPT_SIZE 
 F95B  E8 F76D R             1		CALL	POST_START_COL_2 
			     1			ENDIF 
 F95E  58				POP	AX 
 F95F  86 E0				XCHG	AH, AL					; convert bytes to KB 
 F961  D0 E8				SHR	AL, 1 
 F963  D0 E8				SHR	AL, 1 
 F965  E8 F7D9 R			CALL	OUT_DECU					; write size as decimal 
					PRINT_SZ	S_OPT_K				; display KB unit 
			     1			ENDIF 
			     1			IFDIFI <S_OPT_K>,<SI>			; if SZ is not SI 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-200


 F968  BE F99B R             1		MOV	SI, OFFSET S_OPT_K 
			     1			ENDIF 
 F96B  E8 F79F R             1		CALL	OUT_SZ 
			     1			ENDIF 
				 
 F96E				ROM_SCAN_POST_DONE: 
					POST_COL_END_NL					; end column 2 
			     1			ENDIF 
 F96E  E8 F77F R             1		CALL	POST_END_COL_NL 
			     1			ENDIF 
				 
 F971				ROM_SCAN_POST_EXIT: 
 F971  9D				POPF							; restore checksum result flag 
 F972  5E				POP	SI 
 F973  58				POP	AX 
 F974  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; Display checksum error 
				; 
 F975				ROM_SCAN_POST_CHK: 
					POST_COL_2  POST_ERR_ERR, RED			; 'Error' with red text 
			     1			ENDIF 
			     1			ELSE 
 F975  B3 0C                 1		MOV	BL, LOW RED		; BL = attribute 
			     1			ENDIF 
 F977  BE E90C R             1		MOV	SI, OFFSET POST_ERR_ERR 
 F97A  E8 F76D R             1		CALL	POST_START_COL_2 
			     1			ENDIF 
					PRINT_SZ	S_OPT_CHK				; display 'Checksum' message 
			     1			ENDIF 
			     1			IFDIFI <S_OPT_CHK>,<SI>			; if SZ is not SI 
 F97D  BE F993 R             1		MOV	SI, OFFSET S_OPT_CHK 
			     1			ENDIF 
 F980  E8 F79F R             1		CALL	OUT_SZ 
			     1			ENDIF 
 F983  8A C2				MOV	AL, DL					; AL = computed checksum 
 F985  E8 F803 R			CALL	BYTE_HEX					; write as hex byte 
 F988  EB E4				JMP	ROM_SCAN_POST_DONE			; end column and return 
				 
 F98A  52 4F 4D 00		S_OPT_ROM	DB	'ROM', 0 
 F98E  53 69 7A 65 00		S_OPT_SIZE	DB	'Size', 0 
 F993  43 68 6B 73 75 6D 20	S_OPT_CHK	DB	'Chksum ', 0			; Checksum 
       00			
 F99B  20 4B 42 00		S_OPT_K	DB	' ', POST_K_UNIT, 0 
				 
 F99F				ROM_SCAN_POST ENDP 
						ENDIF 
				 
						IF LIGHT_PEN EQ 1 
				;----------------------------------------------------------------------------; 
				; INT 10,4 - Read Light Pen Position 
				;----------------------------------------------------------------------------; 
				; Return: 
				;	AH = 0 light pen switch not triggered 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-201


				;	   = 1 light pen triggered 
				;	BX = pixel column (0-319 or 0-639, mode dependent) 
				;	CH = raster line (0-199) (CGA and EGA modes 4, 5 and 6) 
				;	CX = raster line (EGA modes except 4, 5 and 6) 
				;	DH = row (0-24) 
				;	DL = column (0-79 or 0-79 mode dependent) 
				; 
				; Size: 128 bytes 
				; 
				; Thx to @Raffzahn for "clean room" specs. 
				;----------------------------------------------------------------------------; 
				; https://nerdlypleasures.blogspot.com/2016/05/ibms-cga-hardware-explained.html 
				; https://www.reenigne.org/blog/cga-reading-the-current-beam-position-with-the-lightpen-latch/ 
				; https://scalibq.wordpress.com/2015/04/19/8088-mph-sprites-where-were-going-we-dont-need-sprites/ 
				;----------------------------------------------------------------------------; 
 F99F				INT_10_4 PROC 
 F99F  8B FA				MOV	DI, DX			; save caller DX 
 F9A1  8B 16 0063 R			MOV	DX, VID_PORT		; 6845 I/O port address (3x4h) 
 F9A5  83 C2 06				ADD	DX, CGA_STAT-CGA_IDX	; DX = 3xAh status port 
 F9A8  EC				IN	AL, DX			; read Status Register 
 F9A9  32 E4				XOR	AH, AH			; AH = 0 (switch not triggered) 
 F9AB  A8 04				TEST	AL, MASK VSPE		; light pen on? (/0100b) (0=on, 1=off) 
 F9AD  75 4A				JNZ	INT_10_4_RESET		; if light pen off, reset latch and exit 
 F9AF  A8 02				TEST	AL, MASK VSPT		; light pen trigger set? (0010b) (0=not set, 1=set) 
 F9B1  74 4A				JZ	INT_10_4_EXIT		; if not set, just exit 
				 
				;----------------------------------------------------------------------------; 
				; Trigger is set, read light pen word from 6845. Address Register is latched 
				; into light pen register when LPSTB pulses high. 
				; 
 F9B3  83 EA 06				SUB	DX, CGA_STAT-CGA_IDX	; DX = 3x4h index port 
 F9B6  B0 10				MOV	AL, 10h			; light pen index (MSB) 
 F9B8  EE				OUT	DX, AL			; select index 
 F9B9  42				INC	DX				; DX = 3x5h data port 
 F9BA  EC				IN	AL, DX			; read MSB 
 F9BB  8A E0				MOV	AH, AL			; save MSB 
 F9BD  4A				DEC	DX				; DX = 3x4h index port 
 F9BE  B0 11				MOV	AL, 11h			; light pen index (LSB) 
 F9C0  EE				OUT	DX, AL			; select index 
 F9C1  42				INC	DX				; DX = 3x5h data port 
 F9C2  EC				IN	AL, DX			; read LSB 
				 
				;----------------------------------------------------------------------------; 
				; Calculate screen location from latched address. Address needs a 
				; "calibration factor" applied due to "slow light pen response". 
				; 
				; -3: 0,1,4,5,6 (CGA low-res text/gfx) 
				; -5: 2,3 (CGA hi-res text) 
				; -4: 7 (MDA text) 
				; 
 F9C3  8B 1E 004E R			MOV	BX, VID_SEG			; BX = start offset of video memory 
 F9C7  D1 EB				SHR	BX, 1				; byte align index 
 F9C9  83 C3 03				ADD	BX, 3				; BX = minimum calibration factor 
 F9CC  91				XCHG	AX, CX			; save AX 
 F9CD  E8 F085 R			CALL	INT_10_IS_TXT		; ZF=1 if text, ZF=0 if gfx, CF=1 if MDA 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-202


 F9D0  9F				LAHF					; save video type flags for later 
 F9D1  75 08				JNZ	INT_10_4_CAL_2		; skip if modes 4,5,6 
 F9D3  72 05				JC	INT_10_4_CAL_1		; +1 if MDA mode 7 
 F9D5  3C 02				CMP	AL, 2				; AL < 2? 
 F9D7  7C 02				JL	INT_10_4_CAL_2		; skip if modes 0,1 (+0) 
 F9D9  43				INC	BX				; +1 for modes 2,3 
 F9DA				INT_10_4_CAL_1: 
 F9DA  43				INC	BX				; +1 for modes 2,3,7 
 F9DB				INT_10_4_CAL_2: 
 F9DB  2B CB				SUB	CX, BX			; CX = calibrated memory regen offset 
 F9DD  73 02				JAE	INT_10_4_CAL_DONE		; is result < 0? 
 F9DF  33 C9				XOR	CX, CX			; if so, use base offset 0000 
 F9E1				INT_10_4_CAL_DONE: 
 F9E1  9E				SAHF					; ZF=1 if text, ZF=0 if gfx 
 F9E2  91				XCHG	AX, CX			; restore AX, CL = video mode 
 F9E3  75 1B				JNZ	INT_10_4_GFX		; jump if graphics mode 
				 
				;----------------------------------------------------------------------------; 
				; Calculate output for Text mode 
				; 
				; Input: 
				;	AX = calibrated memory offset 
				; Output: 
				;	BX = pixel column (0-319 or 0-639) 
				;	CH = raster line (0-199) 
				;	DI = (value for DX) DH = row (0-24), DL = column (0-79) 
				;----------------------------------------------------------------------------; 
				; Formula: 
				;	DX = calibrated memory offset (AX) DIV video columns (DH=row, DL=col) 
				;	BX = col (DL) * 8 
				;	CH = row (DH) * 8 
				;----------------------------------------------------------------------------; 
 F9E5				INT_10_4_TXT: 
 F9E5  B1 03				MOV	CL, 3				; shift counter 3 (for * 8) 
 F9E7  F6 36 004A R			DIV	BYTE PTR VID_COLS		; divide value by char/line 
 F9EB  86 E0				XCHG	AH, AL			; AH = row, AL = col 
 F9ED  8B F8				MOV	DI, AX			; DH = row, DL = col 
 F9EF  8A EC				MOV	CH, AH			; CH = row 
 F9F1  D2 E5				SHL	CH, CL			; CH = raster line (col * 8) 
 F9F3  98				CBW					; AH = 0, AL = col 
 F9F4  D3 E0				SHL	AX, CL			; AX = col * 8 
 F9F6  93				XCHG	AX, BX			; BX = pixel column 
				 
				;----------------------------------------------------------------------------; 
				; DONE: Clear latch and return with AH = 1 
				; 
 F9F7				INT_10_4_DONE: 
 F9F7  B4 01				MOV	AH, 1				; light pen triggered 
				 
				;----------------------------------------------------------------------------; 
				; Light pen strobe reset 
				; 
 F9F9				INT_10_4_RESET: 
 F9F9  83 C2 06				ADD	DX, CGA_PEN_RST-CGA_DATA	; pen latch register 
 F9FC  EE				OUT	DX, AL			; reset light pen latch 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-203


				 
 F9FD				INT_10_4_EXIT: 
 F9FD  8B D7				MOV	DX, DI			; restore/output DX 
 F9FF  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; Calculate output for GFX mode 
				; 
				; Input: 
				;	AX = calibrated memory offset 
				;	CL = video mode 
				; Output: 
				;	BX = pixel column (0-319 or 0-639) 
				;	CH = raster line (0-199) 
				;	DI = (value for DX) DH = row (0-24), DL = column (0-79) 
				;----------------------------------------------------------------------------; 
				; Formula: 
				; 	DX = calibrated memory offset (AX) DIV 40 (DH=row, DL=col) 
				;	CH = row (DH) * 2 
				;	DH = row (DH) / 4 
				;	if ( high res ): 
				; 		DL = col (DL) * 2 
				;	BX = DL * 8 
				; 
				; Note: output registers used as variable names in comments below. 
				;----------------------------------------------------------------------------; 
 FA00				INT_10_4_GFX: 
 FA00  B5 28				MOV	CH, 40			; divide value by 40 
 FA02  F6 F5				DIV	CH				; AL = row, AH = col 
 FA04  86 E0				XCHG	AH, AL			; AH = row, AL = col 
 FA06  8A EC				MOV	CH, AH			; CH = row (DH) * 2 
 FA08  D0 E5				SHL	CH, 1				; adjust for odd/even fields 
				 
				;----------------------------------------------------------------------------; 
				; Multiply column according to graphics mode 
				; 
 FA0A  80 F9 06				CMP	CL, 6				; is 640x200 mode? 
 FA0D  75 02				JNE	INT_10_4_LOW		; if not, jump 
 FA0F  D0 E0				SHL	AL, 1				; DL = col (DL) * 2 
 FA11				INT_10_4_LOW: 
 FA11  B1 03				MOV	CL, 3				; shift counter 3 for * 8 
 FA13  8B D8				MOV	BX, AX			; BL = DL for pixel column 
 FA15  98				CBW					; zero extend BL 
 FA16  D3 E0				SHL	AX, CL			; BX = DL * 8 
 FA18  93				XCHG	AX, BX			; return as BX 
 FA19  49				DEC	CX				; shift counter 2 for / 4 
 FA1A  D2 EC				SHR	AH, CL			; DH = row / 4 
 FA1C  97				XCHG	AX, DI			; return as DX 
 FA1D  EB D8				JMP	SHORT INT_10_4_DONE	; clear latch and return with AH=1 
 FA1F				INT_10_4 ENDP 
						ENDIF 
				 
				; 
				; 79 BYTES HERE / 0 BYTES HERE 5150 
				; 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-204


				BYTES_HERE	GFX_CHARSET 
 = 004F                      1	BYTES_HERE_GFX_CHARSET = GFX_CHARSET-$ 
			     1			IFDEF BYTES_HERE_GFX_CHARSET 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 1F - 8x8 Font bitmaps 
				;----------------------------------------------------------------------------; 
				; Font bitmaps from "VileR", (CC BY-SA 4.0) 
				; https://int10h.org/oldschool-pc-fonts/ 
				;----------------------------------------------------------------------------; 
 FA6E						ORG 0FA6EH 
 FA6E				GFX_CHARSET LABEL BYTE 
							ELSE 
				;----------------------------------------------------------------------------; 
				; A more clone style font 
				; 
 FA6E  00 00 00 00 00 00 00		DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H	; 00H 
       00			
 FA76  7E 81 A5 81 BD 99 81		DB	07EH, 081H, 0A5H, 081H, 0BDH, 099H, 081H, 07EH	; 01H 
       7E			
 FA7E  7E DB FF FF C3 E7 7E		DB	07EH, 0DBH, 0FFH, 0FFH, 0C3H, 0E7H, 07EH, 000H	; 02H 
       00			
 FA86  36 7F 7F 7F 3E 1C 08		DB	036H, 07FH, 07FH, 07FH, 03EH, 01CH, 008H, 000H	; 03H 
       00			
 FA8E  08 1C 3E 7F 3E 1C 08		DB	008H, 01CH, 03EH, 07FH, 03EH, 01CH, 008H, 000H	; 04H 
       00			
 FA96  18 3C 18 66 FF 66 18		DB	018H, 03CH, 018H, 066H, 0FFH, 066H, 018H, 03CH	; 05H 
       3C			
 FA9E  08 1C 3E 7F 7F 3E 08		DB	008H, 01CH, 03EH, 07FH, 07FH, 03EH, 008H, 01CH	; 06H 
       1C			
 FAA6  00 00 18 3C 3C 18 00		DB	000H, 000H, 018H, 03CH, 03CH, 018H, 000H, 000H	; 07H 
       00			
 FAAE  FF FF E7 C3 C3 E7 FF		DB	0FFH, 0FFH, 0E7H, 0C3H, 0C3H, 0E7H, 0FFH, 0FFH	; 08H 
       FF			
 FAB6  00 3C 66 42 42 66 3C		DB	000H, 03CH, 066H, 042H, 042H, 066H, 03CH, 000H	; 09H 
       00			
 FABE  FF C3 99 BD BD 99 C3		DB	0FFH, 0C3H, 099H, 0BDH, 0BDH, 099H, 0C3H, 0FFH	; 0AH 
       FF			
 FAC6  3F 0D 1C 3E 63 63 3E		DB	03FH, 00DH, 01CH, 03EH, 063H, 063H, 03EH, 000H	; 0BH 
       00			
 FACE  3E 63 63 3E 1C 7F 1C		DB	03EH, 063H, 063H, 03EH, 01CH, 07FH, 01CH, 000H	; 0CH 
       00			
 FAD6  0E 0F 0D 0D 1C 7F 1C		DB	00EH, 00FH, 00DH, 00DH, 01CH, 07FH, 01CH, 000H	; 0DH 
       00			
 FADE  0F 3B 37 3B 33 37 77		DB	00FH, 03BH, 037H, 03BH, 033H, 037H, 077H, 070H	; 0EH 
       70			
 FAE6  18 DB 3C E7 3C DB 18		DB	018H, 0DBH, 03CH, 0E7H, 03CH, 0DBH, 018H, 000H	; 0FH 
       00			
 FAEE  60 78 7E 7F 7E 78 60		DB	060H, 078H, 07EH, 07FH, 07EH, 078H, 060H, 000H	; 10H 
       00			
 FAF6  03 0F 3F 7F 3F 0F 03		DB	003H, 00FH, 03FH, 07FH, 03FH, 00FH, 003H, 000H	; 11H 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-205


       00			
 FAFE  18 3C 7E 18 18 7E 3C		DB	018H, 03CH, 07EH, 018H, 018H, 07EH, 03CH, 018H	; 12H 
       18			
 FB06  66 66 66 66 66 00 66		DB	066H, 066H, 066H, 066H, 066H, 000H, 066H, 000H	; 13H 
       00			
 FB0E  3F 6D 6D 3D 0D 0D 0D		DB	03FH, 06DH, 06DH, 03DH, 00DH, 00DH, 00DH, 000H	; 14H 
       00			
 FB16  3F 70 3E 63 63 3E 07		DB	03FH, 070H, 03EH, 063H, 063H, 03EH, 007H, 07EH	; 15H 
       7E			
 FB1E  00 00 00 00 FF FF FF		DB	000H, 000H, 000H, 000H, 0FFH, 0FFH, 0FFH, 000H	; 16H 
       00			
 FB26  3C 7E 18 18 7E 3C 18		DB	03CH, 07EH, 018H, 018H, 07EH, 03CH, 018H, 07EH	; 17H 
       7E			
 FB2E  18 3C 7E 18 18 18 18		DB	018H, 03CH, 07EH, 018H, 018H, 018H, 018H, 000H	; 18H 
       00			
 FB36  18 18 18 18 7E 3C 18		DB	018H, 018H, 018H, 018H, 07EH, 03CH, 018H, 000H	; 19H 
       00			
 FB3E  18 0C 06 7F 06 0C 18		DB	018H, 00CH, 006H, 07FH, 006H, 00CH, 018H, 000H	; 1AH 
       00			
 FB46  0C 18 30 7F 30 18 0C		DB	00CH, 018H, 030H, 07FH, 030H, 018H, 00CH, 000H	; 1BH 
       00			
 FB4E  00 00 00 60 60 7F 00		DB	000H, 000H, 000H, 060H, 060H, 07FH, 000H, 000H	; 1CH 
       00			
 FB56  00 24 66 FF 66 24 00		DB	000H, 024H, 066H, 0FFH, 066H, 024H, 000H, 000H	; 1DH 
       00			
 FB5E  08 1C 1C 3E 3E 7F 7F		DB	008H, 01CH, 01CH, 03EH, 03EH, 07FH, 07FH, 000H	; 1EH 
       00			
 FB66  7F 7F 3E 3E 1C 1C 08		DB	07FH, 07FH, 03EH, 03EH, 01CH, 01CH, 008H, 000H	; 1FH 
       00			
 FB6E  00 00 00 00 00 00 00		DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H	; 20H   
       00			
 FB76  18 18 18 18 18 00 18		DB	018H, 018H, 018H, 018H, 018H, 000H, 018H, 000H	; 21H ! 
       00			
 FB7E  33 66 CC 00 00 00 00		DB	033H, 066H, 0CCH, 000H, 000H, 000H, 000H, 000H	; 22H " 
       00			
 FB86  36 36 7F 36 36 7F 36		DB	036H, 036H, 07FH, 036H, 036H, 07FH, 036H, 036H	; 23H # 
       36			
 FB8E  18 7E 58 38 1C 1A 7E		DB	018H, 07EH, 058H, 038H, 01CH, 01AH, 07EH, 018H	; 24H $ 
       18			
 FB96  E3 A6 EC 18 37 65 C7		DB	0E3H, 0A6H, 0ECH, 018H, 037H, 065H, 0C7H, 000H	; 25H % 
       00			
 FB9E  3C 66 3C 38 6D 66 3D		DB	03CH, 066H, 03CH, 038H, 06DH, 066H, 03DH, 000H	; 26H & 
       00			
 FBA6  06 0C 18 00 00 00 00		DB	006H, 00CH, 018H, 000H, 000H, 000H, 000H, 000H	; 27H ' 
       00			
 FBAE  1C 30 60 60 60 30 1C		DB	01CH, 030H, 060H, 060H, 060H, 030H, 01CH, 000H	; 28H ( 
       00			
 FBB6  38 0C 06 06 06 0C 38		DB	038H, 00CH, 006H, 006H, 006H, 00CH, 038H, 000H	; 29H ) 
       00			
 FBBE  63 36 1C 7F 1C 36 63		DB	063H, 036H, 01CH, 07FH, 01CH, 036H, 063H, 000H	; 2AH * 
       00			
 FBC6  18 18 18 7E 18 18 18		DB	018H, 018H, 018H, 07EH, 018H, 018H, 018H, 000H	; 2BH + 
       00			
 FBCE  00 00 00 00 00 18 18		DB	000H, 000H, 000H, 000H, 000H, 018H, 018H, 030H	; 2CH , 
       30			
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-206


 FBD6  00 00 00 7E 00 00 00		DB	000H, 000H, 000H, 07EH, 000H, 000H, 000H, 000H	; 2DH - 
       00			
 FBDE  00 00 00 00 00 18 18		DB	000H, 000H, 000H, 000H, 000H, 018H, 018H, 000H	; 2EH . 
       00			
 FBE6  02 06 0C 18 30 60 40		DB	002H, 006H, 00CH, 018H, 030H, 060H, 040H, 000H	; 2FH / 
       00			
 FBEE  3E 63 63 6B 63 63 3E		DB	03EH, 063H, 063H, 06BH, 063H, 063H, 03EH, 000H	; 30H 0 
       00			
 FBF6  1C 3C 0C 0C 0C 0C 0C		DB	01CH, 03CH, 00CH, 00CH, 00CH, 00CH, 00CH, 000H	; 31H 1 
       00			
 FBFE  3E 63 03 0E 38 60 7F		DB	03EH, 063H, 003H, 00EH, 038H, 060H, 07FH, 000H	; 32H 2 
       00			
 FC06  7C 06 06 3C 06 06 7C		DB	07CH, 006H, 006H, 03CH, 006H, 006H, 07CH, 000H	; 33H 3 
       00			
 FC0E  0E 1E 36 66 7F 06 06		DB	00EH, 01EH, 036H, 066H, 07FH, 006H, 006H, 000H	; 34H 4 
       00			
 FC16  7E 60 7C 06 06 06 7C		DB	07EH, 060H, 07CH, 006H, 006H, 006H, 07CH, 000H	; 35H 5 
       00			
 FC1E  1E 30 60 7E 63 63 3E		DB	01EH, 030H, 060H, 07EH, 063H, 063H, 03EH, 000H	; 36H 6 
       00			
 FC26  7E 66 0C 18 30 30 30		DB	07EH, 066H, 00CH, 018H, 030H, 030H, 030H, 000H	; 37H 7 
       00			
 FC2E  3E 63 36 1C 36 63 3E		DB	03EH, 063H, 036H, 01CH, 036H, 063H, 03EH, 000H	; 38H 8 
       00			
 FC36  3E 63 63 3F 03 06 7C		DB	03EH, 063H, 063H, 03FH, 003H, 006H, 07CH, 000H	; 39H 9 
       00			
 FC3E  00 00 18 18 00 18 18		DB	000H, 000H, 018H, 018H, 000H, 018H, 018H, 000H	; 3AH : 
       00			
 FC46  00 00 18 18 00 18 18		DB	000H, 000H, 018H, 018H, 000H, 018H, 018H, 030H	; 3BH ; 
       30			
 FC4E  0C 18 30 60 30 18 0C		DB	00CH, 018H, 030H, 060H, 030H, 018H, 00CH, 000H	; 3CH < 
       00			
 FC56  00 00 7E 00 7E 00 00		DB	000H, 000H, 07EH, 000H, 07EH, 000H, 000H, 000H	; 3DH = 
       00			
 FC5E  30 18 0C 06 0C 18 30		DB	030H, 018H, 00CH, 006H, 00CH, 018H, 030H, 000H	; 3EH > 
       00			
 FC66  3E 63 06 0C 0C 00 0C		DB	03EH, 063H, 006H, 00CH, 00CH, 000H, 00CH, 000H	; 3FH ? 
       00			
 FC6E  3E 63 6F 69 6F 60 3F		DB	03EH, 063H, 06FH, 069H, 06FH, 060H, 03FH, 000H	; 40H @ 
       00			
 FC76  3C 66 66 7E 66 66 66		DB	03CH, 066H, 066H, 07EH, 066H, 066H, 066H, 000H	; 41H A 
       00			
 FC7E  7E 63 63 7E 63 63 7E		DB	07EH, 063H, 063H, 07EH, 063H, 063H, 07EH, 000H	; 42H B 
       00			
 FC86  1E 33 60 60 60 33 1E		DB	01EH, 033H, 060H, 060H, 060H, 033H, 01EH, 000H	; 43H C 
       00			
 FC8E  7C 66 63 63 63 66 7C		DB	07CH, 066H, 063H, 063H, 063H, 066H, 07CH, 000H	; 44H D 
       00			
 FC96  7E 60 60 7C 60 60 7E		DB	07EH, 060H, 060H, 07CH, 060H, 060H, 07EH, 000H	; 45H E 
       00			
 FC9E  7E 60 60 7C 60 60 60		DB	07EH, 060H, 060H, 07CH, 060H, 060H, 060H, 000H	; 46H F 
       00			
 FCA6  1E 33 63 60 67 33 1E		DB	01EH, 033H, 063H, 060H, 067H, 033H, 01EH, 000H	; 47H G 
       00			
 FCAE  63 63 63 7F 63 63 63		DB	063H, 063H, 063H, 07FH, 063H, 063H, 063H, 000H	; 48H H 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-207


       00			
 FCB6  3C 18 18 18 18 18 3C		DB	03CH, 018H, 018H, 018H, 018H, 018H, 03CH, 000H	; 49H I 
       00			
 FCBE  06 06 06 06 66 66 3C		DB	006H, 006H, 006H, 006H, 066H, 066H, 03CH, 000H	; 4AH J 
       00			
 FCC6  63 66 6C 78 6C 66 63		DB	063H, 066H, 06CH, 078H, 06CH, 066H, 063H, 000H	; 4BH K 
       00			
 FCCE  30 30 30 30 30 30 3F		DB	030H, 030H, 030H, 030H, 030H, 030H, 03FH, 000H	; 4CH L 
       00			
 FCD6  63 77 7F 6B 63 63 63		DB	063H, 077H, 07FH, 06BH, 063H, 063H, 063H, 000H	; 4DH M 
       00			
 FCDE  63 73 7B 6F 67 63 63		DB	063H, 073H, 07BH, 06FH, 067H, 063H, 063H, 000H	; 4EH N 
       00			
 FCE6  3E 63 63 63 63 63 3E		DB	03EH, 063H, 063H, 063H, 063H, 063H, 03EH, 000H	; 4FH O 
       00			
 FCEE  7E 63 63 7E 60 60 60		DB	07EH, 063H, 063H, 07EH, 060H, 060H, 060H, 000H	; 50H P 
       00			
 FCF6  3E 63 63 63 7B 6E 3C		DB	03EH, 063H, 063H, 063H, 07BH, 06EH, 03CH, 007H	; 51H Q 
       07			
 FCFE  7E 63 63 7E 6C 66 63		DB	07EH, 063H, 063H, 07EH, 06CH, 066H, 063H, 000H	; 52H R 
       00			
 FD06  3E 63 30 1C 06 63 3E		DB	03EH, 063H, 030H, 01CH, 006H, 063H, 03EH, 000H	; 53H S 
       00			
 FD0E  7E 18 18 18 18 18 18		DB	07EH, 018H, 018H, 018H, 018H, 018H, 018H, 000H	; 54H T 
       00			
 FD16  63 63 63 63 63 63 3E		DB	063H, 063H, 063H, 063H, 063H, 063H, 03EH, 000H	; 55H U 
       00			
 FD1E  63 63 63 63 36 1C 08		DB	063H, 063H, 063H, 063H, 036H, 01CH, 008H, 000H	; 56H V 
       00			
 FD26  63 63 63 6B 6B 7F 36		DB	063H, 063H, 063H, 06BH, 06BH, 07FH, 036H, 000H	; 57H W 
       00			
 FD2E  63 63 36 1C 36 63 63		DB	063H, 063H, 036H, 01CH, 036H, 063H, 063H, 000H	; 58H X 
       00			
 FD36  63 63 63 3E 0C 0C 0C		DB	063H, 063H, 063H, 03EH, 00CH, 00CH, 00CH, 000H	; 59H Y 
       00			
 FD3E  7F 06 0C 18 30 60 7F		DB	07FH, 006H, 00CH, 018H, 030H, 060H, 07FH, 000H	; 5AH Z 
       00			
 FD46  3E 30 30 30 30 30 3E		DB	03EH, 030H, 030H, 030H, 030H, 030H, 03EH, 000H	; 5BH [ 
       00			
 FD4E  40 60 30 18 0C 06 02		DB	040H, 060H, 030H, 018H, 00CH, 006H, 002H, 000H	; 5CH \ 
       00			
 FD56  3E 06 06 06 06 06 3E		DB	03EH, 006H, 006H, 006H, 006H, 006H, 03EH, 000H	; 5DH ] 
       00			
 FD5E  1C 36 63 00 00 00 00		DB	01CH, 036H, 063H, 000H, 000H, 000H, 000H, 000H	; 5EH ^ 
       00			
 FD66  00 00 00 00 00 00 00		DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 0FFH	; 5FH _ 
       FF			
 FD6E  30 18 0C 00 00 00 00		DB	030H, 018H, 00CH, 000H, 000H, 000H, 000H, 000H	; 60H ` 
       00			
 FD76  00 00 3C 06 3E 66 3F		DB	000H, 000H, 03CH, 006H, 03EH, 066H, 03FH, 000H	; 61H a 
       00			
 FD7E  60 60 7C 66 66 66 7C		DB	060H, 060H, 07CH, 066H, 066H, 066H, 07CH, 000H	; 62H b 
       00			
 FD86  00 00 3E 63 60 60 3F		DB	000H, 000H, 03EH, 063H, 060H, 060H, 03FH, 000H	; 63H c 
       00			
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-208


 FD8E  06 06 3E 66 66 66 3E		DB	006H, 006H, 03EH, 066H, 066H, 066H, 03EH, 000H	; 64H d 
       00			
 FD96  00 00 3C 66 7C 60 3E		DB	000H, 000H, 03CH, 066H, 07CH, 060H, 03EH, 000H	; 65H e 
       00			
 FD9E  1E 30 30 7C 30 30 30		DB	01EH, 030H, 030H, 07CH, 030H, 030H, 030H, 000H	; 66H f 
       00			
 FDA6  00 00 3F 63 63 3F 03		DB	000H, 000H, 03FH, 063H, 063H, 03FH, 003H, 07EH	; 67H g 
       7E			
 FDAE  60 60 6C 76 66 66 66		DB	060H, 060H, 06CH, 076H, 066H, 066H, 066H, 000H	; 68H h 
       00			
 FDB6  18 00 38 18 18 18 18		DB	018H, 000H, 038H, 018H, 018H, 018H, 018H, 000H	; 69H i 
       00			
 FDBE  06 00 06 06 06 06 66		DB	006H, 000H, 006H, 006H, 006H, 006H, 066H, 03CH	; 6AH j 
       3C			
 FDC6  60 60 66 6C 78 6C 66		DB	060H, 060H, 066H, 06CH, 078H, 06CH, 066H, 000H	; 6BH k 
       00			
 FDCE  18 18 18 18 18 18 0C		DB	018H, 018H, 018H, 018H, 018H, 018H, 00CH, 000H	; 6CH l 
       00			
 FDD6  00 00 76 7F 6B 6B 63		DB	000H, 000H, 076H, 07FH, 06BH, 06BH, 063H, 000H	; 6DH m 
       00			
 FDDE  00 00 6C 76 66 66 66		DB	000H, 000H, 06CH, 076H, 066H, 066H, 066H, 000H	; 6EH n 
       00			
 FDE6  00 00 3E 63 63 63 3E		DB	000H, 000H, 03EH, 063H, 063H, 063H, 03EH, 000H	; 6FH o 
       00			
 FDEE  00 00 7C 66 66 7C 60		DB	000H, 000H, 07CH, 066H, 066H, 07CH, 060H, 060H	; 70H p 
       60			
 FDF6  00 00 3E 66 66 3E 06		DB	000H, 000H, 03EH, 066H, 066H, 03EH, 006H, 006H	; 71H q 
       06			
 FDFE  00 00 36 3B 30 30 30		DB	000H, 000H, 036H, 03BH, 030H, 030H, 030H, 000H	; 72H r 
       00			
 FE06  00 00 3E 70 3C 0E 7C		DB	000H, 000H, 03EH, 070H, 03CH, 00EH, 07CH, 000H	; 73H s 
       00			
 FE0E  18 18 7E 18 18 18 0E		DB	018H, 018H, 07EH, 018H, 018H, 018H, 00EH, 000H	; 74H t 
       00			
 FE16  00 00 66 66 66 66 3B		DB	000H, 000H, 066H, 066H, 066H, 066H, 03BH, 000H	; 75H u 
       00			
 FE1E  00 00 66 66 66 3C 18		DB	000H, 000H, 066H, 066H, 066H, 03CH, 018H, 000H	; 76H v 
       00			
 FE26  00 00 63 63 6B 7F 36		DB	000H, 000H, 063H, 063H, 06BH, 07FH, 036H, 000H	; 77H w 
       00			
 FE2E  00 00 63 36 1C 36 63		DB	000H, 000H, 063H, 036H, 01CH, 036H, 063H, 000H	; 78H x 
       00			
 FE36  00 00 66 66 66 3E 06		DB	000H, 000H, 066H, 066H, 066H, 03EH, 006H, 07CH	; 79H y 
       7C			
 FE3E  00 00 7E 0C 18 30 7E		DB	000H, 000H, 07EH, 00CH, 018H, 030H, 07EH, 000H	; 7AH z 
       00			
 FE46  0E 18 18 78 18 18 0E		DB	00EH, 018H, 018H, 078H, 018H, 018H, 00EH, 000H	; 7BH { 
       00			
 FE4E  18 18 18 00 18 18 18		DB	018H, 018H, 018H, 000H, 018H, 018H, 018H, 000H	; 7CH | 
       00			
 FE56  70 18 18 0E 18 18 70		DB	070H, 018H, 018H, 00EH, 018H, 018H, 070H, 000H	; 7DH } 
       00			
 FE5E  3B 6E 00 00 00 00 00		DB	03BH, 06EH, 000H, 000H, 000H, 000H, 000H, 000H	; 7EH ~ 
       00			
 FE66  18 3C 66 C3 C3 FF 00		DB	018H, 03CH, 066H, 0C3H, 0C3H, 0FFH, 000H, 000H	; 7FH 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-209


       00			
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 1A - System and "Real Time" Clock BIOS Services 
				;----------------------------------------------------------------------------; 
				; INT 1A,0   Read system clock counter 
				; INT 1A,1   Set system clock counter 
				;----------------------------------------------------------------------------; 
 FE6E						ORG 0FE6EH 
 FE6E				INT_1A PROC 
						ASSUME DS:_BDA 
 FE6E  FB				STI						; enable interrupts 
 FE6F  80 EC 01				SUB	AH, 1 				; is function 0 or 1? 
 FE72  77 18				JA	INT_1A_EXIT 			; if not, exit 
 FE74  1E				PUSH	DS 
 FE75  56				PUSH	SI 
 FE76  BE ---- R			MOV	SI, SEG _BDA 			; get BDA segment 
 FE79  8E DE				MOV	DS, SI 				; DS = BDA 
 FE7B  BE 006C R			MOV	SI, OFFSET TIMER			; SI = BIOS Timer 
 FE7E  FA				CLI 						; disable interrupts 
 FE7F  74 0C				JZ	INT_1A_SET 				; AH = 1, jump to Set clock 
											; AH = 0, fall through to Read 
				 
				;----------------------------------------------------------------------------; 
				; INT 1A,0   Read system clock counter 
				;----------------------------------------------------------------------------; 
				; Output: 
				;	AL = midnight flag, 1 if 24 hours passed since reset 
				;	CX = high order word of tick count 
				;	DX = low order word of tick count 
				;----------------------------------------------------------------------------; 
 FE81				INT_1A_READ PROC 
 FE81  FC				CLD						; string direction forward 
 FE82  AD				LODSW 					; AX = low word of timer 
 FE83  92				XCHG	AX, DX 
 FE84  AD				LODSW 					; AX = high word of timer 
 FE85  91				XCHG	AX, CX 
 FE86  33 C0				XOR	AX, AX				; reset midnight flag to 0 
 FE88  86 04				XCHG	AL, [SI]				; AL = BDA flag, BDA = 0 
 FE8A				INT_1A_DONE: 
					;STI 						; re-enable interrupts 
 FE8A  5E				POP	SI 
 FE8B  1F				POP	DS 
 FE8C				INT_1A_EXIT: 
 FE8C  CF				IRET 
 FE8D				INT_1A_READ ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 1A,1   Set system clock counter 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AH = 0 
				;	CX = high order word of tick count 
				;	DX = low order word of tick count 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-210


				;----------------------------------------------------------------------------; 
 FE8D				INT_1A_SET PROC 
 FE8D  89 14				MOV	[SI].LW, DX				; set low word ticks (seconds) 
 FE8F  89 4C 02				MOV	[SI].HW, CX				; set high word ticks (hours) 
 FE92  88 64 04				MOV	[SI].OF, AH				; reset midnight counter (0) 
 FE95  EB F3				JMP	SHORT INT_1A_DONE 
 FE97				INT_1A_SET ENDP 
				 
 FE97				INT_1A ENDP 
				 
 FE97				INT_08_PROC PROC 
				;----------------------------------------------------------------------------; 
				; INT 8 - Floppy Motor shutoff has elapsed - shut off motor 
				;----------------------------------------------------------------------------; 
 FE97				INT_08_MOTOR_OFF: 
 FE97  B0 F0				MOV	AL, NOT MASK FMOT			; BDA motor off on all drives 
 FE99  20 06 003F R			AND	FD_MOTOR_ST, AL			; write to BDA 
 FE9D  34 FC				XOR	AL, NOT MASK FDSEL		; FDC motor off on all drives 
 FE9F  BA 03F2				MOV	DX, FDC_CTRL 			; FD control port 
 FEA2  EE				OUT	DX, AL 				; write to controller 
 FEA3  EB 20				JMP	SHORT INT_08_INT_1C 
				 
				; 
				; 0 BYTES HERE 
				; 
				BYTES_HERE	INT_08 
 = 0000                      1	BYTES_HERE_INT_08 = INT_08-$ 
			     1			IFDEF BYTES_HERE_INT_08 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 8 - Timer 
				;----------------------------------------------------------------------------; 
				; - Run 18.2 times per second by PIT Timer 
				; - f = 1193182 / 10000H 
				; - Increment 32 bit counter, overflows at 24 hours + 9.67 sec 
				;	( 3600s/h - 65,536t / ( 1,193,182t/s / 65,536t ) ) * 24h = ~9.67s 
				; - Decrement floppy disk motor timeout counter 
				;  	  if reaches 0, turns off motor 
				; - only take jumps on special cases 
				; 
				; IMPORTANT NOTE: ROM BASIC's INT 1CH handler clobbers DX, so DX 
				; MUST be call-preserved here. 
				;----------------------------------------------------------------------------; 
 FEA5						ORG 0FEA5H 
 FEA5				INT_08 PROC 
						ASSUME DS:_BDA 
 FEA5  50				PUSH	AX 					; save AX, DX, DS and DI 
 FEA6  52				PUSH	DX					; workaround ROM BASIC INT 1Ch bug 
 FEA7  1E				PUSH	DS 
 FEA8  57				PUSH	DI 
 FEA9  B8 ---- R			MOV	AX, SEG _BDA 			; DS = BIOS Data Area 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-211


 FEAC  8E D8				MOV	DS, AX 
 FEAE  99				CWD						; DX = 0 
				 
				;----------------------------------------------------------------------------; 
				; Increment Timer 
				; 
 FEAF				INT_08_TICK_TIMER:				; Advance the time ticker 
 FEAF  BF 006C R			MOV	DI, OFFSET TIMER 			; Low timer at BDA 0040:006C 
 FEB2  83 05 01				ADD	[DI].LW, 1				; increment low word 
 FEB5  11 55 02				ADC	[DI].HW, DX				; carry into high word 
 FEB8  83 7D 02 18			CMP	[DI].HW, 24 			; rolled over to next day? 
 FEBC  73 13				JAE	INT_08_TICK_DAY			; if so, check for day rollover 
				 
				;----------------------------------------------------------------------------; 
				; Decrement Floppy Motor shutoff counter 
				; 
 FEBE				INT_08_FD_MOTOR: 					; Check if there is a motor timeout 
 FEBE  FB				STI						; interrupts back on 
 FEBF  FE 0E 0040 R			DEC	FD_MOTOR_CT 			; increment counter, has reached 0? 
 FEC3  74 D2				JZ	INT_08_MOTOR_OFF			; if so, turn off motor 
				 
				;----------------------------------------------------------------------------; 
				; Call INT 1CH user vector 
				; 
 FEC5				INT_08_INT_1C: 
 FEC5  CD 1C				INT	1CH					; call user timer hook 
				 
				;----------------------------------------------------------------------------; 
				; Interrupt Complete - send EOI and return 
				; 
 FEC7				INT_08_EOI: 
 FEC7  FA				CLI						; disable interrupts for EOI 
 FEC8  B0 20				MOV	AL, EOI 				; End of Interrupt OCW 
 FECA  E6 20				OUT	INT_P0, AL				; write EOI to port 0 
 FECC  5F				POP	DI 
 FECD  1F				POP	DS 
 FECE  5A				POP	DX					; restore DX 
 FECF  58				POP	AX 
 FED0  CF				IRET 
				 
				;----------------------------------------------------------------------------; 
				; Check if day has rolled over (24H + 9.67s) and reset 32 bit ticker if so 
				; 
 FED1				INT_08_TICK_DAY: 
 FED1  80 3D B0				CMP	BYTE PTR [DI].LW, 176 		; has day rolled over? 
 FED4  72 E8				JB	INT_08_FD_MOTOR			; if not, handle FD motor timeout 
				 
				;----------------------------------------------------------------------------; 
				; Timer has rolled over 24 hours - reset counters and increment midnight 
				; http://www.ctyme.com/intr/rb-2271.htm 
				; http://www.phatcode.net/res/246/files/pctim003.txt 
				; 
 FED6				INT_08_RESET: 
 FED6  89 15				MOV	[DI].LW, DX				; TIMER low word = 0 
 FED8  89 55 02				MOV	[DI].HW, DX				; TIMER high word = 0 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-212


 FEDB  FE 45 04				INC	[DI].OF				; increment TIMER midnight counter 
 FEDE  EB DE				JMP	INT_08_FD_MOTOR			; continue and check motor 
				 
 FEE0				INT_08 ENDP 
 FEE0				INT_08_PROC ENDP 
				 
				; 
				; 3 BYTES HERE 
				; 
				BYTES_HERE	VECTOR_TABLE 
 = 0003                      1	BYTES_HERE_VECTOR_TABLE = VECTOR_TABLE-$ 
			     1			IFDEF BYTES_HERE_VECTOR_TABLE 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Interrupt Vector Table - These fill the IVT prior to bootstrap 
				;----------------------------------------------------------------------------; 
				; Each ISR is found at the compatibility offset described here: 
				; https://www.intel.com/content/dam/doc/reference-guide/efi-compatibility-support-module-specificati
				on-v097.pdf 
				;----------------------------------------------------------------------------; 
 FEE3						ORG 0FEE3H 
 FEE3				VECTOR_TABLE PROC 
 FEE3  FF23 R				DW  OFFSET INT_IRQ 		; INT 00 
 FEE5  FF23 R				DW  OFFSET INT_IRQ 		; INT 01 
 FEE7  E2C3 R				DW  OFFSET INT_02 		; INT 02	NMI 
 FEE9  FF23 R				DW  OFFSET INT_IRQ 		; INT 03 
 FEEB  FF23 R				DW  OFFSET INT_IRQ 		; INT 04 
 FEED  FF54 R				DW  OFFSET INT_05 		; INT 05	Print Screen 
 FEEF  FF23 R				DW  OFFSET INT_IRQ 		; INT 06 
 FEF1  FF23 R				DW  OFFSET INT_IRQ 		; INT 07 
				 
				;----------------------------------------------------------------------------; 
				; Compatibility fixed ORG for INT 08 - 1Eh 
				; 
 FEF3						ORG 0FEF3H 
 FEF3  FEA5 R				DW  OFFSET INT_08 		; INT 08	IRQ0 System timer 
 FEF5  E944 R				DW  OFFSET INT_09_POST		; INT 09	IRQ1 Keyboard IRQ (during POST) 
 FEF7  FF23 R				DW  OFFSET INT_IRQ		; INT 0A	IRQ2 Reserved 
 FEF9  FF23 R				DW  OFFSET INT_IRQ		; INT 0B	IRQ3 COM2 
 FEFB  FF23 R				DW  OFFSET INT_IRQ		; INT 0C	IRQ4 COM1 
 FEFD  FF23 R				DW  OFFSET INT_IRQ		; INT 0D	IRQ5 XT FDC 
 FEFF  EF57 R				DW  OFFSET INT_0E			; INT 0E	IRQ6 Floppy Controller 
 FF01  FF23 R				DW  OFFSET INT_IRQ		; INT 0F	IRQ7 LPT 
 FF03  F065 R				DW  OFFSET INT_10			; INT 10	Video 
 FF05  F84D R				DW  OFFSET INT_11			; INT 11	Equipment Check 
 FF07  F841 R				DW  OFFSET INT_12			; INT 12	Memory Size 
 FF09  EC59 R				DW  OFFSET INT_13			; INT 13	Floppy Disk 
 FF0B  E739 R				DW  OFFSET INT_14			; INT 14	Serial Port 
 FF0D  F859 R				DW  OFFSET INT_15			; INT 15	System Services 
 FF0F  E82E R				DW  OFFSET INT_16			; INT 16	Keyboard Services 
 FF11  EFD2 R				DW  OFFSET INT_17			; INT 17	Printer 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-213


 FF13  E4B6 R				DW  OFFSET INT_18 		; INT 18	Unbootable/ROM BASIC 
 FF15  E6F2 R				DW  OFFSET INT_19			; INT 19	Bootstrap 
 FF17  FE6E R				DW  OFFSET INT_1A			; INT 1A	Time of day 
 FF19  FF53 R				DW  OFFSET INT_RET 		; INT 1B	Ctrl Brk 
 FF1B  FF53 R				DW  OFFSET INT_RET 		; INT 1C	Timer Tick 
 FF1D  F0A4 R				DW  OFFSET INT_1D 		; INT 1D	CRTC param table 
 FF1F  EFC7 R				DW  OFFSET INT_1E 		; INT 1E	Floppy param table 
 = 001F				L_VECTOR_TABLE = ($-VECTOR_TABLE)/2	; number of vectors 1Fh (31) 
 FF21  0000				DW  0 				; INT 1F	8x8 (CP 128-255) custom 
										;		 video font table (0000:0000) 
 FF23				VECTOR_TABLE ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT_IRQ - Handle placeholder hardware interrupts 
				;----------------------------------------------------------------------------; 
				; ISR for any hardware interrupts that have yet to be vectored. 
				; Acknowledge interrupt, mask the active one and write last HW interrupt to BDA. 
				; 
				; Output: 
				;	INT_LAST = last interrupt or 0FFh if non-hardware/unknown interrupt 
				;----------------------------------------------------------------------------; 
 FF23						ORG 0FF23H 
 FF23				INT_IRQ PROC 
							ASSUME DS:_BDA_ABS 
 FF23  50				PUSH	AX 
 FF24  1E				PUSH	DS				; save DS 
 FF25  B0 0B				MOV	AL, OCW3 <,,,,11b> 	; AL = OCW3 Read ISR reg on next pulse 
 FF27  E6 20				OUT	INT_P0, AL			; write to PIC A0 (20h) 
 FF29  33 C0				XOR	AX, AX			; AH = 0, delay for PIC at least 1 clock pulse 
 FF2B  8E D8				MOV	DS, AX			; set DS to BDA_ABS (segment 0000h) 
 FF2D  E4 20				IN	AL, INT_P0			; get current In-Service Register (ISR) 
 FF2F  48				DEC	AX				; if ISR is zero there is no active hardware int 
 FF30  7C 0D				JL	INT_IRQ_DONE		; if no active int, exit with INT_LAST = FFh 
 FF32  40				INC	AX				; otherwise INT_LAST = active interrupt level 
 FF33  8A E0				MOV	AH, AL 			; restore ISR and save to AH 
 FF35  E4 21				IN	AL, INT_IMR			; get current Interrupt Mask Register (IMR) 
 FF37  0A C4				OR	AL, AH 			; mask active interrupt 
 FF39  E6 21				OUT	INT_IMR, AL			; write new IMR to PIC A1 (21h) 
 FF3B  B0 20				MOV	AL, EOI 			; AL = OCW2 End of Interrupt 
 FF3D  E6 20				OUT	INT_P0, AL			; write EOI to PIC A0 (20h) 
 FF3F				INT_IRQ_DONE: 
 FF3F  88 26 046B R			MOV	INT_LAST_ABS, AH	 	; save last interrupt to BDA 
 FF43  1F				POP	DS 
 FF44  58				POP	AX 
 FF45  CF				IRET 
							ASSUME DS:NOTHING 
 FF46				INT_IRQ ENDP 
				 
				;----------------------------------------------------------------------------; 
				; POST Video Adapter Type Strings (2 of 2) 
				; 11 bytes 
				; 
								IF POST_VIDEO_TYPE EQ 1 
 FF46  56 69 64 65 6F 00	POST_VIDEO		DB	'Video', 0 
								ENDIF 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-214


 FF4C  4E 6F 6E 65 00		POST_NONE		DB	'None', 0	; must be contiguous to POST_VIDEO 
				 
				; 
				; 2 BYTES HERE 
				; 
				BYTES_HERE	INT_RET 
 = 0002                      1	BYTES_HERE_INT_RET = INT_RET-$ 
			     1			IFDEF BYTES_HERE_INT_RET 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT_RET - Handle placeholder software interrupts 
				;----------------------------------------------------------------------------; 
 FF53						ORG 0FF53H 
 FF53				INT_RET PROC 
 FF53  CF				IRET 
 FF54				INT_RET ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 5 - Print Screen 
				;----------------------------------------------------------------------------; 
				; Print the contents of the current screen/page. 
				; 
				; Output: 
				; - Screen contents to PRN (BIOS printer 0) 
				; - Status to BDA 50:0H: 
				;	00	Print screen has not been called, or upon return 
				;			from a call there were no errors 
				;	01	Print screen is already in progress 
				;	FF	Error encountered during printing 
				;----------------------------------------------------------------------------; 
				; Things you must do: 
				; 	1. Check status (BDA 50:0H) to ensure PrtScn is not already in progress. 
				;	2. Set working status to 1. 
				;	3. Get the current screen size (columns) and video page. 
				;	4. Save the current cursor position, then move to the top. 
				;	5. Read the char at that position and send to printer. 
				;	6. If last column reached, move screen cursor to start of next line 
				;		and send CR and LF to printer to start new line. 
				;	7. Keep looping until past the last row (always 25) 
				;	8. Restore screen cursor position 
				;	9. Set BDA status to either success (0) or error (-1) 
				;----------------------------------------------------------------------------; 
 FF54						ORG 0FF54H 
 FF54				INT_05 PROC 
							ASSUME DS:_BDA 
 FF54  FC				CLD						; string direction forward 
					PUSHX	AX, DI, ES				; preserve caller registers 
			     1				IFNB <AX>			; exit if last reg 
 FF55  50                    1		PUSH	AX 					; push register and repeat 
			     1		PUSHX	DI, ES, , , , ,  
			     2				IFNB <DI>			; exit if last reg 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-215


 FF56  57                    2		PUSH	DI 					; push register and repeat 
			     2		PUSHX	ES, , , , , ,  
			     3				IFNB <ES>			; exit if last reg 
 FF57  06                    3		PUSH	ES 					; push register and repeat 
			     3		PUSHX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 FF58  BF ---- R			MOV	DI, SEG _DOS_DAT 
 FF5B  8E C7				MOV	ES, DI				; ES = seg 50H 
 FF5D  33 FF				XOR	DI, DI				; DI = PTRSCN_ST (offset 00H) 
 FF5F  B0 01				MOV	AL, 1					; print status = 1 (in progress) 
 FF61  AE				SCASB						; is in progress already? 
 FF62  74 42				JZ	INT_05_EXIT				; if so, exit 
 FF64  FB				STI						; Interrupts should be okay now 
 FF65  4F				DEC	DI					; undo earlier SCASB increment 
 FF66  AA				STOSB						; update status to 1 
					PUSHX	BX, CX, DX				; preserve working registers 
			     1				IFNB <BX>			; exit if last reg 
 FF67  53                    1		PUSH	BX 					; push register and repeat 
			     1		PUSHX	CX, DX, , , , ,  
			     2				IFNB <CX>			; exit if last reg 
 FF68  51                    2		PUSH	CX 					; push register and repeat 
			     2		PUSHX	DX, , , , , ,  
			     3				IFNB <DX>			; exit if last reg 
 FF69  52                    3		PUSH	DX 					; push register and repeat 
			     3		PUSHX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 FF6A  B4 0F				MOV	AH, 0FH				; get video state (columns) 
 FF6C  CD 10				INT	10H					; AH = screen columns, BH = page 
 FF6E  8A DC				MOV	BL, AH				; BL = screen columns 
 FF70  4B				DEC	BX					; fix 0 index 
 FF71  B4 03				MOV	AH, 3					; get cursor position 
 FF73  CD 10				INT	10H					; DH = cursor row, DL = cursor column 
 FF75  52				PUSH	DX					; save starting cursor position 
 FF76  E8 FFAA R			CALL	LPT_CRLF				; start print head on new line 
 FF79  72 1F				JC	INT_05_DONE				; exit if print error 
 FF7B  99				CWD						; start position at row 0, col 0 
 FF7C				INT_05_LOOP_1: 
 FF7C  B4 02				MOV	AH, 2					; set cursor position 
 FF7E  CD 10				INT	10H					; set cursor to DH=row, DL=col 
 FF80  B4 08				MOV	AH, 8					; get char/attr at current position 
 FF82  CD 10				INT	10H					; AL = char at current position 
 FF84  E8 FFB3 R			CALL	LPT_CHAR				; print char in AL 
 FF87  72 11				JC	INT_05_DONE				; exit if print error 
 FF89  3A DA				CMP	BL, DL				; end of screen cols? 
 FF8B  75 07				JNE	INT_05_NEXT_COL			; jump if not 
 FF8D  B2 FF				MOV	DL, -1				; else move to first col and next row 
 FF8F  E8 FFAA R			CALL	LPT_CRLF				; CR and LF to PRN 
 FF92  72 06				JC	INT_05_DONE				; exit if print error 
 FF94				INT_05_NEXT_COL: 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-216


 FF94  42				INC	DX					; move to next column (and maybe row) 
 FF95  80 FE 19				CMP	DH, VID_DEF_ROWS+1		; end of screen rows? 
 FF98  75 E2				JNE	INT_05_LOOP_1			; loop while not last row, CF=0 when done 
 FF9A				INT_05_DONE: 
 FF9A  1A C0				SBB	AL, AL				; print status: AL = 0 if NC, AL = -1 if CF 
 FF9C  4F				DEC	DI					; undo earlier STOSB increment 
 FF9D  AA				STOSB						; update BDA status 
 FF9E  5A				POP	DX					; restore starting cursor position 
 FF9F  B4 02				MOV	AH, 2					; set cursor position in DH/DL 
 FFA1  CD 10				INT	10H 
					POPX	DX, CX, BX 
			     1				IFNB <DX>			; exit if last reg 
 FFA3  5A                    1		POP	DX 					; pop register and repeat 
			     1		POPX	CX, BX, , , , ,  
			     2				IFNB <CX>			; exit if last reg 
 FFA4  59                    2		POP	CX 					; pop register and repeat 
			     2		POPX	BX, , , , , ,  
			     3				IFNB <BX>			; exit if last reg 
 FFA5  5B                    3		POP	BX 					; pop register and repeat 
			     3		POPX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 FFA6				INT_05_EXIT: 
					POPX	ES, DI, AX 
			     1				IFNB <ES>			; exit if last reg 
 FFA6  07                    1		POP	ES 					; pop register and repeat 
			     1		POPX	DI, AX, , , , ,  
			     2				IFNB <DI>			; exit if last reg 
 FFA7  5F                    2		POP	DI 					; pop register and repeat 
			     2		POPX	AX, , , , , ,  
			     3				IFNB <AX>			; exit if last reg 
 FFA8  58                    3		POP	AX 					; pop register and repeat 
			     3		POPX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 FFA9  CF				IRET 
				 
				;----------------------------------------------------------------------------; 
				; LPT_CRLF - Write CR and LF to PRN 
				;----------------------------------------------------------------------------; 
 FFAA				LPT_CRLF PROC 
 FFAA  B0 0D				MOV	AL, CR 
 FFAC  E8 FFB3 R			CALL	LPT_CHAR 
 FFAF  72 11				JC	LPT_CHAR_EXIT			; exit if print error 
				 
				;----------------------------------------------------------------------------; 
				; LPT_LF - Write LF to PRN 
				;----------------------------------------------------------------------------; 
 FFB1				LPT_LF PROC 
 FFB1  B0 0A				MOV	AL, LF 
				 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-217


				;----------------------------------------------------------------------------; 
				; LPT_CHAR - Write a char to PRN 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AL = char to print 
				; Output: 
				;	CF = 1 (CY) if timeout 
				; 
				; AL clobbered if null 
				;----------------------------------------------------------------------------; 
 FFB3				LPT_CHAR PROC 
 FFB3  52				PUSH	DX 
 FFB4  B4 00				MOV	AH, 0					; Print Character function 
 FFB6  99				CWD						; DX = printer 0 (PRN) 
 FFB7  84 C0				TEST	AL, AL				; was input char a null? 
 FFB9  75 02				JNZ	LPT_CHAR_OUT			; jump if not 
 FFBB  B0 20				MOV	AL, ' '				; if so, use a space 
 FFBD				LPT_CHAR_OUT: 
 FFBD  CD 17				INT	17H					; Print AL to PRN0 
 FFBF  D0 EC				SHR	AH, 1					; CF if timeout 
 FFC1  5A				POP	DX 
 FFC2				LPT_CHAR_EXIT: 
 FFC2  C3				RET 
 FFC3				LPT_CHAR ENDP 
 FFC3				LPT_LF ENDP 
 FFC3				LPT_CRLF ENDP 
				 
 FFC3				INT_05 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Check if a 8087 FPU is present and perform quick tests 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	DI = any non-zero value 
				; Output: 
				;	ZF = 0 if no FPU, ZF = 1 if present 
				; 
				; Clobbers: BX, DI 
				; 
				; Sources: 
				;   https://retrocomputing.stackexchange.com/questions/16529/detecting-the-external-x87-fpu 
				;   Intel(R) App Note AP-485 "Intel(R) Processor Identification and the CPUID Instruction" 
				;----------------------------------------------------------------------------; 
 FFC3				HAS_FPU PROC 
 FFC3  97				XCHG	AX, DI			; save AX 
 FFC4  DB E3				FNINIT 				; reset FPU, no wait 
				 
				;----------------------------------------------------------------------------; 
				; Test Status Word 
				; 
 FFC6				FPU_TEST_SW: 
 FFC6  50				PUSH	AX 				; init temp word to non-zero 
 FFC7  8B DC				MOV	BX, SP	 		; use stack memory 
 FFC9  36: DD 3F			FNSTSW WORD PTR SS:[BX]		; store status word 
 FFCC  90				NOP					; delay to allow FPU to complete 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-218


 FFCD  58				POP	AX 				; AX = control word if FNSTCW executed 
 FFCE  84 C0				TEST	AL, AL 			; check exception flags 
 FFD0  75 0C				JNZ	FPU_TEST_DONE		; if flags = 00, FPU is present 
				 
				;----------------------------------------------------------------------------; 
				; Test Control Word 
				; 
 FFD2				FPU_TEST_CW: 
 FFD2  50				PUSH	AX 
 FFD3  36: D9 3F			FNSTCW WORD PTR SS:[BX]		; store control word 
 FFD6  90				NOP					; delay to allow FPU to complete 
 FFD7  58				POP	AX 				; AX = control word 
 FFD8  35 103F				XOR	AX, 0103FH 			; isolate interesting status flags 
 FFDB  25 003F				AND	AX, 03FH 			; check for 8087 "signature" 
										; ZF = 0 if no FPU 
 FFDE				FPU_TEST_DONE: 
 FFDE  97				XCHG	AX, DI			; restore AX 
 FFDF  C3				RET 
 FFE0				HAS_FPU ENDP 
				 
				; 
				; 0 BYTES HERE 
				; 
				BYTES_HERE	VER 
 = 0000                      1	BYTES_HERE_VER = VER-$ 
			     1			IFDEF BYTES_HERE_VER 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Version and Build Strings 
				;----------------------------------------------------------------------------; 
 FFE0						ORG	0FFE0H 
 FFE0  56 65 72 3A 20		VER 	DB	'Ver: ' 
 FFE5  30 2E 32 2E 36			DB	VER_NUM 
 FFEA  2D				DB	'-'				; Show CPU type and 
 FFEB  38				DB	CPU_TYPE			; architecture target 
 FFEC  54				DB	ARCH_TYPE 
							ENDIF 
 FFED  20				DB	' '				; space before date 
 FFEE  00				DB	0 
				 
				; 
				; 0 BYTES HERE 
				; 
				BYTES_HERE	POWER_ON 
 = 0001                      1	BYTES_HERE_POWER_ON = POWER_ON-$ 
			     1			IFDEF BYTES_HERE_POWER_ON 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Page     1-219


 FFEF				BIOS		ENDS 
glabios.asm(12506): warning A4102: Segment near (or at) 64K limit
				 
				;============================================================================; 
				; 
				;				* * *    END OF BIOS   * * * 
				; 
				;============================================================================; 
				 
				END 

Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-1


Macros:

		N a m e			Lines

AAD_I  . . . . . . . . . . . . .  	   1
AAM_I  . . . . . . . . . . . . .  	   1
BEEP_OFF . . . . . . . . . . . .  	   1
BEEP_ON  . . . . . . . . . . . .  	   6
BEXT . . . . . . . . . . . . . .  	   2
BINS . . . . . . . . . . . . . .  	   2
BYTES_HERE . . . . . . . . . . .  	   9
CALL_NS  . . . . . . . . . . . .  	   9
CGA_WAIT_SYNC  . . . . . . . . .  	  26
CLR1 . . . . . . . . . . . . . .  	   1
CMP_EFLAG  . . . . . . . . . . .  	  25
GET_EFLAG  . . . . . . . . . . .  	  64
IO_DELAY . . . . . . . . . . . .  	   2
IO_DELAY_LONG  . . . . . . . . .  	   4
IO_DELAY_SHORT . . . . . . . . .  	   4
IO_DELAY_TURBO . . . . . . . . .  	   5
IRET_F . . . . . . . . . . . . .  	   1
JNWB . . . . . . . . . . . . . .  	   2
JWB  . . . . . . . . . . . . . .  	   4
NOT1 . . . . . . . . . . . . . .  	   1
POPX . . . . . . . . . . . . . .  	   4
POST_CODE  . . . . . . . . . . .  	   8
POST_COL_1 . . . . . . . . . . .  	  13
POST_COL_2 . . . . . . . . . . .  	  13
POST_COL_END . . . . . . . . . .  	   7
POST_COL_END_NL  . . . . . . . .  	   7
POST_FLAG_CLR  . . . . . . . . .  	  10
POST_FLAG_FLIP . . . . . . . . .  	   5
POST_FLAG_SET  . . . . . . . . .  	   5
POST_FLAG_TEST . . . . . . . . .  	   5
PRINTLN_SZ . . . . . . . . . . .  	  10
PRINT_SZ . . . . . . . . . . . .  	  10
PUSHX  . . . . . . . . . . . . .  	   4
ROL4 . . . . . . . . . . . . . .  	   1
ROR4 . . . . . . . . . . . . . .  	   1
SET1 . . . . . . . . . . . . . .  	   1
SET_EFLAG  . . . . . . . . . . .  	  41
SET_GFLAG  . . . . . . . . . . .  	   4
SET_SZ_ATTR  . . . . . . . . . .  	  18
TEST1  . . . . . . . . . . . . .  	   1
TEST_EFLAG . . . . . . . . . . .  	   5
TEST_GFLAG . . . . . . . . . . .  	   1
V20_OP1  . . . . . . . . . . . .  	   6

Structures and Records:

                N a m e                 Width   # fields
                                        Shift   Width   Mask    Initial

BEEP_SL  . . . . . . . . . . . .  	0008	0002
  BEEP_S . . . . . . . . . . . .  	0004	0004	00F0	0000
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-2


  BEEP_L . . . . . . . . . . . .  	0000	0004	000F	0000
COM_LCR  . . . . . . . . . . . .  	0008	0007
  DLAB . . . . . . . . . . . . .  	0007	0001	0080	0000
  LCBK . . . . . . . . . . . . .  	0006	0001	0040	0000
  LCPD . . . . . . . . . . . . .  	0005	0001	0020	0000
  LCEPS  . . . . . . . . . . . .  	0004	0001	0010	0000
  LCPEN  . . . . . . . . . . . .  	0003	0001	0008	0000
  LCSB . . . . . . . . . . . . .  	0002	0001	0004	0000
  LCWLS  . . . . . . . . . . . .  	0000	0002	0003	0000
COM_LSR  . . . . . . . . . . . .  	0008	0008
  LSX  . . . . . . . . . . . . .  	0007	0001	0080	0000
  TSRE . . . . . . . . . . . . .  	0006	0001	0040	0000
  THRE . . . . . . . . . . . . .  	0005	0001	0020	0000
  LBI  . . . . . . . . . . . . .  	0004	0001	0010	0000
  LFE  . . . . . . . . . . . . .  	0003	0001	0008	0000
  LPE  . . . . . . . . . . . . .  	0002	0001	0004	0000
  LOE  . . . . . . . . . . . . .  	0001	0001	0002	0000
  LDR  . . . . . . . . . . . . .  	0000	0001	0001	0000
COM_MCR  . . . . . . . . . . . .  	0008	0006
  MCRX . . . . . . . . . . . . .  	0005	0003	00E0	0000
  MCLB . . . . . . . . . . . . .  	0004	0001	0010	0000
  MCO2 . . . . . . . . . . . . .  	0003	0001	0008	0000
  MCO1 . . . . . . . . . . . . .  	0002	0001	0004	0000
  RTS  . . . . . . . . . . . . .  	0001	0001	0002	0000
  DTR  . . . . . . . . . . . . .  	0000	0001	0001	0000
COM_MSR  . . . . . . . . . . . .  	0008	0008
  MLSD . . . . . . . . . . . . .  	0007	0001	0080	0000
  MRI  . . . . . . . . . . . . .  	0006	0001	0040	0000
  MDSR . . . . . . . . . . . . .  	0005	0001	0020	0000
  MCTS . . . . . . . . . . . . .  	0004	0001	0010	0000
  DDCD . . . . . . . . . . . . .  	0003	0001	0008	0000
  DRI  . . . . . . . . . . . . .  	0002	0001	0004	0000
  DDSR . . . . . . . . . . . . .  	0001	0001	0002	0000
  DCTS . . . . . . . . . . . . .  	0000	0001	0001	0000
CRTC . . . . . . . . . . . . . .  	0010	0010
  H_TC . . . . . . . . . . . . .  	0000
  H_CL . . . . . . . . . . . . .  	0001
  H_SP . . . . . . . . . . . . .  	0002
  H_SW . . . . . . . . . . . . .  	0003
  V_TL . . . . . . . . . . . . .  	0004
  V_SL . . . . . . . . . . . . .  	0005
  V_DR . . . . . . . . . . . . .  	0006
  V_SP . . . . . . . . . . . . .  	0007
  IL . . . . . . . . . . . . . .  	0008
  MSL  . . . . . . . . . . . . .  	0009
  CSL  . . . . . . . . . . . . .  	000A
  CEL  . . . . . . . . . . . . .  	000B
  SA_H . . . . . . . . . . . . .  	000C
  SA_L . . . . . . . . . . . . .  	000D
  CA_H . . . . . . . . . . . . .  	000E
  CA_L . . . . . . . . . . . . .  	000F
DBT  . . . . . . . . . . . . . .  	000B	000B
  SRT  . . . . . . . . . . . . .  	0000
  HLT_ND . . . . . . . . . . . .  	0001
  FMCT . . . . . . . . . . . . .  	0002
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-3


  FBPS . . . . . . . . . . . . .  	0003
  SPT  . . . . . . . . . . . . .  	0004
  SGAP . . . . . . . . . . . . .  	0005
  LSEC . . . . . . . . . . . . .  	0006
  FGAP . . . . . . . . . . . . .  	0007
  FFILL  . . . . . . . . . . . .  	0008
  HDST . . . . . . . . . . . . .  	0009
  FMST . . . . . . . . . . . . .  	000A
DBW  . . . . . . . . . . . . . .  	0010	0002
  HWB  . . . . . . . . . . . . .  	0008	0008	FF00	0000
  LWB  . . . . . . . . . . . . .  	0000	0008	00FF	0000
DMA_CR . . . . . . . . . . . . .  	0008	0008
  DACK . . . . . . . . . . . . .  	0007	0001	0080	0000
  DREQ . . . . . . . . . . . . .  	0006	0001	0040	0000
  DWS  . . . . . . . . . . . . .  	0005	0001	0020	0000
  DPRI . . . . . . . . . . . . .  	0004	0001	0010	0000
  DTIM . . . . . . . . . . . . .  	0003	0001	0008	0000
  DDIS . . . . . . . . . . . . .  	0002	0001	0004	0000
  DHLD . . . . . . . . . . . . .  	0001	0001	0002	0000
  DM2M . . . . . . . . . . . . .  	0000	0001	0001	0000
DMA_MR . . . . . . . . . . . . .  	0008	0005
  DMM  . . . . . . . . . . . . .  	0006	0002	00C0	0040
  DMINC  . . . . . . . . . . . .  	0005	0001	0020	0000
  DMAI . . . . . . . . . . . . .  	0004	0001	0010	0010
  DMOP . . . . . . . . . . . . .  	0002	0002	000C	0000
  DMCH . . . . . . . . . . . . .  	0000	0002	0003	0000
DMA_SMR  . . . . . . . . . . . .  	0008	0002
  SMCLR  . . . . . . . . . . . .  	0002	0006	00FC	0000
  SMCH . . . . . . . . . . . . .  	0000	0002	0003	0000
DMA_SR . . . . . . . . . . . . .  	0008	0008
  CR3  . . . . . . . . . . . . .  	0007	0001	0080	0000
  CR2  . . . . . . . . . . . . .  	0006	0001	0040	0000
  CR1  . . . . . . . . . . . . .  	0005	0001	0020	0000
  CR0  . . . . . . . . . . . . .  	0004	0001	0010	0000
  TC3  . . . . . . . . . . . . .  	0003	0001	0008	0000
  TC2  . . . . . . . . . . . . .  	0002	0001	0004	0000
  TC1  . . . . . . . . . . . . .  	0001	0001	0002	0000
  TC0  . . . . . . . . . . . . .  	0000	0001	0001	0000
DNB  . . . . . . . . . . . . . .  	0008	0002
  HBN  . . . . . . . . . . . . .  	0004	0004	00F0	0000
  LBN  . . . . . . . . . . . . .  	0000	0004	000F	0000
EFLAGS86 . . . . . . . . . . . .  	0008	0008
  FSF  . . . . . . . . . . . . .  	0007	0001	0080	0000
  FZF  . . . . . . . . . . . . .  	0006	0001	0040	0000
  FR1  . . . . . . . . . . . . .  	0005	0001	0020	0000
  FAF  . . . . . . . . . . . . .  	0004	0001	0010	0000
  FR2  . . . . . . . . . . . . .  	0003	0001	0008	0000
  FPF  . . . . . . . . . . . . .  	0002	0001	0004	0000
  FR3  . . . . . . . . . . . . .  	0001	0001	0002	0002
  FCF  . . . . . . . . . . . . .  	0000	0001	0001	0000
EQFLAGS  . . . . . . . . . . . .  	0010	000A
  LPT  . . . . . . . . . . . . .  	000E	0002	C000	0000
  X1 . . . . . . . . . . . . . .  	000D	0001	2000	0000
  GAM  . . . . . . . . . . . . .  	000C	0001	1000	0000
  COM  . . . . . . . . . . . . .  	0009	0003	0E00	0000
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-4


  DMA  . . . . . . . . . . . . .  	0008	0001	0100	0000
  FLP  . . . . . . . . . . . . .  	0006	0002	00C0	0000
  VID  . . . . . . . . . . . . .  	0004	0002	0030	0000
  MBRAM  . . . . . . . . . . . .  	0002	0002	000C	000C
  FPU  . . . . . . . . . . . . .  	0001	0001	0002	0000
  IPL  . . . . . . . . . . . . .  	0000	0001	0001	0001
FDC_CB . . . . . . . . . . . . .  	0008	0004
  FC0MT  . . . . . . . . . . . .  	0007	0001	0080	0000
  FC0MF  . . . . . . . . . . . .  	0006	0001	0040	0040
  FC0SK  . . . . . . . . . . . .  	0005	0001	0020	0000
  FC0CMD . . . . . . . . . . . .  	0000	0005	001F	0000
FDC_CB1  . . . . . . . . . . . .  	0008	0003
  FC1X . . . . . . . . . . . . .  	0003	0005	00F8	0000
  FC1HD  . . . . . . . . . . . .  	0002	0001	0004	0000
  FC1DS  . . . . . . . . . . . .  	0000	0002	0003	0000
FDC_CSB  . . . . . . . . . . . .  	0007	0007
  SB0  . . . . . . . . . . . . .  	0000
  SB1  . . . . . . . . . . . . .  	0001
  SB2  . . . . . . . . . . . . .  	0002
  CYL  . . . . . . . . . . . . .  	0003
  HEAD . . . . . . . . . . . . .  	0004
  SEC  . . . . . . . . . . . . .  	0005
  BPS  . . . . . . . . . . . . .  	0006
FDC_DOR  . . . . . . . . . . . .  	0008	0007
  FDMD . . . . . . . . . . . . .  	0007	0001	0080	0000
  FDMC . . . . . . . . . . . . .  	0006	0001	0040	0000
  FDMB . . . . . . . . . . . . .  	0005	0001	0020	0000
  FDMA . . . . . . . . . . . . .  	0004	0001	0010	0000
  FDDMA  . . . . . . . . . . . .  	0003	0001	0008	0000
  FDCEN  . . . . . . . . . . . .  	0002	0001	0004	0000
  FDSEL  . . . . . . . . . . . .  	0000	0002	0003	0000
FDC_MF . . . . . . . . . . . . .  	0008	0003
  FWRT . . . . . . . . . . . . .  	0007	0001	0080	0000
  FMTBD  . . . . . . . . . . . .  	0004	0003	0070	0000
  FMOT . . . . . . . . . . . . .  	0000	0004	000F	0000
FDC_MFD  . . . . . . . . . . . .  	0008	0005
  FMOTX  . . . . . . . . . . . .  	0004	0004	00F0	0000
  FMOT3  . . . . . . . . . . . .  	0003	0001	0008	0000
  FMOT2  . . . . . . . . . . . .  	0002	0001	0004	0000
  FMOT1  . . . . . . . . . . . .  	0001	0001	0002	0000
  FMOT0  . . . . . . . . . . . .  	0000	0001	0001	0000
FDC_MODE . . . . . . . . . . . .  	0008	0008
  FM1X . . . . . . . . . . . . .  	0007	0001	0080	0000
  FM1D . . . . . . . . . . . . .  	0006	0001	0040	0000
  FM1M . . . . . . . . . . . . .  	0005	0001	0020	0000
  FM18 . . . . . . . . . . . . .  	0004	0001	0010	0000
  FM0X . . . . . . . . . . . . .  	0003	0001	0008	0000
  FM0D . . . . . . . . . . . . .  	0002	0001	0004	0000
  FM0M . . . . . . . . . . . . .  	0001	0001	0002	0000
  FM08 . . . . . . . . . . . . .  	0000	0001	0001	0000
FDC_MSR  . . . . . . . . . . . .  	0008	0008
  FDRR . . . . . . . . . . . . .  	0007	0001	0080	0000
  FIOD . . . . . . . . . . . . .  	0006	0001	0040	0000
  FDND . . . . . . . . . . . . .  	0005	0001	0020	0000
  FDRW . . . . . . . . . . . . .  	0004	0001	0010	0000
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-5


  F3SK . . . . . . . . . . . . .  	0003	0001	0008	0000
  F2SK . . . . . . . . . . . . .  	0002	0001	0004	0000
  F1SK . . . . . . . . . . . . .  	0001	0001	0002	0000
  F0SK . . . . . . . . . . . . .  	0000	0001	0001	0000
FDC_SF . . . . . . . . . . . . .  	0008	0006
  FWIF . . . . . . . . . . . . .  	0007	0001	0080	0000
  FSTBD  . . . . . . . . . . . .  	0004	0003	0070	0000
  FCAL3  . . . . . . . . . . . .  	0003	0001	0008	0000
  FCAL2  . . . . . . . . . . . .  	0002	0001	0004	0000
  FCAL1  . . . . . . . . . . . .  	0001	0001	0002	0000
  FCAL0  . . . . . . . . . . . .  	0000	0001	0001	0000
FDC_ST0  . . . . . . . . . . . .  	0008	0006
  ST0CS  . . . . . . . . . . . .  	0006	0002	00C0	0000
  ST0SK  . . . . . . . . . . . .  	0005	0001	0020	0000
  ST0CHK . . . . . . . . . . . .  	0004	0001	0010	0000
  ST0NR  . . . . . . . . . . . .  	0003	0001	0008	0000
  ST0HD  . . . . . . . . . . . .  	0002	0001	0004	0000
  ST0DRV . . . . . . . . . . . .  	0000	0002	0003	0000
FDC_STATE  . . . . . . . . . . .  	0008	0005
  FSR  . . . . . . . . . . . . .  	0006	0002	00C0	0000
  FDDS . . . . . . . . . . . . .  	0005	0001	0020	0000
  FSE  . . . . . . . . . . . . .  	0004	0001	0010	0000
  FDX  . . . . . . . . . . . . .  	0003	0001	0008	0000
  FSD  . . . . . . . . . . . . .  	0000	0003	0007	0000
GFLAGS . . . . . . . . . . . . .  	0008	0004
  GTBD1  . . . . . . . . . . . .  	0004	0004	00F0	0000
  TURBO  . . . . . . . . . . . .  	0003	0001	0008	0000
  V20  . . . . . . . . . . . . .  	0002	0001	0004	0000
  GTBD2  . . . . . . . . . . . .  	0000	0002	0003	0000
ICW1 . . . . . . . . . . . . . .  	0008	0005
  D4 . . . . . . . . . . . . . .  	0004	0004	00F0	0010
  LTIM . . . . . . . . . . . . .  	0003	0001	0008	0000
  ADI  . . . . . . . . . . . . .  	0002	0001	0004	0000
  SNGL . . . . . . . . . . . . .  	0001	0001	0002	0002
  IC4  . . . . . . . . . . . . .  	0000	0001	0001	0001
ICW2 . . . . . . . . . . . . . .  	0008	0002
  ICW2IVA  . . . . . . . . . . .  	0003	0005	00F8	0000
  ICW2X  . . . . . . . . . . . .  	0000	0003	0007	0000
ICW4 . . . . . . . . . . . . . .  	0008	0004
  SFNM . . . . . . . . . . . . .  	0004	0004	00F0	0000
  ICWBUF . . . . . . . . . . . .  	0002	0002	000C	0000
  AEOI . . . . . . . . . . . . .  	0001	0001	0002	0000
  UPM  . . . . . . . . . . . . .  	0000	0001	0001	0000
KB . . . . . . . . . . . . . . .  	0010	0002
  KBK  . . . . . . . . . . . . .  	000A	0006	FC00	0000
  KBS  . . . . . . . . . . . . .  	0000	000A	03FF	0000
KBBRK  . . . . . . . . . . . . .  	0008	0002
  KBRK . . . . . . . . . . . . .  	0007	0001	0080	0000
  KBRX . . . . . . . . . . . . .  	0000	0007	007F	0000
KBFLAGS1 . . . . . . . . . . . .  	0008	0008
  K1IN . . . . . . . . . . . . .  	0007	0001	0080	0000
  K1CL . . . . . . . . . . . . .  	0006	0001	0040	0000
  K1NL . . . . . . . . . . . . .  	0005	0001	0020	0000
  K1SL . . . . . . . . . . . . .  	0004	0001	0010	0000
  K1AL . . . . . . . . . . . . .  	0003	0001	0008	0000
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-6


  K1CT . . . . . . . . . . . . .  	0002	0001	0004	0000
  K1LS . . . . . . . . . . . . .  	0001	0001	0002	0000
  K1RS . . . . . . . . . . . . .  	0000	0001	0001	0000
KBFLAGS2 . . . . . . . . . . . .  	0008	0008
  K2IN . . . . . . . . . . . . .  	0007	0001	0080	0000
  K2CL . . . . . . . . . . . . .  	0006	0001	0040	0000
  K2NL . . . . . . . . . . . . .  	0005	0001	0020	0000
  K2SL . . . . . . . . . . . . .  	0004	0001	0010	0000
  K2PA . . . . . . . . . . . . .  	0003	0001	0008	0000
  K2SY . . . . . . . . . . . . .  	0002	0001	0004	0000
  K2LA . . . . . . . . . . . . .  	0001	0001	0002	0000
  K2LC . . . . . . . . . . . . .  	0000	0001	0001	0000
KBFLAGS3 . . . . . . . . . . . .  	0008	0008
  KERD . . . . . . . . . . . . .  	0007	0001	0080	0000
  KEFI . . . . . . . . . . . . .  	0006	0001	0040	0000
  KENL . . . . . . . . . . . . .  	0005	0001	0020	0000
  KEEN . . . . . . . . . . . . .  	0004	0001	0010	0000
  KERA . . . . . . . . . . . . .  	0003	0001	0008	0000
  KERC . . . . . . . . . . . . .  	0002	0001	0004	0000
  KEE0 . . . . . . . . . . . . .  	0001	0001	0002	0000
  KEE1 . . . . . . . . . . . . .  	0000	0001	0001	0000
KBFLAGS4 . . . . . . . . . . . .  	0008	0008
  KLTE . . . . . . . . . . . . .  	0007	0001	0080	0000
  KLMU . . . . . . . . . . . . .  	0006	0001	0040	0000
  KLRF . . . . . . . . . . . . .  	0005	0001	0020	0000
  KLAK . . . . . . . . . . . . .  	0004	0001	0010	0000
  KLCI . . . . . . . . . . . . .  	0003	0001	0008	0000
  KLCL . . . . . . . . . . . . .  	0002	0001	0004	0000
  KLNL . . . . . . . . . . . . .  	0001	0001	0002	0000
  KLSL . . . . . . . . . . . . .  	0000	0001	0001	0000
KBP  . . . . . . . . . . . . . .  	0010	0002
  KBPK . . . . . . . . . . . . .  	0006	000A	FFC0	0000
  KBPS . . . . . . . . . . . . .  	0000	0006	003F	0000
KBW  . . . . . . . . . . . . . .  	0010	0002
  KBWK . . . . . . . . . . . . .  	0009	0007	FE00	0000
  KBWS . . . . . . . . . . . . .  	0000	0009	01FF	0000
KP . . . . . . . . . . . . . . .  	0010	0002
  KPWP . . . . . . . . . . . . .  	0004	000C	FFF0	0000
  KPWPX  . . . . . . . . . . . .  	0000	0004	000F	0000
MDA_CH_ATTR  . . . . . . . . . .  	0008	0004
  MDBK . . . . . . . . . . . . .  	0007	0001	0080	0000
  MDBG . . . . . . . . . . . . .  	0004	0003	0070	0000
  MDIN . . . . . . . . . . . . .  	0003	0001	0008	0000
  MDFG . . . . . . . . . . . . .  	0000	0003	0007	0007
NMI  . . . . . . . . . . . . . .  	0008	0002
  NMIE . . . . . . . . . . . . .  	0007	0001	0080	0000
  NMIX . . . . . . . . . . . . .  	0000	0007	007F	0000
OCW1 . . . . . . . . . . . . . .  	0008	0008
  IRQ7 . . . . . . . . . . . . .  	0007	0001	0080	0000
  IRQ6 . . . . . . . . . . . . .  	0006	0001	0040	0000
  IRQ5 . . . . . . . . . . . . .  	0005	0001	0020	0000
  IRQ4 . . . . . . . . . . . . .  	0004	0001	0010	0000
  IRQ3 . . . . . . . . . . . . .  	0003	0001	0008	0000
  IRQ2 . . . . . . . . . . . . .  	0002	0001	0004	0000
  IRQ1 . . . . . . . . . . . . .  	0001	0001	0002	0000
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-7


  IRQ0 . . . . . . . . . . . . .  	0000	0001	0001	0000
OCW2 . . . . . . . . . . . . . .  	0008	0003
  O2CMD  . . . . . . . . . . . .  	0005	0003	00E0	0020
  O2X  . . . . . . . . . . . . .  	0003	0002	0018	0000
  O2L  . . . . . . . . . . . . .  	0000	0003	0007	0000
OCW3 . . . . . . . . . . . . . .  	0008	0005
  O3D7 . . . . . . . . . . . . .  	0007	0001	0080	0000
  ESMM . . . . . . . . . . . . .  	0005	0002	0060	0000
  O3D3 . . . . . . . . . . . . .  	0003	0002	0018	0008
  O3P  . . . . . . . . . . . . .  	0002	0001	0004	0000
  O3RR . . . . . . . . . . . . .  	0000	0002	0003	0000
PFLAGS . . . . . . . . . . . . .  	0010	000A
  WARM . . . . . . . . . . . . .  	000F	0001	8000	0000
  PKI  . . . . . . . . . . . . .  	000E	0001	4000	0000
  PKEY . . . . . . . . . . . . .  	000D	0001	2000	0000
  PFDC . . . . . . . . . . . . .  	000C	0001	1000	0000
  PFSK . . . . . . . . . . . . .  	000B	0001	0800	0000
  PDMA . . . . . . . . . . . . .  	000A	0001	0400	0000
  PMEM . . . . . . . . . . . . .  	0009	0001	0200	0000
  PFXX . . . . . . . . . . . . .  	0008	0001	0100	0000
  PTBD . . . . . . . . . . . . .  	0002	0006	00FC	0000
  GRND . . . . . . . . . . . . .  	0000	0002	0003	0000
PIT_CW . . . . . . . . . . . . .  	0008	0004
  PCWSC  . . . . . . . . . . . .  	0006	0002	00C0	0000
  PCWRW  . . . . . . . . . . . .  	0004	0002	0030	0000
  PCWM . . . . . . . . . . . . .  	0001	0003	000E	0000
  PCWBCD . . . . . . . . . . . .  	0000	0001	0001	0000
PPI_B_F  . . . . . . . . . . . .  	0008	0008
  PBKB . . . . . . . . . . . . .  	0007	0001	0080	0000
  PBKC . . . . . . . . . . . . .  	0006	0001	0040	0000
  PBIO . . . . . . . . . . . . .  	0005	0001	0020	0000
  PBPC . . . . . . . . . . . . .  	0004	0001	0010	0000
  PBSW . . . . . . . . . . . . .  	0003	0001	0008	0000
  PBTB . . . . . . . . . . . . .  	0002	0001	0004	0000
  PBSP . . . . . . . . . . . . .  	0001	0001	0002	0000
  PBST . . . . . . . . . . . . .  	0000	0001	0001	0000
PPI_CR . . . . . . . . . . . . .  	0008	0007
  PPEN . . . . . . . . . . . . .  	0007	0001	0080	0080
  PPAM . . . . . . . . . . . . .  	0005	0002	0060	0000
  PPAD . . . . . . . . . . . . .  	0004	0001	0010	0010
  PPCU . . . . . . . . . . . . .  	0003	0001	0008	0008
  PPBM . . . . . . . . . . . . .  	0002	0001	0004	0000
  PPBD . . . . . . . . . . . . .  	0001	0001	0002	0000
  PPCL . . . . . . . . . . . . .  	0000	0001	0001	0001
PPI_C_X_H  . . . . . . . . . . .  	0008	0006
  PC2PE  . . . . . . . . . . . .  	0007	0001	0080	0000
  PC2IE  . . . . . . . . . . . .  	0006	0001	0040	0000
  PC2T2  . . . . . . . . . . . .  	0005	0001	0020	0000
  PC2CI  . . . . . . . . . . . .  	0004	0001	0010	0000
  PCDRV  . . . . . . . . . . . .  	0002	0002	000C	0000
  PCVID  . . . . . . . . . . . .  	0000	0002	0003	0000
PPI_C_X_L  . . . . . . . . . . .  	0008	0007
  PCPE . . . . . . . . . . . . .  	0007	0001	0080	0000
  PCIE . . . . . . . . . . . . .  	0006	0001	0040	0000
  PCT2 . . . . . . . . . . . . .  	0005	0001	0020	0000
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-8


  PCCI . . . . . . . . . . . . .  	0004	0001	0010	0000
  PCMB . . . . . . . . . . . . .  	0002	0002	000C	0000
  PCFP . . . . . . . . . . . . .  	0001	0001	0002	0000
  PCFD . . . . . . . . . . . . .  	0000	0001	0001	0000
PRN_CTRL . . . . . . . . . . . .  	0008	0006
  LCX  . . . . . . . . . . . . .  	0005	0003	00E0	0000
  LCIRQ  . . . . . . . . . . . .  	0004	0001	0010	0000
  LCDR . . . . . . . . . . . . .  	0003	0001	0008	0000
  LCINI  . . . . . . . . . . . .  	0002	0001	0004	0000
  LCLF . . . . . . . . . . . . .  	0001	0001	0002	0000
  LCOUT  . . . . . . . . . . . .  	0000	0001	0001	0000
PRN_STAT . . . . . . . . . . . .  	0008	0007
  LPBZ . . . . . . . . . . . . .  	0007	0001	0080	0000
  LPACK  . . . . . . . . . . . .  	0006	0001	0040	0000
  LPOP . . . . . . . . . . . . .  	0005	0001	0020	0000
  LPSEL  . . . . . . . . . . . .  	0004	0001	0010	0000
  LPIO . . . . . . . . . . . . .  	0003	0001	0008	0000
  LPX  . . . . . . . . . . . . .  	0001	0002	0006	0000
  LPTO . . . . . . . . . . . . .  	0000	0001	0001	0000
TIMER_C  . . . . . . . . . . . .  	0005	0003
  LW . . . . . . . . . . . . . .  	0000
  HW . . . . . . . . . . . . . .  	0002
  OF . . . . . . . . . . . . . .  	0004
V20_F3 . . . . . . . . . . . . .  	0008	0002
  VF3_OPC  . . . . . . . . . . .  	0003	0005	00F8	00C0
  VF3_SRC  . . . . . . . . . . .  	0000	0003	0007	0000
V20_F4 . . . . . . . . . . . . .  	0008	0003
  VF4_OPC  . . . . . . . . . . .  	0006	0002	00C0	00C0
  VF4_DST  . . . . . . . . . . .  	0003	0003	0038	0000
  VF4_SRC  . . . . . . . . . . .  	0000	0003	0007	0000
V20_R  . . . . . . . . . . . . .  	0008	0002
  VRW  . . . . . . . . . . . . .  	0003	0005	00F8	0000
  ROPC . . . . . . . . . . . . .  	0000	0003	0007	0000
V40_WCY1 . . . . . . . . . . . .  	0008	0004
  IOW  . . . . . . . . . . . . .  	0006	0002	00C0	0000
  UMW  . . . . . . . . . . . . .  	0004	0002	0030	0000
  MMW  . . . . . . . . . . . . .  	0002	0002	000C	0000
  LMW  . . . . . . . . . . . . .  	0000	0002	0003	0000
VID_ATTR . . . . . . . . . . . .  	0008	0002
  VBG  . . . . . . . . . . . . .  	0004	0004	00F0	0000
  VFB  . . . . . . . . . . . . .  	0000	0004	000F	0007
VID_CSGFX  . . . . . . . . . . .  	0008	0005
  CGPH . . . . . . . . . . . . .  	0006	0002	00C0	0000
  CGPL . . . . . . . . . . . . .  	0005	0001	0020	0020
  CGX  . . . . . . . . . . . . .  	0004	0001	0010	0010
  CGIN . . . . . . . . . . . . .  	0003	0001	0008	0008
  CGBG . . . . . . . . . . . . .  	0000	0003	0007	0007
VID_CSTXT  . . . . . . . . . . .  	0008	0004
  CTX  . . . . . . . . . . . . .  	0005	0003	00E0	0020
  CTBI . . . . . . . . . . . . .  	0004	0001	0010	0010
  CTIN . . . . . . . . . . . . .  	0003	0001	0008	0000
  CTBC . . . . . . . . . . . . .  	0000	0003	0007	0000
VID_STAT . . . . . . . . . . . .  	0008	0005
  VSX  . . . . . . . . . . . . .  	0004	0004	00F0	0000
  VSVS . . . . . . . . . . . . .  	0003	0001	0008	0000
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-9


  VSPE . . . . . . . . . . . . .  	0002	0001	0004	0000
  VSPT . . . . . . . . . . . . .  	0001	0001	0002	0000
  VSHS . . . . . . . . . . . . .  	0000	0001	0001	0000

Segments and Groups:

                N a m e         	Length	 Align	Combine Class

BIOS . . . . . . . . . . . . . .  	00010000 PARA	NONE	
RESET  . . . . . . . . . . . . .  	0000	AT	FFFF	
_BASIC . . . . . . . . . . . . .  	0000	AT	F600	
_BDA . . . . . . . . . . . . . .  	00F0	AT	0040	
_BDA_ABS . . . . . . . . . . . .  	0482	AT	0000	
_BIOS  . . . . . . . . . . . . .  	FFF0	AT	F000	
_BOOT_STACK  . . . . . . . . . .  	0100	AT	0030	
_CGA_MEM . . . . . . . . . . . .  	4000	AT	B800	
_DOS_DAT . . . . . . . . . . . .  	0034	AT	0050	
_IPL_SEG . . . . . . . . . . . .  	7E00	AT	0000	
_IVT . . . . . . . . . . . . . .  	0080	AT	0000	
_MDA_MEM . . . . . . . . . . . .  	1000	AT	B000	
_OPT_ROM . . . . . . . . . . . .  	0000	AT	C800	
_VID_BIOS  . . . . . . . . . . .  	0005	AT	C000	

Symbols:            

                N a m e         	Type	 Value	 Attr

ADI  . . . . . . . . . . . . . .  		0002	
AEOI . . . . . . . . . . . . . .  		0001	
ANY_KEY  . . . . . . . . . . . .  	L BYTE	E4E5	BIOS
ARCH_5150  . . . . . . . . . . .  	NUMBER	0050	
ARCH_5160  . . . . . . . . . . .  	NUMBER	0058	
ARCH_5160V2  . . . . . . . . . .  	NUMBER	0059	
ARCH_BOOK88  . . . . . . . . . .  	NUMBER	0042	
ARCH_CPQ . . . . . . . . . . . .  	NUMBER	0051	
ARCH_EHB . . . . . . . . . . . .  	NUMBER	0048	
ARCH_EMU . . . . . . . . . . . .  	NUMBER	0045	
ARCH_FE2010  . . . . . . . . . .  	NUMBER	0046	
ARCH_ID  . . . . . . . . . . . .  	NUMBER	00FE	
ARCH_LASER . . . . . . . . . . .  	NUMBER	004C	
ARCH_M88 . . . . . . . . . . . .  	NUMBER	004D	
ARCH_MARTY . . . . . . . . . . .  	NUMBER	0043	
ARCH_MIST  . . . . . . . . . . .  	NUMBER	0049	
ARCH_SUB_TYPE  . . . . . . . . .  	NUMBER	0000	
ARCH_TD3300  . . . . . . . . . .  	NUMBER	0053	
ARCH_TURBO . . . . . . . . . . .  	NUMBER	0054	
ARCH_TYPE  . . . . . . . . . . .  	ALIAS	 ARCH_TURBO		
ARCH_UM82  . . . . . . . . . . .  	NUMBER	0055	
ARCH_VEN888  . . . . . . . . . .  	NUMBER	0056	
ARCH_VIRTUALXT . . . . . . . . .  	NUMBER	004A	
ATKB_CMD . . . . . . . . . . . .  	NUMBER	0064	
ATKB_IO  . . . . . . . . . . . .  	NUMBER	0060	

BANNER_STRINGS . . . . . . . . .  	N PROC	E4C3	BIOS	Length = 0037
BASE_RAM_ERROR . . . . . . . . .  	L NEAR	E153	BIOS
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-10


BASE_RAM_TEST  . . . . . . . . .  	L NEAR	E127	BIOS
BASE_RAM_TEST_DONE . . . . . . .  	L NEAR	E17F	BIOS
BASE_RAM_ZERO  . . . . . . . . .  	L NEAR	E158	BIOS
BASIC_ROM  . . . . . . . . . . .  	NUMBER	0001	
BASIC_TOP  . . . . . . . . . . .  	L WORD	0000	_BASIC
BEEP . . . . . . . . . . . . . .  	N PROC	E8AE	BIOS	Length = 0013
BEEP_1K  . . . . . . . . . . . .  	NUMBER	04A9	
BEEP_1K7 . . . . . . . . . . . .  	NUMBER	04A0	
BEEP_2K  . . . . . . . . . . . .  	NUMBER	0250	
BEEP_A4  . . . . . . . . . . . .  	NUMBER	0A98	
BEEP_A5  . . . . . . . . . . . .  	NUMBER	054C	
BEEP_B4  . . . . . . . . . . . .  	NUMBER	0970	
BEEP_B5  . . . . . . . . . . . .  	NUMBER	04B8	
BEEP_C4  . . . . . . . . . . . .  	NUMBER	11D1	
BEEP_C5  . . . . . . . . . . . .  	NUMBER	08E8	
BEEP_C6  . . . . . . . . . . . .  	NUMBER	0474	
BEEP_D5  . . . . . . . . . . . .  	NUMBER	07F0	
BEEP_DEFAULT . . . . . . . . . .  	ALIAS	 BEEP_A5		
BEEP_E5  . . . . . . . . . . . .  	NUMBER	0712	
BEEP_ERR_HIGH  . . . . . . . . .  	ALIAS	 BEEP_F5		
BEEP_ERR_LOW . . . . . . . . . .  	ALIAS	 BEEP_C5		
BEEP_F5  . . . . . . . . . . . .  	NUMBER	06AC	
BEEP_G5  . . . . . . . . . . . .  	NUMBER	05F2	
BEEP_L . . . . . . . . . . . . .  		0000	
BEEP_OFF_P . . . . . . . . . . .  	N PROC	E8F1	BIOS	Length = 0005
BEEP_ON_1  . . . . . . . . . . .  	N PROC	E8E2	BIOS	Length = 000F
BEEP_ON_P  . . . . . . . . . . .  	N PROC	E8DC	BIOS	Length = 0015
BEEP_PROC  . . . . . . . . . . .  	N PROC	E874	BIOS	Length = 0082
BEEP_S . . . . . . . . . . . . .  		0004	
BELL . . . . . . . . . . . . . .  	NUMBER	0007	
BIOS_BREAK . . . . . . . . . . .  	L BYTE	0071	_BDA
BIOS_INT_VECTORS_LOOP  . . . . .  	L NEAR	E1D9	BIOS
BIOS_ROM_SCAN  . . . . . . . . .  	N PROC	E545	BIOS	Length = 0043
BIOS_TOP . . . . . . . . . . . .  	N PROC	E000	BIOS	Length = 005B
BIOS_VIDEO . . . . . . . . . . .  	L NEAR	F69F	BIOS
BLACK  . . . . . . . . . . . . .  	NUMBER	0000	
BLOCK_LOOP . . . . . . . . . . .  	L NEAR	E5AA	BIOS
BLOCK_LOOP_DONE  . . . . . . . .  	L NEAR	E5B6	BIOS
BLUE . . . . . . . . . . . . . .  	NUMBER	0009	
BOOT . . . . . . . . . . . . . .  	N PROC	E05B	BIOS	Length = 0468
BOOT_DEVICE  . . . . . . . . . .  	L NEAR	E4A7	BIOS
BOOT_FAIL  . . . . . . . . . . .  	L BYTE	E4C6	BIOS
BOOT_MEDIUM  . . . . . . . . . .  	NUMBER	004D	
BOOT_NORMAL  . . . . . . . . . .  	NUMBER	004E	
BOOT_RETRY . . . . . . . . . . .  	L NEAR	E4AA	BIOS
BOOT_SPEED . . . . . . . . . . .  	ALIAS	 BOOT_TURBO		
BOOT_TURBO . . . . . . . . . . .  	NUMBER	0054	
BROWN  . . . . . . . . . . . . .  	NUMBER	0006	
BS . . . . . . . . . . . . . . .  	NUMBER	0008	
BULL . . . . . . . . . . . . . .  	NUMBER	00F9	
BYTES_HERE_BOOT  . . . . . . . .  	NUMBER	0000	
BYTES_HERE_GFX_CHARSET . . . . .  	NUMBER	004F	
BYTES_HERE_INT_02  . . . . . . .  	NUMBER	0011	
BYTES_HERE_INT_08  . . . . . . .  	NUMBER	0000	
BYTES_HERE_INT_09  . . . . . . .  	NUMBER	0000	
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-11


BYTES_HERE_INT_0E  . . . . . . .  	NUMBER	0001	
BYTES_HERE_INT_10_JMP  . . . . .  	NUMBER	0000	
BYTES_HERE_INT_12  . . . . . . .  	NUMBER	001F	
BYTES_HERE_INT_13  . . . . . . .  	NUMBER	0007	
BYTES_HERE_INT_14  . . . . . . .  	NUMBER	0000	
BYTES_HERE_INT_16  . . . . . . .  	NUMBER	0000	
BYTES_HERE_INT_19  . . . . . . .  	NUMBER	0035	
BYTES_HERE_INT_1D  . . . . . . .  	NUMBER	0001	
BYTES_HERE_INT_1E  . . . . . . .  	NUMBER	0014	
BYTES_HERE_INT_RET . . . . . . .  	NUMBER	0002	
BYTES_HERE_POWER_ON  . . . . . .  	NUMBER	0001	
BYTES_HERE_VECTOR_TABLE  . . . .  	NUMBER	0003	
BYTES_HERE_VER . . . . . . . . .  	NUMBER	0000	
BYTE_HEX . . . . . . . . . . . .  	N PROC	F803	BIOS	Length = 001F

CASSETTE . . . . . . . . . . . .  	NUMBER	0000	
CAS_CRC  . . . . . . . . . . . .  	L WORD	0069	_BDA
CAS_PREV . . . . . . . . . . . .  	L BYTE	006B	_BDA
CAS_RELOCATE . . . . . . . . . .  	NUMBER	0000	
CAS_TIME_CNT . . . . . . . . . .  	L WORD	0067	_BDA
CGA_COLOR  . . . . . . . . . . .  	NUMBER	03D9	
CGA_CTRL . . . . . . . . . . . .  	NUMBER	03D8	
CGA_DATA . . . . . . . . . . . .  	NUMBER	03D5	
CGA_IDX  . . . . . . . . . . . .  	NUMBER	03D4	
CGA_MEM_40 . . . . . . . . . . .  	L BYTE	0000	_CGA_MEM	Length = 0800
CGA_MEM_80 . . . . . . . . . . .  	L BYTE	0800	_CGA_MEM	Length = 3800
CGA_MEM_FLD  . . . . . . . . . .  	NUMBER	2000	
CGA_MEM_SZ . . . . . . . . . . .  	NUMBER	4000	
CGA_PEN_RST  . . . . . . . . . .  	NUMBER	03DB	
CGA_SNOW_REMOVE  . . . . . . . .  	NUMBER	0003	
CGA_STAT . . . . . . . . . . . .  	NUMBER	03DA	
CGBG . . . . . . . . . . . . . .  		0000	
CGIN . . . . . . . . . . . . . .  		0003	
CGPH . . . . . . . . . . . . . .  		0006	
CGPL . . . . . . . . . . . . . .  		0005	
CGX  . . . . . . . . . . . . . .  		0004	
CHECKSUM . . . . . . . . . . . .  	L NEAR	E0BC	BIOS
CHECKSUM_LOOP  . . . . . . . . .  	L NEAR	E591	BIOS
CHECKSUM_OK  . . . . . . . . . .  	L NEAR	E0C5	BIOS
CHECKSUM_ROM . . . . . . . . . .  	L NEAR	E0B4	BIOS
CHECK_ALT_ON . . . . . . . . . .  	L NEAR	EAB9	BIOS
CHECK_BASIC_ROM  . . . . . . . .  	L NEAR	E1E7	BIOS
CHECK_EGA  . . . . . . . . . . .  	L NEAR	F6BA	BIOS
CHECK_ROM  . . . . . . . . . . .  	L NEAR	E548	BIOS
CHECK_TOP_ROW_NUM  . . . . . . .  	L NEAR	EAAA	BIOS
CHECK_VGA  . . . . . . . . . . .  	L NEAR	F6AC	BIOS
CLEAR_POST_SCREEN  . . . . . . .  	L NEAR	E493	BIOS
COLD_BOOT  . . . . . . . . . . .  	NUMBER	0000	
COM  . . . . . . . . . . . . . .  		0009	
COM1_DATA  . . . . . . . . . . .  	NUMBER	03F8	
COM1_IER . . . . . . . . . . . .  	NUMBER	03F9	
COM1_IIR . . . . . . . . . . . .  	NUMBER	03FA	
COM1_LCR . . . . . . . . . . . .  	NUMBER	03FB	
COM1_LSR . . . . . . . . . . . .  	NUMBER	03FD	
COM1_MCR . . . . . . . . . . . .  	NUMBER	03FC	
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-12


COM1_MSR . . . . . . . . . . . .  	NUMBER	03FE	
COM1_SPR . . . . . . . . . . . .  	NUMBER	03FF	
COM2_DATA  . . . . . . . . . . .  	NUMBER	02F8	
COM2_IIR . . . . . . . . . . . .  	NUMBER	02FA	
COM3_DATA  . . . . . . . . . . .  	NUMBER	03E8	
COM3_IIR . . . . . . . . . . . .  	NUMBER	03EA	
COM4_DATA  . . . . . . . . . . .  	NUMBER	02E8	
COM4_IIR . . . . . . . . . . . .  	NUMBER	02EA	
COM_ADDR . . . . . . . . . . . .  	L WORD	0000	_BDA	Length = 0004
COM_DETECT_LOOP  . . . . . . . .  	L NEAR	E306	BIOS
COM_TIME . . . . . . . . . . . .  	L BYTE	007C	_BDA	Length = 0004
COM_TIME_B . . . . . . . . . . .  	NUMBER	007C	
COM_TO . . . . . . . . . . . . .  	NUMBER	0001	
COPYRIGHT  . . . . . . . . . . .  	L BYTE	E031	BIOS
COPY_YEAR  . . . . . . . . . . .  	TEXT  '2022-25'		
CPU_8088 . . . . . . . . . . . .  	NUMBER	0038	
CPU_CHECK_TYPE_2 . . . . . . . .  	L NEAR	F6D6	BIOS
CPU_CHECK_TYPE_2_DONE  . . . . .  	L NEAR	F6E0	BIOS
CPU_IS_V20 . . . . . . . . . . .  	L NEAR	E210	BIOS
CPU_REG_PASS . . . . . . . . . .  	L NEAR	E082	BIOS
CPU_REG_TEST . . . . . . . . . .  	L NEAR	E060	BIOS
CPU_TYPE . . . . . . . . . . . .  	ALIAS	 CPU_8088		
CPU_TYPE_8088  . . . . . . . . .  	L NEAR	E21E	BIOS
CPU_TYPE_DONE  . . . . . . . . .  	L NEAR	E21E	BIOS
CPU_V20  . . . . . . . . . . . .  	NUMBER	0056	
CR . . . . . . . . . . . . . . .  	NUMBER	000D	
CR0  . . . . . . . . . . . . . .  		0004	
CR1  . . . . . . . . . . . . . .  		0005	
CR2  . . . . . . . . . . . . . .  		0006	
CR3  . . . . . . . . . . . . . .  		0007	
CRLF . . . . . . . . . . . . . .  	N PROC	F7C8	BIOS	Length = 0009
CRLF_SHOW_CURSOR . . . . . . . .  	N PROC	F032	BIOS	Length = 0013
CRT_MODE . . . . . . . . . . . .  	L BYTE	F678	BIOS
CTBC . . . . . . . . . . . . . .  		0000	
CTBI . . . . . . . . . . . . . .  		0004	
CTIN . . . . . . . . . . . . . .  		0003	
CTX  . . . . . . . . . . . . . .  		0005	
CURL_BOT . . . . . . . . . . . .  	NUMBER	00F5	
CURL_TOP . . . . . . . . . . . .  	NUMBER	00F4	
CURSOR_DEFAULT . . . . . . . . .  	L WORD	00E8	_BDA
CYAN . . . . . . . . . . . . . .  	NUMBER	0003	

D4 . . . . . . . . . . . . . . .  		0004	
DACK . . . . . . . . . . . . . .  		0007	
DARKBLUE . . . . . . . . . . . .  	NUMBER	0001	
DARKGRAY . . . . . . . . . . . .  	NUMBER	0008	
DARKGREEN  . . . . . . . . . . .  	NUMBER	0002	
DARKMAGENTA  . . . . . . . . . .  	NUMBER	0005	
DARKRED  . . . . . . . . . . . .  	NUMBER	0004	
DBLARROW . . . . . . . . . . . .  	NUMBER	001D	
DCTS . . . . . . . . . . . . . .  		0000	
DDCD . . . . . . . . . . . . . .  		0003	
DDIS . . . . . . . . . . . . . .  		0002	
DDSR . . . . . . . . . . . . . .  		0001	
DETECT_MEMORY  . . . . . . . . .  	N PROC	E59C	BIOS	Length = 00A4
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-13


DETECT_MEMORY_ERR  . . . . . . .  	L NEAR	E611	BIOS
DETECT_MEMORY_ERR_2  . . . . . .  	L NEAR	E637	BIOS
DETECT_MEMORY_ERR_DONE . . . . .  	L NEAR	E63B	BIOS
DHLD . . . . . . . . . . . . . .  		0001	
DISABLE_NMI  . . . . . . . . . .  	L NEAR	E082	BIOS
DLAB . . . . . . . . . . . . . .  		0007	
DM2M . . . . . . . . . . . . . .  		0000	
DMA  . . . . . . . . . . . . . .  		0008	
DMAI . . . . . . . . . . . . . .  		0004	
DMA_0_A  . . . . . . . . . . . .  	NUMBER	0000	
DMA_0_C  . . . . . . . . . . . .  	NUMBER	0001	
DMA_1_A  . . . . . . . . . . . .  	NUMBER	0002	
DMA_1_C  . . . . . . . . . . . .  	NUMBER	0003	
DMA_2_A  . . . . . . . . . . . .  	NUMBER	0004	
DMA_2_C  . . . . . . . . . . . .  	NUMBER	0005	
DMA_3_A  . . . . . . . . . . . .  	NUMBER	0006	
DMA_3_C  . . . . . . . . . . . .  	NUMBER	0007	
DMA_CMD  . . . . . . . . . . . .  	NUMBER	0008	
DMA_FF . . . . . . . . . . . . .  	NUMBER	000C	
DMA_MASK . . . . . . . . . . . .  	NUMBER	000A	
DMA_MASKR  . . . . . . . . . . .  	NUMBER	000E	
DMA_MMASK  . . . . . . . . . . .  	NUMBER	000F	
DMA_MODE . . . . . . . . . . . .  	NUMBER	000B	
DMA_PASS . . . . . . . . . . . .  	L NEAR	E107	BIOS
DMA_P_C0 . . . . . . . . . . . .  	NUMBER	0087	
DMA_P_C1 . . . . . . . . . . . .  	NUMBER	0083	
DMA_P_C2 . . . . . . . . . . . .  	NUMBER	0081	
DMA_P_C3 . . . . . . . . . . . .  	NUMBER	0082	
DMA_REQ  . . . . . . . . . . . .  	NUMBER	0009	
DMA_RESET  . . . . . . . . . . .  	NUMBER	000D	
DMA_SETUP_CH . . . . . . . . . .  	L NEAR	E122	BIOS
DMA_STATUS_OK  . . . . . . . . .  	L NEAR	E3D8	BIOS
DMCH . . . . . . . . . . . . . .  		0000	
DMINC  . . . . . . . . . . . . .  		0005	
DMM  . . . . . . . . . . . . . .  		0006	
DMOP . . . . . . . . . . . . . .  		0002	
DONE_ZERO_ALL_RAM  . . . . . . .  	L NEAR	E60F	BIOS
DOS_FD_PARAM . . . . . . . . . .  	L BYTE	0022	_DOS_DAT	Length = 000E
DOT  . . . . . . . . . . . . . .  	NUMBER	00FA	
DPRI . . . . . . . . . . . . . .  		0004	
DRAM_REFRESH . . . . . . . . . .  	NUMBER	0012	
DREQ . . . . . . . . . . . . . .  		0006	
DRI  . . . . . . . . . . . . . .  		0002	
DTIM . . . . . . . . . . . . . .  		0003	
DTR  . . . . . . . . . . . . . .  		0000	
DWORD_HEX  . . . . . . . . . . .  	N PROC	F7F0	BIOS	Length = 0032
DWS  . . . . . . . . . . . . . .  		0005	

EKB_FLAGS1 . . . . . . . . . . .  	L BYTE	0096	_BDA
EKB_FLAGS2 . . . . . . . . . . .  	L BYTE	0097	_BDA
ENABLE_NMI . . . . . . . . . . .  	L NEAR	E459	BIOS
EOI  . . . . . . . . . . . . . .  	NUMBER	0020	
EQUIP_FLAGS  . . . . . . . . . .  	L WORD	0010	_BDA
ESMM . . . . . . . . . . . . . .  		0005	
EXP_UNIT . . . . . . . . . . . .  	NUMBER	0000	
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-14


EXP_UNIT_CTRL  . . . . . . . . .  	NUMBER	0213	

F0SK . . . . . . . . . . . . . .  		0000	
F1SK . . . . . . . . . . . . . .  		0001	
F2SK . . . . . . . . . . . . . .  		0002	
F3SK . . . . . . . . . . . . . .  		0003	
FAF  . . . . . . . . . . . . . .  		0004	
FC0CMD . . . . . . . . . . . . .  		0000	
FC0MF  . . . . . . . . . . . . .  		0006	
FC0MT  . . . . . . . . . . . . .  		0007	
FC0SK  . . . . . . . . . . . . .  		0005	
FC1DS  . . . . . . . . . . . . .  		0000	
FC1HD  . . . . . . . . . . . . .  		0002	
FC1X . . . . . . . . . . . . . .  		0003	
FCAL0  . . . . . . . . . . . . .  		0000	
FCAL1  . . . . . . . . . . . . .  		0001	
FCAL2  . . . . . . . . . . . . .  		0002	
FCAL3  . . . . . . . . . . . . .  		0003	
FCF  . . . . . . . . . . . . . .  		0000	
FDCEN  . . . . . . . . . . . . .  		0002	
FDC_ADV_SEEK . . . . . . . . . .  	NUMBER	0001	
FDC_A_STAT . . . . . . . . . . .  	NUMBER	03F0	
FDC_B_STAT . . . . . . . . . . .  	NUMBER	03F1	
FDC_CHECK_SEEK . . . . . . . . .  	L NEAR	EDF5	BIOS
FDC_CMD_FMT  . . . . . . . . . .  	NUMBER	000D	
FDC_CMD_RD . . . . . . . . . . .  	NUMBER	0006	
FDC_CMD_RDEL . . . . . . . . . .  	NUMBER	000C	
FDC_CMD_RECAL  . . . . . . . . .  	NUMBER	0007	
FDC_CMD_RSID . . . . . . . . . .  	NUMBER	000A	
FDC_CMD_RTRK . . . . . . . . . .  	NUMBER	0002	
FDC_CMD_SEEK . . . . . . . . . .  	NUMBER	000F	
FDC_CMD_SENSE  . . . . . . . . .  	NUMBER	0008	
FDC_CMD_SPEC . . . . . . . . . .  	NUMBER	0003	
FDC_CMD_STAT . . . . . . . . . .  	NUMBER	0004	
FDC_CMD_WDEL . . . . . . . . . .  	NUMBER	0009	
FDC_CMD_WR . . . . . . . . . . .  	NUMBER	0005	
FDC_CTRL . . . . . . . . . . . .  	NUMBER	03F2	
FDC_DATA . . . . . . . . . . . .  	NUMBER	03F5	
FDC_DMA_BOUND  . . . . . . . . .  	L NEAR	ECE9	BIOS
FDC_DRIVE_STARTED  . . . . . . .  	L NEAR	EE65	BIOS
FDC_ENABLE . . . . . . . . . . .  	NUMBER	0001	
FDC_ERR1_MAP . . . . . . . . . .  	L BYTE	EF40	BIOS
FDC_ERR_MAP_LOOP . . . . . . . .  	L NEAR	EF33	BIOS
FDC_ERR_SEC_CT . . . . . . . . .  	NUMBER	0000	
FDC_FORMAT . . . . . . . . . . .  	N PROC	EDCD	BIOS	Length = 001B
FDC_FORMAT_ERR . . . . . . . . .  	L NEAR	EDCA	BIOS
FDC_HLT_WAIT . . . . . . . . . .  	NUMBER	0001	
FDC_INIT_DMA . . . . . . . . . .  	L NEAR	ED0C	BIOS
FDC_INIT_DMA_EXIT  . . . . . . .  	L NEAR	ED4D	BIOS
FDC_IPL_SW . . . . . . . . . . .  	NUMBER	0000	
FDC_LAST_ST  . . . . . . . . . .  	L 0007	0042	_BDA
FDC_MOTOR_ON . . . . . . . . . .  	L NEAR	EE35	BIOS
FDC_POST . . . . . . . . . . . .  	N PROC	E3EE	BIOS	Length = 003A
FDC_POST_CT_ERR  . . . . . . . .  	L NEAR	E413	BIOS
FDC_POST_DRV_ERR . . . . . . . .  	L NEAR	E40D	BIOS
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-15


FDC_POST_TESTS_COL . . . . . . .  	L NEAR	E41A	BIOS
FDC_POST_TESTS_DONE  . . . . . .  	L NEAR	E419	BIOS
FDC_POST_TESTS_DRV . . . . . . .  	L NEAR	E400	BIOS
FDC_RECAL  . . . . . . . . . . .  	N PROC	EE34	BIOS	Length = 005E
FDC_RECAL_DONE . . . . . . . . .  	L NEAR	EE90	BIOS
FDC_RECAL_ERR  . . . . . . . . .  	L NEAR	EE90	BIOS
FDC_RECAL_SEEK_TEST  . . . . . .  	N PROC	EF8F	BIOS	Length = 0024
FDC_RECV . . . . . . . . . . . .  	N PROC	EE92	BIOS	Length = 004B
FDC_RECV_ALL . . . . . . . . . .  	N PROC	EEE9	BIOS	Length = 0032
FDC_RECV_ALL_DONE  . . . . . . .  	L NEAR	EF0D	BIOS
FDC_RECV_ALL_LOOP  . . . . . . .  	L NEAR	EEF6	BIOS
FDC_RECV_CHECK_ERR . . . . . . .  	L NEAR	EF08	BIOS
FDC_RECV_DELAY . . . . . . . . .  	L NEAR	EEFE	BIOS
FDC_RECV_FDC_ERR . . . . . . . .  	L NEAR	EF12	BIOS
FDC_RECV_READY . . . . . . . . .  	L NEAR	EEC2	BIOS
FDC_RECV_STATUS  . . . . . . . .  	N PROC	EEE7	BIOS	Length = 0034
FDC_RECV_WAIT_POLL . . . . . . .  	L NEAR	EEBE	BIOS
FDC_RWV  . . . . . . . . . . . .  	N PROC	ED7A	BIOS	Length = 004D
FDC_RWVF . . . . . . . . . . . .  	L NEAR	ED60	BIOS
FDC_RWV_ERR  . . . . . . . . . .  	L NEAR	EDCA	BIOS
FDC_RWV_SEND_WAIT  . . . . . . .  	L NEAR	EDA8	BIOS
FDC_SEC_COUNT  . . . . . . . . .  	L NEAR	EDB2	BIOS
FDC_SEC_COUNT_SAME . . . . . . .  	L NEAR	EDC5	BIOS
FDC_SEC_COUNT_SAME_CYL . . . . .  	L NEAR	EDC3	BIOS
FDC_SEEK . . . . . . . . . . . .  	N PROC	EDE8	BIOS	Length = 004C
FDC_SEEK_DONE  . . . . . . . . .  	L NEAR	EE2B	BIOS
FDC_SEEK_ERR . . . . . . . . . .  	L NEAR	EE2E	BIOS
FDC_SEEK_RECAL_ERR . . . . . . .  	L NEAR	EE2E	BIOS
FDC_SEEK_SETTLE  . . . . . . . .  	L NEAR	EE21	BIOS
FDC_SEEK_TRACKS  . . . . . . . .  	L BYTE	EFAF	BIOS
FDC_SEND . . . . . . . . . . . .  	N PROC	EE9A	BIOS	Length = 0043
FDC_SEND_PARAM . . . . . . . . .  	N PROC	EE97	BIOS	Length = 0046
FDC_SEND_READY . . . . . . . . .  	L NEAR	EEB9	BIOS
FDC_SEND_RECV  . . . . . . . . .  	L NEAR	EE9D	BIOS
FDC_SEND_WAIT_POLL . . . . . . .  	L NEAR	EEAB	BIOS
FDC_SEND_WAIT_POLL_1 . . . . . .  	L NEAR	EEB5	BIOS
FDC_SEND_WAIT_TIMER  . . . . . .  	L NEAR	EEC9	BIOS
FDC_STAT . . . . . . . . . . . .  	NUMBER	03F4	
FDC_ST_BADCMD  . . . . . . . . .  	NUMBER	0001	
FDC_ST_DISK_CHG  . . . . . . . .  	NUMBER	0006	
FDC_ST_DMA_64K . . . . . . . . .  	NUMBER	0009	
FDC_ST_DMA_OVR . . . . . . . . .  	NUMBER	0008	
FDC_ST_ERR_CRC . . . . . . . . .  	NUMBER	0010	
FDC_ST_ERR_FDC . . . . . . . . .  	NUMBER	0020	
FDC_ST_ERR_MARK  . . . . . . . .  	NUMBER	0002	
FDC_ST_ERR_MED . . . . . . . . .  	NUMBER	000C	
FDC_ST_ERR_SEC . . . . . . . . .  	NUMBER	0004	
FDC_ST_ERR_SEEK  . . . . . . . .  	NUMBER	0040	
FDC_ST_ERR_WP  . . . . . . . . .  	NUMBER	0003	
FDC_ST_OK  . . . . . . . . . . .  	NUMBER	0000	
FDC_ST_SENSE . . . . . . . . . .  	NUMBER	00FF	
FDC_ST_TIMEOUT . . . . . . . . .  	NUMBER	0080	
FDC_TEST_DRIVE_DONE  . . . . . .  	L NEAR	EFA9	BIOS
FDC_TEST_DRIVE_EXIT  . . . . . .  	L NEAR	EFAD	BIOS
FDC_TEST_DRIVE_SEEK  . . . . . .  	L NEAR	EF9E	BIOS
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-16


FDC_WAIT_DONE  . . . . . . . . .  	L NEAR	EEC3	BIOS
FDC_WAIT_ERR_EXIT  . . . . . . .  	L NEAR	EF3C	BIOS
FDC_WAIT_ERR_EXIT_OK . . . . . .  	L NEAR	EF3F	BIOS
FDC_WAIT_EXIT  . . . . . . . . .  	L NEAR	EEC5	BIOS
FDC_WAIT_INT . . . . . . . . . .  	N PROC	EF6A	BIOS	Length = 0025
FDC_WAIT_INT_DONE  . . . . . . .  	L NEAR	EF8C	BIOS
FDC_WAIT_INT_LOOP1 . . . . . . .  	L NEAR	EF70	BIOS
FDC_WAIT_INT_LOOP2 . . . . . . .  	L NEAR	EF73	BIOS
FDC_WAIT_INT_OK  . . . . . . . .  	L NEAR	EF88	BIOS
FDC_WAIT_SENSE . . . . . . . . .  	N PROC	EEDD	BIOS	Length = 003E
FDC_WAIT_SENSE_EXIT  . . . . . .  	L NEAR	EF11	BIOS
FDC_WAIT_STATUS  . . . . . . . .  	N PROC	EF1B	BIOS	Length = 002D
FDC_WAIT_STATUS_ERR  . . . . . .  	N PROC	EF23	BIOS	Length = 0025
FDC_WAIT_STATUS_ERR_DONE . . . .  	L NEAR	EF3A	BIOS
FDC_WAIT_TIMEOUT . . . . . . . .  	L NEAR	EED4	BIOS
FDC_ZERO_BDA . . . . . . . . . .  	NUMBER	0000	
FDDMA  . . . . . . . . . . . . .  		0003	
FDDS . . . . . . . . . . . . . .  		0005	
FDMA . . . . . . . . . . . . . .  		0004	
FDMB . . . . . . . . . . . . . .  		0005	
FDMC . . . . . . . . . . . . . .  		0006	
FDMD . . . . . . . . . . . . . .  		0007	
FDND . . . . . . . . . . . . . .  		0005	
FDRR . . . . . . . . . . . . . .  		0007	
FDRW . . . . . . . . . . . . . .  		0004	
FDSEL  . . . . . . . . . . . . .  		0000	
FDX  . . . . . . . . . . . . . .  		0003	
FD_AUTO_DETECT . . . . . . . . .  	NUMBER	0000	
FD_CAL_ST  . . . . . . . . . . .  	L BYTE	003E	_BDA
FD_CAL_ST_ABS  . . . . . . . . .  	L BYTE	043E	_BDA_ABS
FD_LAST_OP . . . . . . . . . . .  	L BYTE	0041	_BDA
FD_LR  . . . . . . . . . . . . .  	L BYTE	008B	_BDA
FD_MEDIA_ST  . . . . . . . . . .  	L BYTE	0090	_BDA	Length = 0004
FD_MODE  . . . . . . . . . . . .  	L BYTE	008F	_BDA
FD_MOTOR_CT  . . . . . . . . . .  	L BYTE	0040	_BDA
FD_MOTOR_CT_ABS  . . . . . . . .  	L BYTE	0440	_BDA_ABS
FD_MOTOR_ST  . . . . . . . . . .  	L BYTE	003F	_BDA
FD_TRACK . . . . . . . . . . . .  	L BYTE	0094	_BDA	Length = 0002
FE2010_CONF_REG  . . . . . . . .  	L BYTE	00EC	_BDA
FIELD_EVEN . . . . . . . . . . .  	L NEAR	F5D3	BIOS
FIOD . . . . . . . . . . . . . .  		0006	
FLP  . . . . . . . . . . . . . .  		0006	
FM08 . . . . . . . . . . . . . .  		0000	
FM0D . . . . . . . . . . . . . .  		0002	
FM0M . . . . . . . . . . . . . .  		0001	
FM0X . . . . . . . . . . . . . .  		0003	
FM18 . . . . . . . . . . . . . .  		0004	
FM1D . . . . . . . . . . . . . .  		0006	
FM1M . . . . . . . . . . . . . .  		0005	
FM1X . . . . . . . . . . . . . .  		0007	
FMOT . . . . . . . . . . . . . .  		0000	
FMOT0  . . . . . . . . . . . . .  		0000	
FMOT1  . . . . . . . . . . . . .  		0001	
FMOT2  . . . . . . . . . . . . .  		0002	
FMOT3  . . . . . . . . . . . . .  		0003	
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-17


FMOTX  . . . . . . . . . . . . .  		0004	
FMTBD  . . . . . . . . . . . . .  		0004	
FOUND_ROM  . . . . . . . . . . .  	L NEAR	E557	BIOS
FPF  . . . . . . . . . . . . . .  		0002	
FPU  . . . . . . . . . . . . . .  		0001	
FPU_CHECK  . . . . . . . . . . .  	L NEAR	F6E6	BIOS
FPU_DISP_DONE  . . . . . . . . .  	L NEAR	F6F8	BIOS
FPU_TEST_CW  . . . . . . . . . .  	L NEAR	FFD2	BIOS
FPU_TEST_DONE  . . . . . . . . .  	L NEAR	FFDE	BIOS
FPU_TEST_SW  . . . . . . . . . .  	L NEAR	FFC6	BIOS
FR1  . . . . . . . . . . . . . .  		0005	
FR2  . . . . . . . . . . . . . .  		0003	
FR3  . . . . . . . . . . . . . .  		0001	
FSD  . . . . . . . . . . . . . .  		0000	
FSE  . . . . . . . . . . . . . .  		0004	
FSF  . . . . . . . . . . . . . .  		0007	
FSR  . . . . . . . . . . . . . .  		0006	
FSTBD  . . . . . . . . . . . . .  		0004	
FWIF . . . . . . . . . . . . . .  		0007	
FWRT . . . . . . . . . . . . . .  		0007	
FZF  . . . . . . . . . . . . . .  		0006	

GAM  . . . . . . . . . . . . . .  		000C	
GAME_CTRL  . . . . . . . . . . .  	NUMBER	0201	
GB_FLAGS . . . . . . . . . . . .  	L BYTE	0012	_BDA
GET_DISK_PARAMS  . . . . . . . .  	N PROC	E71E	BIOS	Length = 001B
GET_DISK_PARAMS_ERR  . . . . . .  	L NEAR	E738	BIOS
GET_SW_SETTINGS  . . . . . . . .  	L NEAR	E21E	BIOS
GFX_CHARSET  . . . . . . . . . .  	L BYTE	FA6E	BIOS
GRAY . . . . . . . . . . . . . .  	NUMBER	0007	
GREEN  . . . . . . . . . . . . .  	NUMBER	000A	
GRND . . . . . . . . . . . . . .  		0000	
GTBD1  . . . . . . . . . . . . .  		0004	
GTBD2  . . . . . . . . . . . . .  		0000	

HALF . . . . . . . . . . . . . .  	NUMBER	00AB	
HALT_BEEP  . . . . . . . . . . .  	N PROC	E874	BIOS	Length = 003A
HALT_BEEP_1  . . . . . . . . . .  	L NEAR	E155	BIOS
HALT_BEEP_2  . . . . . . . . . .  	L NEAR	E264	BIOS
HALT_BEEP_REP  . . . . . . . . .  	L NEAR	E885	BIOS
HALT_BEEP_START  . . . . . . . .  	L NEAR	E87C	BIOS
HALT_BEEP_START_ODD  . . . . . .  	L NEAR	E883	BIOS
HALT_ERROR . . . . . . . . . . .  	L NEAR	E0F0	BIOS
HAS_FPU  . . . . . . . . . . . .  	N PROC	FFC3	BIOS	Length = 001D
HBN  . . . . . . . . . . . . . .  		0004	
HDC_CTRL . . . . . . . . . . . .  	NUMBER	0321	
HDC_DMA  . . . . . . . . . . . .  	NUMBER	0323	
HDC_PULSE  . . . . . . . . . . .  	NUMBER	0322	
HDC_READ . . . . . . . . . . . .  	NUMBER	0320	
HDC_STAT . . . . . . . . . . . .  	NUMBER	0324	
HDD_POST . . . . . . . . . . . .  	N PROC	E428	BIOS	Length = 002E
HDD_POST_DONE  . . . . . . . . .  	L NEAR	E456	BIOS
HDD_POST_NONE  . . . . . . . . .  	L NEAR	E453	BIOS
HDD_POST_SHOW_LOOP . . . . . . .  	L NEAR	E44B	BIOS
HD_COUNT . . . . . . . . . . . .  	L BYTE	0075	_BDA
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-18


HD_CTRL  . . . . . . . . . . . .  	L BYTE	0076	_BDA
HD_LAST_ST . . . . . . . . . . .  	L BYTE	0074	_BDA
HD_PORT  . . . . . . . . . . . .  	L BYTE	0077	_BDA
HEART  . . . . . . . . . . . . .  	NUMBER	0003	
HELLO_RAND_TAGLINE . . . . . . .  	N PROC	F8C7	BIOS	Length = 006F
HELLO_WORLD  . . . . . . . . . .  	L NEAR	E273	BIOS
HIDE_CURSOR  . . . . . . . . . .  	N PROC	F03B	BIOS	Length = 000A
HL . . . . . . . . . . . . . . .  	NUMBER	00C4	
HWB  . . . . . . . . . . . . . .  		0008	

IC4  . . . . . . . . . . . . . .  		0000	
ICW2IVA  . . . . . . . . . . . .  		0003	
ICW2X  . . . . . . . . . . . . .  		0000	
ICWBUF . . . . . . . . . . . . .  		0002	
INIT_AT_KBC  . . . . . . . . . .  	NUMBER	0000	
INIT_DMA1  . . . . . . . . . . .  	L NEAR	E0C5	BIOS
INIT_PIT1  . . . . . . . . . . .  	L NEAR	E0F2	BIOS
INIT_PIT1_TEST . . . . . . . . .  	L NEAR	E0D8	BIOS
INIT_PIT1_TEST_DONE  . . . . . .  	L NEAR	E0F2	BIOS
INIT_PIT1_TEST_READ  . . . . . .  	L NEAR	E0E0	BIOS
INIT_ROM_BASIC_DONE  . . . . . .  	L NEAR	E209	BIOS
INIT_ROM_BASIC_SEG . . . . . . .  	L NEAR	E1DD	BIOS
INIT_SW_INT_VECTORS  . . . . . .  	L NEAR	E1D0	BIOS
INIT_V40 . . . . . . . . . . . .  	NUMBER	0000	
INIT_VIDEO . . . . . . . . . . .  	L NEAR	E086	BIOS
INT_02 . . . . . . . . . . . . .  	N PROC	E2C3	BIOS	Length = 0020
INT_02_NMI_HALT  . . . . . . . .  	L NEAR	E2D5	BIOS
INT_02_NMI_PAR . . . . . . . . .  	L NEAR	E2CC	BIOS
INT_05 . . . . . . . . . . . . .  	N PROC	FF54	BIOS	Length = 006F
INT_05_DONE  . . . . . . . . . .  	L NEAR	FF9A	BIOS
INT_05_EXIT  . . . . . . . . . .  	L NEAR	FFA6	BIOS
INT_05_LOOP_1  . . . . . . . . .  	L NEAR	FF7C	BIOS
INT_05_NEXT_COL  . . . . . . . .  	L NEAR	FF94	BIOS
INT_08 . . . . . . . . . . . . .  	N PROC	FEA5	BIOS	Length = 003B
INT_08_EOI . . . . . . . . . . .  	L NEAR	FEC7	BIOS
INT_08_FD_MOTOR  . . . . . . . .  	L NEAR	FEBE	BIOS
INT_08_INT_1C  . . . . . . . . .  	L NEAR	FEC5	BIOS
INT_08_MOTOR_OFF . . . . . . . .  	L NEAR	FE97	BIOS
INT_08_PROC  . . . . . . . . . .  	N PROC	FE97	BIOS	Length = 0049
INT_08_RESET . . . . . . . . . .  	L NEAR	FED6	BIOS
INT_08_TICK_DAY  . . . . . . . .  	L NEAR	FED1	BIOS
INT_08_TICK_TIMER  . . . . . . .  	L NEAR	FEAF	BIOS
INT_09 . . . . . . . . . . . . .  	N PROC	E987	BIOS	Length = 02CB
INT_09_POST  . . . . . . . . . .  	N PROC	E944	BIOS	Length = 001B
INT_09_POST_DONE . . . . . . . .  	L NEAR	E953	BIOS
INT_0E . . . . . . . . . . . . .  	N PROC	EF57	BIOS	Length = 0013
INT_10 . . . . . . . . . . . . .  	N PROC	F065	BIOS	Length = 061B
INT_10_0 . . . . . . . . . . . .  	N PROC	F0E4	BIOS	Length = 00BC
INT_10_0_1 . . . . . . . . . . .  	L NEAR	F0F2	BIOS
INT_10_0_COLOR_BYTE  . . . . . .  	L NEAR	F187	BIOS
INT_10_0_CRTC_LOOP . . . . . . .  	L NEAR	F177	BIOS
INT_10_0_DETECT_DONE . . . . . .  	L NEAR	F147	BIOS
INT_10_0_IS_40_COL . . . . . . .  	L NEAR	F145	BIOS
INT_10_0_IS_CGA  . . . . . . . .  	L NEAR	F121	BIOS
INT_10_0_IS_CGA_GFX  . . . . . .  	L NEAR	F12E	BIOS
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-19


INT_10_0_IS_CGA_TEXT . . . . . .  	L NEAR	F13C	BIOS
INT_10_1 . . . . . . . . . . . .  	N PROC	F1A0	BIOS	Length = 0016
INT_10_2 . . . . . . . . . . . .  	N PROC	F1B6	BIOS	Length = 0039
INT_10_2_DONE  . . . . . . . . .  	L NEAR	F1ED	BIOS
INT_10_3 . . . . . . . . . . . .  	N PROC	F1FC	BIOS	Length = 0011
INT_10_3_CUR_PAGE  . . . . . . .  	N PROC	F1EF	BIOS	Length = 001E
INT_10_4 . . . . . . . . . . . .  	N PROC	F99F	BIOS	Length = 0080
INT_10_4_CAL_1 . . . . . . . . .  	L NEAR	F9DA	BIOS
INT_10_4_CAL_2 . . . . . . . . .  	L NEAR	F9DB	BIOS
INT_10_4_CAL_DONE  . . . . . . .  	L NEAR	F9E1	BIOS
INT_10_4_DONE  . . . . . . . . .  	L NEAR	F9F7	BIOS
INT_10_4_EXIT  . . . . . . . . .  	L NEAR	F9FD	BIOS
INT_10_4_GFX . . . . . . . . . .  	L NEAR	FA00	BIOS
INT_10_4_LOW . . . . . . . . . .  	L NEAR	FA11	BIOS
INT_10_4_RESET . . . . . . . . .  	L NEAR	F9F9	BIOS
INT_10_4_TXT . . . . . . . . . .  	L NEAR	F9E5	BIOS
INT_10_5 . . . . . . . . . . . .  	N PROC	F20D	BIOS	Length = 0027
INT_10_6 . . . . . . . . . . . .  	N PROC	F235	BIOS	Length = 0130
INT_10_6_CHECK_CLS . . . . . . .  	L NEAR	F2AB	BIOS
INT_10_6_DONE  . . . . . . . . .  	L NEAR	F2DA	BIOS
INT_10_6_ENABLE_CGA  . . . . . .  	L NEAR	F2D3	BIOS
INT_10_6_TXT_CLR . . . . . . . .  	L NEAR	F2C3	BIOS
INT_10_6_TXT_CLR_1 . . . . . . .  	L NEAR	F2C1	BIOS
INT_10_6_TXT_CLR_LOOP  . . . . .  	L NEAR	F2C5	BIOS
INT_10_6_TXT_MOVE_LOOP . . . . .  	L NEAR	F2B5	BIOS
INT_10_7 . . . . . . . . . . . .  	N PROC	F234	BIOS	Length = 0131
INT_10_8 . . . . . . . . . . . .  	N PROC	F365	BIOS	Length = 00B9
INT_10_8_CHK_CGA . . . . . . . .  	L NEAR	F373	BIOS
INT_10_8_FAST  . . . . . . . . .  	L NEAR	F36F	BIOS
INT_10_8_GFX_DONE  . . . . . . .  	L NEAR	F408	BIOS
INT_10_8_GFX_HIGH  . . . . . . .  	L NEAR	F410	BIOS
INT_10_8_GFX_LOW_1 . . . . . . .  	L NEAR	F3B5	BIOS
INT_10_8_GFX_LOW_2 . . . . . . .  	L NEAR	F3C1	BIOS
INT_10_8_GFX_SEARCH  . . . . . .  	L NEAR	F3D7	BIOS
INT_10_8_GFX_SEARCH_CHR  . . . .  	L NEAR	F3E5	BIOS
INT_10_8_GFX_SEARCH_TBL  . . . .  	L NEAR	F3E2	BIOS
INT_10_8_MODE_GFX  . . . . . . .  	N PROC	F397	BIOS	Length = 0087
INT_10_8_MODE_GFX_LOW  . . . . .  	L NEAR	F3B3	BIOS
INT_10_8_NOT_CGA . . . . . . . .  	L NEAR	F395	BIOS
INT_10_9 . . . . . . . . . . . .  	N PROC	F41E	BIOS	Length = 0128
INT_10_9A_CGA  . . . . . . . . .  	L NEAR	F442	BIOS
INT_10_9A_FAST . . . . . . . . .  	L NEAR	F42A	BIOS
INT_10_9A_GFX_2  . . . . . . . .  	L NEAR	F4A8	BIOS
INT_10_9A_GFX_FG . . . . . . . .  	L NEAR	F4BB	BIOS
INT_10_9A_GFX_HIGH . . . . . . .  	L NEAR	F50C	BIOS
INT_10_9A_GFX_HIGH_WORD  . . . .  	L NEAR	F510	BIOS
INT_10_9A_GFX_HIGH_WR  . . . . .  	L NEAR	F51D	BIOS
INT_10_9A_GFX_LOW  . . . . . . .  	L NEAR	F4B6	BIOS
INT_10_9A_GFX_LOW_BYTE . . . . .  	L NEAR	F4CD	BIOS
INT_10_9A_GFX_LOW_CHAR . . . . .  	L NEAR	F4C7	BIOS
INT_10_9A_GFX_LOW_NEXT . . . . .  	L NEAR	F4FC	BIOS
INT_10_9A_GFX_LOW_PDEP . . . . .  	L NEAR	F4D4	BIOS
INT_10_9A_GFX_LOW_WR . . . . . .  	L NEAR	F4EC	BIOS
INT_10_9A_MODE_GFX . . . . . . .  	N PROC	F487	BIOS	Length = 00BF
INT_10_9A_MODE_GFX_DONE  . . . .  	L NEAR	F505	BIOS
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-20


INT_10_9A_MODE_GFX_EXIT  . . . .  	L NEAR	F50A	BIOS
INT_10_9_CGA . . . . . . . . . .  	L NEAR	F469	BIOS
INT_10_9_CGA_LOOP  . . . . . . .  	L NEAR	F46B	BIOS
INT_10_9_FAST  . . . . . . . . .  	L NEAR	F436	BIOS
INT_10_A . . . . . . . . . . . .  	N PROC	F41E	BIOS	Length = 0128
INT_10_A_CGA . . . . . . . . . .  	L NEAR	F44D	BIOS
INT_10_A_CGA_DONE  . . . . . . .  	L NEAR	F465	BIOS
INT_10_A_FAST  . . . . . . . . .  	L NEAR	F430	BIOS
INT_10_A_NOT_CGA . . . . . . . .  	L NEAR	F484	BIOS
INT_10_B . . . . . . . . . . . .  	N PROC	F546	BIOS	Length = 002B
INT_10_BOUNDS_OK . . . . . . . .  	L NEAR	F253	BIOS
INT_10_B_DONE  . . . . . . . . .  	L NEAR	F560	BIOS
INT_10_B_SET_COL . . . . . . . .  	L NEAR	F54E	BIOS
INT_10_B_SET_PAL . . . . . . . .  	L NEAR	F555	BIOS
INT_10_C . . . . . . . . . . . .  	N PROC	F571	BIOS	Length = 0021
INT_10_CGA_CHECK . . . . . . . .  	L NEAR	F294	BIOS
INT_10_CGA_DISABLE . . . . . . .  	L NEAR	F29A	BIOS
INT_10_CGA_WAIT  . . . . . . . .  	L NEAR	F29F	BIOS
INT_10_CHECK_BOUNDS  . . . . . .  	L NEAR	F249	BIOS
INT_10_CHK_CGA . . . . . . . . .  	L NEAR	F43C	BIOS
INT_10_C_DONE  . . . . . . . . .  	L NEAR	F58A	BIOS
INT_10_C_XOR . . . . . . . . . .  	L NEAR	F58D	BIOS
INT_10_D . . . . . . . . . . . .  	N PROC	F592	BIOS	Length = 000D
INT_10_DONE  . . . . . . . . . .  	L NEAR	F081	BIOS
INT_10_E . . . . . . . . . . . .  	N PROC	F5E2	BIOS	Length = 006A
INT_10_E_BELL  . . . . . . . . .  	L NEAR	F639	BIOS
INT_10_E_BS  . . . . . . . . . .  	L NEAR	F646	BIOS
INT_10_E_CHAR  . . . . . . . . .  	L NEAR	F5ED	BIOS
INT_10_E_CR  . . . . . . . . . .  	L NEAR	F63E	BIOS
INT_10_E_CTRL  . . . . . . . . .  	L NEAR	F62B	BIOS
INT_10_E_CURS  . . . . . . . . .  	L NEAR	F623	BIOS
INT_10_E_DONE  . . . . . . . . .  	L NEAR	F626	BIOS
INT_10_E_LF  . . . . . . . . . .  	L NEAR	F642	BIOS
INT_10_E_SCROLL  . . . . . . . .  	L NEAR	F5FE	BIOS
INT_10_E_SCROLL_UP . . . . . . .  	L NEAR	F60E	BIOS
INT_10_F . . . . . . . . . . . .  	N PROC	F64C	BIOS	Length = 0008
INT_10_GET_CUR_ADDR  . . . . . .  	N PROC	F654	BIOS	Length = 0024
INT_10_GFX_CHARPOS . . . . . . .  	N PROC	F531	BIOS	Length = 0015
INT_10_GFX_PIXEL . . . . . . . .  	N PROC	F59F	BIOS	Length = 0043
INT_10_IRET  . . . . . . . . . .  	L NEAR	F084	BIOS
INT_10_IS_CGA80  . . . . . . . .  	N PROC	F090	BIOS	Length = 0013
INT_10_IS_CGA80_DONE . . . . . .  	L NEAR	F0A0	BIOS
INT_10_IS_TXT  . . . . . . . . .  	N PROC	F085	BIOS	Length = 000B
INT_10_IS_TXT_DONE . . . . . . .  	L NEAR	F08F	BIOS
INT_10_JMP . . . . . . . . . . .  	L WORD	F045	BIOS
INT_10_RET . . . . . . . . . . .  	L NEAR	F19F	BIOS
INT_10_SCR_GFX . . . . . . . . .  	N PROC	F2DF	BIOS	Length = 0086
INT_10_SCR_GFX_2 . . . . . . . .  	L NEAR	F308	BIOS
INT_10_SCR_GFX_CLR . . . . . . .  	L NEAR	F348	BIOS
INT_10_SCR_GFX_CLR_1 . . . . . .  	L NEAR	F346	BIOS
INT_10_SCR_GFX_CLR_LOOP  . . . .  	L NEAR	F34C	BIOS
INT_10_SCR_GFX_MOVE_LOOP . . . .  	L NEAR	F328	BIOS
INT_10_SCR_GFX_RDY . . . . . . .  	L NEAR	F311	BIOS
INT_10_SCR_TXT . . . . . . . . .  	L NEAR	F261	BIOS
INT_10_SET_CUR_OFFSET  . . . . .  	L NEAR	F1CD	BIOS
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-21


INT_11 . . . . . . . . . . . . .  	N PROC	F84D	BIOS	Length = 000C
INT_12 . . . . . . . . . . . . .  	N PROC	F841	BIOS	Length = 000C
INT_13 . . . . . . . . . . . . .  	N PROC	EC59	BIOS	Length = 0336
INT_13_0 . . . . . . . . . . . .  	N PROC	EC98	BIOS	Length = 004B
INT_13_0_1 . . . . . . . . . . .  	L NEAR	ECAD	BIOS
INT_13_0_2 . . . . . . . . . . .  	L NEAR	ECB3	BIOS
INT_13_0_DONE  . . . . . . . . .  	L NEAR	ECDF	BIOS
INT_13_0_RESET_BAD . . . . . . .  	L NEAR	ECC6	BIOS
INT_13_0_RESET_DONE  . . . . . .  	L NEAR	ECC8	BIOS
INT_13_1 . . . . . . . . . . . .  	N PROC	ECE3	BIOS	Length = 0006
INT_13_2_5 . . . . . . . . . . .  	N PROC	ECEF	BIOS	Length = 00F9
INT_13_2_5_EXIT  . . . . . . . .  	L NEAR	EDC7	BIOS
INT_13_2_5_SEEK_ERR  . . . . . .  	L NEAR	ED4E	BIOS
INT_13_2_5_SETUP_DMA . . . . . .  	L NEAR	ED05	BIOS
INT_13_BAD_CMD . . . . . . . . .  	L NEAR	EC7E	BIOS
INT_13_DONE  . . . . . . . . . .  	L NEAR	EC80	BIOS
INT_13_EXIT  . . . . . . . . . .  	L NEAR	EC8C	BIOS
INT_13_EXIT_1  . . . . . . . . .  	L NEAR	EC8F	BIOS
INT_13_SET_MOTOR_CT  . . . . . .  	L NEAR	EC82	BIOS
INT_14 . . . . . . . . . . . . .  	N PROC	E739	BIOS	Length = 00B2
INT_14_0 . . . . . . . . . . . .  	N PROC	E761	BIOS	Length = 0036
INT_14_0_SET_BAUD  . . . . . . .  	L NEAR	E779	BIOS
INT_14_0_SET_PSW . . . . . . . .  	L NEAR	E77C	BIOS
INT_14_1 . . . . . . . . . . . .  	N PROC	E797	BIOS	Length = 001E
INT_14_2 . . . . . . . . . . . .  	N PROC	E7B5	BIOS	Length = 0016
INT_14_3 . . . . . . . . . . . .  	N PROC	E787	BIOS	Length = 000A
INT_14_DONE  . . . . . . . . . .  	N PROC	E791	BIOS	Length = 0006
INT_14_EXIT  . . . . . . . . . .  	L NEAR	E795	BIOS
INT_14_POLL  . . . . . . . . . .  	N PROC	E7CB	BIOS	Length = 0020
INT_14_POLL_DONE . . . . . . . .  	L NEAR	E7E9	BIOS
INT_14_POLL_LOOP . . . . . . . .  	L NEAR	E7DB	BIOS
INT_14_POLL_PORT . . . . . . . .  	N PROC	E7D3	BIOS	Length = 0018
INT_14_POLL_RET  . . . . . . . .  	L NEAR	E7EA	BIOS
INT_14_RW_ERR  . . . . . . . . .  	L NEAR	E7B0	BIOS
INT_15 . . . . . . . . . . . . .  	N PROC	F859	BIOS	Length = 000A
INT_15_EXIT  . . . . . . . . . .  	L NEAR	F85C	BIOS
INT_16 . . . . . . . . . . . . .  	N PROC	E82E	BIOS	Length = 0046
INT_16_DONE  . . . . . . . . . .  	L NEAR	E86C	BIOS
INT_17 . . . . . . . . . . . . .  	N PROC	EFD2	BIOS	Length = 0060
INT_17_0 . . . . . . . . . . . .  	L NEAR	EFF7	BIOS
INT_17_0_BUSY_LOOP . . . . . . .  	L NEAR	EFFB	BIOS
INT_17_0_OK  . . . . . . . . . .  	L NEAR	F009	BIOS
INT_17_0_TIMEOUT_LOOP  . . . . .  	L NEAR	EFF9	BIOS
INT_17_1 . . . . . . . . . . . .  	L NEAR	F023	BIOS
INT_17_2 . . . . . . . . . . . .  	L NEAR	F014	BIOS
INT_17_2_STATUS  . . . . . . . .  	L NEAR	F015	BIOS
INT_17_2_STATUS_2  . . . . . . .  	L NEAR	F018	BIOS
INT_17_DONE  . . . . . . . . . .  	L NEAR	F01C	BIOS
INT_17_IRET  . . . . . . . . . .  	L NEAR	F022	BIOS
INT_18 . . . . . . . . . . . . .  	N PROC	E4B6	BIOS	Length = 000D
INT_19 . . . . . . . . . . . . .  	N PROC	E6F2	BIOS	Length = 002C
INT_19_BOOT_HD . . . . . . . . .  	NUMBER	0000	
INT_19_IPL_FAIL  . . . . . . . .  	L NEAR	E71D	BIOS
INT_19_READ_MBR  . . . . . . . .  	L NEAR	E704	BIOS
INT_1A . . . . . . . . . . . . .  	N PROC	FE6E	BIOS	Length = 0029
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-22


INT_1A_DONE  . . . . . . . . . .  	L NEAR	FE8A	BIOS
INT_1A_EXIT  . . . . . . . . . .  	L NEAR	FE8C	BIOS
INT_1A_READ  . . . . . . . . . .  	N PROC	FE81	BIOS	Length = 000C
INT_1A_SET . . . . . . . . . . .  	N PROC	FE8D	BIOS	Length = 000A
INT_1D . . . . . . . . . . . . .  	N PROC	F0A4	BIOS	Length = 0040
INT_1D_40  . . . . . . . . . . .  	L 0010	F0A4	BIOS
INT_1D_80  . . . . . . . . . . .  	L 0010	F0B4	BIOS
INT_1D_GFX . . . . . . . . . . .  	L 0010	F0C4	BIOS
INT_1D_MDA . . . . . . . . . . .  	L 0010	F0D4	BIOS
INT_1E . . . . . . . . . . . . .  	L 000B	EFC7	BIOS
INT_1E_PARAM . . . . . . . . . .  	N PROC	EF48	BIOS	Length = 000E
INT_IMR  . . . . . . . . . . . .  	NUMBER	0021	
INT_IRQ  . . . . . . . . . . . .  	N PROC	FF23	BIOS	Length = 0023
INT_IRQ_DONE . . . . . . . . . .  	L NEAR	FF3F	BIOS
INT_KB_ALT . . . . . . . . . . .  	N PROC	EAA1	BIOS	Length = 003E
INT_KB_ALT_BREAK . . . . . . . .  	L NEAR	EB98	BIOS
INT_KB_ALT_SKIP  . . . . . . . .  	L BYTE	EC26	BIOS
INT_KB_CHECK_CTRL_NUM  . . . . .  	L NEAR	E9F0	BIOS
INT_KB_CTRL  . . . . . . . . . .  	L NEAR	EB1E	BIOS
INT_KB_CTRL_ALPHA  . . . . . . .  	L NEAR	EB04	BIOS
INT_KB_CTRL_ALT  . . . . . . . .  	L NEAR	EB23	BIOS
INT_KB_CTRL_ALT_1  . . . . . . .  	L NEAR	EB34	BIOS
INT_KB_CTRL_ALT_DEL  . . . . . .  	L NEAR	EB28	BIOS
INT_KB_CTRL_ASC_TBL  . . . . . .  	L BYTE	E96F	BIOS
INT_KB_CTRL_ASC_TBL_DONE . . . .  	L NEAR	EAF9	BIOS
INT_KB_CTRL_ASC_TBL_LOOP . . . .  	L NEAR	EAE5	BIOS
INT_KB_CTRL_BREAK  . . . . . . .  	L NEAR	E9E4	BIOS
INT_KB_CTRL_NO_ALT . . . . . . .  	N PROC	EADF	BIOS	Length = 003F
INT_KB_CTRL_NO_ALT_1 . . . . . .  	L NEAR	EB12	BIOS
INT_KB_CTRL_NO_DONE  . . . . . .  	L NEAR	EAF6	BIOS
INT_KB_CTRL_SCAN_TBL . . . . . .  	L BYTE	E979	BIOS
INT_KB_DONE  . . . . . . . . . .  	L NEAR	EA98	BIOS
INT_KB_DONE_1  . . . . . . . . .  	L NEAR	EADD	BIOS
INT_KB_DONE_2  . . . . . . . . .  	L NEAR	EA23	BIOS
INT_KB_DONE_3  . . . . . . . . .  	L NEAR	EB77	BIOS
INT_KB_FLAG_CLEAR  . . . . . . .  	L NEAR	EB8F	BIOS
INT_KB_FLAG_FOUND  . . . . . . .  	L NEAR	EB5B	BIOS
INT_KB_FLAG_LOOP . . . . . . . .  	L NEAR	EB51	BIOS
INT_KB_FLAG_TOGGLE . . . . . . .  	L NEAR	EB6E	BIOS
INT_KB_ICNS_BREAK  . . . . . . .  	L NEAR	EB66	BIOS
INT_KB_ICNS_MAKE . . . . . . . .  	L NEAR	EB6C	BIOS
INT_KB_IS_ALT_000  . . . . . . .  	L NEAR	EAC3	BIOS
INT_KB_IS_FLAG . . . . . . . . .  	N PROC	EB45	BIOS	Length = 0053
INT_KB_MEEP_DONE . . . . . . . .  	L NEAR	EA25	BIOS
INT_KB_NOT_ALT_000 . . . . . . .  	L NEAR	EAD0	BIOS
INT_KB_NOT_ICNS  . . . . . . . .  	L NEAR	EB7A	BIOS
INT_KB_NOT_ICNS_1  . . . . . . .  	L NEAR	EB86	BIOS
INT_KB_PAUSE_LOOP  . . . . . . .  	L NEAR	EA1C	BIOS
INT_KB_PUT_BUFFER_2  . . . . . .  	L NEAR	EBA5	BIOS
INT_KB_SET_PAUSE . . . . . . . .  	L NEAR	EA0A	BIOS
INT_KB_TOGGLE_TURBO  . . . . . .  	N PROC	EB39	BIOS	Length = 000C
INT_LAST . . . . . . . . . . . .  	L BYTE	006B	_BDA
INT_LAST_ABS . . . . . . . . . .  	L BYTE	046B	_BDA_ABS
INT_P0 . . . . . . . . . . . . .  	NUMBER	0020	
INT_RET  . . . . . . . . . . . .  	N PROC	FF53	BIOS	Length = 0001
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-23


IOW  . . . . . . . . . . . . . .  		0006	
IO_DELAY_MS  . . . . . . . . . .  	N PROC	E68F	BIOS	Length = 002E
IO_DELAY_MS_FDC  . . . . . . . .  	ALIAS	 IO_DELAY_MS		
IO_DELAY_TICK  . . . . . . . . .  	N PROC	E693	BIOS	Length = 002A
IO_WAIT_LATCH  . . . . . . . . .  	N PROC	E6AD	BIOS	Length = 0010
IO_WAIT_MS_125 . . . . . . . . .  	N PROC	E68B	BIOS	Length = 0032
IO_WAIT_MS_DONE  . . . . . . . .  	L NEAR	E6AC	BIOS
IO_WAIT_MS_LOOP  . . . . . . . .  	L NEAR	E69B	BIOS
IPL  . . . . . . . . . . . . . .  		0000	
IPL_ID . . . . . . . . . . . . .  	L WORD	7DFE	_IPL_SEG
IPL_TOP  . . . . . . . . . . . .  	L BYTE	7C00	_IPL_SEG	Length = 01FE
IRQ0 . . . . . . . . . . . . . .  		0000	
IRQ1 . . . . . . . . . . . . . .  		0001	
IRQ2 . . . . . . . . . . . . . .  		0002	
IRQ3 . . . . . . . . . . . . . .  		0003	
IRQ4 . . . . . . . . . . . . . .  		0004	
IRQ5 . . . . . . . . . . . . . .  		0005	
IRQ6 . . . . . . . . . . . . . .  		0006	
IRQ7 . . . . . . . . . . . . . .  		0007	
ISA_TYPE . . . . . . . . . . . .  	L BYTE	FFFE	BIOS
IS_ALPHA . . . . . . . . . . . .  	L NEAR	EA47	BIOS
IS_ALPHA_DONE  . . . . . . . . .  	L NEAR	EA51	BIOS
IS_TURBO . . . . . . . . . . . .  	NUMBER	-0001	
IVT_08 . . . . . . . . . . . . .  	L WORD	0020	_IVT
IVT_08_SEG . . . . . . . . . . .  	L WORD	0022	_IVT
IVT_09 . . . . . . . . . . . . .  	L WORD	0024	_IVT
IVT_09_SEG . . . . . . . . . . .  	L WORD	0026	_IVT
IVT_10 . . . . . . . . . . . . .  	L WORD	0040	_IVT
IVT_10_SEG . . . . . . . . . . .  	L WORD	0042	_IVT
IVT_18 . . . . . . . . . . . . .  	L WORD	0060	_IVT
IVT_18_SEG . . . . . . . . . . .  	L WORD	0062	_IVT
IVT_1D . . . . . . . . . . . . .  	L DWORD	0074	_IVT
IVT_1E . . . . . . . . . . . . .  	L DWORD	0078	_IVT
IVT_1F . . . . . . . . . . . . .  	L DWORD	007C	_IVT

K1AL . . . . . . . . . . . . . .  		0003	
K1CL . . . . . . . . . . . . . .  		0006	
K1CT . . . . . . . . . . . . . .  		0002	
K1IN . . . . . . . . . . . . . .  		0007	
K1LS . . . . . . . . . . . . . .  		0001	
K1NL . . . . . . . . . . . . . .  		0005	
K1RS . . . . . . . . . . . . . .  		0000	
K1SL . . . . . . . . . . . . . .  		0004	
K2CL . . . . . . . . . . . . . .  		0006	
K2IN . . . . . . . . . . . . . .  		0007	
K2LA . . . . . . . . . . . . . .  		0001	
K2LC . . . . . . . . . . . . . .  		0000	
K2NL . . . . . . . . . . . . . .  		0005	
K2PA . . . . . . . . . . . . . .  		0003	
K2SL . . . . . . . . . . . . . .  		0004	
K2SY . . . . . . . . . . . . . .  		0002	
KBK  . . . . . . . . . . . . . .  		000A	
KBPK . . . . . . . . . . . . . .  		0006	
KBPS . . . . . . . . . . . . . .  		0000	
KBRK . . . . . . . . . . . . . .  		0007	
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-24


KBRX . . . . . . . . . . . . . .  		0000	
KBS  . . . . . . . . . . . . . .  		0000	
KBWK . . . . . . . . . . . . . .  		0009	
KBWS . . . . . . . . . . . . . .  		0000	
KB_ALT . . . . . . . . . . . . .  	L BYTE	0019	_BDA
KB_BUF . . . . . . . . . . . . .  	L WORD	001E	_BDA	Length = 0010
KB_BUF_CLEAR . . . . . . . . . .  	N PROC	E95F	BIOS	Length = 0010
KB_BUF_END . . . . . . . . . . .  	L WORD	003E	_BDA
KB_BUF_END_B . . . . . . . . . .  	NUMBER	003E	
KB_BUF_HAS_KEY . . . . . . . . .  	L NEAR	E84F	BIOS
KB_BUF_HD  . . . . . . . . . . .  	L WORD	001A	_BDA
KB_BUF_HD_ABS  . . . . . . . . .  	L WORD	041A	_BDA_ABS
KB_BUF_ST  . . . . . . . . . . .  	L WORD	0080	_BDA
KB_BUF_ST_ABS  . . . . . . . . .  	L WORD	0480	_BDA_ABS
KB_BUF_TL  . . . . . . . . . . .  	L WORD	001C	_BDA
KB_FILTER_SC . . . . . . . . . .  	NUMBER	0000	
KB_FLAGS . . . . . . . . . . . .  	L WORD	0017	_BDA
KB_FLAGS1  . . . . . . . . . . .  	L BYTE	0017	_BDA
KB_FLAGS2  . . . . . . . . . . .  	L BYTE	0018	_BDA
KB_GET_READ  . . . . . . . . . .  	L NEAR	E868	BIOS
KB_HAPPY . . . . . . . . . . . .  	L NEAR	E39D	BIOS
KB_HLT_WAIT  . . . . . . . . . .  	NUMBER	0001	
KB_INT_CHAR  . . . . . . . . . .  	L NEAR	EA2A	BIOS
KB_INT_CHECK_FN_KEY  . . . . . .  	L NEAR	E9B6	BIOS
KB_INT_CHECK_FN_KEY_DONE . . . .  	L NEAR	E9DB	BIOS
KB_INT_CHECK_FULL  . . . . . . .  	L NEAR	EA8C	BIOS
KB_INT_IS_ALT  . . . . . . . . .  	L NEAR	EA56	BIOS
KB_INT_IS_ALT_DONE . . . . . . .  	L NEAR	EA65	BIOS
KB_INT_IS_CAPS . . . . . . . . .  	L NEAR	EA42	BIOS
KB_INT_IS_CAPS_DONE  . . . . . .  	L NEAR	EA56	BIOS
KB_INT_IS_CTRL . . . . . . . . .  	L NEAR	EA65	BIOS
KB_INT_IS_CTRL_DONE  . . . . . .  	L NEAR	EA71	BIOS
KB_INT_IS_NUM  . . . . . . . . .  	L NEAR	E9F4	BIOS
KB_INT_IS_NUM_DONE . . . . . . .  	L NEAR	EA2A	BIOS
KB_INT_IS_PAUSE  . . . . . . . .  	L NEAR	EA71	BIOS
KB_INT_NOT_FLAG  . . . . . . . .  	L NEAR	EA3E	BIOS
KB_INT_PRTSC . . . . . . . . . .  	L NEAR	EA6D	BIOS
KB_INT_PUT_BUFFER  . . . . . . .  	L NEAR	EA7D	BIOS
KB_INT_PUT_BUFFER_2  . . . . . .  	L NEAR	E9D8	BIOS
KB_INT_SHIFT . . . . . . . . . .  	L NEAR	EA31	BIOS
KB_INT_UC  . . . . . . . . . . .  	L NEAR	EA32	BIOS
KB_KEY_STATUS  . . . . . . . . .  	N PROC	E840	BIOS	Length = 0013
KB_KEY_STATUS_DONE . . . . . . .  	L NEAR	E849	BIOS
KB_RESET_TEST  . . . . . . . . .  	L NEAR	E378	BIOS
KB_SHIFT_STATUS  . . . . . . . .  	N PROC	E86F	BIOS	Length = 0005
KB_WAIT_READ . . . . . . . . . .  	N PROC	E853	BIOS	Length = 001C
KB_WAIT_READ_1 . . . . . . . . .  	L NEAR	E855	BIOS
KEE0 . . . . . . . . . . . . . .  		0001	
KEE1 . . . . . . . . . . . . . .  		0000	
KEEN . . . . . . . . . . . . . .  		0004	
KEFI . . . . . . . . . . . . . .  		0006	
KENL . . . . . . . . . . . . . .  		0005	
KERA . . . . . . . . . . . . . .  		0003	
KERC . . . . . . . . . . . . . .  		0002	
KERD . . . . . . . . . . . . . .  		0007	
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-25


KEY_FLAG_ON_TBL  . . . . . . . .  	L BYTE	EC1E	BIOS
KEY_SCAN_TBL . . . . . . . . . .  	L BYTE	EBA8	BIOS
KEY_SCAN_TBL_HIGH  . . . . . . .  	L BYTE	EC32	BIOS
KLAK . . . . . . . . . . . . . .  		0004	
KLCI . . . . . . . . . . . . . .  		0003	
KLCL . . . . . . . . . . . . . .  		0002	
KLMU . . . . . . . . . . . . . .  		0006	
KLNL . . . . . . . . . . . . . .  		0001	
KLRF . . . . . . . . . . . . . .  		0005	
KLSL . . . . . . . . . . . . . .  		0000	
KLTE . . . . . . . . . . . . . .  		0007	
KPWP . . . . . . . . . . . . . .  		0004	
KPWPX  . . . . . . . . . . . . .  		0000	

LASER_TURBO  . . . . . . . . . .  	NUMBER	01F0	
LBI  . . . . . . . . . . . . . .  		0004	
LBN  . . . . . . . . . . . . . .  		0000	
LCBK . . . . . . . . . . . . . .  		0006	
LCDR . . . . . . . . . . . . . .  		0003	
LCEPS  . . . . . . . . . . . . .  		0004	
LCINI  . . . . . . . . . . . . .  		0002	
LCIRQ  . . . . . . . . . . . . .  		0004	
LCLF . . . . . . . . . . . . . .  		0001	
LCOUT  . . . . . . . . . . . . .  		0000	
LCPD . . . . . . . . . . . . . .  		0005	
LCPEN  . . . . . . . . . . . . .  		0003	
LCSB . . . . . . . . . . . . . .  		0002	
LCWLS  . . . . . . . . . . . . .  		0000	
LCX  . . . . . . . . . . . . . .  		0005	
LDR  . . . . . . . . . . . . . .  		0000	
LF . . . . . . . . . . . . . . .  	NUMBER	000A	
LFE  . . . . . . . . . . . . . .  		0003	
LIGHTCYAN  . . . . . . . . . . .  	NUMBER	000B	
LIGHT_PEN  . . . . . . . . . . .  	NUMBER	0001	
LMW  . . . . . . . . . . . . . .  		0000	
LOE  . . . . . . . . . . . . . .  		0001	
LPACK  . . . . . . . . . . . . .  		0006	
LPBZ . . . . . . . . . . . . . .  		0007	
LPE  . . . . . . . . . . . . . .  		0002	
LPIO . . . . . . . . . . . . . .  		0003	
LPOP . . . . . . . . . . . . . .  		0005	
LPSEL  . . . . . . . . . . . . .  		0004	
LPT  . . . . . . . . . . . . . .  		000E	
LPT1 . . . . . . . . . . . . . .  	NUMBER	0378	
LPT2 . . . . . . . . . . . . . .  	NUMBER	0278	
LPTO . . . . . . . . . . . . . .  		0000	
LPT_ADDR . . . . . . . . . . . .  	L WORD	0008	_BDA	Length = 0003
LPT_ADDR_B . . . . . . . . . . .  	NUMBER	0008	
LPT_CHAR . . . . . . . . . . . .  	N PROC	FFB3	BIOS	Length = 0010
LPT_CHAR_EXIT  . . . . . . . . .  	L NEAR	FFC2	BIOS
LPT_CHAR_OUT . . . . . . . . . .  	L NEAR	FFBD	BIOS
LPT_CRLF . . . . . . . . . . . .  	N PROC	FFAA	BIOS	Length = 0019
LPT_DETECT_LOOP  . . . . . . . .  	L NEAR	E32C	BIOS
LPT_LF . . . . . . . . . . . . .  	N PROC	FFB1	BIOS	Length = 0012
LPT_MDA  . . . . . . . . . . . .  	NUMBER	03BC	
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-26


LPT_TIME . . . . . . . . . . . .  	L BYTE	0078	_BDA	Length = 0004
LPT_TIME_B . . . . . . . . . . .  	NUMBER	0078	
LPT_TO . . . . . . . . . . . . .  	NUMBER	0014	
LPX  . . . . . . . . . . . . . .  		0001	
LSX  . . . . . . . . . . . . . .  		0007	
LTIM . . . . . . . . . . . . . .  		0003	
LWB  . . . . . . . . . . . . . .  		0000	
L_INT_10_JMP . . . . . . . . . .  	NUMBER	0010	
L_INT_KB_ALT_SKIP  . . . . . . .  	NUMBER	000A	
L_INT_KB_CTRL_ASC_TBL  . . . . .  	NUMBER	000C	
L_INT_KB_CTRL_SCAN_TBL . . . . .  	NUMBER	0006	
L_KEY_FLAG_ON_TBL  . . . . . . .  	NUMBER	0008	
L_KEY_SCAN_TBL . . . . . . . . .  	NUMBER	00AA	
L_POST_ERRORS  . . . . . . . . .  	NUMBER	0006	
L_POST_L . . . . . . . . . . . .  	NUMBER	0002	
L_VECTOR_TABLE . . . . . . . . .  	NUMBER	001F	
L_VID_BDA  . . . . . . . . . . .  	NUMBER	001E	

MAGENTA  . . . . . . . . . . . .  	NUMBER	000D	
MAGIC_WORD . . . . . . . . . . .  	NUMBER	AA55	
MAX_RAM  . . . . . . . . . . . .  	NUMBER	0280	
MAX_RAM_AUTO . . . . . . . . . .  	NUMBER	0000	
MAX_RAM_CGA  . . . . . . . . . .  	NUMBER	02E0	
MAX_RAM_MDA  . . . . . . . . . .  	NUMBER	02C0	
MAX_RAM_PC . . . . . . . . . . .  	NUMBER	0280	
MBRAM  . . . . . . . . . . . . .  		0002	
MBR_CHECK  . . . . . . . . . . .  	NUMBER	0000	
MCLB . . . . . . . . . . . . . .  		0004	
MCO1 . . . . . . . . . . . . . .  		0002	
MCO2 . . . . . . . . . . . . . .  		0003	
MCRX . . . . . . . . . . . . . .  		0005	
MCTS . . . . . . . . . . . . . .  		0004	
MDA_ATTR . . . . . . . . . . . .  	NUMBER	0001	
MDA_COLOR_FIX  . . . . . . . . .  	L NEAR	F78E	BIOS
MDA_CTRL . . . . . . . . . . . .  	NUMBER	03B8	
MDA_MEM  . . . . . . . . . . . .  	L BYTE	0000	_MDA_MEM	Length = 1000
MDA_PEN_RST  . . . . . . . . . .  	NUMBER	03BB	
MDA_STAT . . . . . . . . . . . .  	NUMBER	03BA	
MDBG . . . . . . . . . . . . . .  		0004	
MDBK . . . . . . . . . . . . . .  		0007	
MDFG . . . . . . . . . . . . . .  		0000	
MDIN . . . . . . . . . . . . . .  		0003	
MDSR . . . . . . . . . . . . . .  		0005	
MEEP . . . . . . . . . . . . . .  	N PROC	E8C6	BIOS	Length = 0016
MEEPMEEP . . . . . . . . . . . .  	N PROC	E8C3	BIOS	Length = 0019
MEEPMEEP_Z . . . . . . . . . . .  	N PROC	E8C1	BIOS	Length = 001B
MEEP_DELAY . . . . . . . . . . .  	NUMBER	0040	
MEM_ADDR_ERR . . . . . . . . . .  	L NEAR	E665	BIOS
MEM_ADDR_LOOP  . . . . . . . . .  	L NEAR	E647	BIOS
MEM_ADDR_TEST  . . . . . . . . .  	N PROC	E640	BIOS	Length = 0026
MEM_CHECK  . . . . . . . . . . .  	N PROC	E671	BIOS	Length = 000F
MEM_SZ_KB  . . . . . . . . . . .  	L WORD	0013	_BDA
MEM_SZ_PC  . . . . . . . . . . .  	L WORD	0015	_BDA
MEM_TEST . . . . . . . . . . . .  	N PROC	E666	BIOS	Length = 001A
MEM_TEST_VERIFY  . . . . . . . .  	L NEAR	E678	BIOS
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-27


MLSD . . . . . . . . . . . . . .  		0007	
MMW  . . . . . . . . . . . . . .  		0002	
MOVE_COL . . . . . . . . . . . .  	N PROC	F7AE	BIOS	Length = 0017
MOVE_COL_SET . . . . . . . . . .  	L NEAR	F7BA	BIOS
MRI  . . . . . . . . . . . . . .  		0006	
MUTE_TANDY . . . . . . . . . . .  	NUMBER	0000	

NEXT_COL . . . . . . . . . . . .  	L NEAR	F5FD	BIOS
NEXT_COM_PORT  . . . . . . . . .  	L NEAR	E322	BIOS
NEXT_LPT_PORT  . . . . . . . . .  	L NEAR	E34A	BIOS
NEXT_ROM . . . . . . . . . . . .  	L NEAR	E57D	BIOS
NIB_HEX  . . . . . . . . . . . .  	N PROC	F810	BIOS	Length = 0012
NL2_ANY_KEY  . . . . . . . . . .  	L BYTE	E4E2	BIOS
NL_ANY_KEY . . . . . . . . . . .  	L BYTE	E4E3	BIOS
NL_Z . . . . . . . . . . . . . .  	L BYTE	E4C3	BIOS
NMIE . . . . . . . . . . . . . .  		0007	
NMIX . . . . . . . . . . . . . .  		0000	
NMI_ERR_IO . . . . . . . . . . .  	L BYTE	E53B	BIOS
NMI_ERR_PAR  . . . . . . . . . .  	L BYTE	E53D	BIOS
NMI_R0 . . . . . . . . . . . . .  	NUMBER	00A0	
NMI_RESET  . . . . . . . . . . .  	N PROC	E680	BIOS	Length = 000B
NOTE1  . . . . . . . . . . . . .  	NUMBER	000D	
NOTE2  . . . . . . . . . . . . .  	NUMBER	000E	
NOT_HI_RES . . . . . . . . . . .  	L NEAR	F5C1	BIOS
NO_COM_PORT  . . . . . . . . . .  	L NEAR	E316	BIOS
NO_GAME_PORT . . . . . . . . . .  	L NEAR	E2FE	BIOS
NO_LPT_PORT  . . . . . . . . . .  	L NEAR	E340	BIOS

O2CMD  . . . . . . . . . . . . .  		0005	
O2L  . . . . . . . . . . . . . .  		0000	
O2X  . . . . . . . . . . . . . .  		0003	
O3D3 . . . . . . . . . . . . . .  		0003	
O3D7 . . . . . . . . . . . . . .  		0007	
O3P  . . . . . . . . . . . . . .  		0002	
O3RR . . . . . . . . . . . . . .  		0000	
OEM_FONT . . . . . . . . . . . .  	NUMBER	0000	
OPT_ROM_END  . . . . . . . . . .  	NUMBER	FE00	
OUTLN_SZ . . . . . . . . . . . .  	N PROC	F7C5	BIOS	Length = 000C
OUT_CHAR . . . . . . . . . . . .  	N PROC	F817	BIOS	Length = 000B
OUT_DECU . . . . . . . . . . . .  	N PROC	F7D9	BIOS	Length = 0017
OUT_DECU_DONE  . . . . . . . . .  	L NEAR	F7E8	BIOS
OUT_DECU_R . . . . . . . . . . .  	L NEAR	F7DC	BIOS
OUT_SZ . . . . . . . . . . . . .  	N PROC	F79F	BIOS	Length = 000F
OUT_SZ_ATTR  . . . . . . . . . .  	N PROC	F78D	BIOS	Length = 0021
OUT_SZ_ATTR_SET  . . . . . . . .  	L NEAR	F799	BIOS
OUT_SZ_DONE  . . . . . . . . . .  	L NEAR	F7AC	BIOS
OUT_SZ_LOOP  . . . . . . . . . .  	L NEAR	F7A2	BIOS
O_INT_1D_40  . . . . . . . . . .  	NUMBER	0000	
O_INT_1D_80  . . . . . . . . . .  	NUMBER	0010	
O_INT_1D_GFX . . . . . . . . . .  	NUMBER	0020	
O_INT_1D_MDA . . . . . . . . . .  	NUMBER	0030	

PBIO . . . . . . . . . . . . . .  		0005	
PBKB . . . . . . . . . . . . . .  		0007	
PBKC . . . . . . . . . . . . . .  		0006	
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-28


PBPC . . . . . . . . . . . . . .  		0004	
PBSP . . . . . . . . . . . . . .  		0001	
PBST . . . . . . . . . . . . . .  		0000	
PBSW . . . . . . . . . . . . . .  		0003	
PBTB . . . . . . . . . . . . . .  		0002	
PC2CI  . . . . . . . . . . . . .  		0004	
PC2IE  . . . . . . . . . . . . .  		0006	
PC2PE  . . . . . . . . . . . . .  		0007	
PC2T2  . . . . . . . . . . . . .  		0005	
PCCI . . . . . . . . . . . . . .  		0004	
PCDRV  . . . . . . . . . . . . .  		0002	
PCFD . . . . . . . . . . . . . .  		0000	
PCFP . . . . . . . . . . . . . .  		0001	
PCIE . . . . . . . . . . . . . .  		0006	
PCMB . . . . . . . . . . . . . .  		0002	
PCPE . . . . . . . . . . . . . .  		0007	
PCT2 . . . . . . . . . . . . . .  		0005	
PCVID  . . . . . . . . . . . . .  		0000	
PCWBCD . . . . . . . . . . . . .  		0000	
PCWM . . . . . . . . . . . . . .  		0001	
PCWRW  . . . . . . . . . . . . .  		0004	
PCWSC  . . . . . . . . . . . . .  		0006	
PDMA . . . . . . . . . . . . . .  		000A	
PFDC . . . . . . . . . . . . . .  		000C	
PFSK . . . . . . . . . . . . . .  		000B	
PFXX . . . . . . . . . . . . . .  		0008	
PIC_INT_FAIL . . . . . . . . . .  	L NEAR	E1A0	BIOS
PIC_INT_PASS . . . . . . . . . .  	L NEAR	E1C4	BIOS
PIC_INT_TEST . . . . . . . . . .  	L NEAR	E1A6	BIOS
PIC_REG_PASS . . . . . . . . . .  	L NEAR	E1A2	BIOS
PIC_VECT_TMP_LOOP  . . . . . . .  	L NEAR	E1AA	BIOS
PIT_CH0  . . . . . . . . . . . .  	NUMBER	0040	
PIT_CH1  . . . . . . . . . . . .  	NUMBER	0041	
PIT_CH2  . . . . . . . . . . . .  	NUMBER	0042	
PIT_CTRL . . . . . . . . . . . .  	NUMBER	0043	
PKEY . . . . . . . . . . . . . .  		000D	
PKI  . . . . . . . . . . . . . .  		000E	
PMEM . . . . . . . . . . . . . .  		0009	
PORT_COUNT_LOOP  . . . . . . . .  	L NEAR	F72C	BIOS
PORT_COUNT_NONE  . . . . . . . .  	L NEAR	F73A	BIOS
PORT_TEST  . . . . . . . . . . .  	N PROC	E7EB	BIOS	Length = 002F
PORT_TEST_DONE . . . . . . . . .  	L NEAR	E819	BIOS
POST_BANNER  . . . . . . . . . .  	NUMBER	0001	
POST_BOOT  . . . . . . . . . . .  	L BYTE	E8F6	BIOS
POST_BOOT_TYPE . . . . . . . . .  	N PROC	E3B0	BIOS	Length = 0017
POST_BOOT_TYPE_OUT . . . . . . .  	L NEAR	E3C1	BIOS
POST_CARD  . . . . . . . . . . .  	NUMBER	0000	
POST_CARD_PORT . . . . . . . . .  	NUMBER	0080	
POST_CGA . . . . . . . . . . . .  	L BYTE	E822	BIOS
POST_CHS . . . . . . . . . . . .  	L BYTE	F8C3	BIOS
POST_CLR_COLD  . . . . . . . . .  	ALIAS	 BLUE		
POST_CLR_GB  . . . . . . . . . .  	ALIAS	 GRAY		
POST_CLR_TXT . . . . . . . . . .  	ALIAS	 CYAN		
POST_CLR_VAL1  . . . . . . . . .  	ALIAS	 GREEN		
POST_CLR_VAL2  . . . . . . . . .  	ALIAS	 YELLOW		
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-29


POST_CLR_WARM  . . . . . . . . .  	ALIAS	 DARKRED		
POST_CLS . . . . . . . . . . . .  	NUMBER	0000	
POST_COL . . . . . . . . . . . .  	N PROC	F742	BIOS	Length = 0083
POST_COLD  . . . . . . . . . . .  	L BYTE	E900	BIOS
POST_COL_LBL_W . . . . . . . . .  	NUMBER	0007	
POST_COL_PAD . . . . . . . . . .  	NUMBER	0004	
POST_COL_VT  . . . . . . . . . .  	NUMBER	0009	
POST_COL_W . . . . . . . . . . .  	NUMBER	0006	
POST_COM . . . . . . . . . . . .  	L BYTE	E528	BIOS
POST_CONFIG  . . . . . . . . . .  	NUMBER	0001	
POST_CPU . . . . . . . . . . . .  	L BYTE	E4FA	BIOS
POST_CPU_TEST  . . . . . . . . .  	L NEAR	E05D	BIOS
POST_DETECT_COM  . . . . . . . .  	L NEAR	E2FE	BIOS
POST_DETECT_GAM  . . . . . . . .  	L NEAR	E2F3	BIOS
POST_DETECT_LPT  . . . . . . . .  	L NEAR	E324	BIOS
POST_DETECT_PORTS  . . . . . . .  	N PROC	E2E3	BIOS	Length = 0069
POST_EGA . . . . . . . . . . . .  	L BYTE	E81E	BIOS
POST_END_COL . . . . . . . . . .  	N PROC	F784	BIOS	Length = 002A
POST_END_COL_NL  . . . . . . . .  	N PROC	F77F	BIOS	Length = 0005
POST_END_COL_STR . . . . . . . .  	N PROC	F787	BIOS	Length = 0027
POST_ERR . . . . . . . . . . . .  	L BYTE	E905	BIOS
POST_ERROR . . . . . . . . . . .  	L NEAR	E473	BIOS
POST_ERRORS  . . . . . . . . . .  	L WORD	E922	BIOS
POST_ERROR_MSG . . . . . . . . .  	N PROC	E92E	BIOS	Length = 0016
POST_ERROR_MSG_EXIT  . . . . . .  	L NEAR	E943	BIOS
POST_ERROR_MSG_LOOP  . . . . . .  	L NEAR	E934	BIOS
POST_ERROR_MSG_NEXT  . . . . . .  	L NEAR	E941	BIOS
POST_ERR_ERR . . . . . . . . . .  	L BYTE	E90C	BIOS
POST_ERR_MSG . . . . . . . . . .  	N PROC	E905	BIOS	Length = 003F
POST_ERR_PDMA  . . . . . . . . .  	L BYTE	E91E	BIOS
POST_ERR_PFDC  . . . . . . . . .  	L BYTE	E91A	BIOS
POST_ERR_PKEY  . . . . . . . . .  	L BYTE	E916	BIOS
POST_ERR_PKI . . . . . . . . . .  	L BYTE	E913	BIOS
POST_ERR_WAIT  . . . . . . . . .  	NUMBER	0001	
POST_FDD . . . . . . . . . . . .  	L BYTE	E52C	BIOS
POST_FD_COUNT  . . . . . . . . .  	NUMBER	0001	
POST_FLAG_DONE . . . . . . . . .  	L NEAR	E099	BIOS
POST_FPU . . . . . . . . . . . .  	L BYTE	E503	BIOS
POST_GLADOS  . . . . . . . . . .  	NUMBER	0000	
POST_HD  . . . . . . . . . . . .  	L BYTE	E50C	BIOS
POST_HDD . . . . . . . . . . . .  	L BYTE	E530	BIOS
POST_HD_CHECK  . . . . . . . . .  	NUMBER	0001	
POST_HD_COUNT  . . . . . . . . .  	NUMBER	0001	
POST_HD_PARMS  . . . . . . . . .  	NUMBER	0001	
POST_KB_RESET  . . . . . . . . .  	N PROC	E34C	BIOS	Length = 0061
POST_K_UNIT  . . . . . . . . . .  	TEXT  'KB'		
POST_L . . . . . . . . . . . . .  	TEXT  ' [ '		
POST_LPT . . . . . . . . . . . .  	L BYTE	E524	BIOS
POST_LSEP  . . . . . . . . . . .  	L BYTE	E534	BIOS
POST_MDA . . . . . . . . . . . .  	L BYTE	E826	BIOS
POST_MEMORY  . . . . . . . . . .  	L BYTE	E512	BIOS
POST_M_UNIT  . . . . . . . . . .  	TEXT  'MB'		
POST_NONE  . . . . . . . . . . .  	L BYTE	FF4C	BIOS
POST_OK  . . . . . . . . . . . .  	L NEAR	E493	BIOS
POST_OPT_ROM . . . . . . . . . .  	NUMBER	0001	
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-30


POST_QUIET . . . . . . . . . . .  	NUMBER	0000	
POST_R . . . . . . . . . . . . .  	TEXT  ' ]'		
POST_RSEP  . . . . . . . . . . .  	L BYTE	E538	BIOS
POST_START_COL_1 . . . . . . . .  	N PROC	F746	BIOS	Length = 0027
POST_START_COL_2 . . . . . . . .  	N PROC	F76D	BIOS	Length = 0012
POST_START_COL_2_40  . . . . . .  	L NEAR	F742	BIOS
POST_START_COL_START . . . . . .  	L NEAR	F749	BIOS
POST_STRINGS . . . . . . . . . .  	N PROC	E4FA	BIOS	Length = 004B
POST_SYS_CONFIG  . . . . . . . .  	N PROC	F680	BIOS	Length = 00C2
POST_SYS_VIDEO . . . . . . . . .  	N PROC	F680	BIOS	Length = 004E
POST_SYS_VIDEO_DONE  . . . . . .  	L NEAR	F6C8	BIOS
POST_TAB_COL . . . . . . . . . .  	NUMBER	0020	
POST_TAB_COL_I . . . . . . . . .  	NUMBER	0013	
POST_TEST_CHK_ROM  . . . . . . .  	NUMBER	0001	
POST_TEST_DMA  . . . . . . . . .  	NUMBER	0001	
POST_TEST_DMA_TC0  . . . . . . .  	NUMBER	0001	
POST_TEST_FD . . . . . . . . . .  	NUMBER	0001	
POST_TEST_INST . . . . . . . . .  	NUMBER	0000	
POST_TEST_KB . . . . . . . . . .  	NUMBER	0001	
POST_TEST_KEY  . . . . . . . . .  	NUMBER	0001	
POST_TEST_PIC_INT  . . . . . . .  	NUMBER	0001	
POST_TEST_PIC_REG  . . . . . . .  	NUMBER	0001	
POST_TEST_PIT_1  . . . . . . . .  	NUMBER	0001	
POST_TEST_SEEK . . . . . . . . .  	NUMBER	0001	
POST_THEME . . . . . . . . . . .  	NUMBER	0001	
POST_V20 . . . . . . . . . . . .  	L BYTE	E520	BIOS
POST_VGA . . . . . . . . . . . .  	L BYTE	E81A	BIOS
POST_VIDEO . . . . . . . . . . .  	L BYTE	FF46	BIOS
POST_VIDEO_TYPE  . . . . . . . .  	NUMBER	0001	
POST_WARM  . . . . . . . . . . .  	L BYTE	E8FB	BIOS
POST_WARM_COLD . . . . . . . . .  	NUMBER	0001	
POWER_ON . . . . . . . . . . . .  	F PROC	FFF0	BIOS	Length = 0010
PPAD . . . . . . . . . . . . . .  		0004	
PPAM . . . . . . . . . . . . . .  		0005	
PPBD . . . . . . . . . . . . . .  		0001	
PPBM . . . . . . . . . . . . . .  		0002	
PPCL . . . . . . . . . . . . . .  		0000	
PPCU . . . . . . . . . . . . . .  		0003	
PPEN . . . . . . . . . . . . . .  		0007	
PPI_A  . . . . . . . . . . . . .  	NUMBER	0060	
PPI_B  . . . . . . . . . . . . .  	NUMBER	0061	
PPI_B_BOOT . . . . . . . . . . .  	NUMBER	00AC	
PPI_C  . . . . . . . . . . . . .  	NUMBER	0062	
PPI_CW . . . . . . . . . . . . .  	NUMBER	0063	
PTBD . . . . . . . . . . . . . .  		0002	
PTRSCN_ST  . . . . . . . . . . .  	L BYTE	0000	_DOS_DAT

QUARTER  . . . . . . . . . . . .  	NUMBER	00AC	

RAM_DIGITS . . . . . . . . . . .  	NUMBER	0003	
RAM_PARITY . . . . . . . . . . .  	NUMBER	0001	
RAM_TEST . . . . . . . . . . . .  	NUMBER	731D	
RAM_TEST_1 . . . . . . . . . . .  	NUMBER	95A5	
RAM_TEST_2 . . . . . . . . . . .  	NUMBER	731D	
RAM_TEST_LONG  . . . . . . . . .  	NUMBER	0001	
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-31


RANDOM_TAGLINE . . . . . . . . .  	NUMBER	0001	
RED  . . . . . . . . . . . . . .  	NUMBER	000C	
REL_DATE . . . . . . . . . . . .  	L BYTE	FFF5	BIOS
RESET_PPI  . . . . . . . . . . .  	L NEAR	E0A8	BIOS
RESET_VIDEO  . . . . . . . . . .  	L NEAR	E271	BIOS
RESET_VIDEO_DONE . . . . . . . .  	L NEAR	E273	BIOS
ROM_CHECKSUM . . . . . . . . . .  	N PROC	E588	BIOS	Length = 0014
ROM_INIT_SP  . . . . . . . . . .  	L WORD	0069	_BDA
ROM_INIT_SS  . . . . . . . . . .  	L WORD	0067	_BDA
ROM_SCAN_DONE  . . . . . . . . .  	L NEAR	E584	BIOS
ROM_SCAN_POST  . . . . . . . . .  	N PROC	F936	BIOS	Length = 0069
ROM_SCAN_POST_CHK  . . . . . . .  	L NEAR	F975	BIOS
ROM_SCAN_POST_DONE . . . . . . .  	L NEAR	F96E	BIOS
ROM_SCAN_POST_EXIT . . . . . . .  	L NEAR	F971	BIOS
ROPC . . . . . . . . . . . . . .  		0000	
RTC_DATA . . . . . . . . . . . .  	L WORD	00EE	_BDA
RTC_WAIT . . . . . . . . . . . .  	L BYTE	00A0	_BDA
RTS  . . . . . . . . . . . . . .  		0001	

SETTINGS_5160  . . . . . . . . .  	L NEAR	E221	BIOS
SETTINGS_DONE  . . . . . . . . .  	L NEAR	E239	BIOS
SETTINGS_SAVE  . . . . . . . . .  	L NEAR	E244	BIOS
SET_CURSOR . . . . . . . . . . .  	N PROC	F03E	BIOS	Length = 0007
SFNM . . . . . . . . . . . . . .  		0004	
SHOW_CURSOR  . . . . . . . . . .  	N PROC	F035	BIOS	Length = 0010
SHOW_DISK_PARAMS . . . . . . . .  	N PROC	F863	BIOS	Length = 0064
SHOW_DISK_PARAMS_DONE  . . . . .  	L NEAR	F8C0	BIOS
SHOW_PORT_COUNT  . . . . . . . .  	N PROC	F72A	BIOS	Length = 0018
SMCH . . . . . . . . . . . . . .  		0000	
SMCLR  . . . . . . . . . . . . .  		0002	
SNGL . . . . . . . . . . . . . .  		0001	
SPACE  . . . . . . . . . . . . .  	N PROC	F7D1	BIOS	Length = 0008
SQUARE . . . . . . . . . . . . .  	NUMBER	00FE	
ST0CHK . . . . . . . . . . . . .  		0004	
ST0CS  . . . . . . . . . . . . .  		0006	
ST0DRV . . . . . . . . . . . . .  		0000	
ST0HD  . . . . . . . . . . . . .  		0002	
ST0NR  . . . . . . . . . . . . .  		0003	
ST0SK  . . . . . . . . . . . . .  		0005	
STACK_TOP  . . . . . . . . . . .  	L WORD	0100	_BOOT_STACK
STRINGS  . . . . . . . . . . . .  	N PROC	E4C3	BIOS	Length = 0082
SW1_FLP  . . . . . . . . . . . .  	NUMBER	00C0	
SYN  . . . . . . . . . . . . . .  	NUMBER	0016	
S_OPT_CHK  . . . . . . . . . . .  	L BYTE	F993	BIOS
S_OPT_K  . . . . . . . . . . . .  	L BYTE	F99B	BIOS
S_OPT_ROM  . . . . . . . . . . .  	L BYTE	F98A	BIOS
S_OPT_SIZE . . . . . . . . . . .  	L BYTE	F98E	BIOS

TAG0 . . . . . . . . . . . . . .  	L BYTE	E00E	BIOS
TAG1 . . . . . . . . . . . . . .  	L BYTE	F8E6	BIOS
TAG2 . . . . . . . . . . . . . .  	L BYTE	F8FB	BIOS
TAG3 . . . . . . . . . . . . . .  	L BYTE	F911	BIOS
TAGS . . . . . . . . . . . . . .  	L WORD	F92E	BIOS
TC0  . . . . . . . . . . . . . .  		0000	
TC1  . . . . . . . . . . . . . .  		0001	
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-32


TC2  . . . . . . . . . . . . . .  		0002	
TC3  . . . . . . . . . . . . . .  		0003	
TD_MEM . . . . . . . . . . . . .  	NUMBER	00E0	
TD_TURBO . . . . . . . . . . . .  	NUMBER	0090	
TD_WS  . . . . . . . . . . . . .  	NUMBER	0070	
TEST_MEM_LONG  . . . . . . . . .  	L NEAR	E5F4	BIOS
THRE . . . . . . . . . . . . . .  		0005	
TIMER  . . . . . . . . . . . . .  	L 0005	006C	_BDA
TOGGLE_TURBO . . . . . . . . . .  	N PROC	E29C	BIOS	Length = 0016
TOGGLE_TURBO_CURSOR  . . . . . .  	L NEAR	E2AD	BIOS
TOGGLE_TURBO_DONE  . . . . . . .  	L NEAR	E2B0	BIOS
TOP_BANNER . . . . . . . . . . .  	L BYTE	E000	BIOS
TRY_INT_18 . . . . . . . . . . .  	L NEAR	E4B4	BIOS
TSRE . . . . . . . . . . . . . .  		0006	
TURBO  . . . . . . . . . . . . .  		0003	
TURBO_NONE . . . . . . . . . . .  	NUMBER	0000	
TURBO_REV  . . . . . . . . . . .  	NUMBER	0002	
TURBO_STD  . . . . . . . . . . .  	NUMBER	0001	
TURBO_TYPE . . . . . . . . . . .  	NUMBER	0002	

UM82_SPEED . . . . . . . . . . .  	NUMBER	00C0	
UM82_STATUS  . . . . . . . . . .  	NUMBER	00E0	
UMW  . . . . . . . . . . . . . .  		0004	
UNITS_IEC  . . . . . . . . . . .  	NUMBER	0000	
UNSAFE_FLOPPY  . . . . . . . . .  	NUMBER	0000	
UNSAFE_FLP_DIV . . . . . . . . .  	TEXT  3/10		
UNSAFE_REFRESH . . . . . . . . .  	NUMBER	0000	
UPM  . . . . . . . . . . . . . .  		0000	

V20  . . . . . . . . . . . . . .  		0002	
V40_WCR1 . . . . . . . . . . . .  	NUMBER	FFF5	
V40_WCR2 . . . . . . . . . . . .  	NUMBER	FFF6	
VBG  . . . . . . . . . . . . . .  		0004	
VECTOR_TABLE . . . . . . . . . .  	N PROC	FEE3	BIOS	Length = 0040
VER  . . . . . . . . . . . . . .  	L BYTE	FFE0	BIOS
VER_DATE . . . . . . . . . . . .  	TEXT  '01/18/25'		
VER_NAME . . . . . . . . . . . .  	TEXT  'GLaBIOS'		
VER_NUM  . . . . . . . . . . . .  	TEXT  '0.2.6'		
VF3_OPC  . . . . . . . . . . . .  		0003	
VF3_SRC  . . . . . . . . . . . .  		0000	
VF4_DST  . . . . . . . . . . . .  		0003	
VF4_OPC  . . . . . . . . . . . .  		0006	
VF4_SRC  . . . . . . . . . . . .  		0000	
VFB  . . . . . . . . . . . . . .  		0000	
VID  . . . . . . . . . . . . . .  		0004	
VID_BIOS_SZ  . . . . . . . . . .  	L BYTE	0002	_VID_BIOS
VID_BUF_SZ . . . . . . . . . . .  	L WORD	004C	_BDA
VID_CGA40  . . . . . . . . . . .  	NUMBER	0001	
VID_CGA80  . . . . . . . . . . .  	NUMBER	0002	
VID_COLOR  . . . . . . . . . . .  	L BYTE	0066	_BDA
VID_COLS . . . . . . . . . . . .  	L WORD	004A	_BDA
VID_CURS_POS . . . . . . . . . .  	L WORD	0050	_BDA	Length = 0008
VID_CURS_TYPE  . . . . . . . . .  	L WORD	0060	_BDA
VID_DEF_COLS . . . . . . . . . .  	NUMBER	0050	
VID_DEF_ROWS . . . . . . . . . .  	NUMBER	0018	
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-33


VID_MDA  . . . . . . . . . . . .  	NUMBER	0003	
VID_MEM_SEG  . . . . . . . . . .  	L WORD	00EA	_BDA
VID_MEM_SEG_DW . . . . . . . . .  	L DWORD	00E8	_BDA
VID_MN . . . . . . . . . . . . .  	L WORD	0000	_VID_BIOS
VID_MODE . . . . . . . . . . . .  	L BYTE	0049	_BDA
VID_MODE_OK  . . . . . . . . . .  	L NEAR	E267	BIOS
VID_MODE_REG . . . . . . . . . .  	L BYTE	0065	_BDA
VID_MODE_TBL . . . . . . . . . .  	L BYTE	E82B	BIOS
VID_PAGE . . . . . . . . . . . .  	L BYTE	0062	_BDA
VID_PORT . . . . . . . . . . . .  	L WORD	0063	_BDA
VID_ROM  . . . . . . . . . . . .  	NUMBER	0000	
VID_SEG  . . . . . . . . . . . .  	L WORD	004E	_BDA
VID_SP . . . . . . . . . . . . .  	NUMBER	0020	
VID_VEC  . . . . . . . . . . . .  	L WORD	0003	_VID_BIOS
VL . . . . . . . . . . . . . . .  	NUMBER	00B3	
VRW  . . . . . . . . . . . . . .  		0003	
VSHS . . . . . . . . . . . . . .  		0000	
VSPE . . . . . . . . . . . . . .  		0002	
VSPT . . . . . . . . . . . . . .  		0001	
VSVS . . . . . . . . . . . . . .  		0003	
VSX  . . . . . . . . . . . . . .  		0004	

WARM . . . . . . . . . . . . . .  		000F	
WARM_BOOT  . . . . . . . . . . .  	NUMBER	1234	
WARM_BOOT_MEM  . . . . . . . . .  	NUMBER	4321	
WARM_BOOT_SUS  . . . . . . . . .  	NUMBER	5678	
WARM_BOOT_TEST . . . . . . . . .  	NUMBER	9ABC	
WARM_ENABLE  . . . . . . . . . .  	NUMBER	0001	
WARM_FLAG  . . . . . . . . . . .  	L WORD	0072	_BDA
WARM_FLAG_ABS  . . . . . . . . .  	L WORD	0472	_BDA_ABS
WB_LOW_CHECK_OK  . . . . . . . .  	L NEAR	E80B	BIOS
WB_READ_LOOP . . . . . . . . . .  	L NEAR	E806	BIOS
WB_WRITE_1 . . . . . . . . . . .  	L NEAR	E7F1	BIOS
WB_WRITE_LOOP  . . . . . . . . .  	L NEAR	E7F7	BIOS
WHITE  . . . . . . . . . . . . .  	NUMBER	000F	
WORD_HEX . . . . . . . . . . . .  	N PROC	F7FC	BIOS	Length = 0026

X1 . . . . . . . . . . . . . . .  		000D	

YELLOW . . . . . . . . . . . . .  	NUMBER	000E	

ZERO_ALL_RAM . . . . . . . . . .  	L NEAR	E5D2	BIOS
ZERO_ALL_RAM_1 . . . . . . . . .  	L NEAR	E5EE	BIOS
ZERO_ALL_START . . . . . . . . .  	L NEAR	E604	BIOS

??0001 . . . . . . . . . . . . .  	L NEAR	E101	BIOS
??0002 . . . . . . . . . . . . .  	L NEAR	E103	BIOS
??0003 . . . . . . . . . . . . .  	L NEAR	E13B	BIOS
??0004 . . . . . . . . . . . . .  	L NEAR	E13D	BIOS
??0005 . . . . . . . . . . . . .  	L NEAR	E14F	BIOS
??0006 . . . . . . . . . . . . .  	L NEAR	E151	BIOS
??0007 . . . . . . . . . . . . .  	L NEAR	E161	BIOS
??0008 . . . . . . . . . . . . .  	L NEAR	E163	BIOS
??0009 . . . . . . . . . . . . .  	L NEAR	E16B	BIOS
??000A . . . . . . . . . . . . .  	L NEAR	E16D	BIOS
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-34


??000B . . . . . . . . . . . . .  	L NEAR	E1B9	BIOS
??000C . . . . . . . . . . . . .  	NUMBER	0030	
??000D . . . . . . . . . . . . .  	NUMBER	0004	
??000E . . . . . . . . . . . . .  	WORD	0010	_BDA
??0010 . . . . . . . . . . . . .  	L NEAR	E37A	BIOS
??0011 . . . . . . . . . . . . .  	L NEAR	E387	BIOS
??0012 . . . . . . . . . . . . .  	L NEAR	E391	BIOS
??0013 . . . . . . . . . . . . .  	NUMBER	00C0	
??0014 . . . . . . . . . . . . .  	NUMBER	0002	
??0015 . . . . . . . . . . . . .  	WORD	0010	_BDA
??0016 . . . . . . . . . . . . .  	L NEAR	E466	BIOS
??0017 . . . . . . . . . . . . .  	NUMBER	0000	
??0018 . . . . . . . . . . . . .  	L NEAR	E4AF	BIOS
??001B . . . . . . . . . . . . .  	L NEAR	E7FA	BIOS
??001D . . . . . . . . . . . . .  	L NEAR	E88C	BIOS
??001E . . . . . . . . . . . . .  	L NEAR	E88E	BIOS
??001F . . . . . . . . . . . . .  	L NEAR	E890	BIOS
??0020 . . . . . . . . . . . . .  	L NEAR	E897	BIOS
??0021 . . . . . . . . . . . . .  	L NEAR	E899	BIOS
??0022 . . . . . . . . . . . . .  	L NEAR	E89B	BIOS
??0023 . . . . . . . . . . . . .  	L NEAR	E8D0	BIOS
??0024 . . . . . . . . . . . . .  	L NEAR	E8D7	BIOS
??0025 . . . . . . . . . . . . .  	NUMBER	0001	
??0029 . . . . . . . . . . . . .  	L NEAR	EF99	BIOS
??002A . . . . . . . . . . . . .  	L NEAR	EFAB	BIOS
??002C . . . . . . . . . . . . .  	L NEAR	F02A	BIOS
??002F . . . . . . . . . . . . .  	NUMBER	0030	
??0030 . . . . . . . . . . . . .  	NUMBER	0004	
??0031 . . . . . . . . . . . . .  	WORD	0010	_BDA
??0032 . . . . . . . . . . . . .  	L NEAR	F37D	BIOS
??0033 . . . . . . . . . . . . .  	L NEAR	F389	BIOS
??0034 . . . . . . . . . . . . .  	L NEAR	F38E	BIOS
??0035 . . . . . . . . . . . . .  	L NEAR	F44E	BIOS
??0036 . . . . . . . . . . . . .  	L NEAR	F45A	BIOS
??0037 . . . . . . . . . . . . .  	L NEAR	F45F	BIOS
??0038 . . . . . . . . . . . . .  	L NEAR	F46C	BIOS
??0039 . . . . . . . . . . . . .  	L NEAR	F478	BIOS
??003A . . . . . . . . . . . . .  	L NEAR	F47D	BIOS
??003B . . . . . . . . . . . . .  	NUMBER	00C0	
??003C . . . . . . . . . . . . .  	NUMBER	0002	
??003D . . . . . . . . . . . . .  	WORD	0011	_BDA
??003E . . . . . . . . . . . . .  	NUMBER	000E	
??003F . . . . . . . . . . . . .  	NUMBER	0001	
??0040 . . . . . . . . . . . . .  	WORD	0011	_BDA
??0042 . . . . . . . . . . . . .  	NUMBER	0001	
@FILENAME  . . . . . . . . . . .  	TEXT  glabios		
_AH  . . . . . . . . . . . . . .  	NUMBER	0004	
_AL  . . . . . . . . . . . . . .  	NUMBER	0000	
_AX  . . . . . . . . . . . . . .  	NUMBER	0008	
_BDA_SEG . . . . . . . . . . . .  	NUMBER	0400	
_BH  . . . . . . . . . . . . . .  	NUMBER	0007	
_BIOS_TOP  . . . . . . . . . . .  	L WORD	E000	_BIOS
_BL  . . . . . . . . . . . . . .  	NUMBER	0003	
_BOOT  . . . . . . . . . . . . .  	L WORD	E05B	_BIOS
_BP  . . . . . . . . . . . . . .  	NUMBER	000D	
Microsoft (R) Macro Assembler Version 5.00                  3/16/25 14:09:08
GLaBIOS                                                     Symbols-35


_BX  . . . . . . . . . . . . . .  	NUMBER	000B	
_CH  . . . . . . . . . . . . . .  	NUMBER	0005	
_CL  . . . . . . . . . . . . . .  	NUMBER	0001	
_CX  . . . . . . . . . . . . . .  	NUMBER	0009	
_DH  . . . . . . . . . . . . . .  	NUMBER	0006	
_DI  . . . . . . . . . . . . . .  	NUMBER	000F	
_DL  . . . . . . . . . . . . . .  	NUMBER	0002	
_DX  . . . . . . . . . . . . . .  	NUMBER	000A	
_FDC_LAST_ST . . . . . . . . . .  	TEXT  [DI][FDC_LAST_ST-FD_LAST_OP]		
_FD_CAL_ST . . . . . . . . . . .  	TEXT  BYTE PTR [DI][FD_CAL_ST-FD_LAST_OP]		
_FD_LAST_OP  . . . . . . . . . .  	TEXT  BYTE PTR [DI]		
_FD_MEDIA_ST . . . . . . . . . .  	TEXT  BYTE PTR [DI][FD_MEDIA_ST-FD_LAST_OP]		
_FD_MOTOR_ST . . . . . . . . . .  	TEXT  BYTE PTR [DI][FD_MOTOR_ST-FD_LAST_OP]		
_FD_TIMER  . . . . . . . . . . .  	TEXT  BYTE PTR [DI][TIMER-FD_LAST_OP]		
_FD_TRACK  . . . . . . . . . . .  	TEXT  BYTE PTR [DI][FD_TRACK-FD_LAST_OP]		
_KB_FLAGS1 . . . . . . . . . . .  	TEXT  BYTE PTR[BX][-1]		
_KB_FLAGS2 . . . . . . . . . . .  	TEXT  BYTE PTR[BX]		
_POWER_ON  . . . . . . . . . . .  	L WORD	FFF0	_BIOS
_SI  . . . . . . . . . . . . . .  	NUMBER	000E	
_SP  . . . . . . . . . . . . . .  	NUMBER	000C	
__POWER_ON . . . . . . . . . . .  	L FAR 	0000	RESET


  12514 Source  Lines
  14299 Total   Lines
   1555 Symbols

  47666 + 322414 Bytes symbol space free

      1 Warning Errors
      0 Severe  Errors
