Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-1


					PAGE	 	59,132 
					TITLE		GLaBIOS 
				 
				;----------------------------------------------------------------------------; 
				; GLaBIOS (General Libraries and Basic Input Output System) 
				; 
				; A scratch-built, open-source 8088 PC/clone BIOS alternative. 
				; 
				; Copyright (c) 2022-2024, 640KB and contributors 
				; 
				;----------------------------------------------------------------------------; 
				; 
				; This program is free software: you can redistribute it and/or modify it under the terms  
				; of the GNU General Public License as published by the Free Software Foundation, either  
				; version 3 of the License, or (at your option) any later version. 
				; 
				; This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;  
				; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
				; See the GNU General Public License for more details. 
				; 
				; You should have received a copy of the GNU General Public License along with this program.  
				; If not, see <https://www.gnu.org/licenses/>. 
				; 
				;----------------------------------------------------------------------------; 
				; References, Credits and Inspiration: 
				; 
				;  https://stanislavs.org/helppc/ 
				;  http://www.minuszerodegrees.net/ 
				;  https://www.felixcloutier.com/x86/ 
				;  https://sites.google.com/site/pcdosretro/ (offline) 
				; 
				;  "Programmer's Guide to the IBM(R) PC", Peter Norton 
				;  "System BIOS for IBM(R) PC/XT(TM)/AT(R) Computers and Compatibles", 
				;	Phoenix Technologies Ltd. 
				;  "Programmer's Guide to PC Video Systems", Second Edition, Wilton 
				;  (Many more inline...) 
				; 
				;  Font bitmaps by "VileR", (CC BY-SA 4.0) 
				;  https://int10h.org/oldschool-pc-fonts/readme/#legal_stuff 
				; 
				;  @Raffzahn, Contributor and Meckerhut. 
				; 
				;  https://github.com/640-KB/GLaBIOS#further-credits-to 
				; 
				;  "Every byte is sacred, every byte is great, 
				;  when a byte is wasted, God gets quite irate..." 
				;  - David W. Plummer 
				;----------------------------------------------------------------------------; 
				; Build Instructions: 
				; 
				; Build with MASM 5.0 or MASM 6. 
				; 
				;  MAKE.BAT 
				; 
				; or 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-2


				; 
				;  MASM GLABIOS; 
				;  LINK GLABIOS; 
				;  GLA2ROM GLABIOS.EXE GLABIOS.ROM		; Build 8K ROM 
				; 
				; MASM Build Options: 
				;  /DVER_DATE='02/22/22'			; Must be MM/DD/YY format 
				;  /DARCH_TYPE='X'				; P, X, Y or T (see ARCH_* below) 
				;  /DCPU_TYPE='8'					; 8 or V (see CPU_* below) 
				; 
				;----------------------------------------------------------------------------; 
				; POST Error Beep messages: 
				; 
				; Short  Long 
				;	2	1	CPU register test failure 
				;	3	1	CPU instruction test failed 
				;	4	1	Build is V20 but not detected 
				;	2	2	System BIOS ROM checksum error 
				;	3	2	PIT counter 1 test failed 
				;	4	2	DMA register test failed 
				;	5	2	PIC test register failed 
				;	5	3	PIC test interrupt failed 
				;	1	3	Base RAM (0-16KB) read/write error 
				;	3	3	Error loading video adapter ROM 
				;	1	4	Base RAM (0-16KB) parity error 
				; 
				;----------------------------------------------------------------------------; 
				 
				;----------------------------------------------------------------------------; 
				; Build Target Architecture equates (do not edit these) 
				; 
 = 0050				ARCH_5150		EQU	'P'			; 5150 
 = 0058				ARCH_5160		EQU	'X'			; 5160 v1 
 = 0059				ARCH_5160v2		EQU	'Y'			; 5160 v2/3 
 = 0054				ARCH_TURBO		EQU	'T'			; Standard Turbo or clone 
 = 0053				ARCH_TD3300		EQU	'S'			; TD3300A (ST-xx/UNIQUE/Auva) 
 = 0046				ARCH_FE2010		EQU	'F'			; Faraday FE2010A 
 = 0048				ARCH_EHB		EQU	'H'			; EMM Computers/Homebrew8088 
 = 0045				ARCH_EMU		EQU	'E'			; 86Box/Emulator 
 = 004D				ARCH_M88		EQU	'M'			; micro_8088/NuXT 
 = 0049				ARCH_MIST		EQU	'I'			; PCXT_MiSTer 
 = 0055				ARCH_UM82		EQU	'U'			; UMC UM82C088 / ALi M1101 
 = 0043				ARCH_MARTY		EQU	'C'			; MartyPC Emulator 
 = 0056				ARCH_VEN888		EQU	'V'			; Vendex 888-XT 
 = 004C				ARCH_LASER		EQU	'L'			; VTech Laser Turbo XT 
 = 0042				ARCH_BOOK88		EQU	'B'			; Book 8088 
 = 0051				ARCH_CPQ		EQU	'Q'			; Compaq Portable XT 
 = 004A				ARCH_VIRTUALXT	EQU	'J'			; VirtualXT Emulator 
				 
				; 
				; CPU Instruction Set Target 
				; 
 = 0038				CPU_8088		EQU	'8'			; 808x compatible 
 = 0056				CPU_V20		EQU	'V'			; V20 only 
				 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-3


				; 
				; Boot to Turbo or Normal Speed 
				; 
 = 0054				BOOT_TURBO		EQU	'T' 
 = 004E				BOOT_NORMAL		EQU	'N' 
 = 004D				BOOT_MEDIUM		EQU	'M'			; used by FE2010A 
				 
				; 
				; Turbo Switch Behavior 
				; 
 = 0000				TURBO_NONE		EQU	0			; fixed clock no turbo switching 
 = 0001				TURBO_STD		EQU	1			; standard PPI (1=turbo, 0=normal) 
 = 0002				TURBO_REV		EQU	2			; reversed PPI (0=turbo, 1=normal) 
				 
				;----------------------------------------------------------------------------; 
				; BIOS Product Info 
				; 
 =				VER_NAME		EQU	'GLaBIOS' 
					ENDIF 
					ENDIF 
 =				COPY_YEAR		EQU	'2022-25'		; Copyright year range 
				 
				;----------------------------------------------------------------------------; 
				; BEGIN Configurable Build Options 
				;----------------------------------------------------------------------------; 
				; Very important note on custom configuration: 
				; 
				; Not all options can be combined due to very limited ROM code space of 8K, 
				; and fitting withing fixed compatibility ORGs. 
				; 
				; For experimenting with build options, it's highly recommended to use 
				; MASM 5.0 as it will not build if code space is exceeded. Due to differences 
				; in MASM 6, this does not work and can produce a totally broken build. 
				;----------------------------------------------------------------------------; 
				 
				;----------------------------------------------------------------------------; 
				; Select Target Architecture Preset 
				; 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Sub Architecture Types (use with the ARCH_TYPE in parentheses) 
				; 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Default CPU Instruction Set Target 
				; 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Turbo Type 
				; 
				; Some motherboards boot in Normal mode by default and the BIOS may or may not 
				; switch to Turbo speed on boot. Others invert this behavior where it appears 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-4


				; reversed to the BIOS. Use these options to customize for your motherboard. 
				; 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; CGA Snow Removal Method 
				; 
 = 0000				CGA_SNOW_REMOVE	=	0		; 0: Snow, Normal Flashing, Fastest 
										; 1: Less Snow, Some Flashing, Medium Fast 
										; 2: No Snow, Moderate Flashing, Fast 
										; 3: No Snow, More Flashing, Quite Fast 
				 
				;----------------------------------------------------------------------------; 
				; Personality Traits 
				; 
 = 0001				POST_THEME		=	1		; color theme for POST screen (see below) 
 = 0000				POST_CLS		=	0		; clear screen after POST 
 = 0000				POST_GLADOS		=	0		; say "Starting GLaDOS..." on boot 
 = 0001				POST_CONFIG		=	1		; show CPU, FPU and ports on POST 
 = 0000				POST_FD_COUNT	=	0		; show floppy drive count on POST 
 = 0000				POST_HD_COUNT	=	0		; show hard drive count and params on POST 
 = 0000				POST_HD_PARMS	=	0		; show hard drive parameters on POST 
 = 0001				POST_OPT_ROM	=	1		; show option ROM address and loading info 
 = 0001				POST_VIDEO_TYPE	=	1		; show the video adapter type on POST 
 = 0001				POST_WARM_COLD	=	1		; show boot WARM or COLD 
 = 0001				POST_BANNER		=	1		; show banner and version 
 = 0000				WARM_ENABLE		=	0		; 1=enable WARM boot or 0=always COLD boot 
 = 0000				RANDOM_TAGLINE	=	0		; randomize pithy tagline 
 = 0000				UNITS_IEC		=	0		; 0=period-correct "KB" or 1=modern IEC "KiB" 
				 
				;----------------------------------------------------------------------------; 
				; Enable/Disable POST tests (not all tests can be enabled due to 8K ROM space) 
				; 
 = 0001				POST_TEST_INST	=	1		; POST CPU Instruction/Flag Test 
 = 0001				POST_TEST_DMA	=	1		; POST DMA Register Test 
 = 0001				POST_TEST_DMA_TC0	=	1		; POST DMA Terminal Count Test 
 = 0001				POST_TEST_PIT_1	=	1		; POST Timer Channel 1 Test 
 = 0001				POST_TEST_PIC_REG	=	1		; POST PIC Register Test 
 = 0001				POST_TEST_PIC_INT	=	1		; POST PIC Interrupt Test 
 = 0000				POST_TEST_CHK_ROM	=	0		; POST Checksum ROM 
 = 0000				POST_TEST_FD	=	0		; POST Floppy Drive Test 
 = 0000				POST_TEST_SEEK	=	0		; POST Seek Floppy Drives 
 = 0001				POST_TEST_KB	=	1		; POST Keyboard Test (PKI) 
 = 0000				POST_TEST_KEY	=	0		; POST Key Test (PKEY) 
				 
				;----------------------------------------------------------------------------; 
				; Advanced Options (may void your warranty) 
				; 
 = 0280				MAX_RAM_PC		EQU	640		; 640K: base 0000-A000 (for EGA/VGA) 
 = 02C0				MAX_RAM_MDA		EQU	704		; 704K: include A000-B000 (for MDA) 
 = 02E0				MAX_RAM_CGA		EQU	736		; 736K: include A000-B800 (for CGA) 
 = 0280				MAX_RAM 		=	MAX_RAM_PC	; Max detectable low RAM (in KB) 
 = 0000				MAX_RAM_AUTO	=	0		; Auto-detect MAX_RAM from video DIP switches 
 = 0012				DRAM_REFRESH	=	18		; DRAM refresh divisor 1.193 MHz/18 = 66,287.87 Hz 
										; 0=Disable refresh (use only with SRAM!) 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-5


 = 0000				RAM_PARITY		=	0		; Enable RAM parity checking 
 = 0000				RAM_TEST_LONG	=	0		; Long RAM test on cold boot 
 = 0003				RAM_DIGITS		=	3		; Number of zero-padded digits for RAM (3 or 4) 
 = 0001				BASIC_ROM		=	1		; BASIC ROM support at 0F600h 
 = FE00				OPT_ROM_END		=	0FE00H	; Option ROM scan ending address (must be xx00) 
 = 0000				FDC_ENABLE		=	0		; Enable INT 13h floppy support 
 = 0000				FDC_IPL_SW		=	0		; Use IPL switch to enable/disable floppy 
 = 0001				FDC_HLT_WAIT	=	1		; Halt CPU during FD access 
										;   Some chipsets (TD3300A known affected) 
										;   hang during floppy access if this is 
										;   enabled 
 = 0001				FDC_ADV_SEEK	=	1		; Advanced floppy seeking performance 
										;   Store current head position in BDA 
										;   to avoid unnecessary seek commands 
 = 0000				FDC_ZERO_BDA	=	0		; clear FDC FIFO buffer between ops 
										;   Some HD ROMs appropriate this memory 
 = 0000				FDC_ERR_SEC_CT	=	0		; On error, 0=always return 0 sectors 
										;   1=return partial/successful sector count 
 = 0000				KB_HLT_WAIT		=	0		; Halt CPU during KB wait 
 = 0000				MBR_CHECK		=	0		; Verify magic number of DOS MBR at boot 
										;   note: DOS 1.0 does not use MBR, so 
										;   will not boot if this is enabled 
 = 0000				POST_HD_CHECK	=	0		; Enable POST HD drive count and size 
										;   note: Some older WD controller ROMs 
										;   (version 62-000043-0xx known affected) 
										;   have bugs where INT 13h function are 
										;   unusable during POST. Set to 0 to 
										;   work around (disables POST_HD_PARMS) 
 = 0000				FD_AUTO_DETECT	=	0		; Auto-detect number of floppy drives 
										;   use only for DIP switch-less PCs! 
 = 0000				POST_ERR_WAIT	=	0		; Wait for Any Key press to continue if 
										;   there is a POST error 
 = 0000				INT_19_BOOT_HD	=	0		; Try IPL to floppy then hard drive (80h) 
 = 00C0				SW1_FLP		=	MASK FLP	; Default max number of floppy drives 
 = 0001				MDA_ATTR		=	1		; Display MDA character attributes 
										; 2=all, 1=intensity only, 0=filter all 
 = 0001				LIGHT_PEN		=	1		; INT 10h,4 light pen support 
 = 0000				EXP_UNIT		=	0		; Init 5161 I/O Expansion Unit 
 = 0000				KB_FILTER_SC	=	0		; Filter KB make/break code >= 70h 
 = 0000				INIT_AT_KBC		=	0		; Init AT type KB controller 
 = 0000				INIT_V40		=	0		; Init V40 config registers 
 = 0000				OEM_FONT		=	0		; 1=use OEM style font, 0=clone style 
 = 0001				POST_CARD		=	1		; enable POST codes on port 80H 
 = 0000				MUTE_TANDY		=	0		; mute buzzing on Tandy 3 Voice 
				 
				;----------------------------------------------------------------------------; 
				; Hardware hacks! 
				; These run your system way out of spec. You have been warned. 
				;----------------------------------------------------------------------------; 
				 
				;----------------------------------------------------------------------------; 
				; UNSAFE_FLOPPY: Reduce floppy drive head settling time for possibly faster 
				; seek access and burst transfer reads. Warning: this may result in drive 
				; read errors on some hardware. 
				; Specify UNSAFE_FLP_DIV as percentage of head settling time, as configured 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-6


				; in DBT. 
				; 
 = 0000				UNSAFE_FLOPPY	=	0		; Use % of specified disk head settle time 
				;UNSAFE_FLP_DIV	EQU	<1/3>		; 33% 
 =				UNSAFE_FLP_DIV	EQU	<3/10>	; 30% 
				;UNSAFE_FLP_DIV	EQU	<1/4>		; 25% 
				 
				;	IF FDC_ADV_SEEK EQ 1 
				;UNSAFE_FLOPPY	=	1		; reduce head settle times with FDC_ADV 
				;UNSAFE_FLP_DIV	EQU	<1/2>		; 50% 
				;	ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; UNSAFE_REFRESH: Lower the amount of time spent in DMA/DRAM refresh state. 
				; Depending on hardware configuration, this may result in significant speed 
				; and performance gains of up to 5 to 10%, or it may result in instability 
				; and parity errors. 
				; 
				; This is similar to programs such as "SPEEDER" or "FASTV20", which lowers 
				; refresh from 1/18 (65K/s) to 1/64 (18K/s) and 1/655 (1.8K/s) respectively. 
				; 
				; https://forum.vcfed.org/index.php?threads/fastv20-com.24005/ 
				; https://www.pcorner.com/list/UTILITY/SPEEDER.ZIP/INFO/ 
				; https://www.reenigne.org/blog/how-to-get-away-with-disabling-dram-refresh/ 
				; https://en.wikipedia.org/wiki/Memory_refresh 
				; 
 = 0000				UNSAFE_REFRESH	=	0		; Use unsafe DRAM refresh timing 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; END Configurable Build Options 
				;----------------------------------------------------------------------------; 
				 
				 
				;----------------------------------------------------------------------------; 
				; ARCH/build-specific configuration 
				;----------------------------------------------------------------------------; 
				; Defaults / BIOS ID Byte 
				; 
				; https://stanislavs.org/helppc/id_bytes.html 
				; 
 = 00FE				ARCH_ID		=	0FEH			; 0xFE=XT v1/clone (default) 
 = 0000				CASSETTE		=	0			; disable cassette (default) 
				 
					ENDIF 
				 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Configuration for 5160 boards 
				; 
					ENDIF 
					IF ARCH_TYPE EQ ARCH_5160 
 = 0000				TURBO_TYPE		=	TURBO_NONE		; disable Turbo features 
 = 0001				FDC_IPL_SW		=	1			; Use IPL SW1 for drive count 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-7


 = 0001				EXP_UNIT		=	1			; enable Expansion Unit 
 = 0001				OEM_FONT		=	1			; use OEM style font 
					ENDIF 
				 
					ENDIF 
				 
					ENDIF 
				 
					ENDIF 
				 
					ENDIF 
				 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Configuration for Book 8088 
				; 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Configuration for Compaq XT (incomplete) 
				; 
					ENDIF 
				 
					ENDIF 
				 
					ENDIF 
				 
					ENDIF 
				 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Boot to normal or turbo speed (if supported) 
				; 
 = 0000				IS_TURBO		=	TURBO_TYPE NE TURBO_NONE	; use for conditionals 
				 
					ELSE 
 =				BOOT_SPEED		EQU	BOOT_NORMAL 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Reconfigure features as needed 
				;----------------------------------------------------------------------------; 
				; If Cassette enabled, some of the following features must be disabled due to 
				; code space limitations. 
				; 
 = 0000				CAS_RELOCATE	=	0			; keep CAS code in contiguous block 
				 
					ENDIF 
				 
					IF POST_HD_CHECK EQ 0 
 = 0000				POST_HD_PARMS	=	0			; disable HD PARM display also 
					ENDIF 
				 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-8


					IF WARM_ENABLE EQ 0 
 = 0000				POST_WARM_COLD	=	0			; disable show boot WARM or COLD 
					ENDIF 
				 
					IF FDC_ENABLE EQ 0 
 = 0000				POST_TEST_SEEK	=	0			; remove test seek code if no floppy 
					ENDIF 
				 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Secret Menu 
				; 
 = 0000				POST_QUIET		=	0			; Quiet POST, show only memory test 
					ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Enable 186 instructions if V20 
				; 
					ENDIF 
				 
				 
				;----------------------------------------------------------------------------; 
				; POST colors and visuals 
				;----------------------------------------------------------------------------; 
				 
				;----------------------------------------------------------------------------; 
				; PC Text Colors 
				; https://stanislavs.org/helppc/colors.html 
				; 
 = 0000				BLACK			EQU	0 
 = 0001				DARKBLUE		EQU	1 
 = 0002				DARKGREEN		EQU	2 
 = 0003				CYAN			EQU	3 
 = 0004				DARKRED		EQU	4 
 = 0005				DARKMAGENTA		EQU	5 
 = 0006				BROWN			EQU	6 
 = 0007				GRAY			EQU	7 
 = 0008				DARKGRAY		EQU	8 
 = 0009				BLUE			EQU	9 
 = 000A				GREEN			EQU	10 
 = 000B				LIGHTCYAN		EQU	11 
 = 000C				RED			EQU	12 
 = 000D				MAGENTA		EQU	13 
 = 000E				YELLOW		EQU	14 
 = 000F				WHITE			EQU	15 
				 
				;----------------------------------------------------------------------------; 
				; Theme My POST Test! 
				; Pick theme from below or roll your own! 
				;----------------------------------------------------------------------------; 
						ELSE 
						ELSE 
				 
				; Theme #1 - "Old skool BBS" (default) 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-9


 =				POST_CLR_TXT	EQU	CYAN 
 =				POST_CLR_VAL1	EQU	GREEN 
 =				POST_CLR_VAL2	EQU	YELLOW 
 =				POST_CLR_COLD	EQU	BLUE 
 =				POST_CLR_WARM	EQU	DARKRED 
 =				POST_CLR_GB		EQU	GRAY 
						ENDIF 
						ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; POST screen column layout options 
				; 
 =				POST_L		EQU	<' [ '>		; left separator string 
 =				POST_R		EQU	<' ]'>		; right separator string 
 = 0002				L_POST_L		EQU	2			; length of separator 
				 
 = 0020				POST_TAB_COL	EQU	32			; horiz tab width for second column 
 = 0007				POST_COL_LBL_W	EQU	7			; column label width 
 = 0004				POST_COL_PAD	EQU	4			; padding (non colored) space between cols 
				 
 = 0006				POST_COL_W		EQU	POST_COL_LBL_W-1	; zero-based column index 
				 
				; column label width plus separator 
 = 0009				POST_COL_VT		EQU	POST_COL_LBL_W + L_POST_L 
				 
				; space between next column 
 = 0013				POST_TAB_COL_I	EQU	POST_TAB_COL - POST_COL_LBL_W - L_POST_L - POST_COL_PAD 
				 
				; prefer period-correct "KB" or IEC "KiB" 
								ELSE 
 =				POST_K_UNIT		EQU	<'KB'>		; KB size unit abbrev. 
 =				POST_M_UNIT		EQU	<'MB'>		; MB size 
								ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Useful CP-437/Control Chars 
				; 
 = 000D				CR 			EQU	0DH 			; Carriage return 
 = 000A				LF 			EQU	0AH 			; Line feed 
 = 0008				BS			EQU	08H			; Backspace ASCII 
 = 0007				BELL			EQU	07H			; BELL ASCII 
 = 0016				SYN			EQU	16H			; SYN C0 control char 
 = 00B3				VL			EQU	0B3H			; vertical line 
 = 00C4				HL			EQU	0C4H			; horizontal line 
 = 00F4				CURL_TOP		EQU	0F4H 
 = 00F5				CURL_BOT		EQU	0F5H 
 = 00F9				BULL			EQU	0F9H			; Bullet operator (medium centered dot) 
 = 00FA				DOT			EQU	0FAH			; Small middle dot 
 = 00FE				SQUARE		EQU	0FEH			; Black square (rectangle) 
 = 0003				HEART			EQU	03H			; faithful companion 
 = 000D				NOTE1			EQU	0DH 
 = 000E				NOTE2			EQU	0EH 
 = 001D				DBLARROW		EQU	01DH 
 = 00AB				HALF			EQU	0ABH			; 1/2 
 = 00AC				QUARTER		EQU	0ACH			; 1/4 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-10


				 
				;----------------------------------------------------------------------------; 
				; Beepin' Tones 
				; PIT delay = 315,000,000 / 264 / freq (Hz) 
				;----------------------------------------------------------------------------; 
 = 11D1				BEEP_C4		EQU	4561			; Middle C4 (261.626 Hz) (4560.65) 
 = 0A98				BEEP_A4		EQU	2712			; A4 (440.000 Hz)   (2711.78) 
 = 0970				BEEP_B4		EQU	2416 			; B4 (493.883 Hz)   (2415.92) 
 = 08E8				BEEP_C5		EQU	2280			; C5 (523.251 Hz)   (2280.32) 
 = 07F0				BEEP_D5		EQU	2032			; D5 (587.329 Hz)   (2031.54) 
 = 0712				BEEP_E5		EQU	1810			; E5 (659.255 Hz)   (1809.89) 
 = 06AC				BEEP_F5		EQU	1708			; F5 (698.456 Hz)   (1708.31) 
 = 05F2				BEEP_G5		EQU	1522			; G5 (783.991 Hz)   (1521.93) 
 = 054C				BEEP_A5		EQU	1356			; A5 (880.000 Hz)   (1355.89) 
 = 04B8				BEEP_B5		EQU	1208			; B5 (987.766 Hz)   (1207.96) 
 = 0474				BEEP_C6		EQU	1140			; C6 (1046.50 Hz)   (1140.16) 
 = 04A9				BEEP_1K		EQU	1193			; ~1 KHz tone       (1193.18) 
 = 04A0				BEEP_1K7		EQU	1184			; ~1007 Hz (cassette 1 bit) 
 = 0250				BEEP_2K		EQU	BEEP_1K7 / 2	; ~2015 Hz (cassette 0 bit) 
				 
 =				BEEP_DEFAULT	EQU	BEEP_A5		; default beep 
 =				BEEP_ERR_HIGH	EQU	BEEP_F5		; perfect fourth apart for 
 =				BEEP_ERR_LOW	EQU	BEEP_C5		;  alternating error beeps 
				 
				;----------------------------------------------------------------------------; 
				; PC ISA (Instruction Set Architecture) I/O Port Addresses 
				;----------------------------------------------------------------------------; 
				 
				; 8237A DMA Controller 
 = 0000				DMA_0_A		EQU	00H 			; W   Start Address Register channel 0 
 = 0001				DMA_0_C		EQU	01H			; W   Count Register channel 0 
 = 0002				DMA_1_A		EQU	02H			; W   Start Address Register channel 1 
 = 0003				DMA_1_C		EQU	03H			; W   Count Register channel 1 
 = 0004				DMA_2_A		EQU	04H			; W   Start Address Register channel 2 
 = 0005				DMA_2_C		EQU	05H			; W   Count Register channel 2 
 = 0006				DMA_3_A		EQU	06H			; W   Start Address Register channel 3 
 = 0007				DMA_3_C		EQU	07H			; W   Count Register channel 3 
 = 0008				DMA_CMD		EQU	08H			; RW  Status / Command Register 
 = 0009				DMA_REQ		EQU	09H			; W   Request Register 
 = 000A				DMA_MASK		EQU	0AH 			; W   Single Channel Mask Register 
 = 000B				DMA_MODE		EQU	0BH 			; W   Mode Register 
 = 000C				DMA_FF		EQU	0CH 			; W   Flip-Flop Reset Register 
 = 000D				DMA_RESET		EQU	0DH 			; W   Master Reset Register (Mask bits ON) 
 = 000E				DMA_MASKR		EQU	0EH 			; W   Mask Reset Register (Mask bits OFF) 
 = 000F				DMA_MMASK		EQU	0FH 			; RW  MultiChannel Mask Register 
				 
				; DMA Page Registers (74LS670) 
 = 0087				DMA_P_C0		EQU	87H			; DMA Channel (unused on PC) 
 = 0083				DMA_P_C1		EQU	83H			; DMA Channel 0 and 1 
 = 0081				DMA_P_C2		EQU	81H			; DMA Channel 2 
 = 0082				DMA_P_C3		EQU	82H			; DMA Channel 3 
				 
				; 8259 PIC Interrupt Controller 
 = 0020				INT_P0		EQU	20H 			; Port 0 
 = 0021				INT_IMR		EQU	21H 			; Port 1 - OCW1 Interrupt Mask Register 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-11


				 
				; 8253 PIT Timer 
 = 0040				PIT_CH0		EQU	40H			; Timer Channel/Counter 0 
 = 0041				PIT_CH1		EQU	41H			; Timer Channel/Counter 1 
 = 0042				PIT_CH2		EQU	42H			; Timer Channel/Counter 2 - Speaker 
 = 0043				PIT_CTRL		EQU	43H			; Timer Control Word 
				 
				; 8255 PPI Peripheral Interface 
 = 0060				PPI_A			EQU	60H			; PPI (8255) Port A IN  - Keyboard input 
 = 0061				PPI_B			EQU	61H			; PPI (8255) Port B OUT - Speaker, Switch se
				lection, Misc 
 = 0062				PPI_C			EQU	62H			; PPI (8255) Port C IN  - Switches 
 = 0063				PPI_CW		EQU	63H			; PPI (8255) Port Control Word 
				 
				; 8042 (AT) Keyboard Controller 
 = 0060				ATKB_IO		EQU	60H			; 8042 Keyboard input/output buffer register 
 = 0064				ATKB_CMD		EQU	64H			; 8042 Keyboard command/status register 
				 
				; POST TEST card I/O 
 = 0080				POST_CARD_PORT	EQU	80H			; can be 60H, 80H, 300H, 313H 
				 
				; TD3300A (ST-xx/UNIQUE/Auva) Control Registers (90h) 
 = 0070				TD_WS			EQU	70H			; RAM, I/O wait state control 
 = 0090				TD_TURBO		EQU	90H			; Write 2 for Turbo, 3 for Normal 
 = 00E0				TD_MEM		EQU	0E0H			; Memory bank switch 
				 
				; UM82C088 Speed / Status registers 
 = 00C0				UM82_SPEED		EQU	0C0H			; write any value to toggle speed mode 
 = 00E0				UM82_STATUS		EQU	0E0H			; read memory size, speed mode 
				 
				; VTech Laser Turbo XT 
 = 01F0				LASER_TURBO		EQU	1F0H			; CPU speed control port: only bit 7 used 
				 
				; NMI flip/flop 
 = 00A0				NMI_R0		EQU	0A0H			; NMI Mask Register 
				 
				; Joystick / Game Port 
 = 0201				GAME_CTRL		EQU	0201H			; Game Port 
				 
				; 5161 Expansion Unit Port 
 = 0213				EXP_UNIT_CTRL	EQU	0213H			; Extender Card Control Port 
				 
				; Hard Disk Controller 
 = 0320				HDC_READ		EQU	0320H			; Read from/Write to controller 
 = 0321				HDC_CTRL		EQU	0321H			; Read: Controller Status, Write: controller
				 reset 
 = 0322				HDC_PULSE		EQU	0322H			; Write: generate controller select pulse 
 = 0323				HDC_DMA		EQU	0323H			; Write: Pattern to DMA and interrupt mask register 
 = 0324				HDC_STAT		EQU	0324H			; disk attention/status 
				 
				; Video 6845 CRT Controller 
 = 03B8				MDA_CTRL		EQU	03B8H			; MDA CRT Control Port 1 
 = 03BA				MDA_STAT		EQU	03BAH			; MDA Status Register 
 = 03BB				MDA_PEN_RST		EQU	03BBH			; CGA light pen strobe reset 
 = 03D4				CGA_IDX		EQU	03D4H			; CGA Mode Select Register 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-12


 = 03D5				CGA_DATA		EQU	03D5H			; CGA Mode Data Register 
 = 03D8				CGA_CTRL		EQU	03D8H			; CGA Mode Control Register 
 = 03D9				CGA_COLOR		EQU	03D9H			; CGA Color Select register 
 = 03DA				CGA_STAT		EQU	03DAH			; CGA Status Register (R) 
 = 03DB				CGA_PEN_RST		EQU	03DBH			; CGA light pen strobe reset (W) 
				 
				; Serial (COM) ports 
 = 03F8				COM1_DATA		EQU	03F8H 		; 03F8H: TX/RX Buffer, Divisor LSB (RW) 
 = 03F9				COM1_IER		EQU	COM1_DATA+1		; 03F9H: Interrupt Enable Register, Divisor 
				MSB (RW) 
 = 03FA				COM1_IIR		EQU	COM1_DATA+2		; 03FAH: Interrupt Identification Register (
				R) 
 = 03FB				COM1_LCR		EQU	COM1_DATA+3		; 03FBH: Line Control Register (RW) 
 = 03FC				COM1_MCR		EQU	COM1_DATA+4		; 03FCH: Modem Control Register (RW) 
 = 03FD				COM1_LSR		EQU	COM1_DATA+5		; 03FDH: Line Status Register (R) 
 = 03FE				COM1_MSR		EQU	COM1_DATA+6		; 03FEH: Modem Status Register (R) 
 = 03FF				COM1_SPR		EQU	COM1_DATA+7		; 03FFH: Scratch Pad Register (RW) 
 = 02F8				COM2_DATA		EQU	COM1_DATA-100H	; 02F8H: TX/RX Buffer, Divisor LSB (RW) 
 = 02FA				COM2_IIR		EQU	COM2_DATA+2		; 02FAH: Interrupt Identification Register (
				R) 
 = 03E8				COM3_DATA		EQU	COM2_DATA+0F0H	; 03E8H: TX/RX Buffer, Divisor LSB (RW) 
 = 03EA				COM3_IIR		EQU	COM3_DATA+2		; 03FAH: Interrupt Identification Register (
				R) 
 = 02E8				COM4_DATA		EQU	COM3_DATA-100H	; 02E8H: TX/RX Buffer, Divisor LSB (RW) 
 = 02EA				COM4_IIR		EQU	COM4_DATA+2		; 02EAH: Interrupt Identification Register (
				R) 
				 
				; Parallel (LPT) ports 
 = 03BC				LPT_MDA		EQU	03BCH			; LPT1 data port (MDA) 
 = 0378				LPT1			EQU	0378H			; LPT1 data port (I/O) 
 = 0278				LPT2			EQU	0278H			; LPT2 data port (I/O) 
				 
				; Default LPT/COM I/O timeouts (# of 64K LOOPs) 
 = 0014				LPT_TO		EQU	20			; LPT default timeout 
 = 0001				COM_TO		EQU	1			; COM default timeout 
				 
				; V40 Control Registers 
 = FFF6				V40_WCR2		EQU	0FFF6H		; WCU Wait Cycle 2 Register 
 = FFF5				V40_WCR1		EQU	0FFF5H		; WCU Wait Cycle 1 Register 
				 
				;----------------------------------------------------------------------------; 
				; FDC (NEC PD765x) Controller  
				; 
				 
				; Floppy Disk Controller Ports 
 = 03F0				FDC_A_STAT		EQU	03F0H			; Diskette controller status A 
 = 03F1				FDC_B_STAT		EQU	03F1H			; Diskette controller status B 
 = 03F2				FDC_CTRL		EQU	03F2H			; FD controller control port 
 = 03F4				FDC_STAT		EQU	03F4H			; FD controller status register 
 = 03F5				FDC_DATA		EQU	03F5H			; data register (write 1-9 byte command, see
				 INT 13) 
				 
				; FDC Commands 
 = 0002				FDC_CMD_RTRK	EQU	00000010B		; 02H: Read Track (Diagnostic) 
 = 0003				FDC_CMD_SPEC 	EQU	00000011B		; 03H: Specify Step & Head Load 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-13


 = 0004				FDC_CMD_STAT 	EQU	00000100B		; 04H: Sense Drive Status 
 = 0005				FDC_CMD_WR		EQU	00000101B		; 05H: Write Sector 
 = 0006				FDC_CMD_RD		EQU	00000110B		; 06H: Read Sector 
 = 0007				FDC_CMD_RECAL	EQU	00000111B		; 07H: Recalibrate 
 = 0008				FDC_CMD_SENSE	EQU	00001000B		; 08H: Sense Interrupt Status 
 = 0009				FDC_CMD_WDEL	EQU	00001001B		; 09H: Write Deleted Sector 
 = 000A				FDC_CMD_RSID	EQU	00001010B		; 0AH: Read Sector ID 
 = 000C				FDC_CMD_RDEL	EQU	00001100B		; 0CH: Read Deleted Sector 
 = 000D				FDC_CMD_FMT		EQU	00001101B		; 0DH: Format Track 
 = 000F				FDC_CMD_SEEK	EQU	00001111B		; 0FH: Seek 
				 
				; BDA INT 13H Status Flags  
				; https://stanislavs.org/helppc/int_13-1.html 
 = 0000				FDC_ST_OK		EQU	00H			; No error 
 = 0001				FDC_ST_BADCMD	EQU	01H			; Bad command passed to driver 
 = 0002				FDC_ST_ERR_MARK	EQU	02H			; Address mark not found or bad sector 
 = 0003				FDC_ST_ERR_WP	EQU	03H			; Write Protect Error 
 = 0004				FDC_ST_ERR_SEC	EQU	04H			; Sector not found 
 = 0006				FDC_ST_DISK_CHG	EQU	06H			; diskette changed or removed 
 = 0008				FDC_ST_DMA_OVR	EQU	08H			; DMA overrun 
 = 0009				FDC_ST_DMA_64K	EQU 	09H			; DMA access across 64k boundary 
 = 000C				FDC_ST_ERR_MED	EQU	0CH			; Invalid media type 
 = 0010				FDC_ST_ERR_CRC	EQU	10H			; ECC/CRC error on disk read 
 = 0020				FDC_ST_ERR_FDC	EQU	20H			; Controller error 
 = 0040				FDC_ST_ERR_SEEK	EQU	40H			; Seek failure 
 = 0080				FDC_ST_TIMEOUT	EQU	80H 			; Time out, drive not ready 
 = 00FF				FDC_ST_SENSE	EQU	0FFH 			; Sense operation failed 
				 
				; Trivial RAM / data patterns 
 = 95A5				RAM_TEST_1		EQU 	1001010110100101B	; Simple RAM test 095A5H 
 = 731D				RAM_TEST_2		EQU 	0111001100011101B	; Alternate RAM test 0731DH 
 = 731D				RAM_TEST		=	RAM_TEST_2		; pick one 
 = AA55				MAGIC_WORD		EQU	0AA55H		; Magic Word used for option ROM, IPL device 
				 
				; Warm Boot Flag options set in BDA 40:72H 
 = 0000				COLD_BOOT		EQU	0			; Cold Boot - All POST tests 
 = 1234				WARM_BOOT		EQU	1234H			; Warm Boot - Skip some POST tests 
 = 4321				WARM_BOOT_MEM	EQU	4321H			; Warm Boot - Preserve memory 
 = 5678				WARM_BOOT_SUS	EQU	5678H			; Warm Boot - System suspend 
 = 9ABC				WARM_BOOT_TEST	EQU	9ABCH			; Warm Boot - Manufacturer test 
				 
				; Video Related 
 = 0050				VID_DEF_COLS	EQU	80			; standard video mode columns 
 = 0018				VID_DEF_ROWS	EQU	24			; standard video mode rows 
 = 0020				VID_SP		EQU	' '			; fill byte for blank video RAM char 
				 
				 
				;============================================================================; 
				; 
				; 			   * * *   S T R U C T S   * * * 
				; 
				;============================================================================; 
				 
				;----------------------------------------------------------------------------; 
				; BDA Timer Counters (6CH-70H) 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-14


				;----------------------------------------------------------------------------; 
				TIMER_C STRUC 
 0000  ????			LW		DW	?	; 6CH  Timer Counter Low Word (ticks) 
 0002  ????			HW	  	DW	? 	; 6EH  Timer Counter High Word (hours) 
 0004  ??			OF 		DB	? 	; 70H  Timer Overflow flag 
 0005				TIMER_C ENDS 
				 
				;----------------------------------------------------------------------------; 
				; INT 1E Disk Initialization Parameter Table Vector 
				; 
				; https://stanislavs.org/helppc/dbt.html 
				;----------------------------------------------------------------------------; 
				DBT	STRUC 
 0000  ??			SRT		DB	? 	; 00 step-rate time SRT (0CH), head unload time HUT (0FH) 
 0001  ??			HLT_ND	DB	? 	; 01 head load time HLT (01H), DMA mode ND (0) 
 0002  ??			FMCT		DB	? 	; 02 timer ticks to wait before disk motor shutoff 
 0003  ??			FBPS		DB	? 	; 03 bytes per sector (0=128, 1=256, 2=512, 3=1024) 
 0004  ??			SPT		DB	? 	; 04 sectors per track (last sector number) 
 0005  ??			SGAP		DB	? 	; 05 inter-block gap length/gap between sectors 
 0006  ??			LSEC		DB	? 	; 06 data length, if sector length not specified 
 0007  ??			FGAP		DB	? 	; 07 gap length between sectors for format 
 0008  ??			FFILL		DB	? 	; 08 fill byte for formatted sectors 
 0009  ??			HDST		DB	? 	; 09 head settle time in milliseconds 
 000A  ??			FMST		DB	? 	; 0A motor startup time in eighths of a second 
 000B				DBT	ENDS 
				 
				;----------------------------------------------------------------------------; 
				; FDC Command Status Bytes (FDC_LAST_ST) 
				;----------------------------------------------------------------------------; 
				FDC_CSB STRUC 
 0000  ??			SB0		DB	?	; 00 - status register 0 
 0001  ??			SB1		DB	?	; 01 - status register 1 
 0002  ??			SB2		DB	?	; 02 - status register 2 
 0003  ??			CYL		DB	?	; 03 - cylinder number 
 0004  ??			HEAD		DB	?	; 04 - head number 
 0005  ??			SEC		DB	?	; 05 - sector number 
 0006  ??			BPS		DB	?	; 06 - bytes per sector 
 0007				FDC_CSB ENDS 
				 
				;----------------------------------------------------------------------------; 
				; INT 1D Video Initialization Parameter Table Vector (CRTC) 
				; 
				; https://stanislavs.org/helppc/6845.html 
				;----------------------------------------------------------------------------; 
				CRTC	STRUC 
 0000  ??			H_TC		DB	?	; 00 - Horiz. total characters 
 0001  ??			H_CL		DB	?	; 01 - Horiz. displayed characters per line 
 0002  ??			H_SP		DB	?	; 02 - Horiz. synch position 
 0003  ??			H_SW		DB	?	; 03 - Horiz. synch width in characters 
 0004  ??			V_TL		DB	?	; 04 - Vert. total lines 
 0005  ??			V_SL		DB	?	; 05 - Vert. total adjust (scan lines) 
 0006  ??			V_DR		DB	?	; 06 - Vert. displayed rows 
 0007  ??			V_SP		DB	?	; 07 - Vert. synch position (character rows) 
 0008  ??			IL		DB	?	; 08 - Interlace mode 
 0009  ??			MSL		DB	?	; 09 - Maximum scan line address 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-15


 000A  ??			CSL		DB	?	; 0A - Cursor start (scan line) 
 000B  ??			CEL		DB	?	; 0B - Cursor end (scan line) 
 000C  00			SA_H		DB	0	; 0C - Start address (MSB) 
 000D  00			SA_L		DB	0	; 0D - Start address (LSB) 
 000E  00			CA_H		DB	0	; 0E - Cursor address (MSB) (read/write) 
 000F  00			CA_L		DB	0	; 0F - Cursor address (LSB) (read/write) 
 0010				CRTC	ENDS 
				 
				;============================================================================; 
				; 
				; 			   * * *   R E C O R D S   * * * 
				; 
				;============================================================================; 
				 
				;----------------------------------------------------------------------------; 
				; Define Nibbles to Byte 
				; Convert two nibbles to byte (big endian) 
				;----------------------------------------------------------------------------; 
				DNB	RECORD	HBN:4, LBN:4 
				 
				;----------------------------------------------------------------------------; 
				; Define Bytes to Word 
				; Convert two bytes to word (big endian) 
				;----------------------------------------------------------------------------; 
				DBW	RECORD	HWB:8, LWB:8 
				 
				;----------------------------------------------------------------------------; 
				; Convert KiB to Bytes ( K * 1024 ) 
				;----------------------------------------------------------------------------; 
				KB	RECORD	KBK:6, KBS:10 
				 
				;----------------------------------------------------------------------------; 
				; Convert KiB to Words ( K * 1024 / 2 ) 
				;----------------------------------------------------------------------------; 
				KBW	RECORD	KBWK:7, KBWS:9 
				 
				;----------------------------------------------------------------------------; 
				; Convert KiB to Paragraphs ( K * 1024 / 16 ) 
				;----------------------------------------------------------------------------; 
				KBP	RECORD	KBPK:10, KBPS:6 
				 
				;----------------------------------------------------------------------------; 
				; Convert Word to Paragraphs ( K SHL 4 ) 
				;----------------------------------------------------------------------------; 
				KP	RECORD	KPWP:12, KPWPX:4 
				 
				;----------------------------------------------------------------------------; 
				; x86 EFLAGS 
				;----------------------------------------------------------------------------; 
				EFLAGS86	RECORD FSF:1,FZF:1,FR1:1,FAF:1,FR2:1,FPF:1,FR3:1=1,FCF:1 
				 
				;----------------------------------------------------------------------------; 
				; BDA Equipment Flags (40:10H) 
				;----------------------------------------------------------------------------; 
				; 00      |			- LPT : # of LPT ports 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-16


				;   x     |			- X1  :  unused, PS/2 internal modem 
				;    0    |			- GAM : Game port present 
				;     000 |			- COM : # of COM ports present 
				;        0| 		- DMA : DMA (should always be 0) 
				;         |00	 	- FLP : Floppy drives present (+1) (0=1 drive,1=2,etc) 
				;         |  00		- VID : Video mode (00=EGA/VGA, 01=CGA 40x25, 
				; 				-	10=CGA 80x25, 11=MDA 80x25) 
				;         |    11 	- MBRAM: MB RAM (00=64K, 01=128K, 10=192K, 11=256K+) 
				;         |      0	- FPU : FPU installed 
				;         |       1	- IPL : Floppy drive(s) installed (always 1 on 5160) 
				;----------------------------------------------------------------------------; 
								ELSE 
				EQFLAGS RECORD	LPT:2,X1:1,GAM:1,COM:3,DMA:1,FLP:2,VID:2,MBRAM:2=11b,FPU:1,IPL:1=0 
								ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Video Card (VID) DIP switch settings (bits 4-5) 
				; 
 = 0000				VID_ROM	EQU	00b		; OFF/OFF:	EGA/VGA/Option ROM 
 = 0001				VID_CGA40	EQU	01b		; OFF/ON:	CGA 40 column 
 = 0002				VID_CGA80	EQU	10b		; ON/OFF:	CGA 80 column 
 = 0003				VID_MDA	EQU	11b		; ON/ON:	MDA 
				 
				;----------------------------------------------------------------------------; 
				; GLaBIOS Equipment Flags (40:12H) 
				;----------------------------------------------------------------------------; 
				; 76543210 
				; xxxx    |			- TBD		Reserved 
				;     x   |			- TURBO	Turbo supported 
				;      x  |			- V20		1 if V20, 0 if 8088 
				;       xx|			- TBD		Reserved 
				; 84218421 
				;----------------------------------------------------------------------------; 
				GFLAGS RECORD	GTBD1:4,TURBO:1,V20:1,GTBD2:2 
				 
				;----------------------------------------------------------------------------; 
				; POST status flags are stored in BP 
				;----------------------------------------------------------------------------; 
				; BP: 
				; 76543210 
				; x 	    |			- WARM  	Warm Boot flag 
				;  x 	    |			- PKI   	POST Keyboard Interrupt Received 
				;   x     |			- PKEY  	Keyboard key stuck 
				;    x    |			- PFDC  	FDC init failure 
				;     x   |			- PFSK  	FDC seek test failure 
				;      x  |			- PDMA  	DMA error 
				;       x |			- PMEM  	Memory Error 
				;        x|			- PFXX  	Reserved (do not use) 
				;         |xxxxxx		- TBD 
				;         |      xx	- GRND	Random number for tagline 
				; 84218421 
				;----------------------------------------------------------------------------; 
				PFLAGS RECORD WARM:1,PKI:1,PKEY:1,PFDC:1,PFSK:1,PDMA:1,PMEM:1,PFXX:1,PTBD:6,GRND:2 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-17


				; BDA Keyboard Flags 
				;----------------------------------------------------------------------------; 
				; 40:17	Keyboard Flags Byte 1 (Low) 
				;----------------------------------------------------------------------------; 
				;          84218421 
				; 	    |7 	    	- K1IN	insert is active 
				; 	    | 6 	    	- K1CL	caps-lock is active 
				; 	    |  5	    	- K1NL	num-lock is active 
				; 	    |   4    	- K1SL	scroll-lock is active 
				; 	    |    3   	- K1AL	ALT key depressed 
				; 	    |     2  	- K1CT	CTRL key depressed 
				; 	    |      1 	- K1LS	left shift key depressed 
				; 	    |       0	- K1RS	right shift key depressed 
				;----------------------------------------------------------------------------; 
				KBFLAGS1 RECORD	K1IN:1,K1CL:1,K1NL:1,K1SL:1,K1AL:1,K1CT:1,K1LS:1,K1RS:1 
				 
				;----------------------------------------------------------------------------; 
				; 40:18	Keyboard Flags Byte 2 (High) 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |			- K2IN	insert key is depressed 
				;  6 	    |			- K2CL	caps-lock key is depressed 
				;   5	    |			- K2NL	num-lock key is depressed 
				;    4    |			- K2SL	scroll lock key is depressed 
				;     3   |			- K2PA	pause (Ctrl-NumLock) is active 
				;      2  |			- K2SY	system key depressed and held 
				;       1 |			- K2LA	left ALT key depressed 
				;        0|			- K2LC	left CTRL key depressed 
				;----------------------------------------------------------------------------; 
				KBFLAGS2 RECORD	K2IN:1,K2CL:1,K2NL:1,K2SL:1,K2PA:1,K2SY:1,K2LA:1,K2LC:1 
				 
				;----------------------------------------------------------------------------; 
				; BDA Keyboard Flags - Enhanced 
				;----------------------------------------------------------------------------; 
				; 40:96	Keyboard mode/type 
				;----------------------------------------------------------------------------; 
				;          84218421 
				; 	    |7 	    	- KERD	read ID in process 
				; 	    | 6 	    	- KEFI	last char was first ID char 
				; 	    |  5	    	- KENL	force num-lock if Rd ID & KBX 
				; 	    |   4    	- KEEN	101/102 enhanced keyboard installed 
				; 	    |    3   	- KERA	right ALT key depressed 
				; 	    |     2  	- KERC	right CTRL key depressed 
				; 	    |      1 	- KEE0	last code was the E0 hidden code 
				; 	    |       0	- KEE1	last code was the E1 hidden code 
				;----------------------------------------------------------------------------; 
				KBFLAGS3 RECORD	KERD:1,KEFI:1,KENL:1,KEEN:1,KERA:1,KERC:1,KEE0:1,KEE1:1 
				 
				;----------------------------------------------------------------------------; 
				; 40:97	Keyboard LED flags 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |			- KLTE	keyboard transmit error flag 
				;  6 	    |			- KLMU	mode indicator update 
				;   5	    |			- KLRF	re-send received flag 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-18


				;    4    |			- KLAK	ACK received 
				;     3   |			- KLCI	circus system indicator 
				;      2  |			- KLCL	caps-lock indicator 
				;       1 |			- KLNL	num-lock indicator 
				;        0|			- KLSL	scroll lock indicator 
				;----------------------------------------------------------------------------; 
				KBFLAGS4 RECORD	KLTE:1,KLMU:1,KLRF:1,KLAK:1,KLCI:1,KLCL:1,KLNL:1,KLSL:1 
				 
				;----------------------------------------------------------------------------; 
				; 40:71	BIOS Keyboard Break (BIOS_BREAK) 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |			- KBRK	1=break active 
				;  654321 |			- KBRX	unused 
				;----------------------------------------------------------------------------; 
				KBBRK	RECORD	KBRK:1,KBRX:7 
				 
				;----------------------------------------------------------------------------; 
				; FDC BDA Status Flags 
				;----------------------------------------------------------------------------; 
				; 40:3E	FD_CAL_ST	Drive recalibration status flags 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |			- FWIF	1=working interrupt flag 
				;  654    |			- FSTBD	unused 
				;     3   |			- FCAL3	1=recalibrate drive 3 
				;      2  |			- FCAL2	1=recalibrate drive 2 
				;       1 |			- FCAL1	1=recalibrate drive 1 
				;        0|			- FCAL0	1=recalibrate drive 0 
				;----------------------------------------------------------------------------; 
				FDC_SF RECORD	FWIF:1,FSTBD:3,FCAL3:1,FCAL2:1,FCAL1:1,FCAL0:1 
				 
				;----------------------------------------------------------------------------; 
				; 40:3F	FD_MOTOR_ST	Diskette motor status flags 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |			- FWRT	1=write operation 
				;  654    |			- FMTBD	unused 
				;     3210|			- FMOT	1=drive 3 motor on 
				;----------------------------------------------------------------------------; 
				FDC_MF RECORD	FWRT:1,FMTBD:3,FMOT:4 
				 
				;----------------------------------------------------------------------------; 
				; 40:3F	FD_MOTOR_ST	Diskette motor status flags - separated drives 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7654    |			- FMOTX	unused 
				;     3   |			- FMOT3	1=drive 3 on 
				;      2  |			- FMOT2	1=drive 2 on 
				;       1 |			- FMOT1	1=drive 1 on 
				;        0|			- FMOT0	1=drive 0 on 
				;----------------------------------------------------------------------------; 
				FDC_MFD RECORD	FMOTX:4,FMOT3:1,FMOT2:1,FMOT1:1,FMOT0:1 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-19


				; 40:8F	FD_MODE	Floppy drive mode 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |			- FM1X	unused 
				;  6      |			- FM1D	1=drive 1 determined 
				;   5     |			- FM1M	1=drive 1 supports multiple data rates 
				;    4    |			- FM18	1=drive 1 supports 80-track 
				;     3   |			- FM0X	unused 
				;      2  |			- FM0D	1=drive 0 determined 
				;       1 |			- FM0M	1=drive 0 supports multiple data rates 
				;        0|			- FM08	1=drive 0 supports 80-track 
				;----------------------------------------------------------------------------; 
				FDC_MODE RECORD	FM1X:1,FM1D:1,FM1M:1,FM18:1,FM0X:1,FM0D:1,FM0M:1,FM08:1 
				 
				;----------------------------------------------------------------------------; 
				; 40:90H-93H	Floppy drive media state (drives 0-3) 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 76      |			- FSR		data xfr rate in Kb/s (0=500,1=300,2=250) 
				;   5     |			- FDDS	1=dub step required 
				;    4    |			- FSE		1=media established 
				;     3   |			- FSX		unused 
				;      210|			- FSD		(see below) 
				;----------------------------------------------------------------------------; 
				; FSD values: 
				;	0 = 360K disk/360K drive not established 
				;	1 = 360K disk/1.2M drive not established 
				;	2 = 1.2M disk/1.2M drive not established 
				;	3 = 360K disk/360K drive established 
				;	4 = 360K disk/1.2M drive established 
				;	5 = 1.2M disk/1.2M drive established 
				;	6 = reserved 
				;	7 = none of the above 
				;----------------------------------------------------------------------------; 
				FDC_STATE RECORD	FSR:2,FDDS:1,FSE:1,FDX:1,FSD:3 
				 
				;----------------------------------------------------------------------------; 
				; FDC Digital Output Register at 3F2h (write only) 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |			- FDMD	1 = turn floppy drive D motor on 
				;  6      |			- FDMC	1 = turn floppy drive C motor on 
				;   5     |			- FDMB	1 = turn floppy drive B motor on 
				;    4    |			- FDMA	1 = turn floppy drive A motor on 
				;     3   |			- FDDMA	1 = DMA & I/O interface enabled 
				;      2  |			- FDCEN	1 = FDC enable, 0 = hold FDC at reset 
				;       10|			- FDDRV	floppy drive select (0=A, 1=B, 2=C, 3=D) 
				;----------------------------------------------------------------------------; 
				FDC_DOR RECORD	FDMD:1,FDMC:1,FDMB:1,FDMA:1,FDDMA:1,FDCEN:1,FDSEL:2 
				 
				;----------------------------------------------------------------------------; 
				; FDC 765 Status Flags 
				;----------------------------------------------------------------------------; 
				; FDC Main Status Register at 3F4h (read only) 
				; 84218421 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-20


				; 7 	    |			- FDRR	data reg ready for I/O to/from CPU 
				;  6      |			- FIOD	I/O direction; 1=FDC to CPU; 0=CPU to FDC 
				;   5     |			- FDND	FDC is in non-DMA mode 
				;    4    |			- FDRW	FDC read or write command in progress 
				;     3   |			- F3SK	floppy drive 3 in seek mode/busy 
				;      2  |			- F2SK	floppy drive 2 in seek mode/busy 
				;       1 |			- F1SK	floppy drive 1 in seek mode/busy 
				;        0|			- F0SK	floppy drive 0 in seek mode/busy 
				;----------------------------------------------------------------------------; 
				FDC_MSR RECORD	FDRR:1,FIOD:1,FDND:1,FDRW:1,F3SK:1,F2SK:1,F1SK:1,F0SK:1 
				 
				;----------------------------------------------------------------------------; 
				; FDC Command Status Register 0 at 3F5h 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 76	    |			- ST0CS	last command status (see below) 
				;   5     |			- ST0SK	set to 1 when FDD completes a seek command 
				;    4    |			- ST0CHK	equipment check (see note) 
				;     3   |			- ST0NR	not ready on read/write or SS access to head 1 
				;      2  |			- ST0HD	head number at interrupt (head 0 or 1) 
				;       10|			- ST0DRV	unit selected at interrupt (0=A, 1=B, 2=...) 
				;----------------------------------------------------------------------------; 
				; Bits 
				;	 76  Last Command Status 
				;	 00  command terminated successfully 
				;	 01  command execution started but terminated abnormally 
				;	 10  invalid command issued 
				;	 11  command terminated abnormally due to a change in state of 
				;	     the Ready Signal from the FDC  (reserved on PS/2) 
				; 
				;	- equipment check can occur if FDD signals a fault or track zero is 
				;	  not found after 77 steps on a recalibrate command 
				;----------------------------------------------------------------------------; 
				FDC_ST0 RECORD	ST0CS:2,ST0SK:1,ST0CHK:1,ST0NR:1,ST0HD:1,ST0DRV:2 
				 
				;----------------------------------------------------------------------------; 
				; FDC Command Byte 0 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7       |			- FC0MT	MT = Multi-Track 
				;  6      |			- FC0MF	MF = MFM mode 
				;   5     |			- FC0SK	SK = SKip Deleted-data address mark 
				;    43210|			- FC0CMD	FDC command number 
				;----------------------------------------------------------------------------; 
				FDC_CB RECORD	FC0MT:1,FC0MF:1=1,FC0SK:1,FC0CMD:5 
				 
				;----------------------------------------------------------------------------; 
				; FDC Command Byte 1 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 76543   |			- FC1X	unused 
				;      2  |			- FC1HD	head (0-1) 
				;       10|			- FC1DS	drive (0-3) 
				;----------------------------------------------------------------------------; 
				FDC_CB1 RECORD	FC1X:5,FC1HD:1,FC1DS:2 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-21


				 
				;----------------------------------------------------------------------------; 
				; Port 3BD Printer Status Flags returned from INT 17 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |			- LPBZ	not busy (note: 0 means busy) 
				;  6      |			- LPACK	acknowledge (printer is attached) 
				;   5     |			- LPOP	20H out of paper 
				;    4    |			- LPSEL	10H selected (0 means off-line) 
				;     3   |			- LPIO	08H I/O error 
				;      21 |			- LPX		06H unused 
				;        0|			- LPTO	01H time-out error 
				;----------------------------------------------------------------------------; 
				PRN_STAT RECORD	LPBZ:1,LPACK:1,LPOP:1,LPSEL:1,LPIO:1,LPX:2,LPTO:1 
				 
				;----------------------------------------------------------------------------; 
				; Port 3BE printer control register   (Parallel Printer Port) 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 765	    |			- LCX		unused 
				;    4    |			- LCIRQ	0 = IRQ disable, 1=IRQ enable for ACK 
				;     3   |			- LCDR	1 = printer reads output,  (pin 17) 
				;      2  |			- LCINI	0 = initialize printer,  (pin 16) 
				;       1 |			- LCLF	1 = auto line feed,  (pin 14) 
				;        0|			- LCOUT	1 = output data to printer,  (pin 1) 
				;----------------------------------------------------------------------------; 
				PRN_CTRL RECORD	LCX:3,LCIRQ:1,LCDR:1,LCINI:1,LCLF:1,LCOUT:1 
				 
				;----------------------------------------------------------------------------; 
				; Port 3FB - Line Control Register - LCR (read/write) 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7	    |			- DLAB	1 = baud rate divisor (DLAB) 
				;  6      |			- LCBK	0 = turn break off, 1 = force spacing break state 
				;   5     |			- LCPD	0 = parity disabled, 1 = enabled 
				;    4    |			- LCEPS	0 = odd parity, 1 = even (EPS) 
				;     3   |			- LCPEN	0 = no parity, 1 = parity (PEN) 
				;      2  |			- LCSB	0 = 1 stop bit, 1 = 1.5 or 2 
				;       10|			- LCWLS	word length select bits 
				;----------------------------------------------------------------------------; 
				COM_LCR RECORD	DLAB:1,LCBK:1,LCPD:1,LCEPS:1,LCPEN:1,LCSB:1,LCWLS:2 
				 
				;----------------------------------------------------------------------------; 
				; Port 3FC - Modem Control Register - MCR (read/write) 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 765	    |			- MCRX	unused 
				;    4    |			- MCLB	0 = normal, 1 = loop back test 
				;     3   |			- MCO2	OUT2 
				;      2  |			- MCO1	OUT1 
				;       1 |			- RTS		1 = activate RTS 
				;        0|			- DTR		1 = activate DTR 
				;----------------------------------------------------------------------------; 
				COM_MCR RECORD	MCRX:3,MCLB:1,MCO2:1,MCO1:1,RTS:1,DTR:1 
				 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-22


				;----------------------------------------------------------------------------; 
				; Port 3FE - Modem Status Register - MSR (read only) 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7	    |			- MLSD	1 = receive line signal detect 
				;  6      |			- MRI		1 = ring indicator (RI) 
				;   5     |			- MDSR	1 = DSR 
				;    4    |			- MCTS	1 = CTS 
				;     3   |			- DDCD	1 = DDCD Delta Data Carrier Detect (DCD changed) 
				;      2  |			- DRI		1 = RI ring indicator changed 
				;       1 |			- DDSR	1 = DDSR Delta DSR (DSR changed) 
				;        0|			- DCTS	1 = DCTS Delta CTS (CTS changed) 
				;----------------------------------------------------------------------------; 
				COM_MSR RECORD	MLSD:1,MRI:1,MDSR:1,MCTS:1,DDCD:1,DRI:1,DDSR:1,DCTS:1 
				 
				;----------------------------------------------------------------------------; 
				; Port 3FD/2FD - Line Status Register - LSR (read only) 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7	    |			- LSX		unused 
				;  6      |			- TSRE	1 = transmitter shift register empty (TSRE) 
				;   5     |			- THRE	1 = transmitter holding register empty (THRE) 
				;    4    |			- LBI		1 = break interrupt  (BI) 
				;     3   |			- LFE		1 = framing error (FE) 
				;      2  |			- LPE		1 = parity error (PE) 
				;       1 |			- LOE		1 = overrun error (OE) 
				;        0|			- LDR		1 = data ready 
				;----------------------------------------------------------------------------; 
				COM_LSR RECORD	LSX:1,TSRE:1,THRE:1,LBI:1,LFE:1,LPE:1,LOE:1,LDR:1 
				 
				;----------------------------------------------------------------------------; 
				; HALT_BEEP Pattern - Short / Long 
				;----------------------------------------------------------------------------; 
				BEEP_SL RECORD	BEEP_S:4, BEEP_L: 4 
				 
				;----------------------------------------------------------------------------; 
				; PIT Timer CW 
				;----------------------------------------------------------------------------; 
				; Control Word Counter 1 (port 43H) - System Timer: 
				;  01 		- SC: Select Counter 1 
				;    11		- RW: Read/Write 2xR/2xW 
				;      010		- M:  Mode 2, Rate Gen 
				;         0		- BCD: 0 
				;----------------------------------------------------------------------------; 
				PIT_CW RECORD	PCWSC:2, PCWRW:2, PCWM:3, PCWBCD:1 
				 
				;----------------------------------------------------------------------------; 
				; DMA Mode Register 
				;----------------------------------------------------------------------------; 
				; 01 			; Mode 1 (Single) 
				;   0 		; INC: address decrement 
				;    1 		; Auto-initialization 
				;     10 		; Operation: Read from memory 
				;       00 		; Channel 0 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-23


				DMA_MR RECORD	DMM:2=01B, DMINC:1, DMAI:1=1, DMOP:2, DMCH:2 
				 
				;----------------------------------------------------------------------------; 
				; 8237 DMA Command Register 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |		- DACK	1 = DACK sense active high, 0 = low 
				;  6      |		- DREQ	1 = DREQ sense active high, 0 = low 
				;   5     |		- DWS		1 = Extended write selection, 0 = Late write 
				;    4    |		- DPRI	1 = Rotating priority, 0 = Fixed priority 
				;     3   |		- DTIM	1 = Compressed timing, 0 = Normal timing 
				;      2  |		- DDIS	1 = Controller disable, 0 = Controller enable 
				;       1 |		- DHLD	1 = Channel 0 address hold enable, 0 = disable 
				;        0|		- DM2M	1 = Memory-to-memory enable, 0 = disable 
				;----------------------------------------------------------------------------; 
				DMA_CR RECORD	DACK:1,DREQ:1,DWS:1,DPRI:1,DTIM:1,DDIS:1,DHLD:1,DM2M:1 
				 
				;----------------------------------------------------------------------------; 
				; 8237 DMA Status Register 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |		- CR3		1 = Channel 3 request 
				;  6      |		- CR2		1 = Channel 2 request 
				;   5     |		- CR1		1 = Channel 1 request 
				;    4    |		- CR0		1 = Channel 0 request 
				;     3   |		- TC3		1 = Channel 3 has reached TC 
				;      2  |		- TC2		1 = Channel 2 has reached TC 
				;       1 |		- TC1		1 = Channel 1 has reached TC 
				;        0|		- TC0		1 = Channel 0 has reached TC 
				;----------------------------------------------------------------------------; 
				DMA_SR RECORD	CR3:1,CR2:1,CR1:1,CR0:1,TC3:1,TC2:1,TC1:1,TC0:1 
				 
				;----------------------------------------------------------------------------; 
				; 8237 DMA Single Channel Mask Register 
				;----------------------------------------------------------------------------; 
				; 84218421 
				;      2  |		- SMCLR	1 = Set mask bit, 0 = Clear mask bit 
				;       10|		- SMCH	Select channel mask bit (0-3) 
				;----------------------------------------------------------------------------; 
				DMA_SMR RECORD	SMCLR:6,SMCH:2 
				 
				;----------------------------------------------------------------------------; 
				; PIC Control Registers 
				;----------------------------------------------------------------------------; 
				; ICW1: 
				;  000 		- A7-A5: unused on 8086 mode 
				;     1 		- D4:   1 = ICW1 (and Port 0) 
				;      0 		- LTIM: 0 = Edge Triggered Mode (low to high TTL transition) 
				;       0 		- ADI:  0 = Call Address Interval of 8 
				;        1 		- SNGL: 1 = Single mode (no cascading PICs or ICW3) 
				;         1		- IC4:  1 = ICW4 Needed 
				;----------------------------------------------------------------------------; 
				ICW1	RECORD	D4:4=1, LTIM:1, ADI:1, SNGL:1=1, IC4:1=1 
				 
				; ICW2: 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-24


				;  00001 		- T7-T3: Interrupt Vector Address: 
				;				INT = INT | 8 -> IRQ 0-7 to CPU INT 8-15 
				;       000 	- D2-D0: unused on 8086 mode 
				;----------------------------------------------------------------------------; 
				ICW2	RECORD	ICW2IVA:5, ICW2X:3=0 
				 
				; ICW4: 
				;  000 		- D7-D5: unused 
				;     0		- SFNM: 0 = Not Special Fully Nested Mode 
				;      10		- BUF:  2 = Buffered Mode/Slave 
				;        0		- AEOI: 0 = normal EOI 
				;         1		- uPM:  1 = 8086 system 
				;----------------------------------------------------------------------------; 
				ICW4	RECORD	SFNM:4=0, ICWBUF:2, AEOI:1, uPM:1 
				 
				;----------------------------------------------------------------------------; 
				; IMR / OCW1 Interrupt Mask 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |		- IRQ7	1=interrupt masked (disabled), 0=not masked 
				;  6      |		- IRQ6 
				;   5     |		- IRQ5 
				;    4    |		- IRQ4 
				;     3   |		- IRQ3 
				;      2  |		- IRQ2 
				;       1 |		- IRQ1 
				;        0|		- IRQ0 
				;----------------------------------------------------------------------------; 
				OCW1	RECORD	IRQ7:1,IRQ6:1,IRQ5:1,IRQ4:1,IRQ3:1,IRQ2:1,IRQ1:1,IRQ0:1 
				 
				;----------------------------------------------------------------------------; 
				; OCW2 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 765	    |		- O2CMD	Rotate and End of Interrupt Mode Command 
				;					001b = Non-Specific EOI Command (default) 
				;    43   |		- O2X		unused (00) 
				;      210|		- O2L		Interrupt level acted upon 
				;----------------------------------------------------------------------------; 
				OCW2	RECORD	O2CMD:3=001b, O2X:2, O2L:3 
 = 0020				EOI	EQU		OCW2 <>		; Non-Specific EOI 
				 
				;----------------------------------------------------------------------------; 
				; OCW3 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |		- O3D7	unused (0) 
				;  65     |		- ESMM/SMM	Enable/special mask mode 
				;    43   |		- O3D3	unused (01b) 
				;      2  |		- O3P		1=Poll command, 0=No Poll command 
				;       10|		- O3RR	Read Register command 
				;----------------------------------------------------------------------------; 
				OCW3	RECORD	O3D7:1, ESMM:2, O3D3:2=1, O3P:1, O3RR:2 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-25


				; NMI Mask Register 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; x 	    |		- NMIE	1=enable NMI, 0=disable 
				;  0000000|		- NMIX	unused (0) 
				;----------------------------------------------------------------------------; 
				NMI	RECORD	NMIE:1, NMIX:7 
				 
				;----------------------------------------------------------------------------; 
				; V40 WCY1 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 76 	    |		- IOW		I/O Wait States (0-3) 
				;   54    |		- UMW		Upper Memory Block Wait States (0-3) 
				;     32  |		- MMW		Middle Memory Block Wait States (0-3) 
				;       10|		- LMW		Lower Memory Block Wait States (0-3) 
				;----------------------------------------------------------------------------; 
				V40_WCY1	RECORD	IOW:2, UMW:2, MMW:2, LMW:2 
				 
				;----------------------------------------------------------------------------; 
				; 6845 Video - Port 3DA Status Register 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7654    |			- VSX		unused 
				;     3   |			- VSVS	vertical retrace, RAM access OK (next 1.25ms) 
				;      2  |			- VSPE	0 = light pen on, 1 = light pen off 
				;       1 |			- VSPT	light pen trigger set 
				;        0|			- VSHS	horiz or vert retrace, RAM access OK 
				;----------------------------------------------------------------------------; 
				VID_STAT	RECORD	VSX:4, VSVS:1, VSPE:1, VSPT:1, VSHS:1 
				 
				;----------------------------------------------------------------------------; 
				; 6845 Video - 3D9 Color Select Register (Text) 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 765     |			- CTX		unused 
				;    4    |			- CTBI	background intensity 
				;     3   |			- CTIN	select intensity setting 
				;      210|			- CTBC	screen/border RGB 
				;----------------------------------------------------------------------------; 
				VID_CSTXT	RECORD	CTX:3=001B, CTBI:1=1B, CTIN:1, CTBC:3 
				 
				;----------------------------------------------------------------------------; 
				; 6845 Video - 3D9 Color Select Register (Graphics) 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 76      |			- CGPH	palette high bits (unused) 
				;   5     |			- CGPL	1 = palette 1, 0=palette 0 
				;    4    |			- CGX		unused 
				;     3   |			- CGIN	intensity 
				;      210|			- CGBG	RGB for background 
				;----------------------------------------------------------------------------; 
				VID_CSGFX	RECORD	CGPH:2,CGPL:1=1B,CGX:1=1B,CGIN:1=1B,CGBG:3=111B 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-26


				; Default video mem attribute byte to fill memory on clear 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7654    |			- VBG		background color (0-15) default black 
				;     3210|			- VFB		foreground color (0-15) default gray 
				;----------------------------------------------------------------------------; 
				VID_ATTR	RECORD	VBG:4=BLACK,VFB:4=GRAY 
				 
				;----------------------------------------------------------------------------; 
				; MDA Character Attributes 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7       |			- MDBK	1 = blink, 0 = no blink 
				;  654    |			- MDBG	000b = normal, 111b = Reverse 
				;     3   |			- MDIN	0 = normal, 1 = bold 
				;      210|			- MDFG	111 = normal, 001 = underline, 000 = none 
				;----------------------------------------------------------------------------; 
				MDA_CH_ATTR	RECORD	MDBK:1,MDBG:3,MDIN:1,MDFG:3=111B 
				 
				;----------------------------------------------------------------------------; 
				; 8255 PPI Channel Control Register Byte (Port 63h) Flags 
				;----------------------------------------------------------------------------; 
				; Normal operation: Mode 0, Ports A,C (U and L) as INPUT, Port B as OUTPUT 
				; 84218421 
				; 1 	    |			- PPEN	1=Active 
				;  00     |			- PPAM	Port A Mode: (0 default) 
				;    1    |			- PPAD	Port A Dir: 0=output, 1=input (default) 
				;     1   |			- PPCU	Port C (Upper): 0=output, 1=input (default) 
				;      0  | 		- PPBM	Port B Mode: (0 default) 
				;       0 | 		- PPBD	Port B Dir: 0=output (default), 1=input 
				;        1|			- PPCL	Port C (Lower): 0=output, 1=input (default) 
				;----------------------------------------------------------------------------; 
				PPI_CR RECORD	PPEN:1=1,PPAM:2=00b,PPAD:1=1,PPCU:1=1,PPBM:1,PPBD:1,PPCL:1=1 
				 
							ENDIF		; END ARCH_TYPE EQ ARCH_TD3300 
				 
							ENDIF 
				 
							ENDIF 
				 
							ELSE					; NOT ARCH_FE2010 
								ELSE 
				;----------------------------------------------------------------------------; 
				; 5160/Standard: 8255 PPI Channel B (Port 61h) Flags 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |			- PBKB	0=enable keyboard read, 1=clear 
				;  6      |			- PBKC	0=hold keyboard clock low, 1=enable clock 
				;   5     |			- PBIO	0=enable i/o check, 1=disable 
				;    4    |			- PBPC	0=enable memory parity check, 1=disable 
				;     3   |			- PBSW	0=read SW1-4, 1=read SW-5-8 
				;      2  |			- PBTB	0=turbo, 1=normal 
				;       1 |			- PBSP	0=turn off speaker, 1=turn on 
				;        0|			- PBST	0=turn off timer 2, 1=turn on 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-27


				PPI_B_F RECORD	PBKB:1,PBKC:1,PBIO:1,PBPC:1,PBSW:1,PBTB:1,PBSP:1,PBST:1 
								ENDIF 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; 5160: 8255 PPI Channel C (Port 62h) Flags 
				; * When PPI B PBSW = 0 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |			- PCPE	0=no parity error, 1=memory parity error 
				;  6      |			- PCIE	0=no i/o channel error, 1=i/o channel error 
				;   5     |			- PCT2	timer 2 output / cassette data output 
				;    4    |			- PCCI	cassette data input 
				;     32  |			- PCMB	SW 3,4: MB RAM (00=64K, 01=128K, 10=192K, 11=256K) 
				;       1 |			- PCFP	SW 2: 0=no FPU, 1=FPU installed 
				;        0|			- PCFD	SW 1: Floppy drive (IPL) installed 
				;----------------------------------------------------------------------------; 
				PPI_C_X_L RECORD	PCPE:1,PCIE:1,PCT2:1,PCCI:1,PCMB:2,PCFP:1,PCFD:1 
				 
				;----------------------------------------------------------------------------; 
				; 8255 PPI Channel C Flags (Port 62h) 
				; * When PPI B PBSW = 1 
				;----------------------------------------------------------------------------; 
				; 84218421 
				; 7 	    |			- PC2PE	0=no parity error, 1 r/w memory parity check error 
				;  6      |			- PC2IE	0=no i/o channel error, 1 i/o channel check error 
				;   5     |			- PC2T2	timer 2 output 
				;    4    |			- PC2CI	cassette data input 
				;     32  |			- PCDRV	SW 7,8: # of drives (00=1, 01=2, 10=3, 11=4) 
				;       10|			- PCVID	SW 5,6: video Mode (00=ROM, 01=CG40, 10=CG80, 11=MDA) 
				;----------------------------------------------------------------------------; 
				PPI_C_X_H RECORD	PC2PE:1,PC2IE:1,PC2T2:1,PC2CI:1,PCDRV:2,PCVID:2 
				 
				;----------------------------------------------------------------------------; 
				; Set up boot mode (PPI_B_BOOT) for PPI Channel B 
				;----------------------------------------------------------------------------; 
				 
							ELSE				; ARCH_TYPE NE ARCH_5150 
								ELSE			; BOOT_SPEED NE BOOT_TURBO 
				;----------------------------------------------------------------------------; 
				; Default Power-On: KB hold low+disable, NMI on, spkr data off, turbo OFF/ON 
				; 
 = 00AC				PPI_B_BOOT	= MASK PBKB OR MASK PBIO OR MASK PBSW OR MASK PBTB 
				 
								ENDIF			; /BOOT_SPEED EQ BOOT_TURBO 
				 
								ENDIF			; /TURBO_TYPE EQ TURBO_REV 
				 
							ENDIF				; /ARCH_TYPE EQ ARCH_5150 
				 
								ENDIF 
				 
				;============================================================================; 
				; 
				;	 			* * *   M A C R O S   * * * 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-28


				; 
				;============================================================================; 
				 
				;----------------------------------------------------------------------------; 
				; CALL NO STACK - a CALL without a writable stack 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	CALL_JMP = address for CALL 
				;	JMP_SHORT = force SHORT jump 
				; 
				; - SS must be CS 
				;----------------------------------------------------------------------------; 
				CALL_NS 	MACRO CALL_JMP, JMP_SHORT 
						LOCAL	CALL_JMP_PTR, CALL_JMP_RET 
					MOV	SP, OFFSET CALL_JMP_PTR 
							IFNB <JMP_SHORT> 
					JMP	SHORT CALL_JMP 
							ELSE 
					JMP	CALL_JMP 
							ENDIF 
				CALL_JMP_PTR: 
					DW	OFFSET CALL_JMP_RET 
				CALL_JMP_RET: 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Introduce a short delay of ~15 clock cycles for I/O 
				;----------------------------------------------------------------------------; 
				; - Code size: 2 bytes 
				; - 15 clock cycles 
				; - Affects no registers or flags 
				; - CPU Instruction cache is purged 
				; - No stack required 
				;----------------------------------------------------------------------------; 
				IO_DELAY_SHORT	MACRO 
						LOCAL _DONE 
							IF ARCH_TYPE NE ARCH_EMU 
					JMP	SHORT _DONE 
				_DONE: 
							ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Variable delay ~ CX * 15 clock cycles 
				;----------------------------------------------------------------------------; 
				; Input: CX delay in 15 clock cycle increments 
				; Output: CX = 0 
				;----------------------------------------------------------------------------; 
				IO_DELAY	MACRO 
						LOCAL _DONE 
				_DONE: 
					LOOP	_DONE					; long delay for I/O 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-29


				; Long delay ~1.18m clock cycles (roughly 1/4 second on 4.77MHz) 
				;----------------------------------------------------------------------------; 
				; Output: CX = 0 
				;----------------------------------------------------------------------------; 
				IO_DELAY_LONG	MACRO 
							IF ARCH_TYPE NE ARCH_EMU 
					XOR	CX, CX 				; delay 65535 LOOPs 
					IO_DELAY 
							ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Variable delay with slowdown for Turbo builds 
				;----------------------------------------------------------------------------; 
				; Input: CX delay in 30 clock cycle increments 
				; Output: CX = 0 
				;----------------------------------------------------------------------------; 
				IO_DELAY_TURBO	MACRO 
						LOCAL _DONE 
				_DONE: 
						IF IS_TURBO 
					IO_DELAY_SHORT 
						ENDIF 
					LOOP	_DONE					; long delay for I/O 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Compare an equipment flag 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	FLAG = field name from EQUIP_FLAGS RECORD 
				;	FVAL = value to compare 
				;	SET_BDA = if defined, saves CX and sets DS = BDA 
				;		otherwise assumes DS = BDA and clobbers CX 
				; Output: AX = flag value 
				; 
				; Note: flags must not cross byte boundary (which they don't) 
				;----------------------------------------------------------------------------; 
				CMP_EFLAG	MACRO	FLAG, FVAL, SET_BDA 
						LOCAL FLAG_MASK, FLAG_BIT, FLAG_MEM 
							IFNB <SET_BDA> 
					PUSH	CX					; save CX 
					PUSH	DS 
					MOV	CX, SEG _BDA			; DS = BDA 
					MOV	DS, CX 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Shift if flag is in high byte to low for byte operations 
				; 
							IF FLAG LT 8		; is in low byte? 
				FLAG_MASK	= MASK FLAG 
				FLAG_BIT	= FLAG AND 0111B 
				FLAG_MEM	= EQUIP_FLAGS[0]			; low BDA flags byte 
							ELSE				; is in high byte 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-30


				FLAG_MASK	= HIGH MASK FLAG 
				FLAG_BIT	= (FLAG - 8) AND 0111B 
				FLAG_MEM	= EQUIP_FLAGS[1]			; high BDA flags byte 
							ENDIF 
				 
					MOV	AL, BYTE PTR FLAG_MEM 
					AND	AL, FLAG_MASK 
					CMP	AL, FVAL SHL FLAG_BIT 
				 
							IFNB <SET_BDA> 
					POP	DS 
					POP	CX 
							ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Get an equipment flag 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	FLAG = field name from EQUIP_FLAGS RECORD 
				;	SET_BDA = if defined, saves CX and sets DS = BDA 
				;		otherwise assumes DS = BDA and clobbers CX if 3 or 4 shifts 
				; Output: AX = flag value 
				; 
				; Note: flags must not cross byte boundary (which they don't) 
				;----------------------------------------------------------------------------; 
				GET_EFLAG	MACRO	FLAG, SET_BDA 
						LOCAL FLAG_MASK, FLAG_BIT, FLAG_MEM 
							IFNB <SET_BDA> 
					PUSH	CX					; save CX 
					PUSH	DS 
					MOV	CX, SEG _BDA			; DS = BDA 
					MOV	DS, CX 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Shift if flag is in high byte to low for byte operations 
				; 
							IF FLAG LT 8		; is in low byte? 
				FLAG_MASK	= MASK FLAG 
				FLAG_BIT	= FLAG AND 0111B 
				FLAG_MEM	= EQUIP_FLAGS[0]			; low BDA flags byte 
								IF FLAG + WIDTH FLAG GT 8 
									.ERR 
									%OUT ERROR: BDA EQFLAG crosses byte boundary 
								ENDIF 
							ELSE				; is in high byte 
				FLAG_MASK	= HIGH MASK FLAG 
				FLAG_BIT	= (FLAG - 8) AND 0111B 
				FLAG_MEM	= EQUIP_FLAGS[1]			; high BDA flags byte 
							ENDIF 
				 
					MOV	AL, BYTE PTR FLAG_MEM		; AL = equipment flag byte 
					AND	AX, FLAG_MASK			; isolate bits, clear AH 
				 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-31


				;----------------------------------------------------------------------------; 
				; Determine optimal number of shifts based on bit position and shift 
				; right or left depending on fewest. 
				; 
							IF CPU_TYPE	EQ CPU_V20 
								IF FLAG_BIT GT 4 
					ROL	AL, 8-FLAG_BIT			; shift value into position 
								ELSE 
									IF FLAG_BIT EQ 4 
					ROL4	_AL					; shift value into position 
									ELSE 
					ROR	AL, FLAG_BIT			; shift value into position 
									ENDIF 
								ENDIF 
							ELSE 
								IF FLAG_BIT GT 4	; optimal to roll left 
									FLAG_BIT = 8-FLAG_BIT 
									IF FLAG_BIT GT 2	; 3-4 shifts use CL 
					MOV	CL, FLAG_BIT			; CL = bit(s) position of record 
					ROL	AL, CL				; shift value into position 
									ELSE		; 0-2 shifts use single op(s) 
										REPT FLAG_BIT 
					ROL	AL, 1					; shift value into position 
										ENDM 
									ENDIF 
								ELSE			; optimal to roll right 
									IF FLAG_BIT GT 2 
					MOV	CL, FLAG_BIT			; CL = bit(s) position of record 
					ROR	AL, CL				; shift value into position 
									ELSE 
										REPT FLAG_BIT 
					ROR	AL, 1					; shift value into position 
										ENDM 
									ENDIF 
								ENDIF 
							ENDIF 
							IFNB <SET_BDA> 
					POP	DS 
					POP	CX 
							ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Set an equipment flag 
				;----------------------------------------------------------------------------; 
				; Input:  
				;	AL = flag value (clobbered) 
				;	FLAG = field name from EQUIP_FLAGS RECORD 
				;	SET_BDA = if defined, saves CL and set DS = BDA  
				;		otherwise *requires* DS = BDA and CL clobbered 
				; Output: none 
				;----------------------------------------------------------------------------; 
				SET_EFLAG	MACRO	FLAG, SET_BDA 
							IFNB	<SET_BDA> 
					PUSH	CX 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-32


					PUSH	DS 
					MOV	CX, SEG _BDA			; DS = BDA 
					MOV	DS, CX 
							ENDIF 
				 
							IF FLAG LT 8		; is in low byte? 
				FLAG_MASK	= MASK FLAG 
				FLAG_BIT	= FLAG AND 111B 
				FLAG_MEM	= EQUIP_FLAGS[0]			; low BDA flags byte 
							ELSE				; is in high byte 
				FLAG_MASK	= HIGH MASK FLAG 
				FLAG_BIT	= (FLAG - 8) AND 0111B 
				FLAG_MEM	= EQUIP_FLAGS[1]			; high BDA flags byte 
							ENDIF 
				 
					AND	AL, MASK FLAG SHR FLAG		; isolate flag's bit width 
				 
				;----------------------------------------------------------------------------; 
				; Determine optimal number of shifts based on bit position and shift 
				; right or left depending on fewest. 
				; 
							IF CPU_TYPE	EQ CPU_V20 
								IF FLAG_BIT GT 4 
					ROR	AL, 8-FLAG_BIT			; shift value into position 
								ELSE 
					ROL	AL, FLAG_BIT			; shift value into position 
								ENDIF 
							ELSE 
								IF FLAG_BIT GT 4 
					MOV	CL, 8-FLAG_BIT			; CL = bit(s) position of record 
					ROR	AL, CL				; shift value into position 
								ELSE 
					MOV	CL, FLAG_BIT			; CL = bit(s) position of record 
					ROL	AL, CL				; shift value into position 
								ENDIF 
							ENDIF 
				 
					AND	BYTE PTR FLAG_MEM, NOT FLAG_MASK	; clear existing bits(s) 
					OR	BYTE PTR FLAG_MEM, AL			; set new bit(s) 
				 
							IFNB <SET_BDA> 
					POP	DS 
					POP	CX 
							ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Test a single BDA equipment flag 
				;----------------------------------------------------------------------------; 
				; Input: FLAG = field name from EQUIP_FLAGS RECORD 
				; Output: ZF if 0, NZ if 1 
				; 
				; Requires: DS = BDA 
				;----------------------------------------------------------------------------; 
				TEST_EFLAG	MACRO	FLAG 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-33


							IF FLAG LT 8 
					TEST	BYTE PTR EQUIP_FLAGS, LOW MASK FLAG 
							ELSE 
					TEST	BYTE PTR EQUIP_FLAGS[1], HIGH MASK FLAG 
							ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Set a single GLaBIOS flag 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	FLAG = field name from GB_FLAGS RECORD 
				;	FLAG_CLR = if set, zeros flags first 
				; Requires: DS = BDA 
				;----------------------------------------------------------------------------; 
				SET_GFLAG	MACRO	FLAG, FLAG_CLR 
							IFNB	<FLAG_CLR> 
					AND	GB_FLAGS, MASK FLAG		; clear existing flag(s) 
							ENDIF 
					OR	GB_FLAGS, MASK FLAG		; set flag(s) 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Test a single GLaBIOS flag 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	FLAG = field name from GB_FLAGS RECORD 
				; Output: ZF if 0, NZ if 1 
				; 
				; Requires: DS = BDA 
				;----------------------------------------------------------------------------; 
				TEST_GFLAG	MACRO	FLAG 
					TEST	GB_FLAGS, MASK FLAG 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Shortcut to write a null-terminated string to console 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	SZ = string to print 
				;	SAVE_REGS = define (anything) to preserve SI (cost of 2 bytes) 
				;----------------------------------------------------------------------------; 
				PRINT_SZ	MACRO	SZ, SAVE_REGS 
						IFNB	<SAVE_REGS> 
					PUSH	SI					; save SI 
						ENDIF 
						IFDIFI <SZ>,<SI>			; if SZ is not SI 
					MOV	SI, OFFSET SZ 
						ENDIF 
					CALL	OUT_SZ 
						IFNB	<SAVE_REGS> 
					POP	SI 
						ENDIF 
						ENDM 
				 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-34


				;----------------------------------------------------------------------------; 
				; Same as above but print CRLF at the end 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	SZ = string to print 
				;	SAVE_REGS = define (anything) to preserve SI (cost of 2 bytes) 
				; 
				; If called as PRINTLN_SZ SI, will use SI (effectively an alias to  
				;	'CALL OUTLN_SZ') 
				;----------------------------------------------------------------------------; 
				PRINTLN_SZ	MACRO	SZ, SAVE_REGS 
						IFNB	<SAVE_REGS> 
					PUSH	SI					; save SI 
						ENDIF 
						IFDIFI <SZ>,<SI>			; if SZ is not SI 
					MOV	SI, OFFSET SZ 
						ENDIF 
					CALL	OUTLN_SZ 
						IFNB	<SAVE_REGS> 
					POP	SI 
						ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Set text attribute for a block of chars starting at current cursor 
				;----------------------------------------------------------------------------; 
				; This is a more efficient way to set text colors so any normal way to write 
				; to console may be used. 
				; 
				; Example usage: 
				;   SET_SZ_ATTR 0EH, 10			; set attribute to 0EH for next 10 chars 
				; 
				; Code size: 
				; 	16 bytes if registers NOT saved 
				;	22 bytes if registers saved 
				; 	-3 bytes if ATTR is BL 
				;----------------------------------------------------------------------------; 
				SET_SZ_ATTR	MACRO	ATTR, LN, SAVE_REGS 
							IF POST_THEME NE 0	; display color 
						IFNB	<SAVE_REGS> 
					PUSH	AX 
					PUSH	BX 
					PUSH	CX 
						ENDIF ; IFNB 
					MOV	AX, DBW <9, VID_SP>	; AH = write char w/attr, AL = space 
						IFDIFI <ATTR>,<BL>	; if ATTR is not BL 
					MOV	BX, LOW ATTR		; BH = video page 0, BL = attribute 
						ENDIF	; IFDIFI 
					MOV	CX, LN			; CX = repeat times 
					INT	10H 
						IFNB	<SAVE_REGS> 
					POP	CX 
					POP	BX 
					POP	AX 
						ENDIF	; IFNB 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-35


							ENDIF			; END display color 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; POST column UI 
				;----------------------------------------------------------------------------; 
				POST_COL_1	MACRO LBL_STR, INNER_ATTR, SAVE_REGS, ZERO_BH 
						IFNB	<SAVE_REGS> 
					PUSH	BX					; save BX 
						ENDIF 
						IFNB	<ZERO_BH> 
					MOV	BX, LOW INNER_ATTR		; BH = 0, BL = attribute 
						ELSE 
					MOV	BL, LOW INNER_ATTR		; BL = attribute 
						ENDIF 
					MOV	SI, OFFSET LBL_STR 
					CALL	POST_START_COL_1 
						IFNB	<SAVE_REGS> 
					POP	BX 
						ENDIF 
				 
						ENDM 
				 
				POST_COL_2	MACRO LBL_STR, INNER_ATTR, SAVE_REGS, ZERO_BH 
						IFNB	<SAVE_REGS> 
					PUSH	BX					; save BX 
						ENDIF 
						IFNB	<ZERO_BH> 
					MOV	BX, LOW INNER_ATTR		; BH = 0, BL = attribute 
						ELSE 
					MOV	BL, LOW INNER_ATTR		; BL = attribute 
						ENDIF 
					MOV	SI, OFFSET LBL_STR 
					CALL	POST_START_COL_2 
						IFNB	<SAVE_REGS> 
					POP	BX 
						ENDIF 
						ENDM 
				 
				POST_COL_END	MACRO	SAVE_REGS 
						IFNB	<SAVE_REGS> 
					PUSH	BX					; save BX 
						ENDIF 
					CALL	POST_END_COL 
						IFNB	<SAVE_REGS> 
					POP	BX 
						ENDIF 
						ENDM 
				 
				POST_COL_END_NL	MACRO SAVE_REGS 
						IFNB	<SAVE_REGS> 
					PUSH	BX					; save BX 
						ENDIF 
					CALL	POST_END_COL_NL 
						IFNB	<SAVE_REGS> 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-36


					POP	BX 
						ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Beepin' MACROs 
				;----------------------------------------------------------------------------; 
				; Beep on Man 
				;----------------------------------------------------------------------------; 
				BEEP_ON MACRO 	TONE 
						IFNB	<TONE> 
					MOV	AX, TONE 				; custom tone 
						ELSE 
					MOV	AX, BEEP_DEFAULT 
						ENDIF 
					CALL	BEEP_ON_P 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Beep off Man 
				;----------------------------------------------------------------------------; 
				BEEP_OFF MACRO 
					CALL	BEEP_OFF_P 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Write to POST status card, if enabled 
				;----------------------------------------------------------------------------;; 
				; Input: AL (default) or imm8 
				; 
				; Clobbers AL if imm8 
				;----------------------------------------------------------------------------; 
				POST_CODE	MACRO	CODE 
						IF POST_CARD EQ 1 
							IFNB	<CODE>		; if CODE is not blank 
							IFDIFI <CODE>,<AL>	; if CODE is not AL 
					MOV	AL, LOW CODE 
							ENDIF 
							ENDIF 
					OUT	POST_CARD_PORT, AL 
						ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; BYTES_HERE - Track and enforce code/byte space around fixed ORGs 
				;----------------------------------------------------------------------------; 
				; Use to mark a block of free code space. Outputs assembly warning if code  
				; overruns NEXT_LBL, and defines LBL so space can be viewed. Values displayed 
				; in generated listing. 
				; 
				; WTF: why can't MASM %OUT display the value of NEXT_LBL-$? 
				; WTF2: how to fix for MASM 6.1? 
				; 
					.LALL 
				BYTES_HERE	MACRO	NEXT_LBL 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-37


						LOCAL LBL 
				 
				BYTES_HERE_&NEXT_LBL = NEXT_LBL-$ 
				 
						IFDEF BYTES_HERE_&NEXT_LBL 
						IF2 
						IF BYTES_HERE_&NEXT_LBL LT 0 
						.ERR2 
					%OUT WARNING: Out of space at: NEXT_LBL (&BYTES_HERE_&NEXT_LBL) 
						ENDIF 
						ENDIF 
						ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; x86/V20 Instruction MACROs 
				;----------------------------------------------------------------------------; 
				 
				;----------------------------------------------------------------------------; 
				; AAM, AAD with immediate other than 0AH 
				; 
				AAM_I		MACRO	IMM 
					DB	0D4H, IMM			; AAM	imm 
						ENDM 
				 
				AAD_I		MACRO	IMM 
					DB	0D5H, IMM			; AAD	imm 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; V20 MACROs for instruction mnemonics not supported by MASM 
				;----------------------------------------------------------------------------; 
				 
				;----------------------------------------------------------------------------; 
				; V20_R General Purpose Register operands 
				; 
				V20_R		RECORD	VRW:5, ROPC:3 
				 
				;----------------------------------------------------------------------------; 
				; Format 3 - Single Register OPC, Variant 1 
				; 
				V20_F3	RECORD	VF3_OPC:5=11000b, VF3_SRC:3 
				 
				;----------------------------------------------------------------------------; 
				; Format 4 - Two Register OPC, Variant 1 
				; 
				V20_F4	RECORD	VF4_OPC:2=11b, VF4_DST:3, VF4_SRC:3 
				 
				;----------------------------------------------------------------------------; 
				; Registers used as operands for V20 MACROs 
				; 
 = 0000				_AL	EQU	V20_R	<, 000b>		; reg8 
 = 0001				_CL	EQU	V20_R <, 001b> 
 = 0002				_DL	EQU	V20_R <, 010b> 
 = 0003				_BL	EQU	V20_R <, 011b> 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-38


 = 0004				_AH	EQU	V20_R <, _AL OR 100b> 
 = 0005				_CH	EQU	V20_R <, _CL OR 100b> 
 = 0006				_DH	EQU	V20_R <, _DL OR 100b> 
 = 0007				_BH	EQU	V20_R <, _BL OR 100b> 
 = 0008				_AX	EQU	V20_R <1, _AL>		; reg16 
 = 0009				_CX	EQU	V20_R <1, _CL> 
 = 000A				_DX	EQU	V20_R <1, _DL> 
 = 000B				_BX	EQU	V20_R <1, _BL> 
 = 000C				_SP	EQU	V20_R <1, _AH> 
 = 000D				_BP	EQU	V20_R <1, _CH> 
 = 000E				_SI	EQU	V20_R <1, _DH> 
 = 000F				_DI	EQU	V20_R <1, _BH> 
				 
				;----------------------------------------------------------------------------; 
				; Format 1 - Opcode with Size (Byte/Word) 
				; 
				V20_OP1	MACRO OP, R, IMM 
						LOCAL W 
					W	= (R AND MASK VRW) SHR VRW		; W=1 if 16, 0 if 8 
					DB	0FH, OP OR W				; register Width 
					V20_F3 <, R AND MASK ROPC >			; dest register 
							IFNB <IMM> 
					DB	IMM 
							ENDIF 
						ENDM 
				 
				TEST1		MACRO R, IMM 
					V20_OP1	18H, R, IMM 
						ENDM 
				 
				SET1		MACRO R, IMM 
					V20_OP1	1CH, R, IMM 
						ENDM 
				 
				CLR1		MACRO R, IMM 
					V20_OP1	1AH, R, IMM 
						ENDM 
				 
				NOT1		MACRO R, IMM 
					V20_OP1	1EH, R, IMM 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; V20 (B)INS (Binary INS) - reg/reg form 
				;----------------------------------------------------------------------------; 
				BINS		MACRO D, S 
					DB	0FH, 31H 
					V20_F4 <, S AND MASK ROPC, D AND MASK ROPC > 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; V20 (B)EXT (Binary EXT) - reg/reg form 
				;----------------------------------------------------------------------------; 
				BEXT		MACRO D, S 
					DB	0FH, 33H 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-39


					V20_F4 <, S AND MASK ROPC, D AND MASK ROPC > 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; ROL4: roll nibbles left in AL through R8 
				;----------------------------------------------------------------------------; 
				; R8(low nibble)  = AL(low nibble) 
				; R8(high nibble) = R8(low nibble) 
				; AL(low nibble)  = R8(high nibble) 
				; AL(high nibble) clobbered 
				;----------------------------------------------------------------------------; 
				ROL4		MACRO R8 
					V20_OP1	28H, R8					; ROL4 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; ROR4: roll nibbles right in AL through R8 
				;----------------------------------------------------------------------------; 
				; R8(high nibble) = AL(low nibble) 
				; R8(low nibble)  = R8(high nibble) 
				; AL(low nibble)  = R8(low nibble) 
				; AL(high nibble) clobbered 
				;----------------------------------------------------------------------------; 
				ROR4		MACRO R8 
					V20_OP1	2AH, R8					; ROR4 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Operations on POST test FLAGs 
				;----------------------------------------------------------------------------; 
				POST_FLAG_TEST MACRO	FLAG 
							IF CPU_TYPE	EQ CPU_V20 AND (WIDTH FLAG) EQ 1 
					TEST1	_BP, FLAG				; V20: is FLAG set? 
							ELSE 
					TEST	BP, MASK FLAG			; Is FLAG set? 
							ENDIF 
						ENDM 
				 
				POST_FLAG_SET MACRO	FLAG 
							IF CPU_TYPE	EQ CPU_V20 AND (WIDTH FLAG) EQ 1 
					SET1	_BP, FLAG				; V20: Set FLAG 
							ELSE 
					OR	BP, MASK FLAG			; Set FLAG 
							ENDIF 
						ENDM 
				 
				POST_FLAG_FLIP MACRO	FLAG 
							IF CPU_TYPE	EQ CPU_V20 AND (WIDTH FLAG) EQ 1 
					NOT1	_BP, FLAG				; V20: Invert FLAG 
							ELSE 
					XOR	BP, MASK FLAG			; Invert flag 
							ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-40


				; If ZF is needed, set NEED_ZF to use 808x 'AND' instruction instead 
				;----------------------------------------------------------------------------; 
				POST_FLAG_CLR MACRO	FLAG, NEED_ZF 
								LOCAL USE_V20 
							IFNB <NEED_ZF> 
				USE_V20	EQU	0				; use AND instruction instead 
							ELSE 
				USE_V20	EQU	1				; use CLR1 (ZF unaffected) 
							ENDIF 
							IF CPU_TYPE	EQ CPU_V20 AND (WIDTH FLAG) EQ 1 AND USE_V20 
					CLR1		_BP, FLAG			; V20: Clear FLAG 
							ELSE 
					AND	BP, NOT MASK FLAG			; Clear flag 
							ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Jump if Warm Boot 
				;----------------------------------------------------------------------------; 
				JWB		MACRO	LBL 
							IF WARM_ENABLE EQ 1 
					TEST	BP, BP				; is warm boot? 
					JS	LBL					; jump if so 
							ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Jump if not Warm Boot 
				;----------------------------------------------------------------------------; 
				JNWB		MACRO	LBL 
					TEST	BP, BP				; is warm boot? 
					JNS	LBL					; jump if not 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; Wait for a video retrace to enable RAM access for CGA 80 column 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	DX = 03DAH (CGA Status Port) 
				; 
				; Output: 
				;	Display is in retrace 
				;	CLI: Interrupts OFF - must be re-enabled after read/write operation 
				; 
				; https://forum.vcfed.org/index.php?threads/cant-get-rid-of-cga-snow.39319/post-478150 
				; 
				; Due to timing requirements this must be unrolled - CALL/PROC too slow 
				;----------------------------------------------------------------------------; 
				CGA_WAIT_SYNC	MACRO 
						LOCAL	WAIT_NO_HSYNC, WAIT_BLANK, IN_VSYNC 
							IF CGA_SNOW_REMOVE EQ 1 
					CLI						; [2] disable interrupts 
							ENDIF 
				WAIT_NO_HSYNC: 
							IF CGA_SNOW_REMOVE GT 1 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-41


					STI						; [2] enable interrupts 
					NOP						; [3] handle pending interrupts 
					CLI						; [2] disable interrupts 
							ENDIF 
					IN	AL, DX				; [12] read CGA status register 
							IF CGA_SNOW_REMOVE GT 1 
					TEST	AL, MASK VSVS			; [5] in vertical? 
					JNZ	IN_VSYNC				; [4/16] if so, do CGA I/O 
							ENDIF 
					SHR	AL, 1					; [2] in horizontal? 
					JC	WAIT_NO_HSYNC			; [4/16] if so, wait for next one 
				WAIT_BLANK: 
					IN	AL, DX				; [12] read CGA status register 
							IF CGA_SNOW_REMOVE GT 1 
					TEST	AL, MASK VSVS OR MASK VSHS	; [5] in either sync? 
					JZ	WAIT_BLANK				; [4/16] 
							ELSE 
					SHR	AL, 1					; [2] in horizontal sync? 
					JNC	WAIT_BLANK				; [4/16] 
							ENDIF 
				IN_VSYNC: 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; IRET with all current flags 
				;----------------------------------------------------------------------------; 
				IRET_F	MACRO 
					RETF	2 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; PUSH multiple (X number of) registers (up to 8) 
				;----------------------------------------------------------------------------; 
				PUSHX	MACRO r1, r2, r3, r4, r5, r6, r7, r8 
							IFNB <r1>			; exit if last reg 
					PUSH	r1 					; push register and repeat 
					PUSHX	r2, r3, r4, r5, r6, r7, r8 
							ENDIF 
						ENDM 
				 
				;----------------------------------------------------------------------------; 
				; POP multiple registers (up to 8) 
				;----------------------------------------------------------------------------; 
				POPX	MACRO r1, r2, r3, r4, r5, r6, r7, r8 
							IFNB <r1>			; exit if last reg 
					POP	r1 					; pop register and repeat 
					POPX	r2, r3, r4, r5, r6, r7, r8 
							ENDIF 
						ENDM 
				 
				;============================================================================; 
				; 
				;	   		   * * *   S E G M E N T S   * * *  
				; 
				;============================================================================; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-42


				 
				;----------------------------------------------------------------------------; 
				; 0000:0000 - 8086 INT vector table 
				;----------------------------------------------------------------------------; 
 0000				_IVT		SEGMENT AT 0H 
 0020						ORG 8H*4 
 0020  ????			IVT_08 		DW	?			; INT 08H - Timer 
 0022  ????			IVT_08_SEG		DW	?			; INT 08H - Timer Segment 
 0024  ????			IVT_09 		DW	?			; INT 09H - Keyboard 
 0026  ????			IVT_09_SEG		DW	?			; INT 09H - Keyboard Segment 
 0040						ORG 10H*4 
 0040  ????			IVT_10		DW	?			; INT 10H - BIOS video services 
 0042  ????			IVT_10_SEG		DW	?			; INT 10H - Segment 
 0060						ORG 18H*4 
 0060  ????			IVT_18		DW	?			; INT 18H - ROM BASIC 
 0062  ????			IVT_18_SEG		DW	?			; INT 18H - Segment 
 0074						ORG 1DH*4 
 0074  ????????			IVT_1D		DD	?			; INT 1DH - CRTC param table 
 0078  ????????			IVT_1E		DD	?			; INT 1EH - Floppy param table 
 007C  ????????			IVT_1F		DD	?			; INT 1FH - User Font bitmap table 
 0080				_IVT 		ENDS 
				 
				;----------------------------------------------------------------------------; 
				; 0000:0400 - BIOS data area (BDA) - Zero Page Segment Addressing 
				;----------------------------------------------------------------------------; 
 = 0400				_BDA_SEG	=	KP < 40H >			; BDA Seg 40H 
 0000				_BDA_ABS	SEGMENT AT 0H 
 041A						ORG	1AH + _BDA_SEG 
 041A  ????			KB_BUF_HD_ABS	DW	?			; 40:1AH Keyboard buffer head ptr 
 043E						ORG	3EH + _BDA_SEG 
 043E  00			FD_CAL_ST_ABS	FDC_SF <>			; 40:3EH Floppy drive recalibration 
 0440						ORG	40H + _BDA_SEG 
 0440  ??			FD_MOTOR_CT_ABS	DB	?			; 40:40H FD motor shutoff counter 
 046B						ORG	6BH + _BDA_SEG 
 046B  ??			INT_LAST_ABS	DB	?			; 40:6BH POST / Interrupt happened? 
 0472						ORG	72H + _BDA_SEG 
 0472  ????			WARM_FLAG_ABS	DW	?			; 40:72H Warm Boot Flag 
 0480						ORG	80H + _BDA_SEG 
 0480  ????			KB_BUF_ST_ABS	DW	?			; 40:80H Keyboard buffer start ptr 
 0482				_BDA_ABS	ENDS 
				 
				;----------------------------------------------------------------------------; 
				; 0030:0000 - Bootstrap temporary stack 
				;----------------------------------------------------------------------------; 
 0000				_BOOT_STACK	SEGMENT AT 30H 
 0000  0080[						DW 	80H DUP(?)		; temporary stack 
	   ????			
			 ]	
				
 0100				STACK_TOP		LABEL WORD			; top of stack 
 0100				_BOOT_STACK	ENDS 
				 
				;----------------------------------------------------------------------------; 
				; 0040:0000 - BIOS data area (BDA) 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-43


				; https://stanislavs.org/helppc/bios_data_area.html 
				; http://www.bioscentral.com/misc/bda.htm 
				;----------------------------------------------------------------------------; 
 0000				_BDA		SEGMENT AT 40H 
 0000  0004[			COM_ADDR		DW	4 DUP(?) 		; 00H  COM1-4 base addresses 
	   ????			
			 ]	
				
 = 0008				LPT_ADDR_B		EQU	$-_BDA		;	 Low byte hack to force short sign-extend en
				coding 
 0008  0003[			LPT_ADDR		DW	3 DUP(?) 		; 08H  LPT1-3 base addresses 
	   ????			
			 ]	
				
 000E  ????						DW	? 			; 0EH  Extended BIOS data area segment 
 0010  0C00			EQUIP_FLAGS		EQFLAGS <> 			; 10H  Equipment Flags 
 0012  00			GB_FLAGS		GFLAGS <> 			; 12H  Custom Equipment Flags 
 0013  ????			MEM_SZ_KB		DW	?			; 13H  Memory size in kilobytes 
 0015  ????			MEM_SZ_PC		DW	?			; 15H  Memory size SW2 on 5150 
 0017				KB_FLAGS		LABEL WORD 
 0017  00			KB_FLAGS1		KBFLAGS1 <>			; 17H  Keyboard flags 1 
 0018  00			KB_FLAGS2		KBFLAGS2 <>			; 18H  Keyboard flags 2 
 0019  ??			KB_ALT 		DB	?			; 19H  Alt-keypad entry byte 
 001A  ????			KB_BUF_HD		DW	?			; 1AH  Keyboard buffer head ptr 
 001C  ????			KB_BUF_TL		DW	?			; 1CH  Keyboard buffer tail ptr 
 001E  0010[			KB_BUF		DW	16 DUP(?) 		; 1EH  Keyboard buffer 
	   ????			
			 ]	
				
 003E				KB_BUF_END		LABEL WORD			; 3EH  End of keyboard buffer (not inclusive
				) 
 = 003E				KB_BUF_END_B	EQU	3EH			;	 Low byte to force short sign-extend encodin
				g 
 003E  00			FD_CAL_ST		FDC_SF <>			; 3EH  Floppy drive recalibration status 
											;	0 = drive not calibrated 
											;	high bit = working interrupt flag 
 003F  00			FD_MOTOR_ST		FDC_MF <>			; 3FH  FD motor status 
											;	high bit = write operation 
 0040  ??			FD_MOTOR_CT		DB	?			; 40H  FD motor shutoff counter (decr. by IN
				T 8) 
 0041  ??			FD_LAST_OP		DB	?			; 41H  BIOS Status of last FD operation 
 0042  ??			FDC_LAST_ST		FDC_CSB <>			; 42H  FDC command status last result (7 byt
				es) 
 0043  ??			
 0044  ??			
 0045  ??			
 0046  ??			
 0047  ??			
 0048  ??			
				
 0049  ??			VID_MODE		DB	?			; 49H  Current video mode 
 004A  ????			VID_COLS		DW	?			; 4AH  Number of screen columns 
 004C  ????			VID_BUF_SZ		DW	?			; 4CH  Size of video regen buffer in bytes 
 004E  ????			VID_SEG		DW	? 			; 4EH  Starting address in video regen buffer (offse
				t)  
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-44


 0050  0008[			VID_CURS_POS	DW	8 DUP(?)		; 50H-5FH Cursor position of pages 1-8, high=row, lo
				w=col 
	   ????			
			 ]	
				
 0060  ????			VID_CURS_TYPE	DW	? 			; 60H  Starting (Top), Ending (bottom) scan line for
				 cursor 
 0062  ??			VID_PAGE		DB	? 			; 62H  Active display page number 
 0063  ????			VID_PORT		DW	?			; 63H  Base port address for active 6845 CRT
				 controller 
 0065  ??			VID_MODE_REG	DB	?			; 65H  6845 CRT mode control register value (port 3x
				8H) 
 0066  ??			VID_COLOR		DB	? 			; 66H  CGA current color palette setting (po
				rt 3D9H) 
 = 001E				L_VID_BDA		EQU	$-VID_MODE		;      Length in bytes of video data in BDA 
 0067				CAS_TIME_CNT	LABEL WORD			; 67H  5150 Cassette: Counter 
 0067  ????			ROM_INIT_SS		DW	?			; 67H   or Temp location for SS:SP during bl
				ock move 
 0069				CAS_CRC		LABEL	WORD			; 69H  5150 Cassette: CRC 
 0069  ????			ROM_INIT_SP 	DW	? 			; 69H	  or Option ROM init 
 006B				CAS_PREV		LABEL	BYTE			; 6BH  5150 Cassette: Previous byte 
				;FE2010_CONF_REG	LABEL BYTE			; 6BH  FE2010A Config Reg (Standard 63H) 
 006B  ??			INT_LAST		DB	? 			; 6BH  Reserved for POST / Interrupt happene
				d? 
 006C  ????			TIMER			TIMER_C <>			; 6CH-70H Timer Counter 
 006E  ????			
 0070  ??			
				
 0071  ??			BIOS_BREAK		DB	?			; 71H  BIOS break flag (high bit means ctrl-
				break) 
 0072  ????			WARM_FLAG		DW	?			; 72H  Warm Boot Flag (1234H to bypass RAM t
				est) 
 0074  ??			HD_LAST_ST		DB 	? 			; 74H  Status of last hard disk operation (s
				ee INT 13,1) 
 0075  ??			HD_COUNT		DB 	? 			; 75H  Number of hard disks attached 
 0076  ??			HD_CTRL		DB 	? 			; 76H  XT fixed disk drive control byte 
 0077  ??			HD_PORT		DB 	? 			; 77H  Port offset to current fixed disk adapter 
 = 0078				LPT_TIME_B		EQU	$-_BDA		;	 Low byte hack to force short sign-extend en
				coding 
 0078  0004[			LPT_TIME		DB	4 DUP(?) 		; 78H  Time-out value for LPT1-4 (in # of 64
				K LOOPs) 
	    ??			
			 ]	
				
 = 007C				COM_TIME_B		EQU	$-_BDA		;	 Low byte hack to force short sign-extend en
				coding 
 007C  0004[			COM_TIME		DB	4 DUP(?) 		; 7CH  Time-out value for COM1-4 
	    ??			
			 ]	
				
 0080  ????			KB_BUF_ST		DW	?			; 80H  Keyboard buffer start 
 0082  ????						DW	?			; 82H  Keyboard buffer end 
 008B						ORG	08BH 
 008B  ??			FD_LR			DB	?			; 8BH  Last diskette data rate selected 
 008F						ORG	08FH 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-45


 008F  00			FD_MODE		FDC_MODE <>			; 8FH  FDC Drive Mode (see FDC_MODE) 
 0090  0004[			FD_MEDIA_ST		FDC_STATE 4 DUP(<>)	; 90H-93H  Drive 0-3 media state 
	   00			
			 ]	
				
 0094  0002[			FD_TRACK		DB	2 DUP(?)		; 94H-95H  Drive 0-1 current track 
	    ??			
			 ]	
				
 0096  00			EKB_FLAGS1		KBFLAGS3 <>			; 96H  Keyboard mode/type (Enhanced) 
 0097  00			EKB_FLAGS2		KBFLAGS4 <>			; 97H  Keyboard LED flags (Enhanced) 
 00A0						ORG	0A0H 
 00A0  ??			RTC_WAIT		DB	?			; A0H  RTC wait function flag 
 00AC						ORG	0ACH				; ACH-B3H "Reserved" (can be used?) 
 00B0						ORG	0B0H				; B0H-B1H (used by Tandy for keyboard) 
 00E8						ORG	0E8H				; E8H-EFH "Reserved" (can be used?) 
 00E8				VID_MEM_SEG_DW	LABEL DWORD			; E8H-EAH Video mem segment using LDS/LES 
 00E8  ????			CURSOR_DEFAULT	DW	?			; E8H  Power on cursor bottom:top scan line (for Tur
				bo) 
 00EA  ????			VID_MEM_SEG		DW	?			; EAH	 Video mem segment (MDA = B000, CGA 
				= B800) 
 00EC  ??			FE2010_CONF_REG	DB	?			; ECH  FE2010A Config Reg (63H) (alternate) 
 00ED  ??						DB	?			; EDH 
 00EE  ????			RTC_DATA		DW	?			; EEH  GLaTICK address and RTC type 
 00F0				_BDA		ENDS 
				 
				;----------------------------------------------------------------------------; 
				; 0050:0000 - BIOS/DOS Data Area 
				;----------------------------------------------------------------------------; 
 0000				_DOS_DAT	SEGMENT AT 50H 
 0000  ??			PTRSCN_ST		DB 	?			; 00H  Print screen status 
 0001  0003[						DB	3  DUP(?)		; 01H  Used by BASIC 
	    ??			
			 ]	
				
 0004  ??						DB	?			; 04H  Floppy drive flag for single 
											;	  drive systems (0=A,1=B) 
 0005  000A[						DB	10 DUP(?)		; 05H  POST work area 
	    ??			
			 ]	
				
 000F  0013[						DB	19 DUP(?)		 
	    ??			
			 ]	
				
 0022  000E[			DOS_FD_PARAM	DB	14 DUP(?)		; 22H  Floppy drive parameter table 
	    ??			
			 ]	
				
 0030  0004[						DB	4  DUP(?)		; 30H  Mode command 
	    ??			
			 ]	
				
 0034				_DOS_DAT	ENDS 
				 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-46


				;----------------------------------------------------------------------------; 
				; 0000:7C00 - IPL / MBR / Boot Block Segment 
				;----------------------------------------------------------------------------; 
 0000				_IPL_SEG	SEGMENT AT 0H 
 7C00						ORG	07C00H 
 7C00  01FE[			IPL_TOP		DB	510 DUP(?)		; MBR code then MBR magic number 
	    ??			
			 ]	
				
 7DFE  ????			IPL_ID		DW	?			; 0AA55H if valid MBR 
 7E00				_IPL_SEG	ENDS 
				 
				;----------------------------------------------------------------------------; 
				; B000:0000 - MDA Video Memory 
				;----------------------------------------------------------------------------; 
 0000				_MDA_MEM	SEGMENT AT 0B000H 
 0000  1000[			MDA_MEM		DB	1000H DUP(?)	; 4KiB (1000H) total MDA memory 
	    ??			
			 ]	
				
 1000				_MDA_MEM	ENDS 
				 
				;----------------------------------------------------------------------------; 
				; B800:0000 - CGA Video Memory 
				;----------------------------------------------------------------------------; 
 0000				_CGA_MEM	SEGMENT AT 0B800H 
 0000  0800[			CGA_MEM_40		DB	0800H DUP(?)	; page 1 of CGA 40 column (2K) 
	    ??			
			 ]	
				
 0800  3800[			CGA_MEM_80		DB	3800H DUP(?)	; pages 1-4 of CGA 80 column (14K) 
	    ??			
			 ]	
				
 = 4000				CGA_MEM_SZ		= SIZE CGA_MEM_40 + SIZE CGA_MEM_80	; 16 KiB (4000H) total CGA memory 
 = 2000				CGA_MEM_FLD 	= CGA_MEM_SZ / 2		;  8 KiB (2000H) CGA memory field 
 4000				_CGA_MEM	ENDS 
				 
				;----------------------------------------------------------------------------; 
				; C000:0000 - Video Option ROM segment 
				;----------------------------------------------------------------------------; 
 0000				_VID_BIOS	SEGMENT AT 0C000H 
 0000  ????			VID_MN		DW	?			; magic number (0AA55H) 
 0002  ??			VID_BIOS_SZ		DB	?			; length in 512 byte blocks 
 0003  ????			VID_VEC		DW	?			; FAR call to ROM init routine 
 0005				_VID_BIOS	ENDS 
				 
				;----------------------------------------------------------------------------; 
				; C800:0000 - Start of Storage/Other Option ROM segment 
				;----------------------------------------------------------------------------; 
 0000				_OPT_ROM	SEGMENT AT 0C800H 
 0000				_OPT_ROM	ENDS 
				 
				;----------------------------------------------------------------------------; 
				; F000:E000 - System BIOS ROM segment map 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-47


				;----------------------------------------------------------------------------; 
 0000				_BIOS		SEGMENT AT 0F000H 
 E000						ORG	0E000H 
 E000				_BIOS_TOP	LABEL WORD 
 E05B						ORG	0E05BH 
 E05B				_BOOT		LABEL WORD				; BIOS boot offset 
 FFF0						ORG	0FFF0H 
 FFF0				_POWER_ON	LABEL WORD				; CPU power-on jump address 
 FFF0				_BIOS		ENDS 
				 
				;----------------------------------------------------------------------------; 
				; F600:0000 - ROM BASIC segment 
				;----------------------------------------------------------------------------; 
 0000				_BASIC	SEGMENT AT 0F600H 
 0000				BASIC_TOP	LABEL WORD 				; ROM BASIC load offset 
 0000				_BASIC	ENDS 
				 
				;----------------------------------------------------------------------------; 
				; FFFF:0000: 8086 power-on reset vector 
				;----------------------------------------------------------------------------; 
				; The x86 CPU begins code excution at hard-coded address FFFF:0000. 
				; This is that address. Welcome to the party! 
				;----------------------------------------------------------------------------; 
 0000				RESET    	SEGMENT AT 0FFFFH 
 0000				__POWER_ON	LABEL	FAR				; FFFF:0000 
 0000				RESET		ENDS 
				 
				;============================================================================; 
				; 
				;				* * *   C O D E   * * *  
				; 
				;============================================================================; 
				 
				;----------------------------------------------------------------------------; 
				; Main BIOS ROM begins 
				;----------------------------------------------------------------------------; 
				; Note: Memory space from F000:0000 - F000:E05A is available, though a 
				; BIOS identifier string is typically at or near the top of this segment 
				;----------------------------------------------------------------------------; 
						ASSUME	DS:BIOS, SS:BIOS, CS:BIOS, ES:BIOS 
 0000				BIOS    	SEGMENT 
				 
				;----------------------------------------------------------------------------; 
				; F000:FFF0: 8086 power-on reset vector 
				;----------------------------------------------------------------------------; 
				; The x86 CPU begins code excution at hard-coded address FFFF:0000. 
				; This is that address. Welcome to the party! 
				;----------------------------------------------------------------------------; 
 FFF0						ORG	0FFF0H 
 FFF0				POWER_ON	PROC	FAR 
 FFF0  EA E05B ---- R			JMP	FAR	PTR _BOOT 		; always jump to power on routine 
				 
 FFF5						ORG	0FFF5H 
 FFF5  30 31 2F 31 38 2F 32	REL_DATE 	DB	VER_DATE		; Release date 
       35			
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-48


				 
 FFFE						ORG	0FFFEH 
 FFFE  FE			ISA_TYPE	DB	ARCH_ID		; Architecture model 
				 
 FFFF						ORG	0FFFFH		; BIOS ROM checksum byte  
 FFFF  ??					DB	?			; (computed at build time) 
 00010000			POWER_ON	ENDP 
				 
				;----------------------------------------------------------------------------; 
				; F000:E000: Top of BIOS ROM 8K segment 
				;----------------------------------------------------------------------------; 
 E000						ORG	0E000H 
 E000				BIOS_TOP	PROC	NEAR 
				 
 E000  0A			TOP_BANNER	DB	LF 
 E001  47 4C 61 42 49 4F 53			DB	VER_NAME, ' [', HEART, '] ' 
       20 5B 03 5D 20		
								ENDIF 
 E00D  54 68 65 20 68 65 72	TAG0		DB	"The hero we need but don't deserve" 
       6F 20 77 65 20 6E 65	
       65 64 20 62 75 74 20	
       64 6F 6E 27 74 20 64	
       65 73 65 72 76 65	
								ENDIF 
 E02F  0D 0A			COPYRIGHT	DB	CR, LF 
 E031  28 43 29 20 32 30 32			DB	'(C) ', COPY_YEAR, ' ' 
       32 2D 32 35 20		
 E03D  36 34 30 4B 42 20 52			DB	'640KB Released under GPLv3' 
       65 6C 65 61 73 65 64	
       20 75 6E 64 65 72 20	
       47 50 4C 76 33		
 E057  0A					DB	LF 
 E058  00					DB	0 
				 
 E059				BIOS_TOP 	ENDP 
				 
				; 
				; 0 BYTES HERE 
				; 
				BYTES_HERE	BOOT 
 = 0002                      1	BYTES_HERE_BOOT = BOOT-$ 
			     1			IFDEF BYTES_HERE_BOOT 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
							ASSUME CS:BIOS, DS:NOTHING, ES:NOTHING, SS:NOTHING 
				;----------------------------------------------------------------------------; 
				; F000:E05B: Beginning of boot execution 
				;----------------------------------------------------------------------------; 
				; Loosely follow these specs for BIOS POST operations: 
				; 
				; http://minuszerodegrees.net/5160/post/5160%20-%20POST%20-%20Detailed%20breakdown.htm 
				; http://minuszerodegrees.net/5150/post/5150%20-%20POST%20-%20Detailed%20breakdown.htm 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-49


				; https://stanislavs.org/helppc/cold_boot.html 
				; http://philipstorr.id.au/pcbook/book1/post.htm 
				;----------------------------------------------------------------------------; 
 E05B						ORG	0E05BH 
 E05B				BOOT	PROC	NEAR 
 E05B  FA				CLI 					; disable CPU interrupts 
 E05C  FC				CLD					; clear direction flag 
				 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; POST Hardware/System Tests 
				;----------------------------------------------------------------------------; 
				 
 E05D				POST_CPU_TEST: 
				;----------------------------------------------------------------------------; 
				; [1] Test and clear all CPU Registers 
				;----------------------------------------------------------------------------; 
				; Check and set all registers to 0. 
				; 
				; On Failure: 2 short and 1 long beep 
				;----------------------------------------------------------------------------; 
							ASSUME DS:_BDA_ABS, ES:_IVT 
 E05D  B8 731D				MOV	AX, RAM_TEST		; use the standard test pattern 
 E060				CPU_REG_TEST: 
 E060  8B D8				MOV	BX, AX			; the game of telephone 
 E062  8E DB				MOV	DS, BX			;  pass a 
 E064  8C D9				MOV	CX, DS			;  known value 
 E066  8E C1				MOV	ES, CX			;  through all 
 E068  8C C6				MOV	SI, ES			;  registers and 
 E06A  8E D6				MOV	SS, SI			;  ensure the 
 E06C  8C D7				MOV	DI, SS			;  same value 
 E06E  8B EF				MOV	BP, DI			;  makes it all 
 E070  8B E5				MOV	SP, BP			;  the way 
 E072  8B D4				MOV	DX, SP			;  to the end 
 E074  F7 C2 8CE2			TEST	DX, NOT RAM_TEST		; expected result? 
 E078  B3 21				MOV	BL, BEEP_SL <2,1>		; on Failure: 2 short and 1 long beep 
 E07A  75 6E				JNZ	HALT_ERROR 
 E07C  33 C0				XOR	AX, AX 			; otherwise repeat with AX = 0 
 E07E  85 D2				TEST	DX, DX			; if zero it was second pass 
 E080  75 DE				JNZ	CPU_REG_TEST		; Loop again to zero all registers 
 E082				CPU_REG_PASS: 
				 
				;----------------------------------------------------------------------------; 
				; [1B] A brief test of flags and CPU instructions 
				;----------------------------------------------------------------------------; 
				; On Failure: 2 short and 1 long beep 
				;----------------------------------------------------------------------------; 
							IF POST_TEST_INST EQ 1 
 E082				CPU_INST_TEST: 
 E082  B0 01				MOV	AL, 1				; start off with some complicated math 
 E084  02 C0				ADD	AL, AL			; can little Billy add 1 + 1? 
 E086  78 62				JS	HALT_ERROR			; ...better not be negative 
 E088  74 60				JZ	HALT_ERROR			; ...better not be zero 
 E08A  7A 5E				JP	HALT_ERROR			; ...better have an odd number of 1 bits 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-50


 E08C  72 5C				JC	HALT_ERROR			; ...better not be a borrower 
 E08E  2C 03				SUB	AL, 3				; 2 - 3 = ? 
 E090  79 58				JNS	HALT_ERROR			; ...better be negative 
 E092  7B 56				JNP	HALT_ERROR			; ...better have even bits 
 E094  73 54				JNC	HALT_ERROR			; ...better have had to borrow 
 E096  98				CBW					; zero extend the result 
 E097  40				INC	AX				; roll it back over to 0 
 E098  75 50				JNZ	HALT_ERROR			; AX = 0 
 E09A				CPU_TEST_PASS: 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; [2] Disable non-maskable interrupts (NMIs) 
				;----------------------------------------------------------------------------; 
 E09A				DISABLE_NMI: 
 E09A  E6 A0				OUT	NMI_R0, AL			; write AL = 0 to NMI register port 
				 
				;----------------------------------------------------------------------------; 
				; [3] Set Zero Page Register for DMA channels 0 and 1 
				;----------------------------------------------------------------------------; 
 E09C  E6 83				OUT	DMA_P_C1, AL 		; AL = high nibble of segment for DMA (0) 
				 
				;----------------------------------------------------------------------------; 
				; [4] Disable MDA/CGA adapters (for now) 
				;----------------------------------------------------------------------------; 
 E09E				INIT_VIDEO: 
 E09E  BA 03D8				MOV	DX, CGA_CTRL		; DX = 03D8H 
 E0A1  EE				OUT	DX, AL 			; send Disable to CGA Mode Select Register 
 E0A2  40				INC	AX 				; clear MDA control, disable video signal 
 E0A3  B2 B8				MOV	DL, LOW MDA_CTRL		; DX = 03B8H 
 E0A5  EE				OUT	DX, AL 			; send to MDA CRT Control Port 
					POST_CODE				; optionally display 01 on POST card 
			     1			IF POST_CARD EQ 1 
			     1				ENDIF 
 E0A6  E6 80                 1		OUT	POST_CARD_PORT, AL 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Set up POST flags in BP 
				;----------------------------------------------------------------------------; 
 E0A8  81 3E 0472 R 1234		CMP	WARM_FLAG_ABS, WARM_BOOT 
 E0AE  75 03				JNZ	POST_FLAG_DONE 
 E0B0  BD 8000				MOV	BP, MASK WARM		; clear and set POST warm boot flag 
 E0B3				POST_FLAG_DONE: 
				 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Setup SS = CS 
				;----------------------------------------------------------------------------; 
				; Set up temporary stack to point at ROM to enable CALL_NS MACRO 
				;----------------------------------------------------------------------------; 
 E0B3  8C CA				MOV	DX, CS 			; DX = 0F000h (BIOS segment) 
 E0B5  8E D2				MOV	SS, DX			; SS = temp boot stack in CS 
				 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-51


				;----------------------------------------------------------------------------; 
				; [5] Setup 8255 PPI to normal operating state 
				;----------------------------------------------------------------------------; 
				; Normal operation: Mode 0, Ports A,C (U and L) as INPUT, Port B as OUTPUT 
				;----------------------------------------------------------------------------; 
 E0B7				RESET_PPI: 
							ELSE 
 E0B7  B0 99				MOV	AL, PPI_CR <>		; set 8255 A,C to INPUT, B to OUTPUT 
							ENDIF 
 E0B9  E6 63				OUT	PPI_CW, AL 			; send to PPI control port (63H) 
				 
				;----------------------------------------------------------------------------; 
				; Set up PPI port B 
				; 
 E0BB  B0 AC				MOV	AL, PPI_B_BOOT		; KB hold low+disable, NMI on, spkr off 
 E0BD  E6 61				OUT	PPI_B, AL			; send to 8255 Port B 
				 
							ENDIF			; ENDIF ARCH_TD3300 
				 
							ENDIF			; ENDIF ARCH_LASER 
				 
				;			IF (ARCH_TYPE EQ ARCH_EMU) AND (ARCH_SUB_TYPE EQ ARCH_MIST) 
				;----------------------------------------------------------------------------; 
				; Set up Turbo mode for PCXT_MiSTer 
				; 
				;	MOV	DX, MC_PORT			; DX = XTCTL port 
				;	IN	AL, DX			; read current speed 
				;	AND	AL, NOT MCSP_SPD		; clear speed bits 
				;			IF BOOT_SPEED EQ BOOT_TURBO 
				;	OR	AL, MC_XTCTL <MCSP_AT4>	; boot to AT 4MHz 
				;			ELSE 
				;	OR	AL, MC_XTCTL <,,,,MCSP_5> ; boot to XT 5MHz 
				;			ENDIF 
				;	OUT	DX, AL			; set new speed 
				;	MOV	DX, SS			; restore DX 
				;			ENDIF			; ARCH_MIST 
				 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; [9] Disable the 8237 DMA controller chip. 
				;----------------------------------------------------------------------------; 
 E0BF				INIT_DMA1: 
 E0BF  B0 04				MOV	AL, MASK DDIS		; Set Controller Disable bit 
 E0C1  E6 08				OUT	DMA_CMD, AL 		; write to DMA Command Register 
				 
							IF POST_TEST_PIT_1 EQ 1 
				;----------------------------------------------------------------------------; 
				; [10] Test Channel #1 on 8253 timer chip. 
				;----------------------------------------------------------------------------; 
				; Channel #1 on 8253 timer chip. Channel #1 is used in RAM refresh process.   
				; If the test fails, beep failure code 
				; 
				; Test that all data lines are working by reading counter and checking  
				; that all bits from counter go both high and low. 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-52


				;----------------------------------------------------------------------------; 
				; Use 16-bit mode to test low three address lines using high byte of counter. 
				; This avoids a situation where the read counter code is a binary multiple 
				; of the counter causing a bit to not be observed as changing. 
				; 
				; Control Word Counter 1 (port 43H) - System Timer: 
				;  01 		- SC: Select Counter 1 
				;    11		- RW: Read/Write 2xR/2xW 
				;      010		- M:  Mode 2, Rate Gen 
				;         0		- BCD: 0 
				; 
				; Output: Success SI and DI = 0, Failure 3 short, 2 long beeps 
				;----------------------------------------------------------------------------; 
						IF DRAM_REFRESH GT 0	; is DRAM refresh enabled? 
 E0C3  B0 74				MOV	AL, PIT_CW <1, 11B, 2>	; Control Word: Counter 1 
										;   Format: R/W low/high byte: 11b 
										;   Mode: 2 Rate Gen, BCD: 0 
 E0C5  BA 0041				MOV	DX, LOW PIT_CH1		; DX = PIT channel 1 
						ENDIF 
 E0C8  E6 43				OUT	PIT_CTRL, AL		; set Counter mode 
 E0CA  EE				OUT	DX, AL			; set low byte (any value) 
 E0CB  BE 07F8				MOV	SI, 0FFH SHL 3		; flag bits 10-3 for 1 check 
 E0CE  BF F807				MOV	DI, NOT 0FFH SHL 3	; flag bits 10-3 for 0 check 
 E0D1  EE				OUT	DX, AL			; set high byte (any value) 
 E0D2				INIT_PIT1_TEST: 
 E0D2  85 FF				TEST	DI, DI			; have all bits flipped to 0? 
 E0D4  75 04				JNZ	INIT_PIT1_TEST_READ	; if not, keep reading PIT 
 E0D6  46				INC	SI				; have all bits flipped to 1? 
 E0D7  74 13				JZ	INIT_PIT1_TEST_DONE	; if so, success 
 E0D9  4E				DEC	SI				; if not, undo INC and keep reading PIT 
 E0DA				INIT_PIT1_TEST_READ: 
						IF DRAM_REFRESH GT 0	; is DRAM refresh enabled? 
 E0DA  B0 40				MOV	AL, PIT_CW <1,0>		; latch Counter 1 command 
						ENDIF 
 E0DC  E6 43				OUT	PIT_CTRL, AL		; write command to CTC 
 E0DE  EC				IN	AL, DX			; read timer LSB 
 E0DF  8A E0				MOV	AH, AL			; save LSB 
 E0E1  EC				IN	AL, DX			; read timer MSB 
 E0E2  23 F8				AND	DI, AX			; clear all lines read as 0 
 E0E4  0B F0				OR	SI, AX			; set all lines read as 1 
 E0E6  E2 EA				LOOP	INIT_PIT1_TEST		; loop until timeout 
 E0E8  B3 32				MOV	BL, BEEP_SL <3,2>		; beep pattern (3 short, 2 long) 
 E0EA				HALT_ERROR: 
 E0EA  EB 69				JMP	SHORT HALT_BEEP_1		; NEAR jump for POST errors 
							ENDIF 
				 
 E0EC				INIT_PIT1_TEST_DONE: 
				 
				;----------------------------------------------------------------------------; 
				; [9B] 8253 PIT Programmable Interval Timer Initialization Channel 1 
				;----------------------------------------------------------------------------; 
				; Counter 1 - DRAM Refresh 
				;----------------------------------------------------------------------------; 
 E0EC				INIT_PIT1: 
							ELSE 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-53


				;----------------------------------------------------------------------------; 
				; Program PIT with single byte 
				; 
 E0EC  B0 54				MOV	AL, PIT_CW <1, 01B, 2>	; Control Word: Select Counter(SC): 1 
										;   Format(RW): 01b (R/W byte LE) 
										;   Mode(M): 2 (Rate Gen), BCD: 0 (Binary) 
 E0EE  E6 43				OUT	PIT_CTRL, AL		; set Counter mode 
				 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; [12] Reset, Clear and test DMA Offset and Block Size Registers 
				;----------------------------------------------------------------------------; 
				; - Master Reset of DMA controller 
				; - Test 8237 DMA Address/Count Register channels 0-3 
				;----------------------------------------------------------------------------; 
 E0F0  E6 0D				OUT	DMA_RESET, AL 		; Master Reset (send any value of AL) 
				 
							IF POST_TEST_DMA EQ 1 
 E0F2  B4 08				MOV	AH, 8				; test 8 ports 
 E0F4  99				CWD					; starting at port 00H 
					CALL_NS  PORT_TEST		; ZF and CX = 0 if pass, NZ if failed 
 E0F5  BC E0FB R             1		MOV	SP, OFFSET ??0001 
			     1				ELSE 
 E0F8  E9 E7EB R             1		JMP	PORT_TEST 
			     1				ENDIF 
 E0FB                        1	??0001: 
 E0FB  E0FD R                1		DW	OFFSET ??0002 
 E0FD                        1	??0002: 
 E0FD  B3 42				MOV	BL, BEEP_SL <4,2>		; beep pattern (4 short, 2 long) 
 E0FF  75 E9				JNZ	HALT_ERROR 
 E101				DMA_PASS: 
 E101  E6 0D				OUT	DMA_RESET, AL 		; master reset of DMA again 
							ENDIF			; POST_TEST_DMA 
				 
							IF DRAM_REFRESH GT 0 
				;----------------------------------------------------------------------------; 
				; [13] Set Counter DMA Channel 0 for memory refresh 
				;----------------------------------------------------------------------------; 
				; https://www.reenigne.org/blog/how-to-get-away-with-disabling-dram-refresh/ 
				;----------------------------------------------------------------------------; 
 E103  B0 FF				MOV	AL, 0FFH			; Memory refresh counter (16-bit) is 0FFFFH 
 E105  E6 01				OUT	DMA_0_C, AL			; write low order bits 
 E107  90				NOP					; very short I/O delay 
 E108  E6 01				OUT	DMA_0_C, AL			; write high order bits 
				 
				;----------------------------------------------------------------------------; 
				; [13] Set Mode DMA Channel 0 
				;----------------------------------------------------------------------------; 
				; 01 			; Mode 1 (Single) 
				;   0 		; INC: address decrement 
				;    1 		; Auto-initialization 
				;     10 		; type: Read from memory (2) 
				;       00 		; Channel 0 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-54


 E10A  B0 58				MOV	AL, DMA_MR <1,0,1,2,0> 
 E10C  E6 0B				OUT	DMA_MODE, AL		; write to DMA Mode Register 
				 
				;----------------------------------------------------------------------------; 
				; [13B] 8253 Timer set channel #1 for DMA/DRAM refresh 
				;----------------------------------------------------------------------------; 
 E10E  B0 12				MOV	AL, LOW DRAM_REFRESH	; set low byte of divisor 
 E110  E6 41				OUT	PIT_CH1, AL			;  
								ENDIF 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; [13C] Enable DMA and clear mask register on Channels 0-3 
				;----------------------------------------------------------------------------; 
 E112  B0 00				MOV	AL, DMA_CR <>		; Set Controller Enable bit 
 E114  E6 08				OUT	DMA_CMD, AL 		; write to DMA Command Register 
 E116  B1 03				MOV	CL, 3				; Set mode on Channels 1-3 for [13D] 
										;  (and I/O delay between OUTs) 
 E118  E6 0A				OUT	DMA_MASK, AL		; clear mask (enable) on all channels 
				 
				;----------------------------------------------------------------------------; 
				; [13D] Set default Mode for DMA Channels 1-3 
				;----------------------------------------------------------------------------; 
				; 01 			; Mode 1 (Single) 
				;   0 		; INC: address decrement 
				;    0 		; No Auto-initialization 
				;     00 		; type: Verify (0) 
				;       xx 		; Channels 1-3 
				; 
				; Input: CL = 3 (from [13C]), CH = 0 (from CALL_NS in [12]) 
				;----------------------------------------------------------------------------; 
 E11A  B0 41				MOV	AL, DMA_MR <1,0,0,0,1>	; start with channel 1 
 E11C				DMA_SETUP_CH: 
 E11C  E6 0B				OUT	DMA_MODE, AL		; write to DMA Mode Register 
 E11E  40				INC	AX				; next channel 
 E11F  E2 FB				LOOP	DMA_SETUP_CH		; (delay 13-17 clocks between OUTs) 
				 
							IF EXP_UNIT EQ 1 
				;----------------------------------------------------------------------------; 
				; [14] Detect and enable 5161 expansion chassis / extension card 
				;----------------------------------------------------------------------------; 
				; http://minuszerodegrees.net/5161/doco/5161_documentation.htm 
				; 
				; http://minuszerodegrees.net/5161/misc/5161_not_supported.htm 
				; "note: research revealed that the substituted code is not required; the 
				; circuit diagram of the extender card shows that the card is automatically 
				; enabled at application of power." 
				; 
				; Based on the above, it would appear this may not be necessary. 
				;----------------------------------------------------------------------------; 
 E121				INIT_EXP_CHASSIS: 
 E121  BA 0213				MOV	DX, EXP_UNIT_CTRL		; PC Expansion Chassis 
							ENDIF 
 E124  B0 01				MOV	AL, 1 			; otherwise, send 1 to enable 
 E126  EE				OUT	DX, AL 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-55


 E127				INIT_EXP_CHASSIS_DONE: 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; [15] Test and zero first 16KB of RAM 
				;----------------------------------------------------------------------------; 
				; This is necessary to utilize the BIOS Data Area and a usable stack 
				; 
				; Parity bits are in an indeterminate state on power up so parity check must 
				; be disabled until memory is written once. 
				; 
				; On failure: 
				; - Read/Write Error: 1 short, 3 long beeps 
				; - Parity Error: 1 short, 4 long beeps 
				; 
				; Input: CX = 0 from [13D] 
				;----------------------------------------------------------------------------; 
							ASSUME DS:_BDA_ABS, ES:_IVT 
 E127				BASE_RAM_TEST: 
 E127  E4 61				IN	AL, PPI_B 				; AL = PB0 flags 
 E129  0C 30				OR	AL, MASK PBIO OR MASK PBPC	; disable RAM parity and I/O ch. flags 
 E12B  E6 61				OUT	PPI_B, AL 
 E12D  91				XCHG	AX, CX				; AX = 0 = MEM_CHECK pattern and 
 E12E  8E D8				MOV	DS, AX				; DS and ES = IVT segment 0000 
 E130  BE 0472 R			MOV	SI, OFFSET WARM_FLAG_ABS	; SI = warm boot flag offset 
 E133  8B 14				MOV	DX, [SI]				; save warm boot flag 
					CALL_NS  MEM_CHECK			; clear memory and parity bits 
 E135  BC E13B R             1		MOV	SP, OFFSET ??0003 
			     1				ELSE 
 E138  E9 E5C2 R             1		JMP	MEM_CHECK 
			     1				ENDIF 
 E13B                        1	??0003: 
 E13B  E13D R                1		DW	OFFSET ??0004 
 E13D                        1	??0004: 
 E13D  75 14				JNZ	BASE_RAM_ERROR 
 E13F  E4 61				IN	AL, PPI_B				; read PPI channel B 
 E141  0C 10				OR	AL, MASK PBPC 			; clear MB RAM parity flag only 
 E143  E6 61				OUT	PPI_B, AL 
 E145  24 EF				AND	AL, NOT MASK PBPC 		; enable MB RAM parity for test 
 E147  E6 61				OUT	PPI_B, AL 
					CALL_NS  MEM_ADDR_TEST			; test address lines 
 E149  BC E14F R             1		MOV	SP, OFFSET ??0005 
			     1				ELSE 
 E14C  E9 E591 R             1		JMP	MEM_ADDR_TEST 
			     1				ENDIF 
 E14F                        1	??0005: 
 E14F  E151 R                1		DW	OFFSET ??0006 
 E151                        1	??0006: 
 E151  74 05				JZ	BASE_RAM_ZERO			; continue if no errors 
 E153				BASE_RAM_ERROR: 
 E153  B3 13				MOV	BL, BEEP_SL <1,3>			; on failure, 1 short and 3 long beeps 
 E155				HALT_BEEP_1: 
 E155  E9 E874 R			JMP	HALT_BEEP				; NEAR jump to HALT BEEP PROC 
 E158				BASE_RAM_ZERO: 
 E158  B8 731D				MOV	AX, RAM_TEST			; test pattern 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-56


					CALL_NS  MEM_CHECK			; write and verify test pattern 
 E15B  BC E161 R             1		MOV	SP, OFFSET ??0007 
			     1				ELSE 
 E15E  E9 E5C2 R             1		JMP	MEM_CHECK 
			     1				ENDIF 
 E161                        1	??0007: 
 E161  E163 R                1		DW	OFFSET ??0008 
 E163                        1	??0008: 
 E163  75 EE				JNZ	BASE_RAM_ERROR			; ZF and AX = 0 if okay 
					CALL_NS  MEM_CHECK			; write and verify zeros 
 E165  BC E16B R             1		MOV	SP, OFFSET ??0009 
			     1				ELSE 
 E168  E9 E5C2 R             1		JMP	MEM_CHECK 
			     1				ENDIF 
 E16B                        1	??0009: 
 E16B  E16D R                1		DW	OFFSET ??000A 
 E16D                        1	??000A: 
 E16D  75 E4				JNZ	BASE_RAM_ERROR 
 E16F  87 14				XCHG	[SI], DX				; restore warm boot flag, DX = 0 
 E171  40				INC	AX					; AL = 1 
 E172  A2 0440 R			MOV	FD_MOTOR_CT_ABS, AL 		; set motor to turn off on next tick 
							ENDIF				; END RAM_PARITY EQ 1 
				 
				;----------------------------------------------------------------------------; 
				; 
				; YAY! It's now okay to use the first 16KB of RAM: 0000:0000-0000:1FFF 
				; 
				;----------------------------------------------------------------------------; 
				 
				;----------------------------------------------------------------------------; 
				; [18] Setup BOOT R/W stack memory segment 
				;----------------------------------------------------------------------------; 
							ASSUME SS:_BOOT_STACK 
 E175  B8 ---- R			MOV	AX, SEG STACK_TOP 		; SS:SP to temp boot stack 0030:0100 
 E178  8E D0				MOV	SS, AX 
 E17A  BC 0100 R			MOV	SP, OFFSET STACK_TOP 
				 
				;----------------------------------------------------------------------------; 
				; [19] 8259A PIC Interrupt controller Initialization 
				;----------------------------------------------------------------------------; 
				; PIC chip Initialization as follows: 
				; 
				; ICW1: 
				;     1 		- D4:   1 = ICW1 (and Port 0) 
				;      0 		- LTIM: 0 = Edge Triggered Mode (low to high TTL transition) 
				;       0 		- ADI:  0 = Call Address Interval of 8 
				;        1 		- SNGL: 1 = Single mode (no cascading PICs or ICW3) 
				;         1		- IC4:  1 = ICW4 Needed 
				;----------------------------------------------------------------------------; 
				; ICW2: 
				;  00001 		- T7-T3: Interrupt Vector Address: 
				;				INT = INT | 8 -> IRQ 0-7 to CPU INT 8-15 
				;       000 	- D2-D0: unused on 8086 mode 
				;----------------------------------------------------------------------------; 
				; ICW4: 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-57


				;     0		- SFNM: 0 = Not Special Fully Nested Mode 
				;      10		- BUF:  2 = Buffered Mode/Slave 
				;        0		- AEOI: 0 = normal EOI 
				;         1		- uPM:  1 = 8086 system 
				;----------------------------------------------------------------------------; 
 E17D  B2 20				MOV	DL, LOW INT_P0		; DX = PIC Port 0 
 E17F  B0 13				MOV	AL, ICW1 <1,0,0,1,1>	; AL = ICW1 - Port 0 
 E181  EE				OUT	DX, AL 
 E182  42				INC	DX				; DX = PIC Port 1 
 E183  B8 0108				MOV	AX, DBW <1,ICW2 <1>> 	; AL = ICW2 - Port 1, AH = PORT_TEST count 
 E186  EE				OUT	DX, AL 
 E187  40				INC	AX				; AL = ICW4 <0,2,0,1> - Port 1 
 E188  EE				OUT	DX, AL 
				 
							IF POST_TEST_PIC_REG EQ 1 
				;----------------------------------------------------------------------------; 
				; [22] 8259A PIC Test 
				;----------------------------------------------------------------------------; 
				; - Read and write registers (IMR) and verify result 
				;----------------------------------------------------------------------------; 
 E189  E8 E7EB R			CALL	PORT_TEST			; test of PIC IMR register 
 E18C  B3 52				MOV	BL, BEEP_SL <5,2>		; beep error 5 short, 2 long 
 E18E  74 02				JZ	PIC_REG_PASS 
 E190				PIC_INT_FAIL: 
 E190  EB C3				JMP	SHORT HALT_BEEP_1 
 E192				PIC_REG_PASS: 
 E192  4A				DEC	DX				; DX = Port 1 (0021h) 
							ENDIF			; IF POST_TEST_PIC_REG EQ 1 
				 
 E193  B0 FF				MOV	AL, OCW1 <1,1,1,1,1,1,1,1> ; OCW1 - mask all interrupts (for now) 
 E195  EE				OUT	DX, AL			; write IMR to PIC 
				 
							IF POST_TEST_PIC_INT EQ 1 
				;----------------------------------------------------------------------------; 
				; - Set up test interrupt handler for all interrupts 
				; 
 E196				PIC_INT_TEST: 
 E196  B1 1F				MOV	CL, 1FH			; 0 - 1EH BIOS vectors (LOW L_VECTOR_TABLE) 
 E198  33 FF				XOR	DI, DI			; DI = beginning to IVT 
 E19A				PIC_VECT_TMP_LOOP: 
 E19A  B8 FF23 R			MOV	AX, OFFSET INT_IRQ	; offset for handler 
 E19D  AB				STOSW					; write to IVT (ES=0000 from CPU_REG_TEST) 
 E19E  8C C8				MOV	AX, CS			; segment for handler (BIOS) 
 E1A0  AB				STOSW					; write to IVT 
 E1A1  E2 F7				LOOP	PIC_VECT_TMP_LOOP 
				 
				;----------------------------------------------------------------------------; 
				; - Mask all interrupts and ensure none are received 
				; Input: AL = 0 (from MOV AX, CS) 
				; 
 E1A3  BF 046B R			MOV	DI, OFFSET INT_LAST_ABS 
 E1A6  88 05				MOV	[DI], AL			; clear last interrupt flag 
 E1A8  FB				STI					; enable interrupts 
					IO_DELAY				; wait for it... 
 E1A9                        1	??000B: 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-58


 E1A9  E2 FE                 1		LOOP	??000B					; long delay for I/O 
 E1AB  FA				CLI 
 E1AC  43				INC	BX				; beep error 5 short, 3 long 
 E1AD  08 05				OR	[DI], AL			; did any interrupts happen? 
				 
							IF POST_TEST_PIC_REG EQ 1 
 E1AF  75 DF				JNZ	PIC_INT_FAIL 
							ENDIF			; IF POST_TEST_PIC_REG EQ 1 
							ENDIF			; IF POST_TEST_PIC_INT EQ 1 
				 
 E1B1  B0 FE				MOV	AL, NOT MASK IRQ0		; OCW1 - unmask timer 
 E1B3  EE				OUT	DX, AL			; write IMR to PIC 
				 
 E1B4				PIC_INT_PASS: 
				 
				;----------------------------------------------------------------------------; 
				; [23] Setup Channel #0 on 8253 timer chip. 
				;----------------------------------------------------------------------------; 
				; Control Word Counter 0 (port 43H) - System Timer: 
				;  00 		- SC: Select Counter 0 
				;    11		- RW: Read/Write 2xR/2xW 
				;      011		- M:  Mode 3, Square Wave 
				;         0		- BCD: 0 
				;----------------------------------------------------------------------------; 
 E1B4  B0 36				MOV	AL, PIT_CW <0, 11B, 3>	; Control Word: Select Counter(SC): 1 
										;   Format(RW): 11b (Read/Write 2xR/2xW) 
										;   Mode(M): 2 (Rate Gen), BCD: 0 (Binary) 
 E1B6  E6 43				OUT	PIT_CTRL, AL 
 E1B8  0E				PUSH	CS				; I/O delay and set up for DS = CS below 
				 
				;----------------------------------------------------------------------------; 
				; This is what generates IRQ 0 (system timer). 
				; Timer set channel #0 output to a square wave of approx. 18.2 Hz based on 
				;	f = 1,193,181.81 / 10000H = ~ 18.2Hz 
				; Reload counter to WORD (0) to port 40H 
				; 
 E1B9  32 C0				XOR	AL, AL			; reload counter is 2^16 (0) ~ 18.2Hz 
 E1BB  E6 40				OUT	PIT_CH0, AL	  		; send low byte 
 E1BD  1F				POP	DS				; I/O delay and set DS = CS 
 E1BE  E6 40				OUT	PIT_CH0, AL 		; send high byte 
				 
				;----------------------------------------------------------------------------; 
				; [25] Setup default BIOS interrupt vectors (00h - 01Eh) 
				;----------------------------------------------------------------------------; 
				; All segments are set to BIOS (CS) segment by default. 
				; INT 1Fh is skipped and left as 0000:0000. 
				; Exceptions (such as ROM BASIC) are reset below. 
				; Input: ES = 0000 from CPU_REG_TEST 
				;----------------------------------------------------------------------------; 
							ASSUME DS:BIOS, ES:_IVT 
 E1C0				INIT_SW_INT_VECTORS: 
 E1C0  8C C8				MOV	AX, CS 			; AX to BIOS segment 
 E1C2  B1 1F				MOV	CL, 1FH			; 0 - 1EH BIOS vectors (LOW L_VECTOR_TABLE) 
 E1C4  33 FF				XOR	DI, DI			; DI = beginning to IVT 
 E1C6  BE FEE3 R			MOV	SI, OFFSET VECTOR_TABLE 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-59


 E1C9				BIOS_INT_VECTORS_LOOP: 
 E1C9  A5				MOVSW 				; copy vector offset to IVT 
 E1CA  AB				STOSW 				; write BIOS/CS segment 
 E1CB  E2 FC				LOOP	BIOS_INT_VECTORS_LOOP	; loop and set CX = 0 
				 
							IF BASIC_ROM EQ 1 
				;----------------------------------------------------------------------------; 
				; Check for valid BASIC ROMs and set INT 18H vector if detected 
				;----------------------------------------------------------------------------; 
				; - Scan 4 x 8K ROMs starting at seg 0F600h. 
				; - BASIC dectected if for all ROMs, all of the folowing are true: 
				; 	- first two bytes not option ROM (0AAFFh) 
				;	- first two bytes not the same as the previous ROM (this checks to 
				;		 make sure are not all 0000 or FFFF) 
				;	- 8K ROM block has a valid checksum at offset 1FFE 
				;----------------------------------------------------------------------------; 
							ASSUME DS:_BASIC 
 E1CD				INIT_ROM_BASIC_SEG: 
 E1CD  BB ---- R			MOV	BX, SEG _BASIC 			; BX = BASIC SEG in ROM 
 E1D0  8B F3				MOV	SI, BX				; SI = save first BASIC SEG 
 E1D2  BF AA55				MOV	DI, MAGIC_WORD			; start with a negative check result 
 E1D5  B1 04				MOV	CL, 4					; checksum 4 x 8K ROMs 
 E1D7				CHECK_BASIC_ROM: 
 E1D7  8E DB				MOV	DS, BX				; set DS to current segment 
 E1D9  A1 0000 R			MOV	AX, BASIC_TOP			; AX = first two bytes of ROM 
 E1DC  3D AA55				CMP	AX, MAGIC_WORD			; is an option ROM? 
 E1DF  74 18				JE	INIT_ROM_BASIC_DONE		; if so, not ROM BASIC 
 E1E1  97				XCHG	AX, DI				; save last ROM's header to DI 
 E1E2  3B C7				CMP	AX, DI				; is same as last ROM? 
 E1E4  74 13				JE	INIT_ROM_BASIC_DONE		; if so, valid ROM not present 
 E1E6  B0 10				MOV	AL, KB < 8 > / 512 		; 8K ROM size (in 512B blocks) 
 E1E8  80 C7 02				ADD	BH, HIGH KBP < 8 >		; BX = next BASIC 8K ROM segment 
 E1EB  E8 E4ED R			CALL	ROM_CHECKSUM 			; checksum ROM at DS:0, size AL 
 E1EE  E1 E7				LOOPZ	CHECK_BASIC_ROM			; loop 4 ROMs or checksum fail 
 E1F0  75 07				JNZ	INIT_ROM_BASIC_DONE		; if NZ, checksum failed 
				 
				;----------------------------------------------------------------------------; 
				; BASIC ROM detected - set as INT 18h in IVT 
				; 
 E1F2  BF 0060 R			MOV	DI, OFFSET IVT_18			; DI = BASIC offset in IVT 
 E1F5  91				XCHG	AX, CX				; AX = vector offset 0000 
 E1F6  AB				STOSW 					; write to IVT 
 E1F7  96				XCHG	AX, SI 				; AX = BASIC SEG 
 E1F8  AB				STOSW						; write to IVT 
 E1F9				INIT_ROM_BASIC_DONE: 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; [18] Setup DS and ES to BDA segment 
				;----------------------------------------------------------------------------; 
							ASSUME DS:_BDA, ES:_BDA 
 E1F9  B8 ---- R			MOV	AX, SEG _BDA 			; DS and ES to BDA 
 E1FC  8E D8				MOV	DS, AX 
 E1FE  8E C0				MOV	ES, AX 
				 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-60


				;----------------------------------------------------------------------------; 
				; Check CPU type 
				;----------------------------------------------------------------------------; 
				; If V20 is build target but V20 not detected - beep 1 long, 4 short 
				;----------------------------------------------------------------------------; 
 E200				CPU_IS_V20: 
 E200  B8 0101				MOV	AX, DBW <1,1>			; Attempt to pack bytes into nibbles 
					AAD_I	10H					; result is 11 if V20, 11H if x86 
 E203  D5 10                 1		DB	0D5H, 10H			; AAD	imm 
 E205  3C 0B				CMP	AL, 11				; ZF = 1 if V20, ZF = 0 if 8088 
 E207  75 05				JNE	CPU_TYPE_8088			; jump if not V20 
					SET_GFLAG	V20				; set V20 flag 
			     1				ENDIF 
 E209  80 0E 0012 R 04       1		OR	GB_FLAGS, MASK V20		; set flag(s) 
							ELSE 
 E20E				CPU_TYPE_8088: 
							ENDIF 
 E20E				CPU_TYPE_DONE: 
				 
				;----------------------------------------------------------------------------; 
				; [14] Read DIP switch settings and init proper EQUIP_FLAGS 
				;----------------------------------------------------------------------------; 
				; 
				; https://sites.google.com/site/pcdosretro/biosdata 
				; https://stanislavs.org/helppc/int_11.html 
				; 
				; 5150 Sense Switches: 
				;  Port A - when Port B bit 7 = 1 
				;     High| Low 
				; 	00  |			; Disk Drives (00=1, 01=2, 10=3, 11=4) 
				; 	  00| 		; Video (00=EGA/VGA, 01=CGA 40, 10=CGA 80, 11=MDA) 
				;	    |00		; MB RAM (00=16KB, 01=32K, 10=48K, 11=64K) 
				;	    |  0		; FPU installed ("Reserved") 
				; 	    |   0		; IPL Floppy Disk Drive (0=floppy drive installed) 
				;  Port C - I/O RAM (x 32KB) 
				;	High| Low 
				;	    |4321		; RAM size bits 1-4   when Port B bit 2 = 1 
				;	     4325		; RAM size bits 5,2-4 when Port B bit 2 = 0 
				;----------------------------------------------------------------------------; 
				; 5160 Sense Switches: 
				;  Port C 
				;	High| Low 
				; 	00  |			; Disk Drives (00=1, 01=2, 10=3, 11=4) 
				; 	  00| 		; Video (00=EGA/VGA, 01=CGA 40, 10=CGA 80, 11=MDA) 
				;	    |00		; MB RAM Banks (00=Bank 0, Bank 0/1, 10=0/1/2, 11=0/1/2/3) 
				;	    |  0		; FPU installed 
				; 	    |   0		; Test Loop (always 0) 
				; 
				; EQUIP_FLAGS: LPT:2,X1:1,GAM:1,COM:3,DMA:1,FLP:2,VID:2,MBRAM:2,FPU:1,IPL:1 
				;----------------------------------------------------------------------------; 
 E20E				GET_SW_SETTINGS: 
 E20E  E4 61				IN	AL, PPI_B 				; read Port B register 
 E210  50				PUSH	AX					; save original switches, AH = 0 
				 
						ELSE 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-61


						ELSE                          ; not ARCH_5150 OR ARCH_FE2010 
						ELSE 
				;----------------------------------------------------------------------------; 
				; Is a 5160 or standard PPI 
				; 
 E211				SETTINGS_5160: 
 E211  24 F7				AND	AL, NOT MASK PBSW			; set bit 3 = 0 for low switch select 
 E213  E6 61				OUT	PPI_B, AL 
 E215  50				PUSH	AX		 			; save port settings 
 E216  E4 62				IN	AL, PPI_C 				; get low switches 
							ELSE 
 E218  24 0F				AND	AL, MASK MBRAM OR MASK FPU OR MASK IPL ; isolate MB RAM and FPU bits 
 E21A  8A E8				MOV	CH, AL				; save to CH 
							ENDIF 
 E21C  58				POP	AX 					; get port settings 
 E21D  0C 08				OR	AL, MASK PBSW 			; set bit 3 = 1 for high switch select 
 E21F  E6 61				OUT	PPI_B, AL 
 E221  E4 62				IN	AL, PPI_C 				; get high switches 
							ELSE 
 E223  B1 04				MOV	CL, 4 
 E225  D2 E0				SHL	AL, CL				; shift drives and video to high nibble 
 E227  0A C5				OR	AL, CH				; combine RAM, FPU with drives and vid 
							ENDIF 
				 
							ENDIF 
				 
						ENDIF					; not ARCH_TYPE EQ ARCH_EHB 
						ENDIF					; not ARCH_TYPE EQ ARCH_FE2010 
						ENDIF					; not ARCH_TYPE EQ ARCH_5150 
				 
 E229				SETTINGS_DONE: 
				;----------------------------------------------------------------------------; 
				; If set on MB DIP SW1, test and verify FPU. If not detected, disable in BDA. 
				; 
 E229  A8 02				TEST	AL, MASK FPU			; is FPU set? 
 E22B  74 07				JZ	SETTINGS_SAVE			; if not, skip to save flags 
 E22D  E8 FFC3 R			CALL	HAS_FPU				; check FPU, ZF=0 if not detected 
 E230  74 02				JZ	SETTINGS_SAVE			; if detected, save flags 
							ELSE 
 E232  24 FD				AND	AL, NOT MASK FPU			; otherwise clear FPU flag 
							ENDIF 
 E234				SETTINGS_SAVE: 
 E234  A2 0010 R			MOV	BYTE PTR EQUIP_FLAGS, AL	; set to low byte of EQUIP_FLAGS 
				 
							ENDIF 
				 
 E237  92				XCHG	AX, DX				; save EQUIP_FLAGS to DL for later 
 E238  58				POP	AX					; AL = original settings, AH = 0 
 E239  E6 61				OUT	PPI_B, AL				; restore original settings 
				 
							ENDIF 
				 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-62


				; [21] Video BIOS Option ROM scan 
				;----------------------------------------------------------------------------; 
				; Scan 0C000H - 0C800H for video option ROMs (EGA, VGA, etc) 
				; 
				; A video option ROM should set the BDA video type flag to a non-zero value 
				; If the flag is still 0 afterwards, no ROMs loaded succesfully. 
				;----------------------------------------------------------------------------; 
 E23B  B8 ---- R			MOV	AX, SEG _VID_BIOS			; starting segment (C000H) 
 E23E  BF ---- R			MOV	DI, SEG _OPT_ROM			; ending segment (C800H) 
 E241  52				PUSH	DX					; save EQUIP_FLAGS for below 
 E242  E8 E4AA R			CALL	BIOS_ROM_SCAN			; scan segments AX to DI for ROMs 
 E245  5A				POP	DX					; restore EQUIP_FLAGS 
				 
				;----------------------------------------------------------------------------; 
				; Check for a valid video mode in BDA: 
				;  - If BDA video mode is 0, video option ROM was not loaded. Beep and halt 
				;  - If MB video switch is 0 (option ROM), skip reset 
				;  - If not 0, determine correct 6845 video mode and do INT 10H reset 
				;----------------------------------------------------------------------------; 
					GET_EFLAG  VID				; AX = 00=error(ZF), 01=CGA 40, 10=CGA 80, 11=MDA 
			     1				ENDIF 
			     1	;----------------------------------------------------------------------------; 
			     1	; Shift if flag is in high byte to low for byte operations 
			     1	; 
			     1				IF VID LT 8		; is in low byte? 
 = 0030                      1	??000C	= MASK VID 
 = 0004                      1	??000D	= VID AND 0111B 
 = 0010                      1	??000E	= EQUIP_FLAGS[0]			; low BDA flags byte 
			     1					ENDIF 
			     1				ENDIF 
 E246  A0 0010 R             1		MOV	AL, BYTE PTR ??000E		; AL = equipment flag byte 
 E249  25 0030               1		AND	AX, ??000C			; isolate bits, clear AH 
			     1	;----------------------------------------------------------------------------; 
			     1	; Determine optimal number of shifts based on bit position and shift 
			     1	; right or left depending on fewest. 
			     1	; 
			     1				ELSE 
			     1					ELSE			; optimal to roll right 
			     1						IF ??000D GT 2 
 E24C  B1 04                 1		MOV	CL, ??000D			; CL = bit(s) position of record 
 E24E  D2 C8                 1		ROR	AL, CL				; shift value into position 
			     1						ENDIF 
			     1					ENDIF 
			     1				ENDIF 
			     1				ENDIF 
 E250  75 05				JNZ	VID_MODE_OK				; jump if mode valid or video option ROM loa
				ded 
 E252  B3 33				MOV	BL, BEEP_SL <3,3>			; Beep 3 long, 3 short 
 E254				HALT_BEEP_2: 
 E254  E9 E874 R			JMP	HALT_BEEP				; NEAR jump to beep 
 E257				VID_MODE_OK: 
 E257  F6 C2 30				TEST	DL, MASK VID			; is SW1 mode 00? 
 E25A  74 07				JZ	RESET_VIDEO_DONE			; if custom video ROM, skip reset 
 E25C  BB E82A R			MOV	BX, OFFSET VID_MODE_TBL[-1]	; AL = BDA video type, BX = mode table 
 E25F  2E: D7				XLAT	CS:[BX]				; AL = INT 10H video mode 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-63


				 
				;----------------------------------------------------------------------------; 
				; Clear screen and reset the video display 
				; 
 E261				RESET_VIDEO: 
 E261  CD 10				INT	10H					; AH = 0 - Set Video Mode 
 E263				RESET_VIDEO_DONE: 
				 
							IF POST_BANNER EQ 1 
				;----------------------------------------------------------------------------; 
				; Hello Computer ("just use the keyboard") 
				;----------------------------------------------------------------------------; 
 E263				HELLO_WORLD: 
							ELSE 
					PRINTLN_SZ	TOP_BANNER			; display banner and fixed tagline 
			     1			ENDIF 
			     1			IFDIFI <TOP_BANNER>,<SI>			; if SZ is not SI 
 E263  BE E000 R             1		MOV	SI, OFFSET TOP_BANNER 
			     1			ENDIF 
 E266  E8 F742 R             1		CALL	OUTLN_SZ 
			     1			ENDIF 
							ENDIF 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Save the initial cursor mode to BDA for hot key and POST display 
				; 
 E269  33 DB				XOR	BX, BX				; BH = video page 0 
 E26B  B4 03				MOV	AH, 3					; get cursor: CX = power-on cursor 
 E26D  CD 10				INT	10H					;  DX = position 
 E26F  89 0E 00E8 R			MOV	CURSOR_DEFAULT, CX		; save to BDA for Turbo toggle 
				 
							IF POST_BANNER EQ 1 
				;----------------------------------------------------------------------------; 
				; Display VERSION notice in bottom left 
				; 
 E273  52				PUSH	DX					; save cursor position 
 E274  BA 1800				MOV	DX, DBW <24, 0> 			; bottom left row = 24, col = 0 
 E277  B4 02				MOV	AH, 2 				; set bottom cursor position  
 E279  CD 10				INT	10H 					; row = DH, column = DL 
					PRINT_SZ  VER				; display version 
			     1			ENDIF 
			     1			IFDIFI <VER>,<SI>			; if SZ is not SI 
 E27B  BE FFE0 R             1		MOV	SI, OFFSET VER 
			     1			ENDIF 
 E27E  E8 F71C R             1		CALL	OUT_SZ 
			     1			ENDIF 
					PRINT_SZ  REL_DATE			; display build date 
			     1			ENDIF 
			     1			IFDIFI <REL_DATE>,<SI>			; if SZ is not SI 
 E281  BE FFF5 R             1		MOV	SI, OFFSET REL_DATE 
			     1			ENDIF 
 E284  E8 F71C R             1		CALL	OUT_SZ 
			     1			ENDIF 
 E287  5A				POP	DX					; restore previous cursor 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-64


 E288  B4 02				MOV	AH, 2 				; reset cursor position 
 E28A  CD 10				INT	10H 					; row = DH, column = DL 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Jump over INT 02h fixed ORG to continue... 
				; 
 E28C  EB 55 90				JMP	NEAR PTR POST_DETECT_PORTS 
				 
				 
							ENDIF				; IF IS_TURBO 
				 
							ENDIF 
				 
							ENDIF 
				 
							ENDIF 
				 
							ENDIF 
				 
							ENDIF 
				 
				; 
				; 1 BYTES HERE 
				; 
				BYTES_HERE	INT_02 
 = 0034                      1	BYTES_HERE_INT_02 = INT_02-$ 
			     1			IFDEF BYTES_HERE_INT_02 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 2 - NMI  
				;----------------------------------------------------------------------------; 
				; If NMI / IRQ 2 occurs (a parity or I/O exception), display error type and 
				; halt. Exit if it was an 8087 exception as that should be intercepted by  
				; a user coprocessor exception handler. 
				;----------------------------------------------------------------------------; 
 E2C3						ORG 0E2C3H 
 E2C3				INT_02 PROC 
 E2C3  50				PUSH	AX 
 E2C4  E4 62				IN	AL, PPI_C 				; get PC0 register 
 E2C6  A8 C0				TEST	AL, MASK PCPE OR MASK PCIE	; parity or I/O error? 
 E2C8  75 02				JNZ	INT_02_NMI_PAR 			; first, check parity 
 E2CA  58				POP	AX					; if neither, exit 
 E2CB  CF				IRET						; must have been an 8087 NMI 
 E2CC				INT_02_NMI_PAR: 
 E2CC  BE E4A2 R			MOV	SI, OFFSET NMI_ERR_PAR 		; Parity error string 
 E2CF  A8 80				TEST	AL, MASK PCPE			; parity error? 
 E2D1  75 02				JNZ	INT_02_NMI_HALT 
 E2D3  4E				DEC	SI					; otherwise is I/O error 
 E2D4  4E				DEC	SI					; decrement to NMI_ERR_IO 
 E2D5				INT_02_NMI_HALT: 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-65


							ENDIF 
 E2D5  33 C0				XOR	AX, AX				; reset video, clear screen 
 E2D7  E6 A0				OUT	NMI_R0, AL				; mask the unmaskable 
 E2D9  CD 10				INT	10H					; switch to text video mode 
 E2DB  E8 F71C R			CALL	OUT_SZ 				; display string in CS:SI 
 E2DE  E8 E5D1 R			CALL	NMI_RESET				; clear NMI/parity flags 
 E2E1  FA				CLI						; ensure interrupts off 
 E2E2  F4				HLT						; halt CPU 
 E2E3				INT_02 ENDP 
				 
 E2E3				POST_DETECT_PORTS PROC 
				;----------------------------------------------------------------------------; 
				; [37] Setup LPT/COM default timeouts 
				;----------------------------------------------------------------------------; 
							ASSUME ES:_BDA 
 E2E3  BF 0078 R			MOV	DI, OFFSET LPT_TIME 
 E2E6  B8 1414				MOV	AX, DBW <LPT_TO, LPT_TO>	; LPT timeout values 
 E2E9  AB				STOSW						; write x 4 to BDA 
 E2EA  AB				STOSW 
 E2EB  B8 0101				MOV	AX, DBW <COM_TO, COM_TO>	; COM timeout values 
 E2EE  AB				STOSW 
 E2EF  AB				STOSW 
				 
 E2F0  BB 0011 R			MOV	BX, OFFSET EQUIP_FLAGS[1]	; BX = high byte of EQUIP_FLAGS 
				 
				;----------------------------------------------------------------------------; 
				; [38] Detect and enable Game port 
				;----------------------------------------------------------------------------; 
				; Port 201H 
				; Input:  
				;	BX = high byte of EQUIP_FLAGS 
				; 
				; Equipment Bit is set if the lower nibble of an I/O port 201h read is zero 
				; http://www.minuszerodegrees.net/5150_5160/post/IBM%205150%20and%205160%20-%20Bit%2012%20of%20Equip
				ment%20Flag.htm 
				;----------------------------------------------------------------------------; 
 E2F3				POST_DETECT_GAM: 
 E2F3  BA 0201				MOV	DX, GAME_CTRL 
 E2F6  EC				IN	AL, DX 				; will be 0FFH if no port 
 E2F7  A8 0F				TEST	AL, 0FH 
 E2F9  75 03				JNZ	NO_GAME_PORT 
 E2FB  80 0F 10				OR	BYTE PTR [BX], HIGH MASK GAM	; enable Game Port bit 
 E2FE				NO_GAME_PORT: 
				 
				;----------------------------------------------------------------------------; 
				; [37] Detect and enable COM ports 1-4 
				;----------------------------------------------------------------------------; 
				; Ports 3F8H, 2F8H, 3E8H, 2E8H 
				; Input: 
				;	BX = high byte of EQUIP_FLAGS 
				;	ES, DS = BDA segment 
				;----------------------------------------------------------------------------; 
 E2FE				POST_DETECT_COM: 
 E2FE  B9 0004				MOV	CX, 4					; four COM ports 
 E301  33 FF				XOR	DI, DI 				; 00H BDA COM1-4 base addresses 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-66


 E303  BA 03FA				MOV	DX, COM1_IIR			; 3FAH: COM1 Interrupt Ident Reg 
 E306				COM_DETECT_LOOP: 
 E306  32 C0				XOR	AL, AL				; AL = 0 
 E308  EE				OUT	DX, AL				; clear FIFO Control Register (FCR) 
 E309  EC				IN	AL, DX 				; read IIR to clear DMA flags 
 E30A  EC				IN	AL, DX 				; read IIR again 
 E30B  4A				DEC	DX 
 E30C  4A				DEC	DX					; DX = base port 
 E30D  A8 F0				TEST	AL, 11110000B 			; check if any high 4 bits are set 
 E30F  92				XCHG	AX, DX				; AX = detected port 
 E310  75 04				JNZ	NO_COM_PORT				; if so, not a valid port 
 E312  AB				STOSW 					; write I/O port to COM BDA table 
 E313  80 07 02				ADD	BYTE PTR[BX], HIGH(1 SHL COM)	; INC COM port count in flags 
 E316				NO_COM_PORT: 
 E316  2D 00FE				SUB	AX, COM1_DATA-COM2_IIR		; base port to next IIR port 
 E319  92				XCHG	AX, DX				; DX = next IIR port 
 E31A  80 F9 03				CMP	CL, 3 				; is COM2 (COM3 next)? 
 E31D  75 03				JNE	NEXT_COM_PORT			; if not, next 
 E31F  BA 03EA				MOV	DX, COM3_IIR			; restart at 3EAH: COM3 IIR 
 E322				NEXT_COM_PORT: 
 E322  E2 E2				LOOP	COM_DETECT_LOOP 
				 
				;----------------------------------------------------------------------------; 
				; [36] Detect and enable LPT ports 
				;----------------------------------------------------------------------------; 
				; Ports 3BCH, 378H, 278H 
				; Input:  
				;	BX = high byte of EQUIP_FLAGS 
				;	CH = 0 
				;----------------------------------------------------------------------------; 
 E324				POST_DETECT_LPT: 
 E324  B1 03				MOV	CL, 3					; three LPT ports 
 E326  BF 0008 R			MOV	DI, OFFSET LPT_ADDR		; 08H BDA LPT1-3 base addresses 
 E329  BA 03BC				MOV	DX, LPT_MDA				; start with MDA printer base 
 E32C				LPT_DETECT_LOOP: 
 E32C  B0 0B				MOV	AL, MASK LCDR OR MASK LCINI-1	; use init byte - 1 as test data 
 E32E  EE				OUT	DX, AL				; send to LPT data port 
 E32F  42				INC	DX 
 E330  42				INC	DX					; DX = control port 
 E331  40				INC	AX					; AL = Strobe off / init (1100b) 
 E332  EE				OUT	DX, AL				; send to LPT control port 
 E333  4A				DEC	DX 
 E334  4A				DEC	DX					; DX = data port 
 E335  EC				IN	AL, DX				; read from LPT data port 
 E336  34 0B				XOR	AL, MASK LCDR OR MASK LCINI-1	; valid port if same test data 
 E338  75 06				JNZ	NO_LPT_PORT				; if not, not a valid port 
 E33A  92				XCHG	AX, DX				; AX = detected port 
 E33B  AB				STOSW 					; store to LPT BDA table 
 E33C  92				XCHG	AX, DX 
 E33D  80 07 40				ADD	BYTE PTR[BX], HIGH(1 SHL LPT)	; INC LPT port count in flags 
 E340				NO_LPT_PORT: 
 E340  FE CE				DEC	DH 					; DX = DX - 100H (LPT1-LPT2) 
 E342  80 F9 03				CMP	CL, 3 				; is 3BCH (LPT1 next)? 
 E345  75 03				JNE	NEXT_LPT_PORT			; if not, next 
 E347  BA 0378				MOV	DX, LPT1				; restart at 378H: LPT1 data port 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-67


 E34A				NEXT_LPT_PORT: 
 E34A  E2 E0				LOOP	LPT_DETECT_LOOP 
				 
 E34C				POST_DETECT_PORTS ENDP 
				 
						ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Reset Keyboard Interface 
				;----------------------------------------------------------------------------; 
				; http://minuszerodegrees.net/5160/keyboard/5160_keyboard_startup.jpg 
				; 
				; KB Status Port 61h high bits: 
				; 01 - normal operation. wait for keypress, when one comes in, 
				;		force data line low (forcing keyboard to buffer additional 
				;		keypresses) and raise IRQ1 high 
				; 11 - stop forcing data line low. lower IRQ1 and don't raise it again. 
				;		drop all incoming keypresses on the floor. 
				; 10 - lower IRQ1 and force clock line low, resetting keyboard 
				; 00 - force clock line low, resetting keyboard, but on a 01->00 transition, 
				;		IRQ1 would remain high 
				;----------------------------------------------------------------------------; 
 E34C				POST_KB_RESET PROC 
 E34C  BA 0061				MOV	DX, PPI_B 				; DX = PPI port B (61H) 
 E34F  EC				IN	AL, DX 
 E350  24 3F				AND	AL, NOT (MASK PBKB OR MASK PBKC) ; keyboard clock hold LOW and enable 
 E352  EE				OUT	DX, AL				; send to PPI port B 
 E353  96				XCHG	AX, SI				; save modified PPI port B 
				 
				;----------------------------------------------------------------------------; 
				; [31] - Set up and clear keyboard buffer 
				;----------------------------------------------------------------------------; 
 E354  B8 001E R			MOV	AX, OFFSET KB_BUF 		; AX = initial start of buffer 
 E357  BF 001A R			MOV	DI, OFFSET KB_BUF_HD 		; DI = buffer head 
 E35A  AB				STOSW 					; write to head pointer 
 E35B  AB				STOSW 					; write to tail pointer 
 E35C  BF 0080 R			MOV	DI, OFFSET KB_BUF_ST 		; setup buffer start and end 
 E35F  AB				STOSW 
 E360  B0 3E				MOV	AL, KB_BUF_END_B			; (AH already 00) 
 E362  AB				STOSW						; DI = KB_BUF_ST + 4 
				 
				;----------------------------------------------------------------------------; 
				; Hold clock low 20+ ms to signal keyboard to reset. Clear and re-enable. 
				; 
 E363  B0 1E				MOV	AL, 30				; I/O delay for at least 20ms 
 E365  E8 E5E0 R			CALL	IO_DELAY_MS 
 E368  96				XCHG	AX, SI				; restore modified PPI port B 
				 
 E369  0C C0				OR	AL, MASK PBKB OR MASK PBKC	; keyboard enable clock and clear 
 E36B  EE				OUT	DX, AL				; send to PPI port B 
 E36C  51				PUSH	CX					; give a little more time 
 E36D  24 7F				AND	AL, NOT MASK PBKB			; keyboard enable (clear low) 
 E36F  EE				OUT	DX, AL				; send to PPI port B 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-68


				; Unmask KB interrupt IRQ1 
				; 
 E370  E4 21				IN	AL, INT_IMR 			; get PIC Port 1 INT mask 
 E372  96				XCHG	AX, SI 				; SI = save previous INT mask 
 E373  B0 FD				MOV	AL, NOT MASK IRQ1			; unmask only keyboard interrupt 
 E375  E6 21				OUT	INT_IMR, AL 
				 
				;----------------------------------------------------------------------------; 
				; Check if reset scan code was received 
				; 
				; Temporary INT_09_POST interrupt will set 4000H flag on BP 
				; when IRQ1 is received with successful reset code of 0AAh 
				; 
							IF POST_TEST_KB NE 0 
 E377  FB				STI 						; enable interrupts 
 E378				KB_RESET_TEST: 
					IO_DELAY_SHORT				; give a little more time 
			     1				IF ARCH_TYPE NE ARCH_EMU 
 E378  EB 00                 1		JMP	SHORT ??0010 
 E37A                        1	??0010: 
			     1				ENDIF 
					POST_FLAG_TEST  PKI			; KB test flag yet? 
			     1				ELSE 
 E37A  F7 C5 4000            1		TEST	BP, MASK PKI			; Is FLAG set? 
			     1				ENDIF 
 E37E  E1 F8				LOOPZ	KB_RESET_TEST			; Loop until KB flag OR CX is 0 (timeout) 
 E380  FA				CLI 						; disable interrupts again 
					POST_FLAG_FLIP  PKI			; invert PKI flag: 1 = error, 0 = success 
			     1				ELSE 
 E381  81 F5 4000            1		XOR	BP, MASK PKI			; Invert flag 
			     1				ENDIF 
							ENDIF 
					IO_DELAY_LONG 				; additional delay, CX = 0 
			     1				IF ARCH_TYPE NE ARCH_EMU 
 E385  33 C9                 1		XOR	CX, CX 				; delay 65535 LOOPs 
			     1		IO_DELAY 
 E387                        2	??0011: 
 E387  E2 FE                 2		LOOP	??0011					; long delay for I/O 
			     1				ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Ack scan code, clear keyboard again and check that no scan codes were received 
				; 
 E389  EC				IN	AL, DX				; read PPI port B 
 E38A  0C C0				OR	AL, MASK PBKB OR MASK PBKC	; keyboard enable clock and clear 
 E38C  EE				OUT	DX, AL				; send to PPI port B 
 E38D  59				POP	CX					; give a little more time 
 E38E  24 7F				AND	AL, NOT MASK PBKB			; keyboard enable (clear low) 
 E390  EE				OUT	DX, AL				; send to PPI port B 
					IO_DELAY					; delay for KBC, CX = 0 
 E391                        1	??0012: 
 E391  E2 FE                 1		LOOP	??0012					; long delay for I/O 
 E393  E4 60				IN	AL, PPI_A 				; check KB for extraneous key 
							IF POST_TEST_KB NE 0	; all KB tests enabled? 
							ENDIF				; end Key Stuck test 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-69


							ENDIF 
				 
 E395				KB_HAPPY: 
				;----------------------------------------------------------------------------; 
				; Disable keyboard for rest of POST 
				; 
 E395  EC				IN	AL, DX 
 E396  0C C0				OR	AL, MASK PBKB OR MASK PBKC	; keyboard enable clock and clear 
 E398  EE				OUT	DX, AL				; send to PPI port B 
				 
 E399  96				XCHG	AX, SI 				; restore interrupt mask register 
 E39A  E6 21				OUT	INT_IMR, AL 
				 
				;----------------------------------------------------------------------------; 
				; Set up the real INT 09H keyboard interrupt handler 
				; 
							ASSUME ES:_IVT 
 E39C  8E C1				MOV	ES, CX 				; ES = IVT seg (CX is 0 from above) 
 E39E  BF 0024 R			MOV	DI, OFFSET IVT_09 		; DI = INT 9H offset in IVT (24H) 
 E3A1  B8 E987 R			MOV	AX, OFFSET INT_09 		; Vector offset 
 E3A4  AB				STOSW 					; replace in IVT 
				 
 E3A5				POST_KB_RESET ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Begin Hardware POST Test Results 
				;----------------------------------------------------------------------------; 
 E3A5  E8 F03B R			CALL	HIDE_CURSOR				; cursor movement is distracting 
				 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; [17] Detect and test conventional memory 
				;----------------------------------------------------------------------------; 
 E3A8  E8 E501 R			CALL	DETECT_MEMORY			; detect and display memory count 
							ASSUME ES:NOTHING		; ES clobbered by DETECT_MEMORY 
				 
							IF POST_TEST_DMA_TC0 EQ 1 
				;----------------------------------------------------------------------------; 
				; [27B] Verify that the 8237 DMA Channel 0 Terminal Count (TC 0) status bit  
				; is on. This test is only done on a cold boot. 
				;----------------------------------------------------------------------------; 
					JWB	DMA_STATUS_OK			; skip on warm boot 
			     1				ENDIF 
 E3AB  E4 08				IN	AL, DMA_CMD				; verify DMA status register 
 E3AD  A8 01				TEST	AL, MASK TC0			; Channel 0 TC 
 E3AF  75 04				JNZ	DMA_STATUS_OK			; jump if zero reached 
					POST_FLAG_SET  PDMA			; else mark in POST error flags 
			     1				ELSE 
 E3B1  81 CD 0400            1		OR	BP, MASK PDMA			; Set FLAG 
			     1				ENDIF 
 E3B5				DMA_STATUS_OK: 
							ENDIF 
				 
							IF POST_CONFIG EQ 1 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-70


				;----------------------------------------------------------------------------; 
				; Display Additional Configuration Items such as COM/LPT, CPU, FPU, etc 
				;----------------------------------------------------------------------------; 
 E3B5  E8 F5FD R			CALL	POST_SYS_CONFIG			; show CPU, FPU and ports 
							ENDIF 
				 
 E3B8  E8 F032 R			CALL	CRLF_SHOW_CURSOR			; CRLF and re-enable cursor 
				 
				;----------------------------------------------------------------------------; 
				; Unmask IRQs for Timer (IRQ0), Keyboard (IRQ1) and Floppy (IRQ6) 
				;----------------------------------------------------------------------------; 
 E3BB  E4 21				IN	AL, INT_IMR 			; get current OCW1/IMR register 
 E3BD  24 BC				AND	AL, NOT (MASK IRQ6 OR MASK IRQ1 OR MASK IRQ0) ; unmask IR6, IR1, IR0 
 E3BF  E6 21				OUT	INT_IMR, AL 			; send to A1 (Port 1) 
				 
				;----------------------------------------------------------------------------; 
				; [28] Option ROM scan for other ROMs (storage, etc) 
				;----------------------------------------------------------------------------; 
 E3C1  B8 ---- R			MOV	AX, SEG _OPT_ROM			; start at 0C800H 
 E3C4  BF FE00				MOV	DI, OPT_ROM_END			; end below 0FE00H 
 E3C7  E8 E4AA R			CALL	BIOS_ROM_SCAN			; scan for option ROMs, AL = 0 
				 
				;----------------------------------------------------------------------------; 
				; [31] Enable interrupts 
				;----------------------------------------------------------------------------; 
 E3CA  FB				STI 						; Interrupts now enabled 
				 
							ENDIF				; IF FDC_ENABLE 
				 
				;----------------------------------------------------------------------------; 
				; Detect and show hard drive info 
				;----------------------------------------------------------------------------; 
 E3CB				HDD_POST PROC 
							ENDIF				; ENDIF POST_HD_CHECK EQ 1 
 E3CB  E8 F745 R			CALL	CRLF 
 E3CE				HDD_POST_DONE: 
 E3CE				HDD_POST ENDP 
				 
				;----------------------------------------------------------------------------; 
				; [39] Clear and enable I/O and parity NMIs 
				;----------------------------------------------------------------------------; 
 E3CE  E8 E5D1 R			CALL	NMI_RESET				; reset NMI flags 
				 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Enable keyboard 
				; 
 E3D1  E8 E952 R			CALL	KB_BUF_CLEAR			; clear any stray keys in buffer 
 E3D4  E4 61				IN	AL, PPI_B 				; AL = PB0 flags 
 E3D6  24 7F				AND	AL, NOT MASK PBKB			; keyboard clear LOW (enable KB) 
					IO_DELAY_SHORT 
			     1				IF ARCH_TYPE NE ARCH_EMU 
 E3D8  EB 00                 1		JMP	SHORT ??0013 
 E3DA                        1	??0013: 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-71


			     1				ENDIF 
 E3DA  E6 61				OUT	PPI_B, AL				; send to PPI port B 
				 
				;----------------------------------------------------------------------------; 
				; Check for POST errors and clear warm boot flag 
				; 
 E3DC  33 C0				XOR	AX, AX				; AX = 0 
 E3DE  A3 0072 R			MOV	WARM_FLAG, AX			; clear warm boot flag in BDA 
					POST_FLAG_CLR  WARM, 1			; remove warm boot flag, NZ if error 
			     1				IFNB <1> 
 = 0000                      1	??0014	EQU	0				; use AND instruction instead 
			     1				ENDIF 
			     1				ELSE 
 E3E1  81 E5 7FFF            1		AND	BP, NOT MASK WARM			; Clear flag 
			     1				ENDIF 
 E3E5  74 11				JZ	POST_OK				; if no errors, go ahead and boot 
				 
				;----------------------------------------------------------------------------; 
				; Display any POST errors 
				; 
 E3E7				POST_ERROR: 
					PRINT_SZ  POST_ERR			; display "Post Error" 
			     1			ENDIF 
			     1			IFDIFI <POST_ERR>,<SI>			; if SZ is not SI 
 E3E7  BE E8F8 R             1		MOV	SI, OFFSET POST_ERR 
			     1			ENDIF 
 E3EA  E8 F71C R             1		CALL	OUT_SZ 
			     1			ENDIF 
 E3ED  8B C5				MOV	AX, BP				; AX = POST error flags 
 E3EF  E8 F779 R			CALL	WORD_HEX				; display POST error value 
 E3F2  E8 F745 R			CALL	CRLF 
 E3F5  E8 E921 R			CALL	POST_ERROR_MSG			; display POST error messages, BP=0 
				 
							ENDIF 
				 
 E3F8				POST_OK: 
				;----------------------------------------------------------------------------; 
				; Clear screen (partially or completely) and attempt boot 
				; 
 E3F8				CLEAR_POST_SCREEN: 
 E3F8  B7 07				MOV	BH, 7					; attribute fill for on blank line 
							ELSE				; clear only the lower two rows 
 E3FA  B8 0702				MOV	AX, DBW <7, 2>			; AH = 7, scroll down 2 lines 
 E3FD  B9 1700				MOV	CX, DBW <23, 0>			; upper left row 23, column 0 
							ENDIF 
				 
 E400  BA 1950				MOV	DX, DBW <25, 80>			; lower right row 25, column 80 
 E403  CD 10				INT	10H 
				 
							ENDIF 
				 
 E405  E8 E8B0 R			CALL	BEEP 					; beep to signify POST test is done 
							ELSE 
 E408  E8 F745 R			CALL	CRLF 
							ENDIF 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-72


				 
				;----------------------------------------------------------------------------; 
				; [40] DO BOOTSTRAP! 
				;----------------------------------------------------------------------------; 
				 
				;----------------------------------------------------------------------------; 
				; Attempt to IPL three times. If failure, call INT 18h / ROM BASIC. 
				; If INT_19_BOOT_HD is 1, BIOS will also attempt to IPL from 80h (C:) 
				; 
				 
 E40B  99				CWD						; start IPL from drive 00h (A:) 
 E40C				BOOT_DEVICE: 
 E40C  B9 0003				MOV	CX, 3 				; retry three times 
 E40F				BOOT_RETRY: 
 E40F  51				PUSH	CX					; save retry counter 
							ENDIF 
 E410  CD 19				INT	19H 
					IO_DELAY_LONG				; delay between attempts 
			     1				IF ARCH_TYPE NE ARCH_EMU 
 E412  33 C9                 1		XOR	CX, CX 				; delay 65535 LOOPs 
			     1		IO_DELAY 
 E414                        2	??0015: 
 E414  E2 FE                 2		LOOP	??0015					; long delay for I/O 
			     1				ENDIF 
							ENDIF 
 E416  59				POP	CX					; restore retry counter 
 E417  E2 F6				LOOP	BOOT_RETRY 
							ENDIF 
				 
 E419				TRY_INT_18: 
 E419  CD 18				INT	18H					; Try vectored ROM BASIC or boot failure 
											; INT 18h should never return... 
											;  fall through just in case 
				 
				;----------------------------------------------------------------------------; 
				; INT 18 - Unbootable IPL 
				;----------------------------------------------------------------------------; 
				; Display a disk boot failure message and wait for a key to cold reboot. 
				; 
				; This may be re-vectored to ROM BASIC, if present. 
				; 
				; Size: 18 bytes 
				;----------------------------------------------------------------------------; 
 E41B				INT_18 PROC 
					PRINT_SZ  BOOT_FAIL			; print boot failure string 
			     1			ENDIF 
			     1			IFDIFI <BOOT_FAIL>,<SI>			; if SZ is not SI 
 E41B  BE E42B R             1		MOV	SI, OFFSET BOOT_FAIL 
			     1			ENDIF 
 E41E  E8 F71C R             1		CALL	OUT_SZ 
			     1			ENDIF 
 E421  33 C0				XOR	AX, AX				; AH = 0 (wait for key) 
 E423  CD 16				INT	16H					; wait for key press 
 E425  E9 E05B R			JMP	BOOT					; reboot 
 E428				INT_18 ENDP 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-73


				 
 E428				BOOT ENDP 
				 
				;----------------------------------------------------------------------------; 
				; 
				; END OF BIOS POST/BOOTSTRAP 
				; 
				;----------------------------------------------------------------------------; 
				 
						ASSUME DS:_BDA 
 E428				STRINGS PROC 
				 
 E428				BANNER_STRINGS PROC 
				;----------------------------------------------------------------------------; 
				; Banner Strings 
				; 
									ENDIF 
 E428  0D 0A 00			NL_Z			DB	CR, LF, 0			; one NL, null term'd 
 E42B  44 69 73 6B 20 42 6F	BOOT_FAIL		DB	'Disk Boot Fail.' 
       6F 74 20 46 61 69 6C	
       2E			
 E43A  20 59 6F 75 20 6D 6F				DB	' You monster.' 
       6E 73 74 65 72 2E	
 E447  0A			NL2_ANY_KEY		DB	LF 
 E448  0D 0A			NL_ANY_KEY		DB	CR, LF 
 E44A  50 72 65 73 73 20 74	ANY_KEY		DB	'Press the Any Key...' 
       68 65 20 41 6E 79 20	
       4B 65 79 2E 2E 2E	
 E45E  00						DB	 0 
 E45F				BANNER_STRINGS ENDP 
				 
 E45F				POST_STRINGS PROC 
				;----------------------------------------------------------------------------; 
				; POST Test Strings 
				; 
 E45F  43 50 55 00		POST_CPU		DB	'CPU',  0			; 'CPU' followed by default 
 E463  38 30 38 38 00					DB	'8088', 0			;  *must be after POST_CPU 
 E468  46 50 55 00		POST_FPU		DB	'FPU',  0			; 'FPU' followed by default 
 E46C  38 30 38 37 00					DB	'8087', 0			;  *must be after POST_FPU 
 E471  3A 00			POST_HD		DB	':',    0			; HD size letter display 
 E473  20 4D 42						DB	' ', POST_M_UNIT		;  MB or MiB units display 
 E476  00						DB	0				;  *must be after POST_HD 
 E477  52 41 4D 00		POST_MEMORY		DB	'RAM',  0			; RAM Memory test 
									ENDIF 
 E47B  30 30 30 20 4B 42				DB	'000 ', POST_K_UNIT	;  and KB or KiB 
 E481  20 4F 4B 00					DB	' OK',  0 
 E485  56 32 30			POST_V20		DB	'V20' 
									ENDIF 
 E488  00						DB	0 
 E489  4C 50 54 00		POST_LPT		DB	'LPT',  0 
 E48D  43 4F 4D 00		POST_COM		DB	'COM',  0 
 E491  46 44 44 00		POST_FDD		DB	'FDD',  0 
 E495  48 44 44 00		POST_HDD		DB	'HDD',  0 
 E499  20 5B 20 00		POST_LSEP		DB	POST_L, 0 
 E49D  20 5D 00			POST_RSEP		DB	POST_R, 0 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-74


				 
				;----------------------------------------------------------------------------; 
				; NMI strings - these must be contiguous 
				; 
 E4A0  49 4F			NMI_ERR_IO		DB	'IO'				; NMI I/O Error string 
 E4A2  20 50 41 52 49 54 59	NMI_ERR_PAR		DB	' PARITY', 0		; NMI Parity Error 
       00			
				 
 E4AA				POST_STRINGS ENDP 
				 
 E4AA				STRINGS ENDP 
				 
				;============================================================================; 
				; 
				;		        * * *   P R O C s  &  I N T s  * * * 
				; 
				;============================================================================; 
				 
				;----------------------------------------------------------------------------; 
				; Scan, checksum and call BIOS ROM init procedures 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AX = starting segment 
				;	DI = ending segment 
				; Output: 
				;	AX, DI = ending segment 
				;	DF = 0 
				; 
				; Clobbers: AX, BX, SI (anything else the ROM might, except for DS, ES and BP) 
				; Size: 67 bytes 
				;----------------------------------------------------------------------------; 
 E4AA				BIOS_ROM_SCAN PROC 
					PUSHX	BP, DS, ES				; call preserve these registers 
			     1				IFNB <BP>			; exit if last reg 
 E4AA  55                    1		PUSH	BP 					; push register and repeat 
			     1		PUSHX	DS, ES, , , , ,  
			     2				IFNB <DS>			; exit if last reg 
 E4AB  1E                    2		PUSH	DS 					; push register and repeat 
			     2		PUSHX	ES, , , , , ,  
			     3				IFNB <ES>			; exit if last reg 
 E4AC  06                    3		PUSH	ES 					; push register and repeat 
			     3		PUSHX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 E4AD				CHECK_ROM: 
 E4AD  8E D8				MOV	DS, AX 				; DS = starting segment 
 E4AF  93				XCHG	AX, BX				; BX = current DS segment 
 E4B0  B8 0080				MOV	AX, KBP < 2 >			; next 2K segment boundary length 
 E4B3  50				PUSH	AX					; save for use if no ROM found 
 E4B4  33 F6				XOR	SI, SI 				; ROM offset to 0 
 E4B6  AD				LODSW 					; AX = first word (must be 0AA55H) 
 E4B7  3D AA55				CMP	AX, MAGIC_WORD			; is it an extension ROM? 
 E4BA  75 26				JNE	NEXT_ROM 				; if not, check next 2K block 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-75


 E4BC				FOUND_ROM: 
 E4BC  AC				LODSB						; AL = ROM size in 512B blocks 
 E4BD  3C 00				CMP	AL, 0					; is size "reasonable"? 
 E4BF  7E 21				JLE	NEXT_ROM				; if not 1-127, skip it 
 E4C1  E8 E4ED R			CALL	ROM_CHECKSUM 			; checksum ROM at DS:0, AX=bytes read 
							IF POST_OPT_ROM 
 E4C4  E8 F863 R			CALL	ROM_SCAN_POST			; show ROM offset, size and errors 
							ENDIF 
 E4C7  75 19				JNZ	NEXT_ROM				; if NZ, checksum failed, skip it 
 E4C9  5D				POP	BP					; discard previous boundary size 
							ELSE 
 E4CA  B1 04				MOV	CL, 4					; 8088: 512 byte blocks to paragraph 
 E4CC  D3 E8				SHR	AX, CL 
							ENDIF 
 E4CE  50				PUSH	AX					; replace next boundary with ROM size 
				 
				;----------------------------------------------------------------------------; 
				; Call Option ROM's BIOS init routine 
				; 
				; Note: ROM init's can clobber any or all registers so important to save 
				; any that are used here between calls. 
				; 
 E4CF  E4 21				IN	AL, INT_IMR 			; get current OCW1/IMR register 
 E4D1  50				PUSH	AX					; save IMR 
 E4D2  57				PUSH	DI					; save ROM scan ending segment 
 E4D3  1E				PUSH	DS					; ROM init segment 
 E4D4  56				PUSH	SI					; ROM init offset (always 03H) 
 E4D5  8B EC				MOV	BP, SP				; DS:BP = FAR pointer to ROM init 
 E4D7  FF 5E 00				CALL	DWORD PTR [BP]			; FAR CALL to option ROM init 
 E4DA  FA				CLI						; ensure interrupts are still disabled 
 E4DB  5B				POP	BX					; rebalance stack 
 E4DC  5B				POP	BX					; restore current DS segment 
 E4DD  5F				POP	DI					; restore ROM scan ending segment 
 E4DE  58				POP	AX					; restore IMR 
 E4DF  E6 21				OUT	INT_IMR, AL				; reset IMR 
 E4E1  FC				CLD						; ensure direction flag forward 
 E4E2				NEXT_ROM: 
 E4E2  58				POP	AX					; restore next boundary size 
 E4E3  03 C3				ADD	AX, BX				; next boundary 
 E4E5  3B C7				CMP	AX, DI 				; end of extension ROM regions? 
 E4E7  72 C4				JB	CHECK_ROM 				; if not, check next 
 E4E9				ROM_SCAN_DONE: 
					POPX	ES, DS, BP				; restore regs 
			     1				IFNB <ES>			; exit if last reg 
 E4E9  07                    1		POP	ES 					; pop register and repeat 
			     1		POPX	DS, BP, , , , ,  
			     2				IFNB <DS>			; exit if last reg 
 E4EA  1F                    2		POP	DS 					; pop register and repeat 
			     2		POPX	BP, , , , , ,  
			     3				IFNB <BP>			; exit if last reg 
 E4EB  5D                    3		POP	BP 					; pop register and repeat 
			     3		POPX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-76


			     1				ENDIF 
 E4EC  C3				RET 
 E4ED				BIOS_ROM_SCAN ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Perform 8 bit Checksum on a ROM at DS:0000 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	DS = segment for ROM 
				;	AL = ROM size in 512k blocks (1-127) 
				; Output: 
				;	ZF if checksum is valid 
				;	AX = number of bytes read 
				;	DX = 8 bit checksum remainder 
				; 
				; Size: 20 bytes 
				;----------------------------------------------------------------------------; 
 E4ED				ROM_CHECKSUM PROC 
							ASSUME DS:NOTHING 
 E4ED  51				PUSH	CX 
 E4EE  56				PUSH	SI 
 E4EF  98				CBW					; AH = 0 
 E4F0  99				CWD					; DL = 0 (accumulator for sum) 
 E4F1  8B F2				MOV	SI, DX			; start at offset 0 
 E4F3  86 C4				XCHG	AL, AH			; convert 512 byte blocks to 16 bit words 
 E4F5  91				XCHG	AX, CX			; CX = size in 2 byte WORDs 
 E4F6				CHECKSUM_LOOP: 
 E4F6  AD				LODSW					; next two bytes into AL and AH 
 E4F7  02 D0				ADD	DL, AL			; add both to sum 
 E4F9  02 D4				ADD	DL, AH			; ZF if sum is 0 
 E4FB  E2 F9				LOOP	CHECKSUM_LOOP		; loop through entire ROM 
 E4FD  96				XCHG	AX, SI			; AX = bytes read 
 E4FE  5E				POP	SI 
 E4FF  59				POP	CX 
 E500  C3				RET 
 E501				ROM_CHECKSUM ENDP 
				 
				;----------------------------------------------------------------------------; 
				; DETECT_MEMORY - Detect, test and clear RAM 
				;----------------------------------------------------------------------------; 
				; Attempt to determine how much RAM is installed using MEM_ADDR_TEST for  
				; more reliable memory detection. 
				; 
				; Output: Memory count to console 
				; Clobbers: Everything except DS 
				; 
				; NOTE: Testing first two bytes of each block is problematic: 
				; http://minuszerodegrees.net/5160/problems/5160_known_problems_issues.htm 
				; http://minuszerodegrees.net/5160/problems/5160_ram_size_flaw.htm 
				;----------------------------------------------------------------------------; 
 E501				DETECT_MEMORY PROC 
							ASSUME DS:_BDA, ES:NOTHING 
 E501  1E				PUSH	DS 
 E502  B8 ---- R			MOV	AX, SEG _BDA 
 E505  8E D8				MOV	DS, AX 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-77


				 
				;----------------------------------------------------------------------------; 
				; 5150 or MAX_RAM_AUTO: get MAX RAM from MEM_SZ_PC 
				; 
							ELSE 
								ELSE 
				;----------------------------------------------------------------------------; 
				; Otherwise, use default for MAX_RAM and detect 
				; 
 E507  B9 0027				MOV	CX, MAX_RAM / 16 - 1		; Max number of 16KB RAM blocks 
											; after the first 16K block 
											; (ex: 640K / 16K - 1 = 39) 
								ENDIF 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Detect RAM size in 16K blocks 
				; 
 E50A  BA 0400				MOV	DX, KBP < 16 >			; Start at second 16KB block para 
 E50D  8E C2				MOV	ES, DX				; ES = seg 0400H 
 E50F				BLOCK_LOOP: 
 E50F  E8 E591 R			CALL	MEM_ADDR_TEST			; address test on 16KB RAM block at ES 
 E512  75 07				JNZ	BLOCK_LOOP_DONE			; exit loop if test failed 
 E514  80 C6 04				ADD	DH, HIGH KBP < 16 >		; add 400h paras (16 KB) 
 E517  8E C2				MOV	ES, DX 
 E519  E2 F4				LOOP	BLOCK_LOOP				; loop until MAX_RAM 
 E51B				BLOCK_LOOP_DONE: 
				 
				;----------------------------------------------------------------------------; 
				; Test and clear RAM, show memory count 
				; 
				; Input: 
				;	ES/DX = highest memory segment detected 
				; 
							ENDIF 
				 
							ELSE 
 E51B  B1 06				MOV	CL, 6					; 8088: shift right 6 times to get K 
 E51D  D3 EA				SHR	DX, CL 
							ENDIF 
 E51F  89 16 0013 R			MOV	MEM_SZ_KB, DX 			; save to BDA 
 E523  8C C2				MOV	DX, ES				; DX = highest RAM segment detected 
				 
				;----------------------------------------------------------------------------; 
				; Display RAM row 
				; 
					POST_COL_1	POST_MEMORY, POST_CLR_VAL1 ; display RAM column, SI returned 
			     1			ENDIF 
			     1			ELSE 
 E525  B3 0A                 1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute 
			     1			ENDIF 
 E527  BE E477 R             1		MOV	SI, OFFSET POST_MEMORY 
 E52A  E8 F6C3 R             1		CALL	POST_START_COL_1 
			     1			ENDIF 
											;  as POST_KB_OK (next string) 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-78


 E52D  E8 F71C R			CALL	OUT_SZ				; display '000 KB OK' 
					POST_COL_END				; end post column 
			     1			ENDIF 
 E530  E8 F701 R             1		CALL	POST_END_COL 
			     1			ENDIF 
 E533  33 DB				XOR	BX, BX				; BX = 0, memory test counter 
 E535  8E C3				MOV	ES, BX				; start at segment 0000 
 E537				ZERO_ALL_RAM: 
 E537  33 C0				XOR	AX, AX				; zero AX 
 E539  83 C3 10				ADD	BX, 16				; increment memory count value 
 E53C  83 FB 64				CMP	BX, 100				; CF if two digit number 
 E53F  14 09				ADC	AL, POST_COL_VT			; space inner column for 2 or 3 digits 
							ENDIF 
 E541  E8 F72B R			CALL	MOVE_COL				; move to start of inner column 
 E544  53				PUSH	BX					; save RAM size 
 E545  93				XCHG	AX, BX				; move RAM size to AX for display 
 E546  E8 F756 R			CALL	OUT_DECU				; display AX as decimal 
 E549  5B				POP	BX					; restore RAM size 
 E54A  8C C0				MOV	AX, ES				; AX = last segment tested 
 E54C  05 0400				ADD	AX, KBP < 16 >			; move to next 16K segment/block 
 E54F  3B C2				CMP	AX, DX				; is last segment of RAM? 
 E551  73 0D				JNB	DONE_ZERO_ALL_RAM			; exit if end 
 E553				ZERO_ALL_RAM_1: 
 E553  8E C0				MOV	ES, AX				; ES = last segment tested 
				 
							ENDIF				; END RAM_TEST_LONG EQ 1 
				 
				;----------------------------------------------------------------------------; 
				; Write 0's to all memory in this block 
				; 
 E555				ZERO_ALL_START: 
 E555  33 C0				XOR	AX, AX 				; write zeros 
 E557  B9 2000				MOV	CX, KBW < 16 >			; loop 16KB in WORDs 
 E55A  8B F8				MOV	DI, AX				; DI = beginning of segment 
 E55C  F3/ AB				REP	STOSW 				; write zero to next 16KB 
 E55E  EB D7				JMP	SHORT ZERO_ALL_RAM 
 E560				DONE_ZERO_ALL_RAM: 
				 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Done with DETECT_MEMORY 
				; 
 E560  1F				POP	DS 
 E561  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; Compare the result read from memory to the expected results to determine 
				; which bit(s) did not match. 
				; 
				; Error will be displayed as SEG:OFF BBBB. 
				; 
				; - SEG: location/bank in memory of the failed IC, which can be calculated 
				;   using the following: 
				;   http://minuszerodegrees.net/5160/ram/5160_ram_201_error_breakdown.jpg 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-79


				; - OFF: offset where the failure occurred 
				; - BBBB: bit pattern difference between what was expected and what was  
				;   read. This should reveal which IC in that bank failed. 
				;----------------------------------------------------------------------------; 
				; Input: 
				; 	DL = 0 if no parity error, bit 7 or 6 set if error 
				; 
 E562				DETECT_MEMORY_ERR: 
							ENDIF 
					POST_FLAG_SET  PMEM			; set POST Memory error flag 
			     1				ELSE 
 E562  81 CD 0200            1		OR	BP, MASK PMEM			; Set FLAG 
			     1				ENDIF 
 E566  E8 F745 R			CALL	CRLF					; start on new line 
					POST_COL_1	POST_ERR_ERR, RED 
			     1			ENDIF 
			     1			ELSE 
 E569  B3 0C                 1		MOV	BL, LOW RED		; BL = attribute 
			     1			ENDIF 
 E56B  BE E8FF R             1		MOV	SI, OFFSET POST_ERR_ERR 
 E56E  E8 F6C3 R             1		CALL	POST_START_COL_1 
			     1			ENDIF 
 E571  4F				DEC	DI					; move back to last address 
 E572  4F				DEC	DI 
 E573  26: 33 05			XOR	AX, ES:[DI]				; determine incorrect bit(s) 
 E576  97				XCHG	AX, DI				; DI = bit pattern, AX = err offset 
 E577  8C C3				MOV	BX, ES				; segment of error 
 E579  E8 F76D R			CALL	DWORD_HEX				; write address 
 E57C  84 D2				TEST	DL, DL				; was there a parity error? 
 E57E  74 08				JZ	DETECT_MEMORY_ERR_2		; jump if not 
					PRINT_SZ  NMI_ERR_PAR			; print 'PARITY' 
			     1			ENDIF 
			     1			IFDIFI <NMI_ERR_PAR>,<SI>			; if SZ is not SI 
 E580  BE E4A2 R             1		MOV	SI, OFFSET NMI_ERR_PAR 
			     1			ENDIF 
 E583  E8 F71C R             1		CALL	OUT_SZ 
			     1			ENDIF 
 E586  EB 04				JMP	SHORT DETECT_MEMORY_ERR_DONE 
 E588				DETECT_MEMORY_ERR_2: 
 E588  97				XCHG	AX, DI				; restore failed bit pattern 
 E589  E8 F779 R			CALL	WORD_HEX 
 E58C				DETECT_MEMORY_ERR_DONE: 
					POST_COL_END 
			     1			ENDIF 
 E58C  E8 F701 R             1		CALL	POST_END_COL 
			     1			ENDIF 
							ENDIF 
 E58F  EB CF				JMP	SHORT DONE_ZERO_ALL_RAM 
 E591				DETECT_MEMORY ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Test Memory Address Lines on a 16KB block 
				;----------------------------------------------------------------------------; 
				; Write a byte to the first address in a segment and write a different 
				; value with one address line toggled. Read back the values to ensure 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-80


				; they are both correct. Repeat 8 times for each starting bit. 
				; 
				; Input: 
				;	ES = segment to test 
				; Output: 
				;	ZF if okay, NZ if fail 
				;	BX = offset of failed byte/line, DI 
				; 
				; Clobbers AL 
				; 
				; Inspired by: 
				; http://www.ganssle.com/testingram.htm 
				; http://www.paul.de/tips/ramtest.htm 
				; https://www.memtest86.com/tech_memtest-algoritm.html 
				; Size: 38 bytes 
				;----------------------------------------------------------------------------; 
 E591				MEM_ADDR_TEST PROC 
 E591  B0 01				MOV	AL, 1					; pattern to rotate 
 E593  33 DB				XOR	BX, BX				; base address 
 E595  BF 2000				MOV	DI, 2000H				; highest address in 16KB segment 
 E598				MEM_ADDR_LOOP: 
 E598  26: 88 07			MOV	ES:[BX], AL				; write to base address 
 E59B  F6 D0				NOT	AL					; invert value 
 E59D  26: 88 05			MOV	ES:[DI], AL				; write inverted value 
 E5A0  F6 D0				NOT	AL					; revert value 
 E5A2  26: 38 07			CMP	ES:[BX], AL				; is base value the same? 
 E5A5  75 0F				JNZ	MEM_ADDR_ERR			; jump if not 
 E5A7  F6 D0				NOT	AL					; invert value again 
 E5A9  26: 38 05			CMP	ES:[DI], AL				; is second value the same? 
 E5AC  75 08				JNZ	MEM_ADDR_ERR			; jump if not 
 E5AE  F6 D0				NOT	AL					; revert value again 
 E5B0  D0 C0				ROL	AL, 1					; walk test value 
 E5B2  D1 EF				SHR	DI, 1					; move to next address line 
 E5B4  75 E2				JNZ	MEM_ADDR_LOOP			; loop until offset is 0 
 E5B6				MEM_ADDR_ERR: 
 E5B6  C3				RET 
 E5B7				MEM_ADDR_TEST ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Test a 16KB block of Memory at ES:0000 
				;----------------------------------------------------------------------------; 
				; Trivial read/write test - Write pattern RAM_TEST and reads it back, then  
				; repeat with inverse RAM_TEST. If NMI is on, this could trigger a parity 
				; error. 
				; 
				; Input: 
				; 	ES = segment to test 
				; Output: 
				;	ZF and AX = 0 if pass, NZ if fail 
				; 
				; Clobbers: AX, CX, DI 
				; 
				; Size: 26 bytes 
				;----------------------------------------------------------------------------; 
 E5B7				MEM_TEST PROC 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-81


 E5B7  B8 731D				MOV	AX, RAM_TEST			; test pattern 
 E5BA  E8 E5C2 R			CALL	MEM_CHECK				; write and verify pattern 
 E5BD  75 F7				JNZ	MEM_ADDR_ERR			; return if error 
 E5BF  B8 8CE2				MOV	AX, NOT RAM_TEST			; inverted test pattern 
				 
				;----------------------------------------------------------------------------; 
				; Write and verify a 16KB block of Memory at ES:0000 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AX = pattern to write 
				; 	ES = segment for test 
				; Output: 
				;	ZF and AX = 0 if pass, NZ if fail 
				; 
				; Clobbers: AX, CX, DI 
				;----------------------------------------------------------------------------;	 
 E5C2				MEM_CHECK PROC 
 E5C2  B9 2000				MOV	CX, KBW < 16 >			; loop 16KB in WORDs 
 E5C5  33 FF				XOR	DI, DI 				; start at offset 0 
 E5C7  F3/ AB				REP	STOSW 				; write test pattern 
 E5C9				MEM_TEST_VERIFY: 
 E5C9  B5 20				MOV	CH, HIGH KBW < 16 >		; restart loop 16KB in WORDs 
 E5CB  33 FF				XOR	DI, DI 				; start at offset 0 
 E5CD  F3/ AF				REPZ	SCASW 				; loop until CX = 0 OR WORD is not AX 
 E5CF  91				XCHG	AX, CX				; AX = 0 if success 
 E5D0  C3				RET 
 E5D1				MEM_CHECK ENDP 
 E5D1				MEM_TEST ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Reset NMI enable flags 
				;----------------------------------------------------------------------------; 
				; Output: 
				;	AL = current PPI B flags 
				; 
				; Size: 11 bytes 
				;----------------------------------------------------------------------------; 
 E5D1				NMI_RESET PROC 
 E5D1  E4 61				IN	AL, PPI_B				; read current flags 
 E5D3  0C 30				OR	AL, MASK PBIO OR MASK PBPC	; parity, I/O flags high (disable) 
 E5D5  E6 61				OUT	PPI_B, AL				; write to PPI 
 E5D7  34 30				XOR	AL, MASK PBIO OR MASK PBPC	; flags low (enable) 
 E5D9  E6 61				OUT	PPI_B, AL				; write to PPI 
 E5DB  C3				RET 
 E5DC				NMI_RESET ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Delay using PIT counter increments of 125 ms 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AL = wait in 125 ms increments 
				; 
				; AX clobbered 
				; Size: 53 bytes 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-82


 E5DC				IO_WAIT_MS_125 PROC 
 E5DC  B4 7D				MOV	AH, 125 
 E5DE  F6 E4				MUL	AH				; AX = wait in 1 ms 
				 
				;----------------------------------------------------------------------------; 
				; Delay using PIT counter increments of 1 ms 
				;----------------------------------------------------------------------------; 
				; - Calculate the total number of PIT ticks necessary (where 1,193,182 = 1s) 
				; - Latch the PIT and draw down the countdown total on each read. 
				; - Exit when countdown underflows. 
				; 
				; Note: Mode 3 (Square Wave) decements the readable counter by 2, so the 
				; effective frequency of the counter is actually 2,386,364 Hz. 
				; 
				; Input: 
				;	AX = wait in number of ms (clobbered) 
				; 
				; Based on contribution by @Raffzahn (under CC BY-SA 4.0): 
				; https://retrocomputing.stackexchange.com/a/24874/21323 
				; 
				; https://stanislavs.org/helppc/8253.html 
				;----------------------------------------------------------------------------; 
 E5E0				IO_DELAY_MS PROC 
 E5E0  53				PUSH	BX 
 E5E1  BB 0952				MOV	BX, 1193 * 2		; 1,193,182 / 1000 ms * 2 = 2,386 ticks/ms 
				 
				;----------------------------------------------------------------------------; 
				; Delay using PIT counter DX:AX number of ticks 
				;----------------------------------------------------------------------------; 
 E5E4				IO_DELAY_TICK PROC 
 E5E4  51				PUSH	CX 
 E5E5  52				PUSH	DX 
 E5E6  F7 E3				MUL	BX				; DX:AX = countdown of PIT ticks to wait 
 E5E8  93				XCHG	AX, BX			; DX:BX = countdown ticks 
 E5E9  E8 E5FE R			CALL	IO_WAIT_LATCH		; AX = start read 
 E5EC				IO_WAIT_MS_LOOP: 
 E5EC  8B C8				MOV	CX, AX			; CX = last read 
 E5EE  E8 E5FE R			CALL	IO_WAIT_LATCH		; AX = current counter reading 
 E5F1  2B C8				SUB	CX, AX			; CX = # of ticks elapsed since last reading 
 E5F3  2B D9				SUB	BX, CX			; subtract change in ticks from countdown 
 E5F5  83 DA 00				SBB	DX, 0				; borrow out of high word (if necessary) 
 E5F8  73 F2				JAE	IO_WAIT_MS_LOOP		; loop while countdown >= 0 
 E5FA  5A				POP	DX 
 E5FB  59				POP	CX 
 E5FC  5B				POP	BX 
 E5FD				IO_WAIT_MS_DONE: 
 E5FD  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; Latch PIT 0 and read counter to AX 
				;----------------------------------------------------------------------------; 
				; Output: AX = current counter 
				; Time: 123 clock cycles (including CALL) 
				;----------------------------------------------------------------------------; 
 E5FE				IO_WAIT_LATCH PROC 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-83


 E5FE  B0 00				MOV	AL, PIT_CW <0, 0>		; Counter 0, Latch (00b) 
 E600  9C				PUSHF					; save current IF 
 E601  FA				CLI					; disable interrupts 
 E602  E6 43				OUT	PIT_CTRL, AL		; Write command to CTC 
 E604  E4 40				IN	AL, PIT_CH0			; Read low byte of Counter 0 latch 
 E606  8A E0				MOV	AH, AL			; Save it 
 E608  E4 40				IN	AL, PIT_CH0			; Read high byte of Counter 0 latch 
 E60A  9D				POPF					; restore IF state 
 E60B  86 C4				XCHG	AL, AH			; convert endian 
 E60D  C3				RET 
 E60E				IO_WAIT_LATCH ENDP 
 E60E				IO_DELAY_TICK ENDP 
 E60E				IO_DELAY_MS ENDP 
 E60E				IO_WAIT_MS_125 ENDP 
				 
						ELSE 
 =				IO_DELAY_MS_FDC	EQU IO_DELAY_MS 
						ENDIF 
				 
							ENDIF 
				 
				; 
				; 40 BYTES HERE / 6 BYTES HERE 5150 
				; 
				BYTES_HERE	INT_19 
 = 00E4                      1	BYTES_HERE_INT_19 = INT_19-$ 
			     1			IFDEF BYTES_HERE_INT_19 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 19 - Bootstrap Loader 
				;----------------------------------------------------------------------------; 
				; IPL: track 0, sector 1 is loaded into address 0:7C00 and control  
				; is transferred. 
				; 
				; Input: 
				; 	DL = physical drive where boot sector is located (00=A:,80h=C:) 
				; Output: 
				;	Transfer control to bootable MBR if success 
				;	IRET if failure 
				; 
				; Clobbers AX, BX, CX, DH, DI, DS, ES 
				;----------------------------------------------------------------------------; 
 E6F2						ORG 0E6F2H 
 E6F2				INT_19 PROC 
						ASSUME DS:_IPL_SEG, ES:_IPL_SEG 
 E6F2  FB				STI						; enable interrupts 
 E6F3  FC				CLD						; clear direction for STOS 
 E6F4  33 C9				XOR	CX, CX				; CX = 0 
 E6F6  8E D9				MOV	DS, CX				; DS = IPL Segment (0000) 
 E6F8  8E C1				MOV	ES, CX				; ES = IPL Segment (0000) 
 E6FA  BF 0078 R			MOV	DI, OFFSET IVT_1E			; INT 1E vector table address 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-84


 E6FD  B8 EFC7 R			MOV	AX, OFFSET INT_1E 		; INT 1E DBT address 
 E700  AB				STOSW 
 E701  8C C8				MOV	AX, CS				; INT 1E DBT segment 
 E703  AB				STOSW 
 E704				INT_19_READ_MBR: 
 E704  91				XCHG	AX, CX				; AH = 0 (reset) 
 E705  CD 13				INT	13H					; reset disk 0 
 E707  72 14				JC	INT_19_IPL_FAIL			; exit if error 
 E709  B8 0201				MOV	AX, DBW <2, 1>			; AH = 2 (read), AL = 1 sector 
 E70C  BB 7C00 R			MOV	BX, OFFSET IPL_TOP		; ES:BX = IPL boot sector offset 
 E70F  B9 0001				MOV	CX, DBW <0, 1>			; CH = cyl 0, CL = sec 1 
 E712  8A F5				MOV	DH, CH 				; DH = head 0, DL = drive # 
 E714  CD 13				INT	13H					; read 1 sector into ES:BX 
 E716  72 05				JC	INT_19_IPL_FAIL			; exit if error 
							ENDIF 
 E718  EA 7C00 ---- R			JMP 	FAR PTR IPL_TOP 			; jump to IPL segment and boot! 
 E71D				INT_19_IPL_FAIL: 
 E71D  CF				IRET 
						ASSUME DS:NOTHING, ES:NOTHING 
 E71E				INT_19 ENDP 
				 
						ENDIF 
				 
				; 
				; 0 BYTES HERE 
				; 
				BYTES_HERE	INT_14 
 = 001B                      1	BYTES_HERE_INT_14 = INT_14-$ 
			     1			IFDEF BYTES_HERE_INT_14 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 14 - BIOS COM Port Services 
				;----------------------------------------------------------------------------; 
				;	INT 14,0  Initialize serial port parameters 
				;	INT 14,1  Send/write character in AL 
				;	INT 14,2  Receive/read character in AL 
				;	INT 14,3  Get Serial port status 
				; 
				; All functions have: 
				;	  AH = function number (bounds not checked) 
				;	  AL = character to send or receive 
				;	  DX = zero based RS232 card number 
				; 
				; All registers call-preserved (except AX) 
				;----------------------------------------------------------------------------; 
				; Ref: 
				; https://stanislavs.org/helppc/int_14.html 
				;----------------------------------------------------------------------------; 
 E739						ORG 0E739H 
 E739				INT_14 PROC 
							ASSUME DS:_BDA 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-85


 E739  FB				STI 					; enable interrupts 
 E73A  51				PUSH	CX 				; call-preserve CX 
 E73B  B9 0003				MOV	CX, 3 			; will use this 3 in multiple places 
 E73E  3B D1				CMP	DX, CX			; is port number valid? 
 E740  77 53				JA	INT_14_EXIT 		; exit if port is > 3 
					PUSHX	DI, BX, DX, DS		; call-preserve registers 
			     1				IFNB <DI>			; exit if last reg 
 E742  57                    1		PUSH	DI 					; push register and repeat 
			     1		PUSHX	BX, DX, DS, , , ,  
			     2				IFNB <BX>			; exit if last reg 
 E743  53                    2		PUSH	BX 					; push register and repeat 
			     2		PUSHX	DX, DS, , , , ,  
			     3				IFNB <DX>			; exit if last reg 
 E744  52                    3		PUSH	DX 					; push register and repeat 
			     3		PUSHX	DS, , , , , ,  
			     4				IFNB <DS>			; exit if last reg 
 E745  1E                    4		PUSH	DS 					; push register and repeat 
			     4		PUSHX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 E746  BF ---- R			MOV	DI, SEG _BDA 		; DS = BDA 
 E749  8E DF				MOV	DS, DI 
 E74B  8B FA				MOV	DI, DX 			; DI = COM port index (0-3) 
 E74D  8B DF				MOV	BX, DI			; convert to word index 
 E74F  99				CWD					; DX = 0 
 E750  03 11				ADD	DX, [BX][DI]		; DX = 3F8/2F8 base port address 
 E752  74 3D				JZ	INT_14_DONE 		; is port index valid (detected)? 
 E754  3A E1				CMP	AH, CL			; check function number (CL = 3) 
 E756  77 39				JA	INT_14_DONE			; > 3? Not valid 
 E758  74 2D				JZ 	INT_14_3	 		; = 3 then status 
 E75A  80 FC 01				CMP	AH, 1				; check remaining functions 
 E75D  77 56				JA	INT_14_2 			; = 2 then read 
 E75F  74 36				JZ	INT_14_1 			; = 1 then write 
										; = 0 fall through to init 
				 
				;----------------------------------------------------------------------------; 
				; INT 14,0  Initialize serial port parameters 
				;----------------------------------------------------------------------------; 
				; https://stanislavs.org/helppc/int_14-0.html 
				; https://stanislavs.org/helppc/8250.html 
				;----------------------------------------------------------------------------; 
				; Baud rate divisor table: 
				;	0 (000) = 110 baud -> 417H	|	4 (100) = 1200 baud -> 60H 
				;	1 (001) = 150 baud -> 300H	|	5 (101) = 2400 baud -> 30H 
				;	2 (010) = 300 baud -> 180H	|	6 (110) = 4800 baud -> 18H 
				;	3 (011) = 600 baud -> 0C0H	|	7 (111) = 9600 baud -> 0CH 
				; 
				; Formula: 
				;	if (baud == 110) then 
				; 		divisor = 417H 
				;	else 
				;		divisor = 600H >> index 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-86


				;----------------------------------------------------------------------------; 
				; Input: 
				;	DX = base port address 
				;	AL = port params, AH = 0 
				;	CX = 3 (from earlier) 
				;----------------------------------------------------------------------------; 
				 
 E761				INT_14_0 PROC 
				;----------------------------------------------------------------------------; 
				; Set baud rate 
				; 
 E761  8B FA				MOV	DI, DX 			; DX = 3F8/2F8 base port 
 E763  03 D1				ADD	DX, CX			; DX = 3FB/2FB Line Control Register (LCR), CX = 3 
 E765  93				XCHG	AX, BX			; save port params to BL 
 E766  B0 80				MOV	AL, MASK DLAB 		; set baud rate divisor (DLAB); 0 = RBR, THR or IER 
 E768  EE				OUT	DX, AL 			; write to 3FB/2FB (LCR) 
 E769  D3 E3				SHL	BX, CL 			; BH = baud rate, CL = 3 
 E76B  D2 EB				SHR	BL, CL 			; BL = flags 
 E76D  B8 0417				MOV	AX, 417H 			; divisor for 110 baud 
 E770  8A CF				MOV	CL, BH 			; CL = shift counter or 0 for 110 baud (CH = 0) 
 E772  E3 05				JCXZ	INT_14_0_SET_BAUD		; Jump if 110 baud 
 E774  B8 0600				MOV	AX, 600H 			; AX = divisor base (see above formula) 
 E777  D3 E8				SHR	AX, CL			; divisor = 600H >> CL 
 E779				INT_14_0_SET_BAUD: 
 E779  87 D7				XCHG	DX, DI 			; DX = 3F8/2F8, DI = 3FB/2FB (4) 
										; AL = Divisor LSB, AH = Divisor MSB (4) 
 E77B  EF				OUT	DX, AX			; write LSB, then MSB to ports 3F8/3F9 
				;----------------------------------------------------------------------------; 
				; Set parity, stop and word bits 
				;  
 E77C				INT_14_0_SET_PSW: 
 E77C  93				XCHG	AX, BX 			; AL = parity, stop and word bits (4) 
 E77D  87 D7				XCHG	DX, DI 			; DX = 3FB/2FB, DI = 3F8/2F8 (4) 
 E77F  EE				OUT	DX, AL			; set LCR parity, stop and word bits 
 E780  87 D7				XCHG	DX, DI 			; DX = 3F8/2F8, DI = 3FB/2FB (4) 
				;----------------------------------------------------------------------------; 
				; Disable IER 
				; 
 E782  33 C0				XOR	AX, AX 			; AL = 0 (3) 
 E784  42				INC	DX 				; DX = 3F9/2F9 (3) 
 E785  EE				OUT	DX, AL			; DX = 3F9 - Interrupt Enable Register (IER) disabled 
 E786  4A				DEC	DX 				; DX = 3F8 (3) 
										; fall through to get status 
				 
				;----------------------------------------------------------------------------; 
				; INT 14,3  Get Serial port status 
				;----------------------------------------------------------------------------; 
				; Input: 
				; 	DX = base port address 
				; Output: 
				;	AH = port status 
				;	AL = modem status 
				;----------------------------------------------------------------------------; 
 E787				INT_14_3 PROC 
 E787  83 C2 05				ADD	DX, COM1_LSR-COM1_DATA	; DX = 3FD/2FD LSR - Line Status Register 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-87


 E78A  53				PUSH	BX				; delay for I/O 
 E78B  EC				IN	AL, DX 			; get line/port status  
 E78C  86 E0				XCHG	AH, AL 			; save to AH 
 E78E  42				INC	DX 				; DX = 3FE/2FE MSR - Modem Status Register 
 E78F  5B				POP	BX 				; delay for I/O 
 E790  EC				IN	AL, DX 			; get modem status  
 E791				INT_14_3 ENDP 
				 
 E791				INT_14_DONE PROC 
					POPX	DS, DX, BX, DI		; restore all registers 
			     1				IFNB <DS>			; exit if last reg 
 E791  1F                    1		POP	DS 					; pop register and repeat 
			     1		POPX	DX, BX, DI, , , ,  
			     2				IFNB <DX>			; exit if last reg 
 E792  5A                    2		POP	DX 					; pop register and repeat 
			     2		POPX	BX, DI, , , , ,  
			     3				IFNB <BX>			; exit if last reg 
 E793  5B                    3		POP	BX 					; pop register and repeat 
			     3		POPX	DI, , , , , ,  
			     4				IFNB <DI>			; exit if last reg 
 E794  5F                    4		POP	DI 					; pop register and repeat 
			     4		POPX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
				 
 E795				INT_14_EXIT: 
 E795  59				POP	CX 
 E796  CF				IRET 
 E797				INT_14_DONE ENDP 
				 
 E797				INT_14_0 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 14, 1 - Send/write character in AL 
				;----------------------------------------------------------------------------; 
				; Input: 
				; 	DX = base port address 
				;	BL = port timeout 
				;----------------------------------------------------------------------------; 
 E797				INT_14_1 PROC 
 E797  52				PUSH	DX 					; save base port 
 E798  50				PUSH	AX 
 E799  83 C2 04				ADD	DX, COM1_MCR-COM1_DATA		; DX = 3FC/2FC - Modem Control Register 
 E79C  B0 03				MOV	AL, MASK RTS OR MASK DTR	; activate DTR & RTS 
 E79E  EE				OUT	DX, AL				; set DTR or RTS 
 E79F  42				INC	DX 
 E7A0  42				INC	DX 					; DX = 3FE - Modem Status Register 
 E7A1  BB 3020				MOV	BX, DBW <MASK THRE OR MASK LBI, MASK MDSR> ; BH = line (THRE) 
											;  BL = modem (DSR/CTS) 
 E7A4  E8 E7CB R			CALL	INT_14_POLL 			; poll both registers, AH = status 
 E7A7  5B				POP	BX 
 E7A8  8A C3				MOV	AL, BL 				; AL = output char 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-88


 E7AA  5A				POP	DX 					; restore base port 
 E7AB  75 03				JNZ	INT_14_RW_ERR			; Jump if port timeout 
 E7AD  EE				OUT	DX, AL 
 E7AE  EB E1				JMP	SHORT INT_14_DONE 
 E7B0				INT_14_RW_ERR: 
 E7B0  80 CC 80				OR	AH, 10000000B			; set error bit 
 E7B3  EB DC				JMP	SHORT INT_14_DONE 
 E7B5				INT_14_1 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 14, 2 - Receive/read character in AL 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	DX = base port address 
				;	BL = port timeout 
				; Output: 
				;	AH = port status 
				;	AL = character read 
				;	NZ = timeout or failure occurred 
				; 
				; Clobbers: BX 
				;----------------------------------------------------------------------------; 
 E7B5				INT_14_2 PROC 
 E7B5  52				PUSH	DX 					; save base port 
 E7B6  83 C2 04				ADD	DX, COM1_MCR-COM1_DATA		; DX = 3FC/2FC - Modem Control Register 
 E7B9  B0 01				MOV	AL, MASK DTR			; activate DTR 
 E7BB  EE				OUT	DX, AL				; set DTR 
 E7BC  42				INC	DX 
 E7BD  42				INC	DX 					; DX = 3FE/2FE - Modem Status Register 
 E7BE  BB 2001				MOV	BX, DBW <MASK MDSR, MASK LDR>	; BH = modem (DSR), BL = line (data ready) 
 E7C1  E8 E7CB R			CALL	INT_14_POLL 			; poll both registers, AH = status 
 E7C4  5A				POP	DX 					; restore base port 
 E7C5  80 E4 1E				AND	AH, MASK LBI OR MASK LFE OR MASK LPE OR MASK LOE ; include only  
											;  error bits in port status 
 E7C8  EC				IN	AL, DX				; read char from buffer 
 E7C9  EB C6				JMP	SHORT INT_14_DONE 
 E7CB				INT_14_2 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 14 - Poll line then modem status registers 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	DI = port index (0 based byte) 
				; 	DX = 3FE Modem Status Register 
				;	BL = line status expected masked 
				;	BH = modem status expected masked 
				; Output: 
				;	AH = port status 
				;	DX = 3FD Line Status Register 
				;	NZ = timeout or failure occurred 
				; 
				; Clobbers: AX, CX 
				;----------------------------------------------------------------------------; 
 E7CB				INT_14_POLL PROC 
 E7CB  E8 E7D3 R			CALL	INT_14_POLL_PORT 		; first poll modem status 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-89


 E7CE  75 1A				JNZ	INT_14_POLL_RET  		; jump if ZF = 0, timeout or failure occurred 
 E7D0  86 FB				XCHG	BH, BL 			; BH = line status 
 E7D2  4A				DEC	DX				; DX = 3FD Line Status Register (LSR) 
				 
				;----------------------------------------------------------------------------; 
				; INT 14 - Poll status register in DX 
				;----------------------------------------------------------------------------; 
 E7D3				INT_14_POLL_PORT PROC 
 E7D3  56				PUSH	SI 				; call-preserve SI 
 E7D4  33 C9				XOR	CX, CX			; reset poll loop counter 
 E7D6  8A 45 7C				MOV	AL, COM_TIME_B[DI]	; AL = port timeout (< 127) 
 E7D9  98				CBW					; zero extend AX 
 E7DA  96				XCHG	AX, SI 			; SI = port timeout 
 E7DB				INT_14_POLL_LOOP: 
 E7DB  EC				IN	AL, DX 			; check port status 
 E7DC  8A E0				MOV	AH, AL 			; save to AH 
 E7DE  32 C7				XOR	AL, BH 			; mask result bits 
 E7E0  84 C7				TEST	AL, BH 			; did it match expected result? 
 E7E2  74 05				JZ	INT_14_POLL_DONE 
 E7E4  E2 F5				LOOP	INT_14_POLL_LOOP		; poll port 65,535 * timeout times 
 E7E6  4E				DEC	SI 				; 
 E7E7  75 F2				JNZ	INT_14_POLL_LOOP		; Jump if timeout not expired 
 E7E9				INT_14_POLL_DONE: 
 E7E9  5E				POP	SI 
 E7EA				INT_14_POLL_RET: 
 E7EA  C3				RET 
 E7EB				INT_14_POLL_PORT ENDP 
 E7EB				INT_14_POLL ENDP 
				 
 E7EB				INT_14 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; I/O port register test 
				;----------------------------------------------------------------------------; 
				; Do a Walking Bit/March test on I/O port registers. 
				; 
				; Input: 
				;	DX = starting port 
				;	AH = number of sequential ports to test 
				; Output: 
				;	ZF and CX = 0 if success 
				;	NZ if failed 
				; 
				; Adapted from: 
				; https://barrgroup.com/embedded-systems/how-to/memory-test-suite-c 
				; https://www.edaboard.com/threads/walking-1-0-test-for-memory-bist.241278/ 
				; 
				; Size: 47 bytes 
				; Clobbers AX, BX, CX, DX, DI 
				;----------------------------------------------------------------------------; 
 E7EB				PORT_TEST PROC 
 E7EB  B7 01				MOV	BH, 1				; start with low order bit 
 E7ED  33 C9				XOR	CX, CX			; clear counter 
 E7EF  8B FA				MOV	DI, DX			; save starting port 
				 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-90


				;----------------------------------------------------------------------------; 
				; Write a single 1 bit to a different position in each register 
				; 
 E7F1				WB_WRITE_1: 
 E7F1  8A CC				MOV	CL, AH			; register counter 
 E7F3  8B D7				MOV	DX, DI 			; start at first register 
 E7F5  8A C7				MOV	AL, BH			; AL = starting bit to write 
 E7F7				WB_WRITE_LOOP: 
 E7F7  EE				OUT	DX, AL			; write to low byte 
					IO_DELAY_SHORT 
			     1				IF ARCH_TYPE NE ARCH_EMU 
 E7F8  EB 00                 1		JMP	SHORT ??0018 
 E7FA                        1	??0018: 
			     1				ENDIF 
 E7FA  EE				OUT	DX, AL			; write to high byte 
 E7FB  42				INC	DX				; next register/port 
 E7FC  D0 C0				ROL	AL, 1				; walk bit to next position 
 E7FE  E2 F7				LOOP	WB_WRITE_LOOP 
				 
				;----------------------------------------------------------------------------; 
				; Read back bit pattern from each register 
				; 
 E800  8A CC				MOV	CL, AH			; register counter 
 E802  8B D7				MOV	DX, DI 			; start at first register 
 E804  8A DF				MOV	BL, BH			; BL = starting bit to compare 
 E806				WB_READ_LOOP: 
 E806  EC				IN	AL, DX			; read low byte 
 E807  3A C3				CMP	AL, BL			; compare to correct bit 
 E809  75 0E				JNZ	PORT_TEST_DONE		; jump if not okay 
 E80B				WB_LOW_CHECK_OK: 
 E80B  EC				IN	AL, DX			; read high byte 
 E80C  3A C3				CMP	AL, BL			; compare to correct bit 
 E80E  75 09				JNZ	PORT_TEST_DONE		; jump if not okay 
 E810  42				INC	DX				; next register/port 
 E811  D0 C3				ROL	BL, 1				; rotate for next register/bit 
 E813  E2 F1				LOOP	WB_READ_LOOP		; loop all eight registers 
 E815  D0 E7				SHL	BH, 1				; rotate to next starting bit 
 E817  75 D8				JNZ	WB_WRITE_1			; loop until BH = 0 
 E819				PORT_TEST_DONE: 
 E819  C3				RET 
 E81A				PORT_TEST ENDP 
							IF POST_VIDEO_TYPE EQ 1 
				;----------------------------------------------------------------------------; 
				; POST Video Adapter Type Strings 
				; 17 bytes 
				; 
 E81A  56 47 41 00		POST_VGA		DB	'VGA', 0 
 E81E  45 47 41 00		POST_EGA		DB	'EGA', 0 
 E822  43 47 41 00		POST_CGA		DB	'CGA', 0 
 E826  4D 6F 6E 6F 00		POST_MDA		DB	'Mono', 0 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; POST Initial INT 10H Video Mode to BIOS video equipment type 
				; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-91


 E82B  01 03 07			VID_MODE_TBL	DB	1, 3, 7	; Color 40x25, Color 80x25, Mono 80x25 
				 
				; 
				; 0 BYTES HERE 
				; 
				BYTES_HERE	INT_16 
 = 0000                      1	BYTES_HERE_INT_16 = INT_16-$ 
			     1			IFDEF BYTES_HERE_INT_16 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 16 - Keyboard BIOS Services 
				;----------------------------------------------------------------------------; 
				;	INT 16,0	Wait for keystroke and read 
				;	INT 16,1	Get keystroke status 
				;	INT 16,2	Get shift status 
				; Enhanced: 
				;	INT 16,5	Keyboard buffer write 
				;	INT 16,10	Wait for keystroke and read 
				;	INT 16,11	Get keystroke status 
				;	INT 16,12	Get shift status 
				;----------------------------------------------------------------------------; 
 E82E						ORG 0E82EH 
 E82E				INT_16 PROC 
						ASSUME DS:_BDA 
 E82E  FB				STI					; necessary? 
 E82F  FC				CLD 
 E830  1E				PUSH	DS 
 E831  56				PUSH	SI 
 E832  BE ---- R			MOV	SI, SEG _BDA 
 E835  8E DE				MOV	DS, SI 			; DS = BDA segment 
 E837  80 FC 02				CMP	AH, 2 
 E83A  74 33				JE	KB_SHIFT_STATUS 		; AH = 2 - Get Shift Status 
 E83C  77 2E				JA	INT_16_DONE			; AH > 2 - Not valid, exit 
 E83E  7B 15				JNP	KB_WAIT_READ_1		; AH = 0 - Wait for keystroke and read 
										; AH = 1 - Get keystroke (fall through) 
				 
				;----------------------------------------------------------------------------; 
				; AH = 1 - Get keystroke status 
				;----------------------------------------------------------------------------; 
				; Check if a key press is in buffer and return. Does not wait or remove. 
				; Output: 
				;	ZF = 0 if a key pressed (even Ctrl-Break) 
				;	AH = scan code 
				;	AL = ASCII character or zero if special function key 
				;----------------------------------------------------------------------------; 
				;	KB_BUF_HD (1Ah) = "head" next character stored in keyboard buffer 
				;	KB_BUF_TL (1Ch) = "tail" next spot available in keyboard buffer 
				;----------------------------------------------------------------------------; 
 E840				KB_KEY_STATUS PROC 
 E840  BE 001A R			MOV	SI, OFFSET KB_BUF_HD 	; SI = head ptr 
 E843  FA				CLI 					; disable interrupts (already off) 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-92


 E844  AD				LODSW 				; AX = head, SI = tail ptr 
 E845  3B 04				CMP	AX, [SI]	 		; head == tail? 
 E847  75 06				JNE	KB_BUF_HAS_KEY 		; if not, buffer has a key 
 E849				KB_KEY_STATUS_DONE: 
 E849  FB				STI					; re-enable interrupts 
 E84A  5E				POP	SI 
 E84B  1F				POP	DS 
					IRET_F				; IRET with current flags 
 E84C  CA 0002               1		RETF	2 
 E84F				KB_BUF_HAS_KEY: 
 E84F  96				XCHG	AX, SI 			; SI = head 
 E850  AD				LODSW 				; AX = buffer[head], SI = next 
 E851  EB F6				JMP	KB_KEY_STATUS_DONE 
 E853				KB_KEY_STATUS ENDP 
				 
				;----------------------------------------------------------------------------; 
				; AH = 0 - Wait for keystroke and read 
				;----------------------------------------------------------------------------; 
				; Wait until keystroke is in buffer. Key press is removed from buffer. 
				; Output: 
				;	AH = scan code 
				;	AL = ASCII code 
				;----------------------------------------------------------------------------; 
 E853				KB_WAIT_READ PROC 
 E853  FB				STI					; enable interrupts 
						ELSE 
 E854  90				NOP					; wait for any interrupt 
						ENDIF 
 E855				KB_WAIT_READ_1: 
 E855  BE 001A R			MOV	SI, OFFSET KB_BUF_HD 	; SI = head ptr 
 E858  FA				CLI 					; disable interrupts again 
 E859  AD				LODSW 				; AX = head, SI = tail ptr 
 E85A  3B 04				CMP	AX, [SI] 			; head == tail? 
 E85C  74 F5				JE	KB_WAIT_READ 		; if so, buffer is empty 
 E85E  96				XCHG	AX, SI 			; SI = tail 
 E85F  AD				LODSW 				; AX = buffer[tail], SI = next 
 E860  83 FE 3E				CMP	SI, KB_BUF_END_B		; is next >= end of buffer? 
 E863  72 03				JB	KB_GET_READ 		; if not, get tail value 
 E865  BE 001E R			MOV	SI, OFFSET KB_BUF 	; otherwise, wrap next to buffer top 
 E868				KB_GET_READ: 
 E868  89 36 001A R			MOV	KB_BUF_HD, SI 		; head ptr = next 
 E86C				INT_16_DONE: 
 E86C  5E				POP	SI 
 E86D  1F				POP	DS 
 E86E  CF				IRET 
 E86F				KB_WAIT_READ ENDP 
				 
				;----------------------------------------------------------------------------; 
				; AH = 2 - Get shift status 
				;----------------------------------------------------------------------------; 
				; Read Keyboard Flags 
				; Output: 
				;	AL = BIOS keyboard flags (from BDA 0040:0017) 
				;----------------------------------------------------------------------------; 
 E86F				KB_SHIFT_STATUS PROC 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-93


 E86F  A0 0017 R			MOV	AL, KB_FLAGS1 
 E872  EB F8				JMP	SHORT INT_16_DONE 
 E874				KB_SHIFT_STATUS ENDP 
				 
 E874				INT_16 ENDP 
				 
 E874				BEEP_PROC PROC 
				 
				;----------------------------------------------------------------------------; 
				; Repeats LONG_BEEPs then SHORT_BEEPs indefinetly 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	BL low nibble = long beeps 
				;	BL high nibble = short beeps 
				; 
				; Note: must use LOOP for beep since BEEP could occur if PIT is not working 
				;  (then how does the speaker work?) 
				; Note 2: cannot use stack since HALT_BEEP could occur before stack 
				; 
				; Size: 60 bytes 
				;----------------------------------------------------------------------------; 
 E874				HALT_BEEP PROC 
 E874  8C CA				MOV	DX, CS 				; SS to CS 
 E876  8E D2				MOV	SS, DX				; for CALL_NS 
 E878  93				XCHG	AX, BX				; beep pattern to AL 
					POST_CODE					; optionally display beep code on POST card 
			     1			IF POST_CARD EQ 1 
			     1				ENDIF 
 E879  E6 80                 1		OUT	POST_CARD_PORT, AL 
			     1			ENDIF 
					AAM_I	10H					; split nibbles 
 E87B  D4 10                 1		DB	0D4H, 10H			; AAM	imm 
 E87D  95				XCHG	AX, BP				; BP(H) = short beeps, BP(L) = long beeps 
 E87E				HALT_BEEP_START: 
 E87E  8B D5				MOV	DX, BP 				; restore original beep pattern 
 E880  BE 08E8				MOV	SI, BEEP_ERR_LOW			; low C5 
 E883  33 C9				XOR	CX, CX				; low beep on 100% 
 E885				HALT_BEEP_START_ODD: 
 E885  8B F9				MOV	DI, CX				; save counter length 
 E887				HALT_BEEP_REP: 
 E887  8B C6				MOV	AX, SI				; restore beep tone 
					CALL_NS  BEEP_ON_P, 1			; turn on speaker / beep 
 E889  BC E88E R             1		MOV	SP, OFFSET ??001A 
			     1				IFNB <1> 
 E88C  EB 50                 1		JMP	SHORT BEEP_ON_P 
			     1				ENDIF 
 E88E                        1	??001A: 
 E88E  E890 R                1		DW	OFFSET ??001B 
 E890                        1	??001B: 
 E890  8B CF				MOV	CX, DI				; reset counter 
					IO_DELAY					; delay for beep 
 E892                        1	??001C: 
 E892  E2 FE                 1		LOOP	??001C					; long delay for I/O 
					CALL_NS  BEEP_OFF_P, 1			; turn off speaker 
 E894  BC E899 R             1		MOV	SP, OFFSET ??001D 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-94


			     1				IFNB <1> 
 E897  EB 5A                 1		JMP	SHORT BEEP_OFF_P 
			     1				ENDIF 
 E899                        1	??001D: 
 E899  E89B R                1		DW	OFFSET ??001E 
 E89B                        1	??001E: 
 E89B  2B CF				SUB	CX, DI				; set for remainder of counter 
					IO_DELAY					; delay for silence 
 E89D                        1	??001F: 
 E89D  E2 FE                 1		LOOP	??001F					; long delay for I/O 
 E89F  FE CA				DEC	DL					; dec beep repeat count 
 E8A1  75 E4				JNZ	HALT_BEEP_REP			; jump if more of this length 
 E8A3  86 D6				XCHG	DL, DH				; swap beep counts 
 E8A5  85 D2				TEST	DX, DX				; both cycles done? 
 E8A7  74 D5				JZ	HALT_BEEP_START			; if so, restart beep pattern 
 E8A9  B5 55				MOV	CH, 100H * 1/3			; else, short beep on 33% 
 E8AB  BE 06AC				MOV	SI, BEEP_ERR_HIGH			; high F5 
 E8AE  EB D5				JMP	SHORT HALT_BEEP_START_ODD	; start short cycle 
 E8B0				HALT_BEEP ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Make a beepin' beep 
				;----------------------------------------------------------------------------; 
				; Play a (correctly pitched) A6 for 250ms 
				;----------------------------------------------------------------------------; 
 E8B0				BEEP PROC 
 E8B0  50				PUSH	AX 
 E8B1  53				PUSH	BX 
					BEEP_ON 
			     1			ELSE 
 E8B2  B8 054C               1		MOV	AX, BEEP_DEFAULT 
			     1			ENDIF 
 E8B5  E8 E8DE R             1		CALL	BEEP_ON_P 
 E8B8  B0 02				MOV	AL, 2				; 1/4 second pause 
 E8BA  E8 E5DC R			CALL	IO_WAIT_MS_125 
					BEEP_OFF 
 E8BD  E8 E8F3 R             1		CALL	BEEP_OFF_P 
 E8C0  5B				POP	BX 
 E8C1  58				POP	AX 
 E8C2  C3				RET 
 E8C3				BEEP ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Two very short beeps if ZF, one short if NZ 
				;----------------------------------------------------------------------------; 
 E8C3				MEEPMEEP_Z PROC 
 E8C3  75 03				JNZ	MEEP				; if ZF=0, skip first meep 
				 
				;----------------------------------------------------------------------------; 
				; Two very short beeps 
				; Size: 27 bytes 
				; Output: CX = 0 
				;----------------------------------------------------------------------------; 
							ELSE 
 = 0020				MEEP_DELAY	EQU	20H 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-95


							ENDIF 
 E8C5				MEEPMEEP PROC 
 E8C5  E8 E8C8 R			CALL MEEP				; first meep 
				 
				;----------------------------------------------------------------------------; 
				; One very short beep 
				;----------------------------------------------------------------------------; 
 E8C8				MEEP PROC 
 E8C8  50				PUSH	AX 
 E8C9  53				PUSH	BX 
					BEEP_ON 
			     1			ELSE 
 E8CA  B8 054C               1		MOV	AX, BEEP_DEFAULT 
			     1			ENDIF 
 E8CD  E8 E8DE R             1		CALL	BEEP_ON_P 
 E8D0  B5 20				MOV	CH, MEEP_DELAY 
					IO_DELAY				; delay while meeping 
 E8D2                        1	??0020: 
 E8D2  E2 FE                 1		LOOP	??0020					; long delay for I/O 
					BEEP_OFF 
 E8D4  E8 E8F3 R             1		CALL	BEEP_OFF_P 
 E8D7  B5 20				MOV	CH, MEEP_DELAY 
					IO_DELAY				; delay between beeps 
 E8D9                        1	??0021: 
 E8D9  E2 FE                 1		LOOP	??0021					; long delay for I/O 
 E8DB  5B				POP	BX 
 E8DC  58				POP	AX 
 E8DD  C3				RET 
 E8DE				MEEP ENDP 
 E8DE				MEEPMEEP ENDP 
 E8DE				MEEPMEEP_Z ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Turn on speaker at given tone 
				;----------------------------------------------------------------------------; 
				; Input: 
				; 	AX = TONE 
				; Output: 
				;	BL = previous PPI state 
				; 
				; http://www.cs.binghamton.edu/~reckert/220/8254_timer.html 
				; 
				; Clobbers BL, AL 
				; Cannot use stack since this could be called before it is working. 
				;----------------------------------------------------------------------------; 
 E8DE				BEEP_ON_P PROC 
 E8DE  93				XCHG	AX, BX				; save tone to BX 
 E8DF  B0 B6				MOV	AL, PIT_CW <2, 11B, 3>		; Select Timer 2, LE, Mode 3 (square) 
 E8E1  E6 43				OUT	PIT_CTRL, AL			; Send to PIT control word (43H) 
 E8E3  93				XCHG	AX, BX				; restore tone 
 E8E4				BEEP_ON_1 PROC 
 E8E4  E6 42				OUT	PIT_CH2, AL				; send low byte to timer 
 E8E6  8A C4				MOV	AL, AH 				; select high byte 
 E8E8  E6 42				OUT	PIT_CH2, AL				; send high byte to timer 
 E8EA  E4 61				IN	AL, PPI_B				; read current PPI port B status 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-96


 E8EC  8A D8				MOV	BL, AL				; save original PPI state 
 E8EE  0C 03				OR	AL, MASK PBSP OR MASK PBST	; enable speaker and time gates 
 E8F0  E6 61				OUT	PPI_B, AL				; write back to port B 
 E8F2  C3				RET 
 E8F3				BEEP_ON_1 ENDP 
 E8F3				BEEP_ON_P ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Turn off speaker 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	BL = original (speaker off) PPI state 
				; 
				; Clobbers: AL 
				;----------------------------------------------------------------------------; 
 E8F3				BEEP_OFF_P PROC 
 E8F3  8A C3				MOV	AL, BL				; restore original PPI state 
 E8F5  E6 61				OUT	PPI_B, AL				; write back to port B 
 E8F7  C3				RET 
 E8F8				BEEP_OFF_P ENDP 
				 
 E8F8				BEEP_PROC ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Additional POST messages 
				;----------------------------------------------------------------------------; 
								ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Display all POST messages 
				;----------------------------------------------------------------------------; 
				; See PFLAGS 
				; Output: BP (high byte) = 0 
				; Clobbers: AX, CX, SI 
				; Size: 63 bytes 
				;----------------------------------------------------------------------------; 
 E8F8				POST_ERR_MSG PROC 
				 
				;----------------------------------------------------------------------------; 
				; POST Error Strings 
				; 
 E8F8  0D 0A 50 4F 53 54 20	POST_ERR		DB	CR, LF, 'POST '	; POST Error 
 E8FF  45 72 72 6F 72 20 00	POST_ERR_ERR	DB	'Error ', 0		; Error 
 E906  4B 42 00			POST_ERR_PKI	DB	'KB',   0		; Reset returned non-success "301" 
 E909  4B 65 79 00		POST_ERR_PKEY	DB	'Key',  0		; Reset did not clear KBC 
 E90D  46 44 43 00		POST_ERR_PFDC	DB	'FDC',  0		; General FD init failure 
 E911  44 4D 41 00		POST_ERR_PDMA	DB	'DMA',  0		; DMA TC0 error 
				 
				;----------------------------------------------------------------------------; 
				; POST String Vectors - indexed by PFLAGS 
				; 
 E915				POST_ERRORS LABEL WORD 
 E915  E906 R				DW	OFFSET POST_ERR_PKI		; PKI  : Keyboard Interrupt Error 
 E917  E909 R				DW	OFFSET POST_ERR_PKEY		; PKEY : Keyboard Key Stuck 
 E919  E90D R				DW	OFFSET POST_ERR_PFDC		; PFDC : FDC Init Failure 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-97


 E91B  E491 R				DW	OFFSET POST_FDD			; PFSK : FDC Seek Test Failure 
 E91D  E911 R				DW	OFFSET POST_ERR_PDMA		; PDMA : DMA TC0 Error 
 E91F  E477 R				DW	OFFSET POST_MEMORY		; PMEM : RAM Error 
 = 0006				L_POST_ERRORS	EQU	($-POST_ERRORS)/SIZE POST_ERRORS 
				 
 E921				POST_ERROR_MSG PROC 
 E921  B9 0007				MOV	CX, L_POST_ERRORS+1		; # of available POST error messages 
 E924  BE E913 R			MOV	SI, OFFSET POST_ERRORS-2	; SI = string table pointer 
											;  add one LOOP for WARM BOOT flag 
 E927				POST_ERROR_MSG_LOOP: 
 E927  2E: AD				LODS	WORD PTR CS:[SI]			; AX = next message offset 
 E929  D1 E5				SHL	BP, 1					; CF = POST error flag 
 E92B  73 07				JNC	POST_ERROR_MSG_NEXT		; no flag? 
 E92D  9C				PUSHF						; save BP ZF 
 E92E  96				XCHG	AX, SI				; SI = error string 
					PRINTLN_SZ  SI				; write string with CRLF 
			     1			ENDIF 
			     1			ENDIF 
 E92F  E8 F742 R             1		CALL	OUTLN_SZ 
			     1			ENDIF 
 E932  96				XCHG	AX, SI				; SI = string table pointer 
 E933  9D				POPF 
 E934				POST_ERROR_MSG_NEXT: 
 E934  E0 F1				LOOPNZ  POST_ERROR_MSG_LOOP		; loop until end of strings or flags 
 E936				POST_ERROR_MSG_EXIT: 
 E936  C3				RET 
 E937				POST_ERROR_MSG ENDP 
				 
 E937				POST_ERR_MSG ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Additional INT 9h - Keyboard Code 
				;----------------------------------------------------------------------------; 
				 
				;----------------------------------------------------------------------------; 
				; INT 9 - Test keyboard during POST 
				; Size: 27 bytes 
				;----------------------------------------------------------------------------; 
 E937				INT_09_POST PROC 
 E937  50				PUSH	AX 
					POST_FLAG_CLR PKI				; clear POST test int flag 
			     1				ELSE 
 = 0001                      1	??0022	EQU	1				; use CLR1 (ZF unaffected) 
			     1				ENDIF 
			     1				ELSE 
 E938  81 E5 BFFF            1		AND	BP, NOT MASK PKI			; Clear flag 
			     1				ENDIF 
 E93C  E4 60				IN	AL, PPI_A				; read keyboard scan from PPI 
 E93E  3C AA				CMP	AL, 0AAH 
 E940  75 04				JNE	INT_09_POST_DONE			; jump if not expected AAh 
					POST_FLAG_SET PKI				; set POST keyboard test pass flag 
			     1				ELSE 
 E942  81 CD 4000            1		OR	BP, MASK PKI			; Set FLAG 
			     1				ENDIF 
 E946				INT_09_POST_DONE: 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-98


 E946  E4 61				IN	AL, PPI_B				; read keyboard status 
 E948  0C C0				OR	AL, MASK PBKB OR MASK PBKC	; set clear keyboard and enable clock 
 E94A  E6 61				OUT	PPI_B, AL				; write to PPI Control Port B 
 E94C  B0 20				MOV	AL, EOI				; Send End of Interrupt 
 E94E  E6 20				OUT	INT_P0, AL 
 E950  58				POP	AX 
 E951  CF				IRET 
 E952				INT_09_POST ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Clear keyboard circular buffer 
				;----------------------------------------------------------------------------; 
				; Clear/init circular buffer at KB_BUF 
				; Clobbers AX, DI 
				; 
				; Size: 16 bytes 
				;----------------------------------------------------------------------------; 
 E952				KB_BUF_CLEAR PROC 
						ASSUME ES:_BDA_ABS 
 E952  06				PUSH	ES 					; save ES 
 E953  33 C0				XOR	AX, AX 
 E955  8E C0				MOV	ES, AX 
 E957  26: A1 0480 R			MOV	AX, ES:KB_BUF_ST_ABS 		; AX = original start of buffer 
 E95B  BF 041A R			MOV	DI, OFFSET KB_BUF_HD_ABS	; DI = buffer head 
 E95E  AB				STOSW 					; write to head pointer 
 E95F  AB				STOSW 					; write to tail pointer 
 E960  07				POP	ES 
 E961  C3				RET 
						ASSUME ES:NOTHING 
 E962				KB_BUF_CLEAR ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 9 - Keyboard Additional Data Tables 
				;----------------------------------------------------------------------------; 
				; When CTRL held, modify ASCII codes for these scan codes (10 bytes) 
				; 
 E962				INT_KB_CTRL_ASC_TBL LABEL BYTE 
 E962  00 03				DB	00H, 03H				; Ctrl 2	-> ASCII 0 
 E964  1E 07				DB	1EH, 07H				; Ctrl 6	-> ASCII 1EH 
 E966  1F 0C				DB	1FH, 0CH				; Ctrl '-'	-> ASCII 1FH 
 E968  7F 0E				DB	7FH, 0EH				; Ctrl BS 	-> ASCII 07FH 
 E96A  0A 1C				DB	0AH, 1CH				; Ctrl Enter -> ASCII 0AH 
				 
				;----------------------------------------------------------------------------; 
				; When CTRL held, modify scan codes for these scan codes (14 bytes) 
				; 
 E96C				INT_KB_CTRL_SCAN_TBL LABEL BYTE 
 E96C  77 47				DB	77H, 47H 				; Ctrl Home 
 E96E  84 49				DB	84H, 49H 				; Ctrl PgUp 
 E970  73 4B				DB	73H, 4BH 				; Ctrl Left Arrow 
 E972  74 4D				DB	74H, 4DH 				; Ctrl Right Arrow 
 E974  75 4F				DB	75H, 4FH 				; Ctrl End 
 E976  76 51				DB	76H, 51H 				; Ctrl PgDn 
 E978  72 37				DB	72H, 37H				; Keypad * / PrtSc 
				 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-99


 = 000C				L_INT_KB_CTRL_ASC_TBL	EQU ($-INT_KB_CTRL_ASC_TBL)/2		; 12 total 
 = 0006				L_INT_KB_CTRL_SCAN_TBL	EQU ($-INT_KB_CTRL_SCAN_TBL)/2-1	; 6 
				 
				; 
				; 0 BYTES HERE 
				; 
				BYTES_HERE	INT_09 
 = 000D                      1	BYTES_HERE_INT_09 = INT_09-$ 
			     1			IFDEF BYTES_HERE_INT_09 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 9 - Keyboard Interrupt IRQ1 (Hardware Handler) 
				;----------------------------------------------------------------------------; 
				; Handles hardware Interrupt generated by the KBC connected to IRQ 1. The  
				; scan code that is received is translated to all of the behaviors and key 
				; combinations used by the PC. 
				; 
				;----------------------------------------------------------------------------; 
				; References: 
				;  https://stanislavs.org/helppc/scan_codes.html 
				;  https://stanislavs.org/helppc/make_codes.html 
				;  https://stanislavs.org/helppc/keyboard_commands.html 
				;  https://stanislavs.org/helppc/8042.html 
				;  http://www.techhelpmanual.com/106-int_09h__keyboard_interrupt.html 
				;  https://www.phatcode.net/res/223/files/html/Chapter_20/CH20-1.html 
				; 
				; KBFLAGS1 RECORD	K1IN:1,K1CL:1,K1NL:1,K1SL:1,K1AL:1,K1CT:1,K1LS:1,K1RS:1 
				; KBFLAGS2 RECORD	K2IN:1,K2CL:1,K2NL:1,K2SL:1,K2PA:1,K2SY:1,K2LA:1,K2LC:1 
				;----------------------------------------------------------------------------; 
				; Things you must do: 
				; - Check for a scan code from the KBC via PPI Port A (60h) 
				; - Clear and Enable the keyboard bit (7) on PPI Port B 
				; - Examine the Make or Break system scan code 
				; - If a toggle key (Shift, Alt, Ctrl, Caps Lock, Num Lock or Scroll Lock), 
				;	update that flag in the BDA (17-18h) 
				; - Determine if the scan code is altered by an active shift or toggle state 
				; - If Ctrl-Alt-Del is pressed, do a warm reboot of the system 
				; - If Print Screen is pressed, call INT 05h 
				; - If Pause/Ctrl-NumLock is pressed, enter pause/hold state 
				; - If Ctrl-Break is pressed, call INT 1Bh 
				; - Handle any special, non-standard translations 
				; - Translate printable chars to their ASCII/CP-437 value 
				; 
				; In short, it needs to do this: 
				;    https://stanislavs.org/helppc/scan_codes.html 
				;----------------------------------------------------------------------------; 
 E987						ORG 0E987H 
 E987				INT_09 PROC 
							ASSUME DS:_BDA 
 E987  50				PUSH	AX						; save AX first 
 E988  E4 60				IN	AL, PPI_A 					; read scan code from PPI Port A 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-100


 E98A  8A E0				MOV	AH, AL					; save scan code to AH 
 E98C  E4 61				IN	AL, PPI_B 					; read Control Port B 
 E98E  50				PUSH	AX						; save status, and I/O delay 
 E98F  0C 80				OR	AL, MASK PBKB				; set clear keyboard bit 
 E991  E6 61				OUT	PPI_B, AL 					; write to Control Port B 
 E993  58				POP	AX						; restore status, and I/O delay 
 E994  E6 61				OUT	PPI_B, AL 					; write to Control Port B 
				 
				;----------------------------------------------------------------------------; 
				; Send non-specific EOI to PIC 
				; 
 E996  B0 20				MOV	AL, EOI 					; End of Interrupt OCW 
 E998  E6 20				OUT	INT_P0, AL					; write EOI to port 0 
 E99A  FB				STI							; enable interrupts 
 E99B  FC				CLD							; string functions increment 
							ELSE 
					PUSHX	BX, CX, DX, DI, SI			; save working registers 
			     1				IFNB <BX>			; exit if last reg 
 E99C  53                    1		PUSH	BX 					; push register and repeat 
			     1		PUSHX	CX, DX, DI, SI, , ,  
			     2				IFNB <CX>			; exit if last reg 
 E99D  51                    2		PUSH	CX 					; push register and repeat 
			     2		PUSHX	DX, DI, SI, , , ,  
			     3				IFNB <DX>			; exit if last reg 
 E99E  52                    3		PUSH	DX 					; push register and repeat 
			     3		PUSHX	DI, SI, , , , ,  
			     4				IFNB <DI>			; exit if last reg 
 E99F  57                    4		PUSH	DI 					; push register and repeat 
			     4		PUSHX	SI, , , , , ,  
			     5				IFNB <SI>			; exit if last reg 
 E9A0  56                    5		PUSH	SI 					; push register and repeat 
			     5		PUSHX	, , , , , ,  
			     6				ENDIF 
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
							ENDIF 
					PUSHX	DS, ES					; save segment registers 
			     1				IFNB <DS>			; exit if last reg 
 E9A1  1E                    1		PUSH	DS 					; push register and repeat 
			     1		PUSHX	ES, , , , , ,  
			     2				IFNB <ES>			; exit if last reg 
 E9A2  06                    2		PUSH	ES 					; push register and repeat 
			     2		PUSHX	, , , , , ,  
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 E9A3  B9 ---- R			MOV	CX, SEG _BDA 				; CX = BIOS Data Area, CH = 0 
 E9A6  8A C4				MOV	AL, AH					; AL = original scan code 
 E9A8  3C FF				CMP	AL, 0FFH 					; check for Detection Error/Overrun 
 E9AA  74 6D				JZ	INT_KB_MEEP_DONE				; if overrun, meep and exit 
 E9AC  8E D9				MOV	DS, CX					; DS = BIOS Data Area 
 E9AE  8C CA				MOV	DX, CS					; ES = BIOS code segment 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-101


 E9B0  8E C2				MOV	ES, DX 
 E9B2  8B 16 0017 R			MOV	DX, KB_FLAGS				; DL=KB_FLAGS1, DH=KB_FLAGS2 
				 
				;----------------------------------------------------------------------------; 
				; 1. Is a function key? 
				; Function keys have different scan codes based on shift, ALT or CTRL state 
				; 
 E9B6				KB_INT_CHECK_FN_KEY: 
 E9B6  3C 44				CMP	AL, 044H					; is above F10 scan code? 
 E9B8  77 21				JA	KB_INT_CHECK_FN_KEY_DONE 
 E9BA  3C 3B				CMP	AL, 03BH					; is below F1 scan code? 
 E9BC  72 1D				JB	KB_INT_CHECK_FN_KEY_DONE 
 E9BE  B0 00				MOV	AL, 0						; ASCII always 0 on F-keys 
				 
				;----------------------------------------------------------------------------; 
				; Is a Function key. Check if shift, ALT or Ctrl is held? 
				; 
 E9C0  F6 C2 0F				TEST	DL, MASK K1AL OR MASK K1CT OR MASK K1LS OR MASK K1RS 
 E9C3  74 16				JZ	KB_INT_CHECK_FN_KEY_DONE		; no control keys held 
 E9C5  80 C4 2D				ADD	AH, 2DH					; adjust to ALT 
 E9C8  F6 C2 08				TEST	DL, MASK K1AL				; is it ALT? 
 E9CB  75 0B				JNZ	KB_INT_PUT_BUFFER_2			; if so, put in buffer 
 E9CD  80 EC 0A				SUB	AH, 2DH-23H					; adjust to CTRL 
 E9D0  F6 C2 04				TEST	DL, MASK K1CT				; is CTRL? 
 E9D3  75 03				JNZ	KB_INT_PUT_BUFFER_2			; if so, put in buffer 
 E9D5  80 EC 0A				SUB	AH, 23H-19H					; adjust to shift 
 E9D8				KB_INT_PUT_BUFFER_2:					; fit short jumps above 
 E9D8  E9 EA71 R			JMP	KB_INT_PUT_BUFFER 
				 
 E9DB				KB_INT_CHECK_FN_KEY_DONE:				; not a function key 
				 
				;----------------------------------------------------------------------------; 
				; 2. Handle "early" Ctrl such as Ctrl-Break and Ctrl-NumLock 
				; 
 E9DB  F6 C2 04				TEST	DL, MASK K1CT				; is Ctrl held? 
 E9DE  74 14				JZ	KB_INT_IS_NUM				; if not, skip to IS_NUM 
				 
				;----------------------------------------------------------------------------; 
				; Is Ctrl-Break? 
				; 
 E9E0  3C 46				CMP	AL, 46H					; Scroll Lock (Break) 
 E9E2  75 0C				JNZ	INT_KB_CHECK_CTRL_NUM			; jump if not Break 
				 
 E9E4				INT_KB_CTRL_BREAK: 
 E9E4  E8 E952 R			CALL	KB_BUF_CLEAR				; clear keyboard buffer 
 E9E7  C6 06 0071 R 80			MOV	BIOS_BREAK, KBBRK <1>			; BIOS break flag 
 E9EC  CD 1B				INT	1BH						; call BIOS Break handler 
 E9EE  EB 27				JMP	SHORT INT_KB_DONE_2 
				 
				;----------------------------------------------------------------------------; 
				; Is Ctrl-NumLock (Pause)? 
				; 
 E9F0				INT_KB_CHECK_CTRL_NUM: 
 E9F0  3C 45				CMP	AL, 45H					; is Num Lock key? 
					;CMP	AL, 35H					; key pad / (for testing) 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-102


 E9F2  74 16				JZ	INT_KB_SET_PAUSE				; if not, put in Pause 
				 
				;----------------------------------------------------------------------------; 
				; 3. Handle numeric keypad entry according to the following: 
				; 
				;	Num	Shift	ASCII	Scan 
				; 	0	0	0	52h	5230 0020 
				;	0	1	'0'	52h	5200 80A2 
				;	1	0	'0'	52h	5200 8000 
				;	1	1	0	52h	5200 8080 
				; 
 E9F4				KB_INT_IS_NUM: 
 E9F4  F6 C2 20				TEST	DL, MASK K1NL				; is NUM LOCK on? 
 E9F7  74 25				JZ	KB_INT_IS_NUM_DONE			; if not, do nothing 
 E9F9  3C 53				CMP	AL, 53H					; is higher than Del key? 
 E9FB  77 21				JA	KB_INT_IS_NUM_DONE 
 E9FD  3C 47				CMP	AL, 47H					; is lower than Home/7 key? 
 E9FF  72 1D				JB	KB_INT_IS_NUM_DONE 
				 
				;----------------------------------------------------------------------------; 
				; Keypad number pressed and Num Lock is on, so invert shift behavior. 
				; 
 EA01  D0 E0				SHL	AL, 1						; invert NumLock and Shift 
 EA03  F6 C2 03				TEST	DL, MASK K1LS OR MASK K1RS		;  behavior and jump ahead 
 EA06  74 1E				JZ	KB_INT_UC					; jump if no shift held 
 EA08  EB 1B				JMP	SHORT KB_INT_SHIFT 
				 
				;----------------------------------------------------------------------------; 
				; KB Ctrl-NumLock Screen Pause 
				;----------------------------------------------------------------------------; 
 EA0A				INT_KB_SET_PAUSE: 
 EA0A  BB 0018 R			MOV	BX, OFFSET KB_FLAGS2			; (-1 byte to use indirect) 
 EA0D  80 0F 08				OR	BYTE PTR [BX], MASK K2PA		; set PAUSE flag 
				 
								ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Loop until Pause flag is cleared 
				; 
 EA10				INT_KB_PAUSE_LOOP: 
 EA10  F4				HLT							; be a good neighbor 
 EA11  90				NOP							; let another interrupt happen 
 EA12  F6 07 08				TEST	BYTE PTR [BX], MASK K2PA		; check the Pause flag 
 EA15  75 F9				JNZ	INT_KB_PAUSE_LOOP				; loop until clear 
 EA17				INT_KB_DONE_2: 
 EA17  EB 73				JMP	SHORT INT_KB_DONE				; exit INT 
				 
				;----------------------------------------------------------------------------; 
				; Emit a feeble meep and exit 
				; 
 EA19				INT_KB_MEEP_DONE: 
 EA19  E8 E8C8 R			CALL	MEEP 
 EA1C  EB 6E				JMP	SHORT INT_KB_DONE				; exit INT 
				 
 EA1E				KB_INT_IS_NUM_DONE: 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-103


				 
				;----------------------------------------------------------------------------; 
				; 4. Do scan code to ASCII translation 
				;----------------------------------------------------------------------------; 
 EA1E				KB_INT_CHAR:						; is a regular key ? 
 EA1E  D0 E0				SHL	AL, 1						; align index for table 
							ENDIF 
 EA20  F6 C2 0B				TEST	DL, MASK K1LS OR MASK K1RS OR MASK K1AL	; is either shift key or ALT already pressed
				? 
 EA23  75 01				JNZ	KB_INT_UC					; if so, use uppercase table 
 EA25				KB_INT_SHIFT: 
 EA25  40				INC	AX 						; if not shifted, increment 
 EA26				KB_INT_UC:							;  one to use lower case 
 EA26  BB EB8B R			MOV	BX, OFFSET KEY_SCAN_TBL 
 EA29  2E: D7				XLAT	CS:[BX]					; ASCII key in AL = CS:BX[AL] 
 EA2B  84 C0				TEST	AL, AL					; a is flag key code? 
 EA2D  79 03				JNS	KB_INT_NOT_FLAG 
 EA2F  E9 EB28 R			JMP	INT_KB_IS_FLAG 
 EA32				KB_INT_NOT_FLAG: 
 EA32  84 E4				TEST	AH, AH					; test high bit of scan code 
 EA34  78 56				JS	INT_KB_DONE					; if set, it is an unhandled break c
				ode 
 EA36				KB_INT_IS_CAPS: 
 EA36  F6 C2 40				TEST	DL, MASK K1CL				; is CAPS LOCK on? 
 EA39  74 0F				JZ	KB_INT_IS_CAPS_DONE 
 EA3B				IS_ALPHA:							; CF if AL is not [A-Za-z] 
 EA3B  50				PUSH	AX						; save original AL 
 EA3C  0C 20				OR	AL, 'a'-'A'					; lowercase it for comparison 
 EA3E  3C 61				CMP	AL, 'a'					; is less than 'a'? 
 EA40  72 03				JB	IS_ALPHA_DONE				; CF if not alpha 
 EA42  3C 7B				CMP	AL, 'z'+1					; is greater than 'z'? 
 EA44  F5				CMC							; CF if not alpha 
 EA45				IS_ALPHA_DONE: 
 EA45  58				POP	AX						; restore original AL 
 EA46  72 02				JC	KB_INT_IS_CAPS_DONE			; jump if not alpha 
 EA48  34 20				XOR	AL, 'a'-'A'					; otherwise, toggle case 
				 
 EA4A				KB_INT_IS_CAPS_DONE: 
				;----------------------------------------------------------------------------; 
				; 5. Handle ALT chars that require ASCII translation 
				; 
 EA4A				KB_INT_IS_ALT: 
 EA4A  F6 C2 08				TEST	DL, MASK K1AL				; is ALT currently held? 
 EA4D  75 46				JNZ	INT_KB_ALT 
				 
				;----------------------------------------------------------------------------; 
				; 6. Handle additional Non-ALT special case chars 
				; 
 EA4F  3D 3700				CMP	AX, 3700H					; is Shift-PrtSc? 
 EA52  74 0D				JZ	KB_INT_PRTSC				; jump if so 
 EA54  3D 4C00				CMP	AX, 4C00H					; Numeric 5 key (unshifted) 
 EA57  74 33				JZ	INT_KB_DONE					; discard and exit 
				 
 EA59				KB_INT_IS_ALT_DONE: 
				 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-104


				;----------------------------------------------------------------------------; 
				; 7. Handle CTRL chars 
				; 
 EA59				KB_INT_IS_CTRL: 
 EA59  F6 C2 04				TEST	DL, MASK K1CT				; is CTRL currently held? 
 EA5C  74 07				JZ	KB_INT_IS_CTRL_DONE			; jump if not 
 EA5E  E9 EB12 R			JMP	INT_KB_CTRL					; otherwise, CTRL is held 
				 
				;----------------------------------------------------------------------------; 
				; Handle Shift-PrtSc 
				; 
 EA61				KB_INT_PRTSC: 
 EA61  CD 05				INT	5H						; call print screen handler 
 EA63  EB 27				JMP	SHORT INT_KB_DONE 
				 
 EA65				KB_INT_IS_CTRL_DONE: 
				;----------------------------------------------------------------------------; 
				; Test if in Ctrl-NumLock PAUSE 
				; If in Pause, any remaining key will exit and be discarded 
				; 
 EA65				KB_INT_IS_PAUSE: 
 EA65  F6 C6 08				TEST	DH, MASK K2PA				; is in pause? 
 EA68  74 07				JZ	KB_INT_PUT_BUFFER 
 EA6A  80 26 0018 R F7			AND	KB_FLAGS2, NOT MASK K2PA		; clear pause flag 
 EA6F  EB 1B				JMP	SHORT INT_KB_DONE				; discard key and exit int 
				 
				;----------------------------------------------------------------------------; 
				; All special cases have been handled 
				; Store AX in keyboard buffer 
				; 
 EA71				KB_INT_PUT_BUFFER: 
 EA71  8B 3E 001C R			MOV	DI, KB_BUF_TL 				; DI = tail ptr 
 EA75  8D 75 02				LEA	SI, [DI][2]					; SI = next (maybe) 
 EA78  83 FE 3E				CMP	SI, KB_BUF_END_B				; is next >= end of buffer? 
 EA7B  72 03				JB	KB_INT_CHECK_FULL 			; if not, check if buffer is full 
 EA7D  BE 001E R			MOV	SI, OFFSET KB_BUF 			; otherwise, wrap to first address 
 EA80				KB_INT_CHECK_FULL: 
 EA80  3B 36 001A R			CMP	SI, KB_BUF_HD 				; next == head? 
 EA84  74 93				JE	INT_KB_MEEP_DONE				; Beep if ZF - buffer is full 
 EA86  89 05				MOV	[DI], AX 					; buffer[head] = AX 
 EA88  89 36 001C R			MOV	KB_BUF_TL, SI 				; tail = next 
				 
				;----------------------------------------------------------------------------; 
				; Restore registers and exit 
				; 
 EA8C				INT_KB_DONE: 
					POPX	ES, DS 
			     1				IFNB <ES>			; exit if last reg 
 EA8C  07                    1		POP	ES 					; pop register and repeat 
			     1		POPX	DS, , , , , ,  
			     2				IFNB <DS>			; exit if last reg 
 EA8D  1F                    2		POP	DS 					; pop register and repeat 
			     2		POPX	, , , , , ,  
			     3				ENDIF 
			     2				ENDIF 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-105


			     1				ENDIF 
							ELSE 
					POPX	SI, DI, DX, CX, BX			; restore used registers 
			     1				IFNB <SI>			; exit if last reg 
 EA8E  5E                    1		POP	SI 					; pop register and repeat 
			     1		POPX	DI, DX, CX, BX, , ,  
			     2				IFNB <DI>			; exit if last reg 
 EA8F  5F                    2		POP	DI 					; pop register and repeat 
			     2		POPX	DX, CX, BX, , , ,  
			     3				IFNB <DX>			; exit if last reg 
 EA90  5A                    3		POP	DX 					; pop register and repeat 
			     3		POPX	CX, BX, , , , ,  
			     4				IFNB <CX>			; exit if last reg 
 EA91  59                    4		POP	CX 					; pop register and repeat 
			     4		POPX	BX, , , , , ,  
			     5				IFNB <BX>			; exit if last reg 
 EA92  5B                    5		POP	BX 					; pop register and repeat 
			     5		POPX	, , , , , ,  
			     6				ENDIF 
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
							ENDIF 
 EA93  58				POP	AX 
 EA94  CF				IRET 
				 
				;----------------------------------------------------------------------------; 
				; 6. Only ALT key is held (no CTRL) 
				; 
				; Space bar is the only key that returns the same scan code and ASCII code  
				; when ALT is held. 
				; 
 EA95				INT_KB_ALT PROC 
 EA95  80 FC 39				CMP	AH, 39H					; is space bar? 
 EA98  74 BF				JZ	KB_INT_IS_ALT_DONE			; continue 
 EA9A  8B D8				MOV	BX, AX 
 EA9C  B0 00				MOV	AL, 0						; AL will be 0 for any others 
				 
 EA9E				CHECK_TOP_ROW_NUM: 
 EA9E  80 FC 0D				CMP	AH, 0DH					; is above '=' scan code? 
 EAA1  77 0A				JA	CHECK_ALT_ON 
 EAA3  80 FC 02				CMP	AH, 2 
 EAA6  72 05				JB	CHECK_ALT_ON 
 EAA8  80 C4 76				ADD	AH, 76H 
 EAAB  EB C4				JMP	SHORT KB_INT_PUT_BUFFER 
				 
				;----------------------------------------------------------------------------; 
				; 7. Check for ALT + 000 numeric entry 
				; Alt held, and number is valid numeric keypad 
				; Note: AH must be preserved 
				; 
 EAAD				CHECK_ALT_ON: 
 EAAD  80 EB 30				SUB	BL, '0'					; ASCII convert and test 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-106


 EAB0  72 12				JB	INT_KB_NOT_ALT_000			; jump if less than 0 
 EAB2  80 FB 09				CMP	BL, 9 
 EAB5  77 0D				JA	INT_KB_NOT_ALT_000			; jump if above 9 
				 
 EAB7				INT_KB_IS_ALT_000: 
 EAB7  93				XCHG	AX, BX					; AL = input byte, save AX 
 EAB8  8A 26 0019 R			MOV	AH, KB_ALT					; AH = partial working byte 
 EABC  D5 0A				AAD							; AL = AL + ( AH * 10 ) 
 EABE  A2 0019 R			MOV	KB_ALT, AL					; save new working byte to BDA 
 EAC1  93				XCHG	AX, BX					; restore AH, AL = 0 
 EAC2  EB C8				JMP	SHORT INT_KB_DONE				; interrupt complete 
				 
				;----------------------------------------------------------------------------; 
				; 8. Check for ALT modified chars that are skipped 
				; Uses table INT_KB_ALT_SKIP 
				; 
 EAC4				INT_KB_NOT_ALT_000: 
 EAC4  BF EC09 R			MOV	DI, OFFSET INT_KB_ALT_SKIP 
 EAC7  B1 0A				MOV	CL, 10					; L_INT_KB_ALT_SKIP 
 EAC9  86 E0				XCHG	AH, AL 
 EACB  F2/ AE				REPNE SCASB						; is in table? 
 EACD  86 E0				XCHG	AH, AL 
 EACF  75 88				JNZ	KB_INT_IS_ALT_DONE			; if not found, continue 
 EAD1				INT_KB_DONE_1: 
 EAD1  EB B9				JMP	SHORT INT_KB_DONE				; if found, skip 
				 
 EAD3				INT_KB_ALT ENDP 
				 
				;----------------------------------------------------------------------------; 
				; 9. Only CTRL key is held (no ALT) 
				;----------------------------------------------------------------------------; 
 EAD3				INT_KB_CTRL_NO_ALT PROC 
				 
				;----------------------------------------------------------------------------; 
				; Handle CTRL exceptions after ASCII or scan code is modified. These require 
				; a lookup table since they do not follow a predictable pattern. 
				; 
 EAD3  93				XCHG	AX, BX					; BH = scan code, BL = ASCII 
 EAD4  B1 0C				MOV	CL, L_INT_KB_CTRL_ASC_TBL		; length of table 
 EAD6  BE E962 R			MOV	SI, OFFSET INT_KB_CTRL_ASC_TBL 
 EAD9				INT_KB_CTRL_ASC_TBL_LOOP: 
 EAD9  2E: AD				LODS	WORD PTR CS:[SI]				; AH = scan code, AL = new ASCII 
 EADB  3A E7				CMP	AH, BH					; scan code match? 
 EADD  E0 FA				LOOPNE INT_KB_CTRL_ASC_TBL_LOOP		; if not keep looping until end 
 EADF  75 0C				JNZ	INT_KB_CTRL_ASC_TBL_DONE		; no matches, restore AX and continue 
 EAE1  80 F9 06				CMP	CL, L_INT_KB_CTRL_SCAN_TBL		; was first list segment? 
 EAE4  7F 04				JG	INT_KB_CTRL_NO_DONE			; if so, match found and AX is set, exit 
 EAE6  B4 00				MOV	AH, 0						; ASCII code 0 
 EAE8  86 C4				XCHG	AL, AH					; AH = scan code, AL = 0 
 EAEA				INT_KB_CTRL_NO_DONE: 
 EAEA  E9 EA65 R			JMP	KB_INT_IS_CTRL_DONE			; AX set, exit 
 EAED				INT_KB_CTRL_ASC_TBL_DONE: 
 EAED  93				XCHG	AX, BX					; restore AX 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-107


				; Skip ; ' ` 
				; 
 EAEE  80 FC 27				CMP	AH, 27H					; pass < 27 
 EAF1  72 05				JB	INT_KB_CTRL_ALPHA 
 EAF3  80 FC 29				CMP	AH, 29H					; pass > 29 
 EAF6  76 94				JNA	INT_KB_DONE					; skip 27-29 
				 
				;----------------------------------------------------------------------------; 
				; For scan codes 10H-32H return only low 5 bits of ASCII code when CTRL is held 
				; 
 EAF8				INT_KB_CTRL_ALPHA: 
 EAF8  80 FC 10				CMP	AH, 10H 
 EAFB  72 09				JB	INT_KB_CTRL_NO_ALT_1 
 EAFD  80 FC 32				CMP	AH, 32H 
 EB00  77 04				JA	INT_KB_CTRL_NO_ALT_1 
 EB02  24 1F				AND	AL, 00011111B				; adjust ASCII value 
 EB04  EB E4				JMP	SHORT INT_KB_CTRL_NO_DONE 
 EB06				INT_KB_CTRL_NO_ALT_1: 
				 
				;----------------------------------------------------------------------------; 
				; If scan code between 02H-35H and hasn't been modified yet, return nothing 
				; 
 EB06  80 FC 02				CMP	AH, 2 
 EB09  72 DF				JB	INT_KB_CTRL_NO_DONE			; pass < 2 
 EB0B  80 FC 35				CMP	AH, 35H 
 EB0E  77 DA				JA	INT_KB_CTRL_NO_DONE			; pass > 35 
 EB10  EB BF				JMP	SHORT INT_KB_DONE_1			; don't return 2-35? 
				 
 EB12				INT_KB_CTRL_NO_ALT ENDP 
				 
				;----------------------------------------------------------------------------; 
				; 8. Ctrl key is held 
				;----------------------------------------------------------------------------; 
 EB12				INT_KB_CTRL: 
 EB12  F6 C2 08				TEST	DL, MASK K1AL				; is ALT also currently held? 
 EB15  74 BC				JZ	INT_KB_CTRL_NO_ALT			; jump if no ALT 
				 
				;----------------------------------------------------------------------------; 
				; 9. Ctrl-Alt keys are held 
				;----------------------------------------------------------------------------; 
 EB17				INT_KB_CTRL_ALT: 
 EB17  80 FC 53				CMP	AH, 53H					; is Ctrl-Alt-Del? 
							ELSE 
 EB1A  75 CE				JNZ	INT_KB_CTRL_NO_DONE			; put in buffer as-is and exit 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Handle Ctrl-Alt-Del (Warm reboot) 
				; 
 EB1C				INT_KB_CTRL_ALT_DEL: 
 EB1C  E8 E8B0 R			CALL	BEEP						; BEEP on ctrl-alt-del 
							ELSE 
 EB1F  C7 06 0072 R 0000		MOV	WARM_FLAG, COLD_BOOT			; clear warm boot flag 
							ENDIF 
 EB25  E9 E05B R			JMP	BOOT						; warm reboot 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-108


				 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; 5. Is a flag key? 
				;----------------------------------------------------------------------------; 
				;  40:18	Keyboard Flags Byte 2 (High) 
				; 84218421 
				; 7 	    |			- K2IN	insert key is depressed 
				;  6 	    |			- K2CL	caps-lock key is depressed 
				;   5	    |			- K2NL	num-lock key is depressed 
				;    4    |			- K2SL	scroll lock key is depressed 
				;     3   |			- K2PA	suspend key has been toggled 
				;      2  |			- K2SY	system key depressed and held 
				;       1 |			- K2LA	left ALT key depressed 
				;        0|			- K2LC	left CTRL key depressed 
				;----------------------------------------------------------------------------; 
 =				_KB_FLAGS2	EQU	BYTE PTR[BX]			; Use index addressing 
 =				_KB_FLAGS1	EQU	_KB_FLAGS2[-1]			;  for byte savings 
				 
 EB28				INT_KB_IS_FLAG PROC 
 EB28  BB 0018 R			MOV	BX, OFFSET KB_FLAGS2			; BX = KB_FLAGS2 
 EB2B  BF EC01 R			MOV	DI, OFFSET KEY_FLAG_ON_TBL 
 EB2E  8A C4				MOV	AL, AH					; AL = original scan code 
 EB30  24 7F				AND	AL, 01111111B				; clear high bit for search 
 EB32  B1 01				MOV	CL, 1						; set up bit mask counter 
 EB34				INT_KB_FLAG_LOOP: 
 EB34  AE				SCASB 						; look for scan code 
 EB35  74 07				JZ	INT_KB_FLAG_FOUND 
 EB37  D0 E1				SHL	CL, 1 					; CL will contain bit mask 
 EB39  75 F9				JNZ	INT_KB_FLAG_LOOP				; CF if not found too 
 EB3B  E9 EA32 R			JMP	KB_INT_NOT_FLAG 
 EB3E				INT_KB_FLAG_FOUND: 
 EB3E  FA				CLI 
 EB3F  8A C1				MOV	AL, CL					; move to AL for work 
				 
				;----------------------------------------------------------------------------; 
				; Ins, Caps, Num, Scrl send break codes, but state is kept by BIOS so ignore those. 
				; 
 EB41  A8 F0				TEST	AL, MASK K1IN OR MASK K1CL OR MASK K1NL OR MASK K1SL 
 EB43  74 18				JZ	INT_KB_NOT_ICNS				; don't clear on break code on these 
 EB45  84 E4				TEST	AH, AH					; is Ins, Caps, Num, Scrl break code? 
 EB47  79 06				JNS	INT_KB_ICNS_MAKE				; if not, jump to make 
				 
				;----------------------------------------------------------------------------; 
				; Handle KB_FLAGS2 for Ins, Caps, Num, Scroll Lock for both make and break 
				; 
 EB49				INT_KB_ICNS_BREAK: 
 EB49  F6 D0				NOT	AL 
 EB4B  20 07				AND	_KB_FLAGS2, AL 
 EB4D  EB 0B				JMP	SHORT	INT_KB_DONE_3 
 EB4F				INT_KB_ICNS_MAKE: 
 EB4F  08 07				OR	_KB_FLAGS2, AL				; set flag in KB_FLAGS2 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-109


				; Otherwise toggle the flag for Ins, Caps, Num, Scrl. 
				; 
				; Note: The Ins key is treated as a key press with code 5200H. 
				; 
 EB51				INT_KB_FLAG_TOGGLE: 
 EB51  30 47 FF				XOR	_KB_FLAGS1, AL				; toggle flag 
 EB54  A8 80				TEST	AL, MASK K1IN				; is insert key? 
 EB56  B0 00				MOV	AL, 0 
 EB58  75 2E				JNZ	INT_KB_PUT_BUFFER_2			; pass through as a key if so 
 EB5A				INT_KB_DONE_3: 
 EB5A  E9 EA8C R			JMP	INT_KB_DONE 
				 
				;----------------------------------------------------------------------------; 
				; Scan code for Alt, Ctrl, Left or Right Shift 
				; On make code, set flag.  On break code, clear flag. 
				; 
 EB5D				INT_KB_NOT_ICNS: 
				 
				;----------------------------------------------------------------------------; 
				; Handle KB_FLAGS2 for Ctrl or Alt 
				; 
 EB5D  A8 0C				TEST	AL, MASK K1AL OR MASK K1CT		; is Alt or Ctrl? 
 EB5F  74 08				JZ	INT_KB_NOT_ICNS_1				; jump if not 
 EB61  D0 E8				SHR	AL, 1						; adjust for KB_FLAGS2 
 EB63  D0 E8				SHR	AL, 1 
 EB65  30 07				XOR	_KB_FLAGS2, AL				; toggle flag 
 EB67  8A C1				MOV	AL, CL					; restore AL 
				 
 EB69				INT_KB_NOT_ICNS_1: 
 EB69  4B				DEC	BX						; _KB_FLAGS2 = KB_FLAGS1 
 EB6A  84 E4				TEST	AH, AH					; is a break code? 
 EB6C  78 04				JS	INT_KB_FLAG_CLEAR				; if so, clear flag 
 EB6E  08 07				OR	_KB_FLAGS2, AL				; set flag 
 EB70  EB E8				JMP	SHORT INT_KB_DONE_3			; done 
				 
 EB72				INT_KB_FLAG_CLEAR: 
 EB72  F6 D0				NOT	AL						; invert mask 
 EB74  20 07				AND	_KB_FLAGS2, AL				; clear flag 
 EB76  80 F9 08				CMP	CL, MASK K1AL				; was it ALT key? 
 EB79  75 DF				JNZ	INT_KB_DONE_3				; if not, done 
				 
 EB7B				INT_KB_IS_FLAG ENDP 
				 
				;----------------------------------------------------------------------------; 
				; ALT has just been released 
				;----------------------------------------------------------------------------; 
				; Check if there a partial value of ALT+000 (ALT-GR) numpad entry work byte? 
				; 
 EB7B				INT_KB_ALT_BREAK: 
 EB7B  A0 0019 R			MOV	AL, KB_ALT 
 EB7E  84 C0				TEST	AL, AL					; is ALT working sum 0? 
 EB80  74 D8				JZ	INT_KB_DONE_3				; if so, end 
 EB82  B4 00				MOV	AH, 0						; Scan code is 0 
 EB84  88 26 0019 R			MOV	KB_ALT, AH					; clear ALT byte working sum 
 EB88				INT_KB_PUT_BUFFER_2: 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-110


 EB88  E9 EA71 R			JMP	KB_INT_PUT_BUFFER				; use value as output char 
				 
				;----------------------------------------------------------------------------; 
				; Keyboard scancode mapping tables 
				;----------------------------------------------------------------------------; 
				; For each scan code this table contains ASCII characters. The first byte is 
				; the shifted (shift held) ASCII char, followed by the non-shifted ASCII char. 
				; 
				; Flag chars (noted by *) return their scan code with most sig bit set  
				; (also their break code). 
				;----------------------------------------------------------------------------; 
 EB8B				KEY_SCAN_TBL	LABEL BYTE 
 EB8B  0002[				DB	2 DUP(0), 2 DUP(1BH) 		; 00-01H	None, Escape 
	   00			
			 ]	
       0002[			
	   1B			
			 ]	
				
 EB8F  21 31 40 32 23 33 24		DB	'!1@2#3$4%5^6' 			; 02-		(Top row keys) 
       34 25 35 5E 36		
 EB9B  26 37 2A 38 28 39 29		DB	'&7*8(9)0_-+='			;   -0DH 
       30 5F 2D 2B 3D		
 EBA7  08 08 00 09			DB	8, 8, 0, 9 				; 0E-0FH	Backspace, Tab 
 EBAB  51 71 57 77 45 65 52		DB	'QqWwEeRrTtYy' 			; 10-		(Second row keys) 
       72 54 74 59 79		
 EBB7  55 75 49 69 4F 6F 50		DB	'UuIiOoPp{[}]' 			;    1BH 
       70 7B 5B 7D 5D		
 EBC3  0002[				DB	2 DUP(0DH) 				; 1C		Enter 
	   0D			
			 ]	
				
 EBC5  0002[				DB	2 DUP(01DH OR 80H) 		; 1D		*Ctrl 
	   9D			
			 ]	
				
 EBC7  41 61 53 73 44 64 46		DB	'AaSsDdFfGgHh'			; 1E-		(Third row keys) 
       66 47 67 48 68		
 EBD3  4A 6A 4B 6B 4C 6C 3A		DB	'JjKkLl:;"', "'", '~`'		;   -29H 
       3B 22 27 7E 60		
 EBDF  0002[				DB	2 DUP(02AH OR 80H)  		; 2A		*Left shift 
	   AA			
			 ]	
				
 EBE1  7C 5C 5A 7A 58 78 43		DB	'|\ZzXxCcVvBb' 			; 2B-		(Fourth row keys) 
       63 56 76 42 62		
 EBED  4E 6E 4D 6D 3C 2C 3E		DB	'NnMm<,>.?/' 			;   -35H 
       2E 3F 2F			
 EBF7  0002[				DB	2 DUP(36H OR 80H)			; 36H		*Right Shift 
	   B6			
			 ]	
				
 EBF9  00 2A				DB	0, '*' 				; 37H		PrtSc/'*' 
 EBFB  0002[				DB	2 DUP(38H OR 80H)			; 38H		*Alt 
	   B8			
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-111


			 ]	
				
 EBFD  0002[				DB	2 DUP(' ')				; 39H		Space 
	   20			
			 ]	
				
 EBFF  0002[				DB	2 DUP(3AH OR 80H) 		; 3AH		*Caps Lock 
	   BA			
			 ]	
				
				 
				;----------------------------------------------------------------------------; 
				; IMPORTANT NOTE: these next two tables are placed here to fill the "hole" 
				; for the F1-F10 keys since those scan codes are handled separately. 
				; This space can be used as long as exactly 20 bytes is left to maintain the 
				; table index. Left commented-out below for reference: 
				;	DW	10 DUP(0) 				; 3B-44H	F1-F10 
				 
				;----------------------------------------------------------------------------; 
				; Table for scan codes that are keys that set flags. 
				; The byte's index corresponds to the flag bit position in BDA's KB_FLAGS1. 
				; Length: 8 bytes 
				; 
 EC01				KEY_FLAG_ON_TBL	LABEL BYTE	;                            ICNSATLR 
 EC01  36				DB	36H			; Right shift on	0110110 -> 00000001 
 EC02  2A				DB	2AH			; Left shift on	0101010 -> 00000010 
 EC03  1D				DB	1DH			; cTrl on		0011101 -> 00000100 
 EC04  38				DB	38H			; Alt on		0111000 -> 00001000 
 EC05  46				DB	46H			; Scroll lock on 	1000110 -> 00010000 
 EC06  45				DB	45H			; Num lock on	1000101 -> 00100000 
 EC07  3A				DB	3AH			; Caps lock on	0111010 -> 01000000 
 EC08  52				DB	52H			; Insert on		1010010 -> 10000000 
 = 0008				L_KEY_FLAG_ON_TBL	EQU $-KEY_FLAG_ON_TBL 
				 
				;----------------------------------------------------------------------------; 
				; Alt keys that are "skipped" and return no scan codes 
				; Length: 10 bytes 
				; 
 EC09				INT_KB_ALT_SKIP	LABEL BYTE 
 EC09  0F				DB	0FH					; Tab 
 EC0A  1C				DB	1CH					; Enter 
 EC0B  27				DB	27H					; ; 
 EC0C  28				DB	28H					; ' 
 EC0D  29				DB	29H					; ` 
 EC0E  2B				DB	2BH					; \ 
 EC0F  33				DB	33H					; , 
 EC10  34				DB	34H					; . 
 EC11  35				DB	35H					; / 
 EC12  37				DB	37H					; * PrcSc 
 = 000A				L_INT_KB_ALT_SKIP	EQU $-INT_KB_ALT_SKIP 
				 
				;----------------------------------------------------------------------------; 
				; Resume scancode table at 45H (word aligned) 
				; 
 EC15						ORG	KEY_SCAN_TBL + 45H * 2 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-112


 EC15				KEY_SCAN_TBL_HIGH	LABEL BYTE 
 EC15  0002[				DB	2 DUP(45H OR 80H)			; 45H		*Num Lock 
	   C5			
			 ]	
				
 EC17  0002[				DB	2 DUP(46H OR 80H)			; 46H		*Scroll Lock 
	   C6			
			 ]	
				
 EC19  37 00				DB	'7', 0				; 47H		Home/7 
 EC1B  38 00				DB	'8', 0				; 48H		Up/8 
 EC1D  39 00				DB	'9', 0				; 49H		PgUp/9 
 EC1F  0002[				DB	2 DUP('-')				; 4AH		Keypad '-' 
	   2D			
			 ]	
				
 EC21  34 00				DB	'4', 0				; 4BH		Left/4 
 EC23  35 00				DB	'5', 0				; 4CH		Center/5 
 EC25  36 00				DB	'6', 0				; 4DH		Right/6 
 EC27  0002[				DB	2 DUP('+')				; 4EH		Keypad '+' 
	   2B			
			 ]	
				
 EC29  31 00				DB	'1', 0				; 4FH		End/1 
 EC2B  32 00				DB	'2', 0				; 50H		Down/2 
 EC2D  33 00				DB	'3', 0				; 51H		PgDn/3 
 EC2F  30 D2				DB	'0', 52H OR 80H			; 52H		*Ins/0 
 EC31  2E 00				DB	'.', 0				; 53H		Del 
 EC33  0002[				DB	2 DUP(0)				; 54H		SysReq 
	   00			
			 ]	
				
 = 00AA				L_KEY_SCAN_TBL EQU $-KEY_SCAN_TBL 
				 
 EC35				INT_09 ENDP 
				 
							ENDIF 
				 
				; 
				; 7 BYTES HERE / 6 BYTES HERE 5150 
				; 
				BYTES_HERE	INT_13 
 = 0024                      1	BYTES_HERE_INT_13 = INT_13-$ 
			     1			IFDEF BYTES_HERE_INT_13 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 13H - Diskette BIOS Services 
				;----------------------------------------------------------------------------; 
				;	INT 13,0  Reset disk system 
				;	INT 13,1  Get disk status 
				;	INT 13,2  Read disk sectors 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-113


				;	INT 13,3  Write disk sectors 
				;	INT 13,4  Verify disk sectors 
				;	INT 13,5  Format disk track 
				; 
				;  Typical params: 
				;	AH = function request number 
				;	AL = number of sectors	(1-128) 
				;	CH = cylinder number	(0-1023) 
				;	CL = sector number	(1-17) 
				;	DH = head number		(0-15) 
				;	DL = drive number		(0=A:, 1=B:, 80H=C:, 81H=D:) (for AH=2-5) 
				;	ES:BX = address of user buffer 
				; 
				;  Output: 
				;	CF = 0 if successful 
				;	   = 1 if error 
				;	AH = status of operation (https://stanislavs.org/helppc/int_13-1.html) 
				; 
				;----------------------------------------------------------------------------; 
				;  All functions: 
				;	- return FD_LAST_OP ([41H]) in AH 
				;	- set CF if error 
				;	- reset motor shutoff counter 
				; 
				;  Reference: 
				;	https://stanislavs.org/helppc/int_13.html 
				;	https://stanislavs.org/helppc/765.html 
				;	NEC Microcomputers, Inc. PD765C Application Note 8 (Mar 1979) 
				; 
				;  Ports: 
				;	3F0-3F7 Floppy disk controller (except PCjr) 
				;	3F0 Diskette controller status A 
				;	3F1 Diskette controller status B 
				;	3F2 controller control port 
				;	3F4 controller status register 
				;	3F5 data register (write 1-9 byte command, see INT 13) 
				;	3F6 Diskette controller data 
				;	3F7 Diskette digital input 
				; 
				;----------------------------------------------------------------------------; 
				 
				;----------------------------------------------------------------------------; 
				; Use indexed addressing to DI = FD_LAST_OP for byte savings. 
				; 
 =				_FD_LAST_OP		EQU	BYTE PTR [DI]				; FD_LAST_OP 
 =				_FD_MOTOR_ST	EQU	_FD_LAST_OP[FD_MOTOR_ST-FD_LAST_OP]	; FD_MOTOR_ST 
 =				_FD_CAL_ST		EQU	_FD_LAST_OP[FD_CAL_ST-FD_LAST_OP]	; FD_CAL_ST 
 =				_FD_TRACK		EQU	_FD_LAST_OP[FD_TRACK-FD_LAST_OP]	; FD_TRACK 
 =				_FD_MEDIA_ST	EQU	_FD_LAST_OP[FD_MEDIA_ST-FD_LAST_OP]	; FD_MEDIA_ST 
 =				_FD_TIMER		EQU	_FD_LAST_OP[TIMER-FD_LAST_OP]		; TIMER 
 =				_FDC_LAST_ST	EQU	[DI][FDC_LAST_ST-FD_LAST_OP]		; FDC_LAST_ST 
				 
 EC59						ORG 0EC59H 
 EC59				INT_13 PROC 
						ASSUME DS:_BDA 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-114


 EC59  FB				STI 						; enable interrupts 
 EC5A  FC				CLD 
					PUSHX	DS, DI				; save caller registers 
			     1				IFNB <DS>			; exit if last reg 
 EC5B  1E                    1		PUSH	DS 					; push register and repeat 
			     1		PUSHX	DI, , , , , ,  
			     2				IFNB <DI>			; exit if last reg 
 EC5C  57                    2		PUSH	DI 					; push register and repeat 
			     2		PUSHX	, , , , , ,  
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 EC5D  BF ---- R			MOV	DI, SEG _BDA			; DS = BDA 
 EC60  8E DF				MOV	DS, DI 
 EC62  47				INC	DI					; DI = FD_LAST_OP throughout 
 EC63  80 65 FE 7F			AND	_FD_MOTOR_ST, NOT MASK FWRT	; clear write operation flag 
 EC67  80 FC 01				CMP	AH, 1 				; AH = 1? 
 EC6A  74 77				JE	INT_13_1 				; AH = 1, jump to Status 
					PUSHX	DX, CX, BX				; save caller registers 
			     1				IFNB <DX>			; exit if last reg 
 EC6C  52                    1		PUSH	DX 					; push register and repeat 
			     1		PUSHX	CX, BX, , , , ,  
			     2				IFNB <CX>			; exit if last reg 
 EC6D  51                    2		PUSH	CX 					; push register and repeat 
			     2		PUSHX	BX, , , , , ,  
			     3				IFNB <BX>			; exit if last reg 
 EC6E  53                    3		PUSH	BX 					; push register and repeat 
			     3		PUSHX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 EC6F  C6 05 00				MOV	_FD_LAST_OP, FDC_ST_OK		; clear last operation 
 EC72  72 24				JB	INT_13_0 				; AH = 0, jump to Reset 
 EC74  80 FA 03				CMP	DL, 3 				; is drive number > 3? 
 EC77  77 05				JA	INT_13_BAD_CMD 			; if so, exit 
 EC79  80 FC 06				CMP	AH, 6 				; AH = 2 through 5? 
 EC7C  72 71				JB	INT_13_2_5 				; jump to FDC RWVF command 
 EC7E				INT_13_BAD_CMD: 
 EC7E  FE 05				INC	_FD_LAST_OP				; otherwise return "bad command" (1) 
 EC80				INT_13_DONE: 
 EC80  8A 25				MOV	AH, _FD_LAST_OP 			; AH = last operation status 
 EC82				INT_13_SET_MOTOR_CT: 
 EC82  93				XCHG	AX, BX				; save AL 
 EC83  B0 02				MOV	AL, DBT.FMCT 			; INT_1E[2] = motor shutoff counter 
 EC85  E8 EF48 R			CALL	INT_1E_PARAM 			; AL = shutoff counter value (37) 
 EC88  A2 0040 R			MOV	FD_MOTOR_CT, AL 			; update in BDA 
 EC8B  93				XCHG	AX, BX				; restore AL 
 EC8C				INT_13_EXIT: 
					POPX	BX, CX, DX				; restore caller registers 
			     1				IFNB <BX>			; exit if last reg 
 EC8C  5B                    1		POP	BX 					; pop register and repeat 
			     1		POPX	CX, DX, , , , ,  
			     2				IFNB <CX>			; exit if last reg 
 EC8D  59                    2		POP	CX 					; pop register and repeat 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-115


			     2		POPX	DX, , , , , ,  
			     3				IFNB <DX>			; exit if last reg 
 EC8E  5A                    3		POP	DX 					; pop register and repeat 
			     3		POPX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 EC8F				INT_13_EXIT_1: 
					POPX	DI, DS				; restore caller registers 
			     1				IFNB <DI>			; exit if last reg 
 EC8F  5F                    1		POP	DI 					; pop register and repeat 
			     1		POPX	DS, , , , , ,  
			     2				IFNB <DS>			; exit if last reg 
 EC90  1F                    2		POP	DS 					; pop register and repeat 
			     2		POPX	, , , , , ,  
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 EC91  80 FC 01				CMP	AH, FDC_ST_OK+1			; check AH for error (CF = AH < 1) 
 EC94  F5				CMC   					; invert CF for return (CF = ! CF) 
					IRET_F 					; return from int with current flags 
 EC95  CA 0002               1		RETF	2 
				 
				;----------------------------------------------------------------------------; 
				; INT 13, 0: Reset disk system 
				;----------------------------------------------------------------------------; 
				; Performs hard reset on FDC controller 
				; 
				; Input: 
				;	AH = 00 
				;	DL = drive number (0=A:, 1=2nd floppy, 80h=drive 0, 81h=drive 1) 
				;		(unused - drive is determined by BDA motor status) 
				; 
				; Output: 
				;	AH = disk operation status  (see INT 13,STATUS) 
				;	CF = 0 if successful 
				;	   = 1 if error 
				; 
				; To Convert FD_MOTOR_ST to FDC byte use the following table/formula: 
				;	Motors On 	Drive # 
				;	0 0 0 0	 	- 			AND with 1111, jump if AL = 0 
				;	1 x x x		3			TEST bit 1000, if non-zero then AL = 3 
				;	0 1 0 x		2 			Shift right once and AL will be correct 
				;	0 0 1 x		1 			" 
				;	0 0 0 x	 	0			" 
				; 
				;----------------------------------------------------------------------------; 
				; Things you must do: 
				; 
				;	- if a motor flag is on in BDA, turn it on in the FDC also 
				;	- clear reset flag in controller and pull heads to track 0 
				;	- set ALL disks need recalibration on next seek (Why all drives?) 
				;	- setting the controller reset flag causes the disk to recalibrate 
				;	  	on the next disk operation 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-116


				;	- if bit 7 is set, the diskette drive indicated by the lower 7 bits 
				;		will reset then the hard disk will follow; return code in AH is 
				;		for the drive requested (this is done by HD BIOS) 
				;----------------------------------------------------------------------------; 
 EC98				INT_13_0 PROC 
 EC98  BA 03F2				MOV	DX, FDC_CTRL			; port 3F2H, FDC Digital Output 
 EC9B  FA				CLI 						; disable interrupts 
 EC9C  A0 003F R			MOV	AL, FD_MOTOR_ST 			; 3FH - Diskette motor status 
 EC9F  8A E8				MOV	CH, AL 				; save to CH 
 ECA1  24 0F				AND	AL, MASK FMOT			; isolate motor status flags 
 ECA3  74 0E				JZ	INT_13_0_2				; jump if no motors are on, default to 0 
				 
				;----------------------------------------------------------------------------; 
				; One motor is on (according to BDA). Convert motor run flags to binary number 
				; since FDC requires a drive index for the reset. 
				; 
 ECA5  D0 E8				SHR	AL, 1					; disregard low bit (will be 0 either way) 
 ECA7  A8 04				TEST	AL, MASK FMOT3 SHR 1		; test for drive 3? 
 ECA9  74 02				JZ	INT_13_0_1				; if not drive 3, AL is now correct 
 ECAB  B0 03				MOV	AL, 3 				; otherwise set AL to drive 3 
 ECAD				INT_13_0_1: 
							ELSE 
 ECAD  B1 04				MOV	CL, 4 				; move low nibble of FD_MOTOR_ST 
 ECAF  D2 E5				SHL	CH, CL				;  into high nibble of CH 
 ECB1  0A C5				OR	AL, CH 				; combine nibbles with AL 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Reset the controller by holding FDC reset (bit 2) at 0. 
				; Perform the following memory operations here to satisfy reset timing for FDC: 
				; - Flag all drives for recalibration (not just the drive in DL) 
				; 
 ECB3				INT_13_0_2: 
 ECB3  0C 08				OR	AL, MASK FDDMA			; enable DMA & I/O interface, FDC reset 
 ECB5  EE				OUT	DX, AL				; send to FDC 
 ECB6  88 65 FD				MOV	_FD_CAL_ST, AH 			; flag all drives for recalibration 
				 
				;----------------------------------------------------------------------------; 
				; Re-enable FDC by setting bit 2 to 1. 
				; Wait for Interrupt (WIF) from FDC 
				; 
 ECB9  0C 04				OR	AL, MASK FDCEN			; set FDC enable 
 ECBB  EE				OUT	DX, AL				; send to FDC 
 ECBC  FB				STI 						; enable interrupts 
 ECBD  E8 EEDD R			CALL	FDC_WAIT_SENSE			; wait for FDC to signal interrupt 
 ECC0  72 04				JC	INT_13_0_RESET_BAD		; jump if FDC read/sense error 
 ECC2  3C C0				CMP	AL, FDC_ST0 < 11B >		; was successful reset? 
 ECC4  74 02				JZ	INT_13_0_RESET_DONE		; jump if success, AH = 0 
 ECC6				INT_13_0_RESET_BAD: 
 ECC6  B4 20				MOV	AH, FDC_ST_ERR_FDC		; otherwise, controller failure 
 ECC8				INT_13_0_RESET_DONE: 
 ECC8  88 25				MOV	_FD_LAST_OP, AH			; set last result 
 ECCA  75 B6				JNZ	INT_13_SET_MOTOR_CT		; exit on error with AH already set 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-117


				; (Re)send Specify bytes to FDC 
				; 
 ECCC  B0 03				MOV	AL, FDC_CMD_SPEC 			; [0] FDC Specify command 
 ECCE  E8 EE9A R			CALL	FDC_SEND 				; send command in AL, CF if error 
 ECD1  72 0C				JC	INT_13_0_DONE 
 ECD3  B0 00				MOV	AL, DBT.SRT				; [1] step rate time, head unload time 
 ECD5  E8 EE97 R			CALL	FDC_SEND_PARAM 
 ECD8  72 05				JC	INT_13_0_DONE 
 ECDA  B0 01				MOV	AL, DBT.HLT_ND			; [2] head load time (01H), DMA mode (ND) 
 ECDC  E8 EE97 R			CALL	FDC_SEND_PARAM 
				 
				;----------------------------------------------------------------------------; 
				; Exit and return with AL = 0 
				; 
 ECDF				INT_13_0_DONE: 
 ECDF  B0 00				MOV	AL, 0					; 0 sectors read 
 ECE1  EB 9D				JMP	SHORT INT_13_DONE 
 ECE3				INT_13_0 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 13, 1: Get disk status 
				;----------------------------------------------------------------------------; 
				; Output: AL and AH = status of last operation 
				;----------------------------------------------------------------------------; 
 ECE3				INT_13_1 PROC 
 ECE3  8A 05				MOV	AL, _FD_LAST_OP 			; AL = last operation status 
 ECE5  8A E0				MOV	AH, AL				; AH = last operation status 
 ECE7  EB A6				JMP	SHORT INT_13_EXIT_1 
 ECE9				INT_13_1 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; DMA page boundary overrun 
				; 
 ECE9				FDC_DMA_BOUND: 
 ECE9  80 0D 09				OR	_FD_LAST_OP, FDC_ST_DMA_64K	; DMA boundary error 
 ECEC  F9				STC						; re-set CF 
 ECED  EB 5E				JMP	SHORT FDC_INIT_DMA_EXIT		; rebalance stack and exit 
				 
				;----------------------------------------------------------------------------; 
				; INT 13, AH=2-5: FDC read/write operations 
				;----------------------------------------------------------------------------; 
				; All commands: 
				; 
				; 	AL = number of sectors to read  (1-128 dec.) 
				;	AH = function number 
				;	CH = track/cylinder number  (0-1023 dec., see below) 
				;	CL = sector number  (1-17 dec.) 
				;	DH = head number  (0-15 dec.) 
				;	DL = drive number (0=A:, 1=2nd floppy, 80h=drive 0, 81h=drive 1) 
				;	ES:BX = pointer to buffer 
				;----------------------------------------------------------------------------; 
				; Things you must do: 
				; 
				;	1. Set FD_MOTOR_ST read/write flag for operation 
				;	2. Motor ON (update BDA) 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-118


				;		- is motor already on? Skip wait for spin up 
				;		- wait only for writes? 
				;		- check if recalibration is necessary 
				;	3. Set up DMA 
				;	4. seek drive DL to cylinder CH, head DH 
				; 	5. send command 
				;	6. wait for interrupt 
				;	7. fetch results 
				;	8. Check FDC status bytes for result 
				; 
				; Things you should do: 
				;	- Check if drive is valid? Check if exists in BDA and not a hard drive 
				;----------------------------------------------------------------------------; 
 ECEF				INT_13_2_5 PROC 
 ECEF  86 C4				XCHG	AL, AH				; AL = function, AH = sectors to read 
 ECF1  50				PUSH	AX					; save function, sector count 
 ECF2  52				PUSH	DX					; save head, drive 
 ECF3  B6 46				MOV	DH, DMA_MR <1,0,0,1,2> 		; set DMA read mode 1 (AH = 2) 
 ECF5  3C 02				CMP	AL, 2					; is read? 
 ECF7  74 0C				JE	INT_13_2_5_SETUP_DMA		; if so, proceed to setup 
 ECF9  B6 42				MOV	DH, DMA_MR <1,0,0,0,2> 		; set DMA verify mode 0 (AH = 4) 
 ECFB  3C 04				CMP	AL, 4					; is verify? 
 ECFD  74 06				JE	INT_13_2_5_SETUP_DMA		; if so, proceed to setup 
 ECFF  B6 4A				MOV	DH, DMA_MR <1,0,0,2,2> 		; else DMA write/format mode 2 (AH = 3,5) 
 ED01  80 4D FE 80			OR	_FD_MOTOR_ST, MASK FWRT		; turn on write flag 
 ED05				INT_13_2_5_SETUP_DMA: 
 ED05  8A C6				MOV	AL, DH				; AL = DMA mode, AH = sectors to read 
 ED07  E8 EDE8 R			CALL	FDC_SEEK 				; Turn on motor, CH = track, DL = drive 
 ED0A  72 42				JC	INT_13_2_5_SEEK_ERR		; exit if seek error 
											; fall through to set up DMA 
				 
				;----------------------------------------------------------------------------; 
				; FDC_INIT_DMA: Configure DMA channel 2 for FDC operation 
				;----------------------------------------------------------------------------; 
				; Input: 
				;  AH = sectors to read 
				;  AL = DMA mode: 
				;	01000110 (46H) - Read 
				;	01000010 (42H) - Verify 
				;	01001010 (4AH) - Write 
				; 	01 			; Mode: Single mode select 
				; 	  0  			; Address increment 
				;	   0 			; Auto-initialization disable 
				;	    xx		; 00=verify, 01=write, 10=read, 11=unused 
				;	      10		; Channel 2 select 
				;  ES:BX = pointer to buffer 
				; 
				; Output: 
				;  CF = 0 success, 1 if error DMA exceeds segment 
				;----------------------------------------------------------------------------; 
				; Things you must do: 
				;	- Calculate # of bytes to transfer by multiplying AL (sectors) by 
				;		sector size in INT 1E Disk Base Table. 
				;	- Calculate physical memory address from ES:BX and normalize to 
				;		Paragraph:Offset (P:FFFFH). 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-119


				;	- Verify that Offset + Byte Count does not exceed the remaining 
				;		space in that paragraph. The DMA controller can only select one 
				;		paragraph bank at a time, so writes will NOT wrap to next para. 
				;		Exit with DMA Boundary error if segment is exceeded. 
				;	- Reset the high/low byte flip-flop (send any value to I/O port 0CH) 
				;	- Set DMA mode for Channel 2 to either Verify, Read or Write/Format 
				;	- Disable interrupts while programming DMA 
				;	- Set the DMA Page (memory paragraph) for DMA channel 2 (I/O port 81H) 
				;	- Set the DMA Byte Counter to size of transfer minus 1 (since 
				;		DMA's counter is 0-indexed) 
				;	- Set the DMA Address register to beginning of DMA buffer from ES:BX 
				;	- Enable interrupts and unmask DMA Channel 2 
				; 
				;----------------------------------------------------------------------------; 
				; References: 
				;  https://pdf1.alldatasheet.com/datasheet-pdf/view/127822/AMD/8237A.html 
				;  https://wiki.osdev.org/ISA_DMA#Floppy_Disk_DMA_Initialization 
				;  https://stackoverflow.com/questions/52396915/how-to-write-assembly-language-to-make-dma-works 
				;  https://userpages.umbc.edu/~squire/intel_book.pdf 
				;----------------------------------------------------------------------------; 
 ED0C				FDC_INIT_DMA: 
 ED0C  51				PUSH	CX					; save track / sector 
 ED0D  8C C2				MOV	DX, ES 				; get and shift ES by one nibble 
							ELSE 
 ED0F  B1 04				MOV	CL, 4					; DL = lowest and highest nibble of ES 
 ED11  D3 C2				ROL	DX, CL				; DH = middle nibbles 
							ENDIF 
 ED13  E6 0B				OUT	DMA_MODE, AL			; write to DMA mode reg (port 0BH) 
 ED15  32 C0				XOR	AL, AL				; AX = sectors to read << 8 
 ED17  91				XCHG	AX, CX				; CX = sectors, AX = scratch 
 ED18  B0 03				MOV	AL, DBT.FBPS			; get bytes/sector param (0=128, 1=256, 2=512, 3=102
				4) 
 ED1A  E8 EF48 R			CALL	INT_1E_PARAM			; AL = shift count (default 2 => 512) 
 ED1D  91				XCHG	AX, CX				; AX = sectors, CL = bytes per sector shifts 
 ED1E  D1 E8				SHR	AX, 1					; adjust shift for bytes/sector * 128 
 ED20  D3 E0				SHL	AX, CL				; AX = bytes to transfer (AX * 2^CL) 
 ED22  48				DEC	AX					; AX = bytes to transfer - 1 
 ED23  91				XCHG	AX, CX				; CX = bytes to transfer - 1 
 ED24  8A C2				MOV	AL, DL				; AL = lowest and highest nibble of ES 
 ED26  24 0F				AND	AL, 0FH				; AL = only high nibble of ES 
 ED28  80 E2 F0				AND	DL, 0F0H				; DX = low three nibbles of ES (shifted left
				 1 nibble) 
 ED2B  03 DA				ADD	BX, DX				; BX = DMA start offset for transfer 
 ED2D  14 00				ADC	AL, 0					; AL = DMA page 
 ED2F  8B D3				MOV	DX, BX				; check that buffer offset + length does not exceed 
				segment 
 ED31  03 D1				ADD	DX, CX				; DX = DMA end offset, test for boundary overflow 
 ED33  72 B4				JC	FDC_DMA_BOUND			; error if DMA access across 64k boundary 
 ED35  FA				CLI						; Disable interrupts 
 ED36  E6 0C				OUT	DMA_FF, AL				; DMA clear flip-flop (port 0CH) (any value)
				 
 ED38  E6 81				OUT	DMA_P_C2, AL 			; set DMA Channel 2 Page Address Register (port 81H)
				 
 ED3A  93				XCHG	AX, BX				; AL = address low byte, AH = high byte 
 ED3B  E6 04				OUT	DMA_2_A, AL				; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-120


 ED3D  86 C4				XCHG	AL, AH 				; AH = address low byte, AL = high byte 
 ED3F  E6 04				OUT	DMA_2_A, AL				; 
 ED41  91				XCHG	AX, CX				; AL = byte/count low byte, AH = high byte 
 ED42  E6 05				OUT	DMA_2_C, AL				; 
 ED44  86 C4				XCHG	AL, AH				; AH = byte/count low byte, AL = high byte 
 ED46  E6 05				OUT	DMA_2_C, AL 
 ED48  FB				STI						; Enable interrupts 
 ED49  B0 02				MOV	AL, DMA_SMR <0, 2>		; DMA clear single channel 2 mask bit 
 ED4B  E6 0A				OUT	DMA_MASK, AL			; Unmask DMA Channel 2 (port 0AH) 
 ED4D				FDC_INIT_DMA_EXIT: 
 ED4D  59				POP	CX					; CL = sector, CH = track 
 ED4E				INT_13_2_5_SEEK_ERR: 
 ED4E  5A				POP	DX 					; DL = drive, DH = head 
 ED4F  58				POP	AX					; AL = function, AH = sectors to read 
 ED50  72 8D				JC	INT_13_0_DONE			; exit if DMA error with AL = 0 
				 
				;----------------------------------------------------------------------------; 
				; Set FDC command byte 
				; 
 ED52  B3 C5				MOV	BL, FDC_CB <1,,0,FDC_CMD_WR>	; FDC Write Data - Multi-Track, MFM 
 ED54  3C 03				CMP	AL, 3 				; is write (AH=3)? 
 ED56  74 08				JE	FDC_RWVF				; jump if write 
 ED58  B3 4D				MOV	BL, FDC_CB <0,,0,FDC_CMD_FMT>	; FDC Format Track - Single-Track, MFM 
 ED5A  3C 05				CMP	AL, 5 				; is format (AH=5)? 
 ED5C  74 02				JE	FDC_RWVF 				; jump if format 
 ED5E  B3 E6				MOV	BL, FDC_CB <1,,1,FDC_CMD_RD>	; FDC Read/Verify - MT, MFM, Skip deleted 
											; else read (AH=2,4) 
 ED60				FDC_RWVF: 
 ED60  93				XCHG	AX, BX				; AL = FDC cmd byte, BL = function 
				 
				;----------------------------------------------------------------------------; 
				; FDC_RWVF: read, write, verify or format sectors 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AL = FDC command byte 
				;	BL = INT 13h function number 
				;	BH = sectors to read 
				;	DL = drive (0-3) 
				;	DH = head (0-1) 
				;----------------------------------------------------------------------------; 
 ED61  E8 EE9A R			CALL	FDC_SEND 				; [0] send command in AL, CF if error 
 ED64  72 64				JC	FDC_RWV_ERR 
 ED66  8A C6				MOV	AL, DH				; AL/DH = head, DL=drive 
 ED68  D0 E0				SHL	AL, 1					; [1] head / drive byte:  
 ED6A  D0 E0				SHL	AL, 1					;  xxxxx     ; unused 
 ED6C  0A C2				OR	AL, DL 				;       h    ; head number (bit 3) 
 ED6E  24 07				AND	AL, MASK FC1HD OR MASK FC1DS	;        dd  ; drive number (bit 1,2) 
 ED70  E8 EE9A R			CALL	FDC_SEND 				; send command in AL, CF if error 
 ED73  72 55				JC	FDC_RWV_ERR 
 ED75  80 FB 05				CMP	BL, 5					; is format? 
 ED78  74 53				JE	FDC_FORMAT 
				 
				;----------------------------------------------------------------------------; 
				; FDC_RWV: read, write or verify sectors 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-121


				; Input: 
				;	CH = track/cylinder number (0-39) 
				;	CL = sector number (1-17) 
				;	DH = head number (0-1) (bounds not checked) 
				; 
				; Output: 
				;	AL = number of sectors read, written or verified 
				;----------------------------------------------------------------------------; 
 ED7A				FDC_RWV PROC 
 ED7A  8A C5				MOV	AL, CH 				; [2] cylinder number 
 ED7C  E8 EE9A R			CALL	FDC_SEND 				; send command in AL, CF if error 
 ED7F  72 49				JC	FDC_RWV_ERR 
 ED81  8A C6				MOV	AL, DH 				; [3] head number 
 ED83  E8 EE9A R			CALL	FDC_SEND 				; send command in AL, CF if error 
 ED86  72 42				JC	FDC_RWV_ERR 
 ED88  8A C1				MOV	AL, CL 				; [4] sector number 
 ED8A  E8 EE9A R			CALL	FDC_SEND 				; send command in AL, CF if error 
 ED8D  72 3B				JC	FDC_RWV_ERR 
 ED8F  B0 03				MOV	AL, DBT.FBPS			; [5] bytes per sector 
 ED91  E8 EE97 R			CALL	FDC_SEND_PARAM			; 2 = 512 bytes 
 ED94  72 34				JC	FDC_RWV_ERR 
 ED96  B0 04				MOV	AL, DBT.SPT				; [6] end of track (last sector in track) 
 ED98  E8 EE97 R			CALL	FDC_SEND_PARAM 
 ED9B  72 2D				JC	FDC_RWV_ERR 
 ED9D  8A D8				MOV	BL, AL				; BL = sectors per track 
 ED9F  B0 05				MOV	AL, DBT.SGAP			; [7] sector gap length 
 EDA1  E8 EE97 R			CALL	FDC_SEND_PARAM 
 EDA4  72 24				JC	FDC_RWV_ERR 
 EDA6  B0 06				MOV	AL, DBT.LSEC			; [8] data length (if cmd byte 5==0) 
				 
				;----------------------------------------------------------------------------; 
				; Send last param and wait for status 
				; 
 EDA8				FDC_RWV_SEND_WAIT: 
 EDA8  E8 EE97 R			CALL	FDC_SEND_PARAM 
 EDAB  72 1D				JC	FDC_RWV_ERR 
 EDAD  E8 EF1B R			CALL	FDC_WAIT_STATUS			; wait for WIF and get status 
							IF FDC_ERR_SEC_CT NE 1 
 EDB0  72 18				JC	FDC_RWV_ERR				; if error, report 0 sectors read 
							ENDIF 
											; fall through for FDC SEC COUNT 
				 
				;----------------------------------------------------------------------------; 
				; FDC_SEC_COUNT: get the number of sectors read/verified/written 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	BL = sectors per track (1-9) 
				;	BH = number of sectors to read 
				;	CH = start track/cylinder number (0-39) 
				;	CL = start sector number (1-17) 
				;	DH = head number (0-1) 
				; Output: 
				;	AL = sectors transferred 
				;	AH = preserved 
				; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-122


				; Note: If the operation finishes at the last head/sector of a track,  
				;	FDC will report the head/track/sector position to be the beginning  
				;	of the next track. 
				;----------------------------------------------------------------------------; 
 EDB2				FDC_SEC_COUNT: 
 EDB2  A0 0047 R			MOV	AL, FDC_LAST_ST.SEC		; AL = FDC reported end sector 
 EDB5  8A D5				MOV	DL, CH				; DL = start track 
 EDB7  3B 55 04				CMP	DX, WORD PTR _FDC_LAST_ST.CYL	; rolled to next head or track? 
 EDBA  74 09				JE	FDC_SEC_COUNT_SAME		; if not, ended on the same head/track 
				 
				;----------------------------------------------------------------------------; 
				; Command has ended on a different head or track. Calculate the correct 
				; number of sectors spanned. 
				; 
 EDBC  3A 75 05				CMP	DH, _FDC_LAST_ST.HEAD		; end on same head but different track? 
 EDBF  75 02				JNE	FDC_SEC_COUNT_SAME_CYL		; if so, has spanned a full head 
 EDC1  02 C3				ADD	AL, BL				; add two tracks worth of sectors 
 EDC3				FDC_SEC_COUNT_SAME_CYL: 
 EDC3  02 C3				ADD	AL, BL				; add ending sector 
 EDC5				FDC_SEC_COUNT_SAME: 
 EDC5  2A C1				SUB	AL, CL				; AL = ending - starting = sec read 
					;CMP	AL, BH				; verify requested # of sectors was 
											; # actually read (not necessary). 
				 
 EDC7				FDC_RWV ENDP					; fall through for exit 
				 
				;----------------------------------------------------------------------------; 
				; Done with all disk operations and return AL 
				; 
 EDC7				INT_13_2_5_EXIT: 
 EDC7  E9 EC80 R			JMP	INT_13_DONE 
				 
				;----------------------------------------------------------------------------; 
				; Clear AL and exit on any read/write error 
				; 
 EDCA				FDC_RWV_ERR: 
 EDCA				FDC_FORMAT_ERR: 
 EDCA  E9 ECDF R			JMP	INT_13_0_DONE			; on error: exit with sectors read = 0 
				 
				;----------------------------------------------------------------------------; 
				; INT 13, 5: Format Track 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AH = 05 
				;	AL = interleave value (XT only) / sectors per track 
				;	CX = track/cylinder number (see below for format) 
				;	DL = head number  (0-15 dec.) 
				;	ES:BX = pointer to block of "track address fields" (provided by DOS) 
				;----------------------------------------------------------------------------; 
 EDCD				FDC_FORMAT PROC 
 EDCD  B0 03				MOV	AL, DBT.FBPS			; [2] bytes per sector 
 EDCF  E8 EE97 R			CALL	FDC_SEND_PARAM 
 EDD2  72 F6				JC	FDC_FORMAT_ERR 
 EDD4  B0 04				MOV	AL, DBT.SPT				; [3] sectors per track 
 EDD6  E8 EE97 R			CALL	FDC_SEND_PARAM 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-123


 EDD9  72 EF				JC	FDC_FORMAT_ERR 
 EDDB  B0 07				MOV	AL, DBT.FGAP			; [4] format gap length 
 EDDD  E8 EE97 R			CALL	FDC_SEND_PARAM 
 EDE0  72 E8				JC	FDC_FORMAT_ERR 
 EDE2  B0 08				MOV	AL, DBT.FFILL			; [5] format fill byte 
 EDE4  B1 01				MOV	CL, 1					; format always starts at sector 1 
 EDE6  EB C0				JMP	SHORT FDC_RWV_SEND_WAIT		; send, wait for WIF and get status 
 EDE8				FDC_FORMAT ENDP 
				 
 EDE8				INT_13_2_5 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; FDC_SEEK: Seek to track 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	CH = track 
				;	DL = drive (0-3) (bounds not checked) 
				;	DI = OFFSET FD_LAST_OP 
				;----------------------------------------------------------------------------; 
 EDE8				FDC_SEEK PROC 
 EDE8  50				PUSH	AX 
 EDE9  53				PUSH	BX 
 EDEA  E8 EE34 R			CALL	FDC_RECAL 				; recalibrate if needed 
 EDED  72 3F				JC	FDC_SEEK_RECAL_ERR		; exit if recal error 
				 
							IF FDC_ADV_SEEK EQ 1 
				;----------------------------------------------------------------------------; 
				; If FDC_ADV_SEEK, the current track where the head is positioned is saved in 
				; the BDA so that a subsequent operation on the same track will not require 
				; another seek. This may result in performance improvements on sequential reads. 
				; 
 EDEF  75 04				JNZ	FDC_CHECK_SEEK			; recal not needed, check if seek 
				 
				;----------------------------------------------------------------------------; 
				; Recal was executed and now on track 0. Just do a head settle if it was 
				; the destination track. 
				; 
 EDF1  84 ED				TEST	CH, CH				; destination track 0? 
 EDF3  74 2C				JZ	FDC_SEEK_SETTLE			; if so, skip to head settle time 
				 
				;----------------------------------------------------------------------------; 
				; Check BDA to see if head is already positioned at the destination track. 
				; 
 EDF5				FDC_CHECK_SEEK: 
 EDF5  32 FF				XOR	BH, BH 
 EDF7  8A DA				MOV	BL, DL				; BX = drive # 
 EDF9  38 69 53				CMP	_FD_TRACK[BX], CH			; compare last track seek to dest 
 EDFC  74 2D				JE	FDC_SEEK_DONE			; already on track - nothing to do 
							ENDIF				; end IF FDC_ADV_SEEK 
				 
 EDFE  B0 0F				MOV	AL, FDC_CMD_SEEK			; seek command (0FH) 
 EE00  E8 EE9A R			CALL	FDC_SEND 				; send command, CF if error 
 EE03  72 29				JC	FDC_SEEK_ERR 
 EE05  8A C2				MOV	AL, DL 				; AL = drive number 
 EE07  E8 EE9A R			CALL	FDC_SEND 				; send command, CF if error 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-124


 EE0A  72 22				JC	FDC_SEEK_ERR			; necessary? 
 EE0C  8A C5				MOV	AL, CH 				; AL = track number 
 EE0E  E8 EE9A R			CALL	FDC_SEND 				; send command, CF if error 
 EE11  72 1B				JC	FDC_SEEK_ERR 
 EE13  E8 EEDD R			CALL	FDC_WAIT_SENSE			; wait for WIF, sense and get status 
 EE16  72 16				JC	FDC_SEEK_ERR 
 EE18  34 60				XOR	AL, FDC_ST0 <01B, 1>		; select abnormal term, seek complete 
 EE1A  24 60				AND	AL, FDC_ST0 <01B, 1>		; ZF = abnormal term AND seek complete 
 EE1C  74 10				JZ	FDC_SEEK_ERR 
							IF FDC_ADV_SEEK EQ 1 
 EE1E  88 69 53				MOV	_FD_TRACK[BX], CH			; save last seeked track (BX = drv #) 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Allow time for heads to settle after seek. This may be skipped on emulators. 
				; 
 EE21				FDC_SEEK_SETTLE: 
							IF ARCH_TYPE NE ARCH_EMU 
 EE21  B8 0009				MOV	AX, DBT.HDST			; AH=0 JIC (AH=0 from FDC_WAIT_SENSE) 
 EE24  E8 EF48 R			CALL	INT_1E_PARAM			; AL = head settle time (ms) 
 EE27  E8 E5E0 R			CALL	IO_DELAY_MS_FDC			; delay AX ms 
							ENDIF 
 EE2A  F8				CLC						; no error 
 EE2B				FDC_SEEK_DONE: 
 EE2B  5B				POP	BX 
 EE2C  58				POP	AX 
 EE2D  C3				RET 
				 
 EE2E				FDC_SEEK_RECAL_ERR: 
 EE2E				FDC_SEEK_ERR: 
 EE2E  80 0D 40				OR	_FD_LAST_OP, FDC_ST_ERR_SEEK 
 EE31  F9				STC 
 EE32  EB F7				JMP	SHORT FDC_SEEK_DONE 
 EE34				FDC_SEEK ENDP 
				 
				;----------------------------------------------------------------------------; 
				; FDC_RECAL: recalibrate drive, if necessary 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	DL = drive to recalibrate (0-3) (bounds not checked) 
				;	DI = OFFSET FD_LAST_OP 
				; Output: 
				;	CF if error 
				; 
				; Clobbers: AX, BX (if ADV_SEEK) 
				;----------------------------------------------------------------------------; 
 EE34				FDC_RECAL PROC 
 EE34  51				PUSH	CX 
				 
				;----------------------------------------------------------------------------; 
				; FDC_MOTOR_ON: Turn on motor 
				;----------------------------------------------------------------------------; 
				; Input: 
				; 	DL = drive number (0-3) (bounds not checked) 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-125


				; Things you must do: 
				;	- is motor already on? Skip wait for spin up 
				;	- wait only for writes? 
				;	- check if recalibration is necessary 
				;----------------------------------------------------------------------------; 
 EE35				FDC_MOTOR_ON: 
 EE35  8A CA				MOV	CL, DL 				; move to CL for shift 
				 
				;----------------------------------------------------------------------------; 
				; Convert drive number to motor run format 
				; 
 EE37  B8 0110				MOV	AX, 110H 				; AH -> RUN_ST, AL -> FDC byte 
 EE3A  D3 E0				SHL	AX, CL 				; shift drive flags 
 EE3C  FA				CLI 						; disable interrupts 
 EE3D  8A 6D FE				MOV	CH, _FD_MOTOR_ST			; get current RUN_ST 
 EE40  84 EC				TEST	CH, AH 				; is drive already running? 
 EE42  75 21				JNZ	FDC_DRIVE_STARTED			; skip startup if so 
 EE44  0A C1				OR	AL, CL 				; combine drive number to FDC byte 
 EE46  0C 0C				OR	AL, MASK FDDMA OR MASK FDCEN	; set DMA and controller enable flags 
 EE48  52				PUSH	DX					; preserve DX 
 EE49  BA 03F2				MOV	DX, FDC_CTRL			; turn on motor 
 EE4C  EE				OUT	DX, AL				; port 3F2H, FDC Digital Output 
 EE4D  5A				POP	DX 
 EE4E  8A C5				MOV	AL, CH 				; AL = FD_MOTOR_ST 
 EE50  8A EC				MOV	CH, AH				; CH = RUN_ST drive bit field 
 EE52  24 F0				AND	AL, NOT MASK FMOT 		; clear motor status of FD_MOTOR_ST 
 EE54  0A C4				OR	AL, AH				; combine nibbles, SF if write 
 EE56  98				CBW						; restart timer to max for operation 
 EE57  A3 003F R			MOV	WORD PTR FD_MOTOR_ST, AX	; write to motor status and timer 
 EE5A  79 09				JNS	FDC_DRIVE_STARTED 		; delay for motor spinup if write op 
				 
				;----------------------------------------------------------------------------; 
				; Delay using timer tick counter 
				; 
 EE5C  FB				STI 						; enable interrupts 
 EE5D  B0 0A				MOV	AL, DBT.FMST			; AL = INT_1E[10] 
 EE5F  E8 EF48 R			CALL	INT_1E_PARAM 			; AL = motor startup time (in 125ms) 
 EE62  E8 E5DC R			CALL	IO_WAIT_MS_125			; wait AL * 125ms 
				 
 EE65				FDC_DRIVE_STARTED: 
 EE65  80 E5 0F				AND	CH, MASK FMOT			; isolate drives, remove write flag 
 EE68  FB				STI 						; ensure interrupts enabled 
				 
				;----------------------------------------------------------------------------; 
				; Calibrate drive if necessary 
				; 
 EE69  84 6D FD				TEST	CH, _FD_CAL_ST 			; 0 means drive is uncalibrated 
 EE6C  75 22				JNZ	FDC_RECAL_DONE 			; if drive is calibrated, exit 
 EE6E  B0 07				MOV	AL, FDC_CMD_RECAL 		; recalibrate command (07H) 
 EE70  E8 EE9A R			CALL	FDC_SEND 				; send command, CF if error 
 EE73  72 1B				JC	FDC_RECAL_ERR 
 EE75  8A C1				MOV	AL, CL 				; AL = drive number 
 EE77  E8 EE9A R			CALL	FDC_SEND 				; send command, CF if error 
					;JC	FDC_RECAL_ERR			; (necessary?) 
 EE7A  E8 EEDD R			CALL	FDC_WAIT_SENSE 			; wait for WIF, sense and get status in AL 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-126


 EE7D  72 11				JC	FDC_RECAL_ERR 
 EE7F  34 60				XOR 	AL, FDC_ST0 <01B, 1>		; select abnormal term, seek complete 
 EE81  24 60				AND	AL, FDC_ST0 <01B, 1>		; ZF = abnormal term AND seek complete 
 EE83  F9				STC						; presume failure 
 EE84  74 0A				JZ	FDC_RECAL_ERR			; jump if error 
 EE86  08 6D FD				OR	_FD_CAL_ST, CH 			; mark drive as calibrated and CLC 
				 
							IF FDC_ADV_SEEK EQ 1 
				;----------------------------------------------------------------------------; 
				; Save track 0 to BDA FD_TRACK 
				; 
 EE89  32 FF				XOR	BH, BH				; track 0 and set ZF 
 EE8B  8A DA				MOV	BL, DL				; BX = drive index 
 EE8D  88 79 53				MOV	_FD_TRACK[BX], BH			; save last track seek 0 
							ENDIF 
				 
 EE90				FDC_RECAL_ERR: 
 EE90				FDC_RECAL_DONE: 
 EE90  59				POP	CX 
 EE91  C3				RET 
 EE92				FDC_RECAL ENDP 
				 
				;----------------------------------------------------------------------------; 
				; FDC_RECV: Wait for FDC ready to send and read next FDC Status byte into AL 
				;----------------------------------------------------------------------------; 
				; Timeout is 5 timer ticks = ~275ms. 
				; 
				; Input: None 
				; Output: 
				;	AL = top of FDC status stack 
				;	AH = 80H if error, 0 if success 
				;	CF if timeout or error 
				;----------------------------------------------------------------------------; 
 EE92				FDC_RECV PROC 
 EE92  53				PUSH	BX 
 EE93  33 DB				XOR	BX, BX				; flag is 0 if RECV operation 
 EE95  EB 06				JMP	SHORT FDC_SEND_RECV 
				 
				;----------------------------------------------------------------------------; 
				; FDC_SEND_PARAM: Wait for FDC ready and send a floppy param in AL 
				;----------------------------------------------------------------------------; 
				; Same as below except AL input is INT_1E param index 
				;----------------------------------------------------------------------------; 
 EE97				FDC_SEND_PARAM PROC 
 EE97  E8 EF48 R			CALL	INT_1E_PARAM 			; AL = INT_1E[AL] param 
				 
				;----------------------------------------------------------------------------; 
				; FDC_SEND: Wait for FDC ready to receive and send a single command 
				;----------------------------------------------------------------------------; 
				; Timeout is 5 timer ticks = ~275ms. 
				; 
				; Input: 
				;	AL = byte to send to FDC 
				; 
				; Output: 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-127


				;	AL = status register 
				;	AH = 80H if error, 0 if success 
				;	CF and ZF if error 
				;----------------------------------------------------------------------------; 
 EE9A				FDC_SEND PROC 
 EE9A  53				PUSH	BX 
 EE9B  B3 01				MOV	BL, 1					; flag is 1 if SEND operation 
				 
 EE9D				FDC_SEND_RECV: 
 EE9D  8A F8				MOV	BH, AL				; save byte to send 
 EE9F  51				PUSH	CX 
 EEA0  52				PUSH	DX 					; call-preserve used registers 
				 
				;----------------------------------------------------------------------------; 
				; Wait for FDC I/O direction = CPU to FDC and Data Reg Ready 
				; 
 EEA1  BA 03F4				MOV	DX, FDC_STAT 			; port 3F4H - FDC Main Status Register 
 EEA4  B9 0005				MOV	CX, 5					; CX = # of ticks to wait 
 EEA7  8A 26 006C R			MOV	AH, BYTE PTR TIMER.LW		; get starting tick counter low byte 
				 
 EEAB				FDC_SEND_WAIT_POLL: 
 EEAB  EC				IN	AL, DX				; AL = FDC status register 
 EEAC  84 C0				TEST	AL, AL				; is DRR = I/O to/from CPU? 
 EEAE  79 19				JNS	FDC_SEND_WAIT_TIMER		; if not, check if timeout has elapsed 
				 
				;----------------------------------------------------------------------------; 
				; FDC is ready for I/O 
				; 
 EEB0  42				INC	DX 					; port 3F5H - FDC Command Status Register 
 EEB1  84 DB				TEST	BL, BL				; is send or receive? 
 EEB3  74 09				JZ	FDC_RECV_WAIT_POLL		; jump if receive 
				 
				;----------------------------------------------------------------------------; 
				; SEND operation 
				;----------------------------------------------------------------------------; 
 EEB5				FDC_SEND_WAIT_POLL_1: 
 EEB5  A8 40				TEST	AL, MASK FIOD			; is I/O direction = CPU to FDC (0)? 
 EEB7  75 10				JNZ	FDC_SEND_WAIT_TIMER		; if not, check if timeout has elapsed 
				 
				;----------------------------------------------------------------------------; 
				; Status is ready to send 
				; 
 EEB9				FDC_SEND_READY: 
 EEB9  8A C7				MOV	AL, BH				; restore AL byte to send 
 EEBB  EE				OUT	DX, AL				; send command 
 EEBC  EB 05				JMP	SHORT FDC_WAIT_DONE		; status = success (0), CF = 0 and done 
				 
				;----------------------------------------------------------------------------; 
				; RECEIVE operation 
				;----------------------------------------------------------------------------; 
 EEBE				FDC_RECV_WAIT_POLL: 
 EEBE  A8 40				TEST	AL, MASK FIOD			; is I/O direction = FDC to CPU (1)? 
 EEC0  74 07				JZ	FDC_SEND_WAIT_TIMER		; if not, check if timeout has elapsed 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-128


				; Data is ready to read 
				; 
 EEC2				FDC_RECV_READY: 
 EEC2  EC				IN	AL, DX				; read from FDC 
				 
				;----------------------------------------------------------------------------; 
				; Completed with success 
				; 
 EEC3				FDC_WAIT_DONE: 
 EEC3  32 E4				XOR	AH, AH 				; status = success (0), CF = 0 
				 
 EEC5				FDC_WAIT_EXIT: 
 EEC5  5A				POP	DX 
 EEC6  59				POP	CX 
 EEC7  5B				POP	BX 
 EEC8  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; Check if timeout has expired 
				; 
 EEC9				FDC_SEND_WAIT_TIMER: 
 EEC9  A0 006C R			MOV	AL, BYTE PTR TIMER.LW		; get current tick counter 
 EECC  3A C4				CMP	AL, AH				; still the same? 
 EECE  74 DB				JZ	FDC_SEND_WAIT_POLL		; loop if the same 
 EED0  8A E0				MOV	AH, AL				; otherwise, save new tick value to AH 
 EED2  E0 D7				LOOPNZ FDC_SEND_WAIT_POLL		; loop until # of ticks (CX) has elapsed 
				 
 EED4				FDC_WAIT_TIMEOUT: 
 EED4  B4 80				MOV	AH, FDC_ST_TIMEOUT 		; time out, drive not ready error 
 EED6  08 26 0041 R			OR	FD_LAST_OP, AH			; set flag in BDA 
 EEDA  F9				STC						; set error 
 EEDB  EB E8				JMP	SHORT	FDC_WAIT_EXIT 
				 
 EEDD				FDC_SEND ENDP 
 EEDD				FDC_SEND_PARAM ENDP 
 EEDD				FDC_RECV ENDP 
				 
				;----------------------------------------------------------------------------; 
				; FDC_WAIT_SENSE: wait for WIF, sense status and get status bytes 
				;----------------------------------------------------------------------------; 
				; Output: 
				;	CF if FDC read/timeout error 
				;	NZ if result status error 
				;	AL = FDC_LAST_ST (BDA Floppy drive status) 
				;	AH = 0 if success, 80H if failure 
				;----------------------------------------------------------------------------; 
 EEDD				FDC_WAIT_SENSE PROC 
 EEDD  E8 EF6A R			CALL	FDC_WAIT_INT 			; wait for WIF 
 EEE0  72 2F				JC	FDC_WAIT_SENSE_EXIT 
 EEE2  B0 08				MOV	AL, FDC_CMD_SENSE			; sense Interrupt status 
 EEE4  E8 EE9A R			CALL	FDC_SEND 
				 
				;----------------------------------------------------------------------------; 
				; FDC_RECV_STATUS: 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-129


				; Output: 
				;	CF if FDC read/timeout error 
				;	NZ if result status error 
				; 
				;	AL = FDC_LAST_ST (BDA Floppy drive status), if success 
				;	AH = 0 if success, 80H if failure 
				;----------------------------------------------------------------------------; 
 EEE7				FDC_RECV_STATUS PROC 
 EEE7  72 28				JC	FDC_WAIT_SENSE_EXIT		; return if timeout error 
											; fall through to FDC_RECV_ALL 
				 
				;----------------------------------------------------------------------------; 
				; FDC_RECV_ALL: Pop all status bytes from FDC to BDA 
				;----------------------------------------------------------------------------; 
				; Check for FDC errors and set FD_LAST_OP if necessary 
				; Input: DS = BDA (40H), DI = FD_LAST_OP (41H) 
				; Output: AH = 0 if success, 80H if failure 
				;----------------------------------------------------------------------------; 
 EEE9				FDC_RECV_ALL PROC 
 EEE9  06				PUSH	ES 
 EEEA  51				PUSH	CX 
 EEEB  57				PUSH	DI					; preserve DI (FD_LAST_OP) 
 EEEC  52				PUSH	DX 
 EEED  BA 03F4				MOV	DX, FDC_STAT 
 EEF0  1E				PUSH	DS					; ES = BDA segment 
 EEF1  07				POP	ES 
 EEF2  47				INC	DI					; DI = FDC_LAST_ST (FDC Last Result) 
 EEF3  B9 0007				MOV	CX, 7					; loop up to 7 FDC bytes 
 EEF6				FDC_RECV_ALL_LOOP: 
 EEF6  E8 EE92 R			CALL	FDC_RECV				; AL = next byte, AH = 0 if success 
 EEF9  72 12				JC	FDC_RECV_ALL_DONE			; CF if failure 
 EEFB  AA				STOSB						; write to BDA 
				 
				;----------------------------------------------------------------------------; 
				; Additional delay for FDC to settle 
				; 
						ELSE					;  ~37us at 10MHz, ~46us at 8MHz) 
 EEFC  B0 0A				MOV	AL, 10				; delay ~225 clocks (~47us at 4.77) 
						ENDIF 
 EEFE				FDC_RECV_DELAY:					; [7+19(AX-1)] clocks 
 EEFE  48				DEC	AX					; [3] 
 EEFF  75 FD				JNZ	FDC_RECV_DELAY			; [4+16(AX-1)] 
				 
				;----------------------------------------------------------------------------; 
				; Check for additional bytes to be read from FDC registers 
				; 
 EF01  EC				IN	AL, DX				; DX = 03F4H 
 EF02  24 10				AND	AL, MASK FDRW 			; is FDC R/W command in progress flag? 
 EF04  E0 F0				LOOPNZ FDC_RECV_ALL_LOOP		; loop until no flag or 7 bytes read 
 EF06  75 0A				JNZ	FDC_RECV_FDC_ERR			; command still in progress? 
											; AL = 0 (no command in progress) or CX = 0 
						ENDIF 
 EF08				FDC_RECV_CHECK_ERR: 
 EF08  A0 0042 R			MOV	AL, FDC_LAST_ST.SB0 		; AL = last FDC status byte 0 
 EF0B  A8 C0				TEST	AL, MASK ST0CS			; check Last Command Status 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-130


 EF0D				FDC_RECV_ALL_DONE: 
 EF0D  5A				POP	DX 
 EF0E  5F				POP	DI					; DI = FD_LAST_OP 
 EF0F  59				POP	CX 
 EF10  07				POP	ES 
 EF11				FDC_WAIT_SENSE_EXIT: 
 EF11  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; Command still in progress after reading 7 bytes. Return FDC error. 
				; 
 EF12				FDC_RECV_FDC_ERR: 
 EF12  B4 20				MOV	AH, FDC_ST_ERR_FDC		; controller still busy after 
 EF14  08 26 0041 R			OR	FD_LAST_OP, AH			;  reading max bytes 
 EF18  F9				STC 
 EF19  EB F2				JMP	SHORT FDC_RECV_ALL_DONE 
 EF1B				FDC_RECV_ALL ENDP 
 EF1B				FDC_RECV_STATUS ENDP 
 EF1B				FDC_WAIT_SENSE ENDP 
				 
				;----------------------------------------------------------------------------; 
				; FDC_WAIT_STATUS: Wait for WIF, get status bytes and check for error 
				;----------------------------------------------------------------------------; 
 EF1B				FDC_WAIT_STATUS PROC 
 EF1B  E8 EF6A R			CALL	FDC_WAIT_INT 			; wait for WIF 
 EF1E  E8 EEE7 R			CALL	FDC_RECV_STATUS			; read FDC status into BDA 
											; CF if FDC error, NZ if status error 
 EF21  76 1C				JBE	FDC_WAIT_ERR_EXIT_OK		; exit if ZF or CF error 
				 
				;----------------------------------------------------------------------------; 
				; FDC_WAIT_STATUS_ERR: Map FDC Command Status Register 1 to BDA error codes 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AL = Last result from FDC_LAST_ST 
				; Output: 
				;	CF if error 
				;	AH/AL = BDA Floppy drive status 
				;----------------------------------------------------------------------------; 
 EF23				FDC_WAIT_STATUS_ERR PROC 
 EF23  A8 40				TEST	AL, FDC_ST0 < 01B >		; command terminated abnormally? 
 EF25  B0 20				MOV	AL, FDC_ST_ERR_FDC		; if not, FDC error 
 EF27  74 11				JZ	FDC_WAIT_STATUS_ERR_DONE 
 EF29  98				CBW						; AH = 0 
 EF2A  0A 65 02				OR	AH, _FDC_LAST_ST.SB1		; AH = last status byte 1, ZF if 0 
 EF2D  74 0B				JZ	FDC_WAIT_STATUS_ERR_DONE	; skip if AH = 0 
 EF2F  56				PUSH	SI 
 EF30  BE EF40 R			MOV	SI, OFFSET FDC_ERR1_MAP 
 EF33				FDC_ERR_MAP_LOOP: 
 EF33  2E: AC				LODS	BYTE PTR CS:[SI]			; fetch next error byte 
 EF35  D0 E4				SHL	AH, 1					; CF if this status flag 
 EF37  77 FA				JA	FDC_ERR_MAP_LOOP			; loop if NC (not this flag) 
 EF39  5E				POP	SI					;  and NZ (more flags to check) 
 EF3A				FDC_WAIT_STATUS_ERR_DONE: 
 EF3A  8A E0				MOV	AH, AL				; AH = last result 
 EF3C				FDC_WAIT_ERR_EXIT: 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-131


 EF3C  08 25				OR	_FD_LAST_OP, AH			; BDA 40:41H 
 EF3E  F9				STC 
 EF3F				FDC_WAIT_ERR_EXIT_OK: 
 EF3F  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; FDC Status register to INT 13h error map 
				; Note: Must check from most sig bit to lowest since higher 
				; bits are more meaningful. 
				; 
 EF40				FDC_ERR1_MAP LABEL BYTE 
 EF40  04				DB	FDC_ST_ERR_SEC			; 80 end of cylinder 
 EF41  20				DB	FDC_ST_ERR_FDC			; 40 unused (always zero) 
 EF42  10				DB	FDC_ST_ERR_CRC			; 20 data error CRC 
 EF43  08				DB	FDC_ST_DMA_OVR			; 10 DMA timeout/overrun 
 EF44  20				DB	FDC_ST_ERR_FDC			; 08 unused (always zero) 
 EF45  04				DB	FDC_ST_ERR_SEC			; 04 Sector Not Found 
 EF46  03				DB	FDC_ST_ERR_WP			; 02 Write Protect 
 EF47  02				DB	FDC_ST_ERR_MARK			; 01 Address mark not found or bad sector 
				 
 EF48				FDC_WAIT_STATUS_ERR ENDP 
 EF48				FDC_WAIT_STATUS ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Retrieve a parameter value from the DBT by index 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AL = parameter index (bounds not checked) 
				; Output: 
				;	AL = byte 
				; 
				; Size: 14 bytes 
				;----------------------------------------------------------------------------; 
 EF48				INT_1E_PARAM PROC 
 EF48  1E				PUSH	DS 
 EF49  53				PUSH	BX 
 EF4A  33 DB				XOR	BX, BX 				; BX = IVT 
 EF4C  8E DB				MOV	DS, BX 				; DS = IVT 
							ASSUME DS:_IVT 
 EF4E  C5 1E 0078 R			LDS	BX, IVT_1E				; DS:BX = INT 1EH in IVT 
 EF52  D7				XLAT 						; AL = byte 
 EF53  5B				POP	BX 
 EF54  1F				POP	DS 
							ASSUME DS:NOTHING 
 EF55  C3				RET 
 EF56				INT_1E_PARAM ENDP 
				 
				; 
				; 2 BYTES HERE 
				; 
				BYTES_HERE	INT_0E 
 = 0001                      1	BYTES_HERE_INT_0E = INT_0E-$ 
			     1			IFDEF BYTES_HERE_INT_0E 
			     1			IF2 
			     1			ENDIF 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-132


			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 0EH - Floppy Disk Interrupt IRQ6 
				;----------------------------------------------------------------------------; 
				; This interrupt is issued upon floppy disk I/O completion and sets the 
				; floppy disk working interrupt flag at 40:3E, bit 7. 
				;----------------------------------------------------------------------------; 
 EF57						ORG 0EF57H 
 EF57				INT_0E PROC 
 EF57  FB				STI						; necessary? 
 EF58  50				PUSH	AX 
 EF59  1E				PUSH	DS 
 EF5A  33 C0				XOR	AX, AX				; DS = BDA_ABS segment 
 EF5C  8E D8				MOV	DS, AX 
							ASSUME DS:_BDA_ABS 
 EF5E  80 0E 043E R 80			OR	FD_CAL_ST_ABS, MASK FWIF	; turn on working interrupt flag 
 EF63  B0 20				MOV	AL, EOI 				; End of Interrupt OCW 
 EF65  E6 20				OUT	INT_P0, AL				; write EOI to port 0 
 EF67  1F				POP	DS 
							ASSUME DS:NOTHING 
 EF68  58				POP	AX 
 EF69  CF				IRET 
 EF6A				INT_0E ENDP 
				 
				;----------------------------------------------------------------------------; 
				; FDC_WAIT_INT: Wait for BDA Working Interrupt Flag from FDC 
				;----------------------------------------------------------------------------; 
				; Input: DS = BDA, DI = FD_LAST_OP 
				; Output: CF if timeout 
				;----------------------------------------------------------------------------; 
 EF6A				FDC_WAIT_INT PROC 
							ASSUME DS:_BDA 
 EF6A  FB				STI						; ensure interrupts are on 
 EF6B  50				PUSH	AX 					; call preserve regs 
 EF6C  51				PUSH	CX 
 EF6D  B9 0025				MOV	CX, 2 * (1000/55) + 1		; timeout ~2 sec (37 ticks) 
 EF70				FDC_WAIT_INT_LOOP1: 
 EF70  A1 006C R			MOV	AX, TIMER.LW			; AX = time ticks 
 EF73				FDC_WAIT_INT_LOOP2: 
 EF73  F6 45 FD 80			TEST	_FD_CAL_ST, MASK FWIF 		; check for WIF in FD_CAL_ST (3EH) 
 EF77  75 0F				JNZ	FDC_WAIT_INT_OK			; if so, exit 
							IF FDC_HLT_WAIT GT 0 
 EF79  F4				HLT						; wait for any INT 
							ENDIF 
 EF7A  3B 06 006C R			CMP	AX, TIMER.LW			; has timer tick changed? 
 EF7E  74 F3				JZ	FDC_WAIT_INT_LOOP2		; if not, wait for next INT 
 EF80  E2 EE				LOOP	FDC_WAIT_INT_LOOP1		; decrement tick counter and resume loop 
 EF82  80 0D 80				OR	_FD_LAST_OP, FDC_ST_TIMEOUT 	; FDC result set time out, drive not ready 
 EF85  F9				STC 
 EF86  EB 04				JMP	SHORT FDC_WAIT_INT_DONE 
 EF88				FDC_WAIT_INT_OK: 
 EF88  80 65 FD 7F			AND	_FD_CAL_ST, NOT MASK FWIF 	; clear working interrupt flag 
 EF8C				FDC_WAIT_INT_DONE: 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-133


 EF8C  59				POP	CX 
 EF8D  58				POP	AX 
 EF8E  C3				RET 
 EF8F				FDC_WAIT_INT ENDP 
				 
 EF8F				INT_13 ENDP 
				 
							ENDIF 
				 
				; 
				; 20 BYTES HERE 
				; 
				BYTES_HERE	INT_1E 
 = 0038                      1	BYTES_HERE_INT_1E = INT_1E-$ 
			     1			IFDEF BYTES_HERE_INT_1E 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 1E - Disk Initialization Parameter Table Vector 
				;----------------------------------------------------------------------------; 
				; Provides a "pluggable" method to allow additional disk ROMs or DOS to  
				; replace this table. 
				; 
				;  00  Head Step Rate (SRT) = 0CH = 12ms 
				;      Head Unload Time (HUT) = 15 x (16ms increments) = 240ms(?) 
				;  01  Head Load Time = 2 (2ms increments) = 1, DMA flag (0 = use DMA) 
				;  02  timer ticks to wait before disk motor shutoff = 37 
				;  03  512 bytes per sector (0=128, 1=256, 2=512, 3=1024) = 2 
				;  04  sectors per track (last sector number) = 8 
				;  05  inter-block gap length/gap between sectors (mills) 42 
				;  06  data length, if sector length not specified = 0FFH 
				;  07  gap length between sectors for format (mills) 80 
				;  08  fill byte for formatted sectors = 0F6H 
				;  09  head settle time in milliseconds = 25 
				;  0A  motor startup time in eighths of a second = 4 
				;  MFM = 2 
				; 
				; https://stanislavs.org/helppc/dbt.html 
				; https://stanislavs.org/helppc/765.html 
				; https://stanislavs.org/helppc/int_1e.html 
				;----------------------------------------------------------------------------; 
 EFC7						ORG 	0EFC7H 
 EFC7  CF			INT_1E	DBT 	<DNB <12, 15>, 0010B, 37, 2, 8, 42, 0FFH, 80, 0F6H, 25, 4> 
 EFC8  02			
 EFC9  25			
 EFCA  02			
 EFCB  08			
 EFCC  2A			
 EFCD  FF			
 EFCE  50			
 EFCF  F6			
 EFD0  19			
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-134


 EFD1  04			
				
				 
				;----------------------------------------------------------------------------; 
				; INT 17 - Printer BIOS Services 
				;----------------------------------------------------------------------------; 
				;	INT 17,0   Print character 
				;	INT 17,1   Initialize printer port 
				;	INT 17,2   Read printer port status 
				; 
				; https://www.stanislavs.org/helppc/ports.html 
				; https://en.wikipedia.org/wiki/Parallel_port#IBM_PC_implementation 
				; http://www.techhelpmanual.com/907-parallel_printer_adapter_ports.html 
				;----------------------------------------------------------------------------; 
				; Things you must do (on all calls): 
				; - Verify printer is within range 0-2. 
				; - Verify printer index is detected and get I/O address. 
				; - Return AH = 0 if any of the above are not met. 
				; - Do the function call 
				; - Get port status and return in AH for any valid calls. 
				;----------------------------------------------------------------------------; 
 EFD2						ORG 0EFD2H 
 EFD2				INT_17 PROC 
						ASSUME DS:_BDA 
 EFD2  FB				STI 						; enable interrupts 
 EFD3  83 FA 03				CMP	DX, LENGTH LPT_ADDR		; is port number valid? 
 EFD6  73 4A				JAE	INT_17_IRET 			; if not, exit 
					PUSHX	DX, DI, CX, AX, DS		; call-preserve working regs 
			     1				IFNB <DX>			; exit if last reg 
 EFD8  52                    1		PUSH	DX 					; push register and repeat 
			     1		PUSHX	DI, CX, AX, DS, , ,  
			     2				IFNB <DI>			; exit if last reg 
 EFD9  57                    2		PUSH	DI 					; push register and repeat 
			     2		PUSHX	CX, AX, DS, , , ,  
			     3				IFNB <CX>			; exit if last reg 
 EFDA  51                    3		PUSH	CX 					; push register and repeat 
			     3		PUSHX	AX, DS, , , , ,  
			     4				IFNB <AX>			; exit if last reg 
 EFDB  50                    4		PUSH	AX 					; push register and repeat 
			     4		PUSHX	DS, , , , , ,  
			     5				IFNB <DS>			; exit if last reg 
 EFDC  1E                    5		PUSH	DS 					; push register and repeat 
			     5		PUSHX	, , , , , ,  
			     6				ENDIF 
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 EFDD  B9 ---- R			MOV	CX, SEG _BDA 			; CH = 0, CL = 40H 
 EFE0  8E D9				MOV	DS, CX				; DS = BDA 
 EFE2  8B FA				MOV	DI, DX 				; DI = LPT port index (0-2) 
 EFE4  8A 4D 78				MOV	CL, LPT_TIME_B[DI]		; CX = port timeout 
 EFE7  D1 E7				SHL	DI, 1 				; convert to word-aligned index 
 EFE9  8B 55 08				MOV	DX, LPT_ADDR_B[DI]		; DX = data port address 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-135


 EFEC  1F				POP	DS 					; restore DS 
 EFED  85 D2				TEST	DX, DX 				; is port index valid (detected)? 
 EFEF  74 2B				JZ	INT_17_DONE 			; if not, exit 
 EFF1  FE CC				DEC	AH 
 EFF3  74 2E				JZ	INT_17_1				; AH = 1 then init 
 EFF5  7F 1D				JG	INT_17_2	 			; AH = 2 then status 
											; AH = 0 fall through to print 
				 
				;----------------------------------------------------------------------------; 
				; AH = 0 - Print Character 
				;----------------------------------------------------------------------------; 
				; Write character and returns status 
				; 
				; Input: 
				;	AH = -1 (not 0) 
				;	AL = character to print 
				;	CX = timeout "value" (the number of 64k loops) 
				;	DX = LPT data port (278, 378, 3BC) 
				; 
				; Output: 
				;	AH = printer status, see AH = 2 
				; 
				;----------------------------------------------------------------------------; 
				; 765	    |			- LCX		unused 
				;    4    |			- LCIRQ	0 = IRQ disable, 1=IRQ enable for ACK 
				;     3   |			- LCDR	1 = printer reads output,  (pin 17) 
				;      2  |			- LCINI	0 = initialize printer,  (pin 16) 
				;       1 |			- LCLF	1 = auto line feed,  (pin 14) 
				;        0|			- LCOUT	1 = output data to printer,  (pin 1) 
				; PRN_CTRL RECORD	LCX:3,LCIRQ:1,LCDR:1,LCINI:1,LCLF:1,LCOUT:1 
				;----------------------------------------------------------------------------; 
 EFF7				INT_17_0: 
 EFF7  EE				OUT	DX, AL			; write the character to data port 
 EFF8  42				INC	DX				; DX to status port 
 EFF9				INT_17_0_TIMEOUT_LOOP: 
 EFF9  33 FF				XOR	DI, DI			; set abitrary timeout counter 
 EFFB				INT_17_0_BUSY_LOOP: 
 EFFB  EC				IN	AL, DX			; read status port 
 EFFC  A8 80				TEST	AL, MASK LPBZ 		; printer busy? 
 EFFE  75 09				JNZ	INT_17_0_OK			; if not, toggle strobe pin and exit 
 F000  4F				DEC	DI 
 F001  75 F8				JNZ	INT_17_0_BUSY_LOOP 
 F003  E2 F4				LOOP	INT_17_0_TIMEOUT_LOOP 	; loop BDA/LPT timeout value 
 F005  0C 01				OR	AL, MASK LPTO		; printer timed out - set flag 
 F007  EB 0F				JMP	SHORT INT_17_2_STATUS_2	; exit with status in AL 
 F009				INT_17_0_OK: 
 F009  B0 0D				MOV	AL, MASK LCDR OR MASK LCINI OR MASK LCOUT ; /strobe pin HIGH 
 F00B  42				INC	DX 				; DX = control port 
 F00C  52				PUSH	DX				; I/O delay 
 F00D  EE				OUT	DX, AL 
 F00E  5A				POP	DX				; I/O delay 
 F00F  B0 0C				MOV	AL, MASK LCDR OR MASK LCINI	; /strobe pin LOW 
 F011  EE				OUT	DX, AL 
 F012  4A				DEC	DX 				; reset to data port 
 F013  4A				DEC	DX				; and fall through to status 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-136


				 
				;----------------------------------------------------------------------------; 
				; AH = 2 - Read printer port status 
				;----------------------------------------------------------------------------; 
				; Return status of specified printer port 
				; 
				; Input: 
				;	AH = 1 (not 2) 
				;	DX = LPT data port (278, 378, 3BC) 
				; 
				; Output: 
				;	AH = status: 
				; 
				;		|7|6|5|4|3|2|1|0|  Printer status bits 
				;		 | | | | | | | `---- time out		(always 0) 
				;		 | | | | | `------- unused 
				;		 | | | | `-------- I/O error		Pin 15 
				;		 | | | `--------- selected		Pin 13 
				;		 | | `---------- out of paper		Pin 12 
				;		 | `----------- acknowledge		Pin 10 
				;		 `------------ not busy			/Pin 11 
				; 
				; PRN_STAT RECORD	LPBZ:1,LPACK:1,LPOP:1,LPSEL:1,LPIO:1,LPX:2,LPTO:1 
				;----------------------------------------------------------------------------; 
 F014				INT_17_2: 
 F014  42				INC	DX 				; DX to status port 
 F015				INT_17_2_STATUS: 
 F015  EC				IN	AL, DX			; AL = status 
 F016  24 F8				AND	AL, NOT (MASK LPX OR MASK LPTO)	; mask time-out pins 
 F018				INT_17_2_STATUS_2: 
 F018  34 48				XOR	AL, MASK LPACK OR MASK LPIO ; acknowledge and error are active low 
 F01A  8A E8				MOV	CH, AL			; save status to CH so AL can be restored 
 F01C				INT_17_DONE: 
 F01C  58				POP	AX				; restore AL 
 F01D  8A E5				MOV	AH, CH			; AH = status 
 F01F  59				POP	CX 
 F020  5F				POP	DI 
 F021  5A				POP	DX 
 F022				INT_17_IRET: 
 F022  CF				IRET 
				 
				;----------------------------------------------------------------------------; 
				; AH = 1 - Initialize printer port 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AH = 0 (not 1) 
				;	DX = LPT data port (278, 378, 3BC) 
				; 
				; Output: 
				;	AH = status, see AH = 2 
				;----------------------------------------------------------------------------; 
 F023				INT_17_1: 
 F023  B0 08				MOV	AL, MASK LCDR		; printer reads output = 1 
 F025  42				INC	DX 
 F026  42				INC	DX				; DX = control port 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-137


 F027  EE				OUT	DX, AL			; send to control port 
 F028  B5 08				MOV	CH, HIGH 800H		; delay 800H-ish loops 
					IO_DELAY 				; wait, then CX = 0 
 F02A                        1	??0027: 
 F02A  E2 FE                 1		LOOP	??0027					; long delay for I/O 
 F02C  0C 04				OR	AL, MASK LCINI		; initialize printer = 1 
 F02E  EE				OUT	DX, AL			; send to control port 
 F02F  4A				DEC	DX				; DX = status port 
 F030  EB E3				JMP	SHORT INT_17_2_STATUS	; small delay, read status and return 
 F032				INT_17 ENDP 
				 
 F032				CRLF_SHOW_CURSOR PROC 
				;----------------------------------------------------------------------------; 
				; CRLF then show cursor display (this exists to utilize the free bytes here) 
				;----------------------------------------------------------------------------; 
 F032  E8 F745 R			CALL	CRLF 
				 
				;----------------------------------------------------------------------------; 
				; Show cursor display - restores saved cursor in CURSOR_DEFAULT 
				;----------------------------------------------------------------------------; 
				; Input: 
				; 	DS = BDA 
				; Clobbers CX 
				;----------------------------------------------------------------------------; 
 F035				SHOW_CURSOR PROC 
							ASSUME DS:_BDA 
 F035  8B 0E 00E8 R			MOV	CX, CURSOR_DEFAULT	; reset to original 
 F039  EB 03				JMP	SHORT SET_CURSOR 
				 
				;----------------------------------------------------------------------------; 
				; Hide cursor display 
				;----------------------------------------------------------------------------; 
				; Clobbers CX 
				;----------------------------------------------------------------------------; 
 F03B				HIDE_CURSOR PROC 
 F03B  B9 2000				MOV	CX, DBW < 00100000b >	; hide cursor (CH bit 5 = 1) 
				 
				;----------------------------------------------------------------------------; 
				; Set Video Cursor type 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	CX = cursor type 
				;----------------------------------------------------------------------------; 
 F03E				SET_CURSOR PROC 
 F03E  50				PUSH	AX				; (not necessary) 
 F03F  B4 01				MOV	AH, 1 
 F041  CD 10				INT	10H 
 F043  58				POP	AX 
 F044  C3				RET 
 F045				SET_CURSOR ENDP 
				 
 F045				HIDE_CURSOR ENDP 
 F045				SHOW_CURSOR ENDP 
 F045				CRLF_SHOW_CURSOR ENDP 
				 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-138


				; 
				; 0 BYTES HERE 
				; 
				BYTES_HERE	INT_10_JMP 
 = 0000                      1	BYTES_HERE_INT_10_JMP = INT_10_JMP-$ 
			     1			IFDEF BYTES_HERE_INT_10_JMP 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 10h - Function Jump Table 
				;----------------------------------------------------------------------------; 
 F045						ORG 0F045H 
 F045				INT_10_JMP LABEL WORD 
 F045  F0E4 R				DW	OFFSET INT_10_0		; AH = 0 - Set video mode 
 F047  F1A0 R				DW	OFFSET INT_10_1		; AH = 1 - Set cursor type 
 F049  F1B6 R				DW	OFFSET INT_10_2		; AH = 2 - Set cursor position 
 F04B  F1FC R				DW	OFFSET INT_10_3		; AH = 3 - Read cursor position 
							IF LIGHT_PEN EQ 1 
 F04D  F8CC R				DW	OFFSET INT_10_4		; AH = 4 - Read light pen 
							ENDIF 
 F04F  F20D R				DW	OFFSET INT_10_5		; AH = 5 - Select active display page 
 F051  F235 R				DW	OFFSET INT_10_6		; AH = 6 - Scroll active page up 
 F053  F234 R				DW	OFFSET INT_10_7		; AH = 7 - Scroll active page down 
 F055  F344 R				DW	OFFSET INT_10_8		; AH = 8 - Read character and attribute at cursor 
 F057  F3DF R				DW	OFFSET INT_10_9		; AH = 9 - Write character and attribute at cursor 
 F059  F3DF R				DW	OFFSET INT_10_A		; AH = A - Write character at current cursor 
 F05B  F4C3 R				DW	OFFSET INT_10_B		; AH = B - Set color palette 
 F05D  F4EE R				DW	OFFSET INT_10_C		; AH = C - Write graphics pixel at coordinate 
 F05F  F50F R				DW	OFFSET INT_10_D		; AH = D - Read graphics pixel at coordinate 
 F061  F55F R				DW	OFFSET INT_10_E		; AH = E - Write text in teletype mode 
 F063  F5C9 R				DW	OFFSET INT_10_F		; AH = F - Get current video state 
 = 0010				L_INT_10_JMP	EQU	($-INT_10_JMP)/2 
				 
				;----------------------------------------------------------------------------; 
				; INT 10h - Video BIOS Services 
				;----------------------------------------------------------------------------; 
				; BIOS Interface to CGA/MDA display adapters. 
				;----------------------------------------------------------------------------; 
				; References and Info Sources: 
				;  "PC System Programming", Tischer 
				;  "Programmer's Guide to PC Video Systems", Second Edition, Wilton 
				;  https://github.com/joncampbell123/dosbox-x/blob/master/src/ints/int10_char.cpp 
				;  https://github.com/joncampbell123/dosbox-x/issues/256 
				;  https://www.seasip.info/VintagePC/cga.html 
				;  https://www.reenigne.org/blog/crtc-emulation-for-mess/ 
				;  (many other posts and articles...) 
				; 
				; Thx to @Raffzahn for "clean room" specs for various display routines. 
				;----------------------------------------------------------------------------; 
 F065						ORG 0F065H 
 F065				INT_10 PROC 
 F065  FB				STI					; enable interrupts 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-139


 F066  80 FC 0F				CMP	AH, L_INT_10_JMP-1	; function valid? 
 F069  77 19				JA	INT_10_IRET			; exit if function not valid 
					PUSHX	ES, DS, DI			; always preserve these registers 
			     1				IFNB <ES>			; exit if last reg 
 F06B  06                    1		PUSH	ES 					; push register and repeat 
			     1		PUSHX	DS, DI, , , , ,  
			     2				IFNB <DS>			; exit if last reg 
 F06C  1E                    2		PUSH	DS 					; push register and repeat 
			     2		PUSHX	DI, , , , , ,  
			     3				IFNB <DI>			; exit if last reg 
 F06D  57                    3		PUSH	DI 					; push register and repeat 
			     3		PUSHX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F06E  FC				CLD					; string instructions forward direction 
 F06F  BF ---- R			MOV	DI, SEG _BDA		; DS = BDA segment 
 F072  8E DF				MOV	DS, DI 
 F074  8B F8				MOV	DI, AX			; save AX 
 F076  86 E0				XCHG	AH, AL			; AL = function, AH = video mode 
 F078  D0 E0				SHL	AL, 1				; word align index 
 F07A  98				CBW					; AX = jump index 
 F07B  97				XCHG	AX, DI			; restore AX, DI = jump offset 
 F07C  2E: FF 95 F045 R			CALL	CS:INT_10_JMP[DI] 
 F081				INT_10_DONE: 
					POPX	DI, DS, ES 
			     1				IFNB <DI>			; exit if last reg 
 F081  5F                    1		POP	DI 					; pop register and repeat 
			     1		POPX	DS, ES, , , , ,  
			     2				IFNB <DS>			; exit if last reg 
 F082  1F                    2		POP	DS 					; pop register and repeat 
			     2		POPX	ES, , , , , ,  
			     3				IFNB <ES>			; exit if last reg 
 F083  07                    3		POP	ES 					; pop register and repeat 
			     3		POPX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F084				INT_10_IRET: 
 F084  CF				IRET 
				 
				;----------------------------------------------------------------------------; 
				; Is Current video mode text or GFX? 
				;----------------------------------------------------------------------------; 
				; Input: 
				; 	DS = BDA (040h) 
				; Output: 
				;	AL = current video mode 
				; 	ZF = 0 if CGA GFX (modes 4-6) 
				;	ZF = 1 if CGA/MDA Text (modes 0-3 and 7) 
				;	CF = 1 if MDA 
				;----------------------------------------------------------------------------; 
 F085				INT_10_IS_TXT PROC 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-140


 F085  A0 0049 R			MOV	AL, VID_MODE 
 F088  3C 07				CMP	AL, 7				; ZF if mode MDA 
 F08A  F5				CMC					; CF if MDA 
 F08B  74 02				JZ	INT_10_IS_TXT_DONE 
 F08D  A8 04				TEST	AL, 4 AND 5 AND 6		; NZ if GFX modes 4,5,6? 
 F08F				INT_10_IS_TXT_DONE: 
 F08F  C3				RET 
 F090				INT_10_IS_TXT ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Is Current video CGA 80 col? 
				;----------------------------------------------------------------------------; 
				; Output: 
				;	ZF = 1 if mode is 2 or 3 
				;	ZF = 0 all others 
				;----------------------------------------------------------------------------; 
 F090				INT_10_IS_CGA80 PROC 
 F090  50				PUSH	AX 
 F091  1E				PUSH	DS 
 F092  B8 ---- R			MOV	AX, SEG _BDA 
 F095  8E D8				MOV	DS, AX 
 F097  A0 0049 R			MOV	AL, VID_MODE 
 F09A  3C 02				CMP	AL, 2				; is mode 2? 
 F09C  74 02				JZ	INT_10_IS_CGA80_DONE 
 F09E  3C 03				CMP	AL, 3				; is mode 3? 
 F0A0				INT_10_IS_CGA80_DONE: 
 F0A0  1F				POP	DS 
 F0A1  58				POP	AX 
 F0A2  C3				RET 
 F0A3				INT_10_IS_CGA80 ENDP 
				 
				; 
				; 1 BYTE HERE 
				; 
				BYTES_HERE	INT_1D 
 = 0001                      1	BYTES_HERE_INT_1D = INT_1D-$ 
			     1			IFDEF BYTES_HERE_INT_1D 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 1D - Video mode register value table  
				;----------------------------------------------------------------------------; 
				; https://stanislavs.org/helppc/6845.html 
				;----------------------------------------------------------------------------; 
 F0A4						ORG 0F0A4H					; 116 bytes 
 F0A4				INT_1D PROC 
				 
				; 40x25 CGA text 
 F0A4  38			INT_1D_40		CRTC	<38H,28H,2DH,0AH,1FH,06H,19H,1CH,02H,07H,06H,07H> 
 F0A5  28			
 F0A6  2D			
 F0A7  0A			
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-141


 F0A8  1F			
 F0A9  06			
 F0AA  19			
 F0AB  1C			
 F0AC  02			
 F0AD  07			
 F0AE  06			
 F0AF  07			
 F0B0  00			
 F0B1  00			
 F0B2  00			
 F0B3  00			
				
 = 0000				O_INT_1D_40		EQU	INT_1D_40-INT_1D		; 40x25 mode data offset 
				 
				; 80x25 CGA text 
						ELSE 
 F0B4  71			INT_1D_80		CRTC	<71H,50H,5AH,0AH,1FH,06H,19H,1CH,02H,07H,06H,07H> 
 F0B5  50			
 F0B6  5A			
 F0B7  0A			
 F0B8  1F			
 F0B9  06			
 F0BA  19			
 F0BB  1C			
 F0BC  02			
 F0BD  07			
 F0BE  06			
 F0BF  07			
 F0C0  00			
 F0C1  00			
 F0C2  00			
 F0C3  00			
				
						ENDIF 
 = 0010				O_INT_1D_80		EQU	INT_1D_80-INT_1D		; 80x25 mode data offset 
				 
				; 320x200 CGA graphics 
 F0C4  38			INT_1D_GFX		CRTC	<38H,28H,2DH,0AH,7FH,06H,64H,70H,02H,01H,06H,07H> 
 F0C5  28			
 F0C6  2D			
 F0C7  0A			
 F0C8  7F			
 F0C9  06			
 F0CA  64			
 F0CB  70			
 F0CC  02			
 F0CD  01			
 F0CE  06			
 F0CF  07			
 F0D0  00			
 F0D1  00			
 F0D2  00			
 F0D3  00			
				
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-142


 = 0020				O_INT_1D_GFX	EQU	INT_1D_GFX-INT_1D		; 320x200 mode data offset 
				 
				; MDA text 
 F0D4  61			INT_1D_MDA		CRTC	<61H,50H,52H,0FH,19H,06H,19H,19H,02H,0DH,0BH,0CH> 
 F0D5  50			
 F0D6  52			
 F0D7  0F			
 F0D8  19			
 F0D9  06			
 F0DA  19			
 F0DB  19			
 F0DC  02			
 F0DD  0D			
 F0DE  0B			
 F0DF  0C			
 F0E0  00			
 F0E1  00			
 F0E2  00			
 F0E3  00			
				
 = 0030				O_INT_1D_MDA	EQU	INT_1D_MDA-INT_1D		; MDA mode data offset 
				 
 F0E4				INT_1D ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,0 - Set video mode 
				;----------------------------------------------------------------------------; 
				; AL = video mode: 
				;   0000  00  M 40x25 B/W text (CGA) 
				;   0001  01  C 40x25 16 color text (CGA) 
				;   0010  02  M 80x25 16 shades of gray text (CGA) 
				;   0011  03  C 80x25 16 color text (CGA) 
				;   0100  04  C 320x200 4 color graphics (CGA) 
				;   0101  05  C 320x200 4 color graphics (CGA) 
				;   0110  06  M 640x200 B/W graphics (CGA) 
				;   0111  07  M 80x25 Monochrome text (MDA,HERC) 
				; 
				; Clobbers: ES 
				;----------------------------------------------------------------------------; 
				; Things you must do: 
				; 	1. Check that the new video mode is valid: 0-7. For MDA, the mode 
				;		will always be 7. If CGA mode > 6, reset in current mode. 
				;	2. Clear the video BDA block data 
				;	3. Determine the type of adapter from motherboard switches 
				;	4. Disable the adapter to reprogram it. 
				;	5. Based on new input mode and MB switches, determine: 
				;		- Adapter base I/O port (03B4H for MDA, 03D4H for CGA) 
				;		- RAM base segment (0B000H for MDA, 0B800H for CGA) 
				;		- RAM size (16K for CGA gfx, 4K for 80x25 text, 2K for 40x25 text) 
				;		- RAM fill data (0 for gfx, space char with attribute 7 for text) 
				;		- Corresponding entry from INT 1DH CRTD table for new video mode 
				;		- Corresponding mode byte from CRT_MODE table 
				;	6. Clear regen RAM by filling with data from above 
				;	7. Write data from CRTD table to adapter registers to set mode 
				;	8. Write CGA palette register 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-143


				;	9. Enable adapter with new mode byte 
				; 
				;----------------------------------------------------------------------------; 
 F0E4				INT_10_0 PROC 
							ELSE 
					PUSHX	BX, DX, BP, CX, SI 
			     1				IFNB <BX>			; exit if last reg 
 F0E4  53                    1		PUSH	BX 					; push register and repeat 
			     1		PUSHX	DX, BP, CX, SI, , ,  
			     2				IFNB <DX>			; exit if last reg 
 F0E5  52                    2		PUSH	DX 					; push register and repeat 
			     2		PUSHX	BP, CX, SI, , , ,  
			     3				IFNB <BP>			; exit if last reg 
 F0E6  55                    3		PUSH	BP 					; push register and repeat 
			     3		PUSHX	CX, SI, , , , ,  
			     4				IFNB <CX>			; exit if last reg 
 F0E7  51                    4		PUSH	CX 					; push register and repeat 
			     4		PUSHX	SI, , , , , ,  
			     5				IFNB <SI>			; exit if last reg 
 F0E8  56                    5		PUSH	SI 					; push register and repeat 
			     5		PUSHX	, , , , , ,  
			     6				ENDIF 
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
							ENDIF 
 F0E9  BF 0049 R			MOV	DI, OFFSET VID_MODE		; start with VID_MODE (49H) 
 F0EC  3C 07				CMP	AL, 7					; is new video mode > 7? 
 F0EE  72 02				JB	INT_10_0_1				; if not, is valid mode 
 F0F0  8A 05				MOV	AL, [DI]				; otherwise use current mode 
 F0F2				INT_10_0_1: 
 F0F2  93				XCHG	AX, BX				; BL = new video mode 
				 
				;----------------------------------------------------------------------------; 
				; Clear all video data in BDA 
				; 
 F0F3  33 C0				XOR	AX, AX 
 F0F5  B9 000F				MOV	CX, L_VID_BDA / 2			; Video data in BDA (in WORDs) 
 F0F8  1E				PUSH	DS 
 F0F9  07				POP	ES					; ES = BDA 
 F0FA  F3/ AB				REP	STOSW					; clear data, set CX = 0 
				 
				;----------------------------------------------------------------------------; 
				; Determine video adapter type and new mode and re-program 6845 
				; 
					CMP_EFLAG VID, VID_MDA			; is switch MDA (ON, ON)? 
			     1				ENDIF 
			     1	;----------------------------------------------------------------------------; 
			     1	; Shift if flag is in high byte to low for byte operations 
			     1	; 
			     1				IF VID LT 8		; is in low byte? 
 = 0030                      1	??002A	= MASK VID 
 = 0004                      1	??002B	= VID AND 0111B 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-144


 = 0010                      1	??002C	= EQUIP_FLAGS[0]			; low BDA flags byte 
			     1				ENDIF 
 F0FC  A0 0010 R             1		MOV	AL, BYTE PTR ??002C 
 F0FF  24 30                 1		AND	AL, ??002A 
 F101  3C 30                 1		CMP	AL, VID_MDA SHL ??002B 
			     1				ENDIF 
 F103  8A C1				MOV	AL, CL				; 0 = CGA disable video signal 
 F105  BE 0010				MOV	SI, O_INT_1D_80			; SI = CGA 80 CRTD offset 
 F108  B7 50				MOV	BH, VID_DEF_COLS			; default 80 columns 
 F10A  B5 10				MOV	CH, HIGH SIZE MDA_MEM		; Total MDA video memory = 1000H (4K) 
 F10C  8A E5				MOV	AH, CH				; MDA/CGA 80x25 page size = 1000H (4K) 
 F10E  BF 0720				MOV	DI, DBW <VID_ATTR<>, VID_SP>	; fill memory with attr and space 
 F111  75 0E				JNE	INT_10_0_IS_CGA			; jump if not MDA 
 F113  40				INC	AX					; 1 = MDA disable video signal value 
 F114  BD ---- R			MOV	BP, SEG _MDA_MEM			; BP = MDA memory segment (0B000H) 
 F117  BA 03B8				MOV	DX, MDA_CTRL			; MDA Mode Select Register (03B8H) 
 F11A  B3 07				MOV	BL, 7					; only valid MDA display mode is 7 
 F11C  BE 0030				MOV	SI, O_INT_1D_MDA			; SI = MDA CRTD offset 
 F11F  EB 26				JMP	SHORT INT_10_0_DETECT_DONE	; MDA mode selected, continue 
 F121				INT_10_0_IS_CGA: 
 F121  B5 40				MOV	CH, HIGH CGA_MEM_SZ		; Total CGA video memory = 4000H (16K) 
 F123  BA 03D8				MOV	DX, CGA_CTRL			; CGA Mode Select Register (3D8H) 
 F126  BD ---- R			MOV	BP, SEG _CGA_MEM			; BP = CGA memory segment (0B800H) 
 F129  F6 C3 04				TEST	BL, 0100B				; text or gfx mode? 
 F12C  74 0E				JZ	INT_10_0_IS_CGA_TEXT		; jump if text 
 F12E				INT_10_0_IS_CGA_GFX: 
 F12E  BE 0020				MOV	SI, O_INT_1D_GFX			; SI = CGA GFX CRTD offset 
 F131  B4 40				MOV	AH, HIGH CGA_MEM_SZ		; CGA gfx page size = 4000H (16K) 
 F133  33 FF				XOR	DI, DI				; DI = memory fill 0's 
 F135  F6 C3 02				TEST	BL, 0010B				; is 80 or 40 col text? 
 F138  75 0D				JNZ	INT_10_0_DETECT_DONE		; jump if 80 
 F13A  EB 09				JMP	SHORT INT_10_0_IS_40_COL	; else set 40 columns 
 F13C				INT_10_0_IS_CGA_TEXT: 
 F13C  F6 C3 02				TEST	BL, 0010B				; is 80 or 40 col text? 
 F13F  75 06				JNZ	INT_10_0_DETECT_DONE		; jump if 80 
 F141  B4 08				MOV	AH, HIGH SIZE CGA_MEM_40	; CGA 40x25 page size = 800H (2K) 
 F143  33 F6				XOR	SI, SI				; SI = CGA 40 CRTD offset (00H) 
 F145				INT_10_0_IS_40_COL: 
 F145  D0 EF				SHR	BH, 1					; BH = 40 columns 
 F147				INT_10_0_DETECT_DONE: 
 F147  89 1E 0049 R			MOV	WORD PTR VID_MODE, BX		; write BDA video mode and columns 
 F14B  8E C5				MOV	ES, BP				; ES = video memory segment 
 F14D  89 2E 00EA R			MOV	VID_MEM_SEG, BP			; write video segment for later 
 F151  EE				OUT	DX, AL				; disable video 
 F152  88 26 004D R			MOV	BYTE PTR VID_BUF_SZ[1], AH	; write BDA video page size 
 F156  83 EA 04				SUB	DX, CGA_CTRL-CGA_IDX		; DX = 6845 index register port 
 F159  89 16 0063 R			MOV	VID_PORT, DX			; write BDA video I/O port 
 F15D  8B EB				MOV	BP, BX				; save video mode to BP 
				 
				;----------------------------------------------------------------------------; 
				; Fill video regen/memory 
				; 
 F15F  97				XCHG	AX, DI				; AX = fill byte 
 F160  33 FF				XOR	DI, DI				; start at offset 0 
 F162  D1 E9				SHR	CX, 1					; WORD size counter 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-145


 F164  F3/ AB				REP	STOSW 
				 
				;----------------------------------------------------------------------------; 
				; Write CRTC data to 6845 registers 
				; 
 F166  1E				PUSH	DS					; save DS = BDA 
 F167  8B C1				MOV	AX, CX				; AX = 0 
 F169  A2 0062 R			MOV	VID_PAGE, AL			; video page 1 = 0 
 F16C  8E D8				MOV	DS, AX				; DS = IVT 
							ASSUME DS:_IVT 
 F16E  C5 1E 0074 R			LDS	BX, IVT_1D				; DS:BX = BIOS:INT_1D 
							ASSUME DS:NOTHING 
 F172  8B 78 0A				MOV	DI, WORD PTR [BX][SI].CSL	; DI = cursor type (start and end) 
 F175  B1 10				MOV	CL, SIZE CRTC			; size of CRTC data 
 F177				INT_10_0_CRTC_LOOP: 
 F177  8A 20				MOV	AH, [BX][SI]			; AH = next byte from table 
 F179  EF				OUT	DX, AX				; write AH to register index AL 
 F17A  40				INC	AX					; next register index 
 F17B  46				INC	SI					; next byte in table 
 F17C  E2 F9				LOOP	INT_10_0_CRTC_LOOP 
				 
				;----------------------------------------------------------------------------; 
				; Send mode and color bytes to display adapter 
				; 
 F17E  95				XCHG	AX, BP				; AL = new video mode 
 F17F  3C 06				CMP	AL, 6					; is CGA color gfx mode? 
 F181  B4 3F				MOV	AH, VID_CSGFX <>			; use for 640x200 mode 6 
 F183  74 02				JE	INT_10_0_COLOR_BYTE		; jump if so 
 F185  B4 30				MOV	AH, VID_CSTXT <>			; otherwise use for text/low gfx 
 F187				INT_10_0_COLOR_BYTE: 
 F187  BB F5F5 R			MOV	BX, OFFSET CRT_MODE 
 F18A  2E: D7				XLAT	CS:[BX]				; AL = control byte data 
 F18C  1F				POP	DS					; DS = BDA 
							ASSUME DS:_BDA 
 F18D  83 C2 04				ADD	DX, CGA_CTRL-CGA_IDX		; DX = control reg port (3D8H) 
 F190  A3 0065 R			MOV	WORD PTR VID_MODE_REG, AX	; write mode and color to BDA 
 F193  EF				OUT	DX, AX				; write mode and color to adapter 
 F194  97				XCHG	AX, DI				; AX = cursor bytes from CRTC table 
 F195  86 E0				XCHG	AH, AL				; convert endian for cursor bytes 
 F197  A3 0060 R			MOV	VID_CURS_TYPE, AX			; write cursor type to BDA 
							ELSE 
					POPX	SI, CX, BP, DX, BX 
			     1				IFNB <SI>			; exit if last reg 
 F19A  5E                    1		POP	SI 					; pop register and repeat 
			     1		POPX	CX, BP, DX, BX, , ,  
			     2				IFNB <CX>			; exit if last reg 
 F19B  59                    2		POP	CX 					; pop register and repeat 
			     2		POPX	BP, DX, BX, , , ,  
			     3				IFNB <BP>			; exit if last reg 
 F19C  5D                    3		POP	BP 					; pop register and repeat 
			     3		POPX	DX, BX, , , , ,  
			     4				IFNB <DX>			; exit if last reg 
 F19D  5A                    4		POP	DX 					; pop register and repeat 
			     4		POPX	BX, , , , , ,  
			     5				IFNB <BX>			; exit if last reg 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-146


 F19E  5B                    5		POP	BX 					; pop register and repeat 
			     5		POPX	, , , , , ,  
			     6				ENDIF 
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
							ENDIF 
 F19F				INT_10_RET: 
 F19F  C3				RET 
 F1A0				INT_10_0 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,1 - Set cursor type 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	CH = cursor starting scan line (cursor top) (low order 5 bits) 
				;	CL = cursor ending scan line (cursor bottom) (low order 5 bits) 
				;----------------------------------------------------------------------------; 
 F1A0				INT_10_1 PROC 
 F1A0  52				PUSH	DX 
 F1A1  97				XCHG	AX, DI			; save AX 
 F1A2  89 0E 0060 R			MOV	VID_CURS_TYPE, CX		; write new cursor to BDA 
 F1A6  B0 0A				MOV	AL, CRTC.CSL		; AL = cursor start index (scan line) 
 F1A8  8A E5				MOV	AH, CH			; CH = cursor starting scan line (top) 
 F1AA  8B 16 0063 R			MOV	DX, VID_PORT		; DX = 6845 index register port 
 F1AE  EF				OUT	DX, AX			; write AH to 6845 reg index in AL 
 F1AF  40				INC	AX				; AL = cursor end index (scan line) 
 F1B0  8A E1				MOV	AH, CL			; CL = cursor ending scan line (bottom) 
 F1B2  EF				OUT	DX, AX			; write AH to 6845 reg index in AL 
 F1B3  97				XCHG	AX, DI			; restore AX 
 F1B4  5A				POP	DX 
 F1B5  C3				RET 
 F1B6				INT_10_1 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,2 - Set cursor position 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AH = 02 
				;	BH = page number (0 for graphics modes) 
				;	DH = row 
				;	DL = column 
				;----------------------------------------------------------------------------;	 
				; Things you must do: 
				;	1. Update the BDA Cursor position (50H-5FH) with the new video page 
				;		with the new cursor position 
				;	2. Calculate the memory address of the cursor's position, and set it 
				;		to the 6845 Cursor address register 
				; 
				; Things you should do: 
				;	- Make sure page number is valid for adapter type and current mode 
				; 
				;----------------------------------------------------------------------------;	 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-147


 F1B6				INT_10_2 PROC 
 F1B6  50				PUSH	AX 
 F1B7  8A C7				MOV	AL, BH			; AL = new video page 
 F1B9  3C 07				CMP	AL, 7				; is new video page > 7? 
 F1BB  77 30				JA	INT_10_2_DONE		; if so, not valid, return 
				 
				;----------------------------------------------------------------------------; 
				; 1. Set cursor position in BDA 
				; 
 F1BD  98				CBW					; AX = page number 
 F1BE  97				XCHG	AX, DI			; DI = page number 
 F1BF  D1 E7				SHL	DI, 1				; word align index 
 F1C1  89 95 0050 R			MOV	VID_CURS_POS[DI], DX	; write to page cursor position in BDA 
 F1C5  38 3E 0062 R			CMP	VID_PAGE, BH		; is this the current page? 
 F1C9  75 22				JNE	INT_10_2_DONE		; if not, do nothing and exit 
 F1CB  53				PUSH	BX 
 F1CC  52				PUSH	DX 
				 
				;----------------------------------------------------------------------------; 
				; 2. Set cursor position in 6845 Cursor address register 
				; 
 F1CD				INT_10_SET_CUR_OFFSET: 
 F1CD  A0 004A R			MOV	AL, BYTE PTR VID_COLS	; AL = screen cols 
 F1D0  F6 E6				MUL	DH				; AX = row * screen cols 
 F1D2  32 F6				XOR	DH, DH			; DX = col 
 F1D4  03 C2				ADD	AX, DX			; AX = ( row * screen cols ) + col 
										; AX = byte offset for cursor position to page memor
				y 
 F1D6  8B 1E 004E R			MOV	BX, VID_SEG 
 F1DA  D1 EB				SHR	BX, 1				; byte align 
 F1DC  03 D8				ADD	BX, AX 
 F1DE  B0 0E				MOV	AL, CRTC.CA_H		; 6845 Cursor address high reg (0EH) 
 F1E0  8A E7				MOV	AH, BH			; Cursor address (MSB) 
 F1E2  8B 16 0063 R			MOV	DX, VID_PORT 
 F1E6  EF				OUT	DX, AX			; write AH to index AL 
 F1E7  40				INC	AX				; AL = CA_L (0FH) 
 F1E8  8A E3				MOV	AH, BL			; Cursor address (LSB) 
 F1EA  EF				OUT	DX, AX			; write AH to index AL 
 F1EB  5A				POP	DX 
 F1EC  5B				POP	BX 
 F1ED				INT_10_2_DONE: 
 F1ED  58				POP	AX 
 F1EE  C3				RET 
 F1EF				INT_10_2 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,3 - Read cursor position and Size for current page 
				;----------------------------------------------------------------------------; 
				; Output: 
				;	ZF = 0 and BH = 0 if MDA/CGA GFX 
				;  	ZF = 1 and BH = VID_PAGE if CGA text 
				;----------------------------------------------------------------------------; 
 F1EF				INT_10_3_CUR_PAGE PROC 
 F1EF  32 FF				XOR	BH, BH			; BH = 0 
 F1F1  F6 06 0049 R 04			TEST	VID_MODE, 0100B		; is >= 4? 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-148


 F1F6  75 04				JNZ	INT_10_3			; jump if not MDA or GFX 
 F1F8  8A 3E 0062 R			MOV	BH, VID_PAGE		; otherwise BH = VID_PAGE 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,3 - Read cursor position and Size 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AH = 03 
				;	BH = video page 
				; Output: 
				;	CH = cursor starting scan line (low order 5 bits) 
				;	CL = cursor ending scan line (low order 5 bits) 
				;	DH = row 
				;	DL = column 
				;----------------------------------------------------------------------------; 
 F1FC				INT_10_3 PROC 
 F1FC  50				PUSH	AX 
 F1FD  8A C7				MOV	AL, BH			; AL = video page 
 F1FF  98				CBW					; AX = video page 
 F200  97				XCHG	AX, DI			; DI = video page 
 F201  D1 E7				SHL	DI, 1				; word align index 
 F203  8B 95 0050 R			MOV	DX, VID_CURS_POS[DI] 
 F207  8B 0E 0060 R			MOV	CX, VID_CURS_TYPE 
 F20B  58				POP	AX 
 F20C  C3				RET 
 F20D				INT_10_3 ENDP 
 F20D				INT_10_3_CUR_PAGE ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,5 - Select active display page 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AH = 05 
				;	AL = new page number 
				;----------------------------------------------------------------------------; 
				; Things you must do: 
				;	1. Write the new page number to BDA (40:62H) 
				;	2. Calculate new regen buffer page offset and update BDA and 
				;		6845 Start address register 
				;	3. Calculate the memory address of the cursor's position, and set it 
				;		to the 6845 Cursor address register 
				; 
				; Things you should do: 
				;	- Bounds check that page number is valid for adapter and current mode? 
				;----------------------------------------------------------------------------; 
 F20D				INT_10_5 PROC 
					PUSHX	AX, BX, DX			; call-preserve working registers 
			     1				IFNB <AX>			; exit if last reg 
 F20D  50                    1		PUSH	AX 					; push register and repeat 
			     1		PUSHX	BX, DX, , , , ,  
			     2				IFNB <BX>			; exit if last reg 
 F20E  53                    2		PUSH	BX 					; push register and repeat 
			     2		PUSHX	DX, , , , , ,  
			     3				IFNB <DX>			; exit if last reg 
 F20F  52                    3		PUSH	DX 					; push register and repeat 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-149


			     3		PUSHX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; 1. Write the new page number to BDA (40:62H). 
				; 
 F210  A2 0062 R			MOV	VID_PAGE, AL 
 F213  98				CBW					; AX = video page 
 F214  97				XCHG	AX, DI			; DI = page number (save for later) 
				 
				;----------------------------------------------------------------------------; 
				; 2. Calculate new regen buffer page offset and update BDA and  
				;	6845 Start address register 
				; 
 F215  A1 004C R			MOV	AX, VID_BUF_SZ		; AX = Size of video regen buffer (bytes) 
 F218  F7 E7				MUL	DI				; AX = offset of start of page regen buffer 
 F21A  A3 004E R			MOV	VID_SEG, AX			; write to BDA 
 F21D  D1 E8				SHR	AX, 1				; video segment byte-indexed 
 F21F  8A D8				MOV	BL, AL			; AH = Start address (MSB), BL = (LSB) 
 F221  B0 0C				MOV	AL, CRTC.SA_H		; 6845 Start address register 
 F223  8B 16 0063 R			MOV	DX, VID_PORT		; 6845 I/O port address 
 F227  EF				OUT	DX, AX			; write AH (MSB) to index AL 
 F228  40				INC	AX				; AL = 0DH 
 F229  8A E3				MOV	AH, BL			; AH = Start address (LSB) 
 F22B  EF				OUT	DX, AX			; write AH (LSB) to index AL 
				 
				;----------------------------------------------------------------------------; 
				; 3. Set cursor position in 6845 Cursor address register 
				; 
 F22C  D1 E7				SHL	DI, 1				; get the current cursor position 
 F22E  8B 95 0050 R			MOV	DX, VID_CURS_POS[DI]	; DH/DL = cursor position on current page 
 F232  EB 99				JMP	INT_10_SET_CUR_OFFSET	; write it to the new page's offset on 6845 
				 
 F234				INT_10_5 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,7 - Scroll active page down 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AL = number of lines to scroll, previous lines are 
				;	     blanked, if 0 or AL > screen size, window is blanked 
				;	BH = attribute to be used on blank line 
				;	CH = row of upper left corner of scroll window 
				;	CL = column of upper left corner of scroll window 
				;	DH = row of lower right corner of scroll window 
				;	DL = column of lower right corner of scroll window 
				;----------------------------------------------------------------------------; 
				; 
				;   0000  00  M 40x25 B/W text (CGA) 
				;   0001  01  C 40x25 16 color text (CGA) 
				;   0010  02  M 80x25 16 shades of gray text (CGA) 
				;   0011  03  C 80x25 16 color text (CGA) 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-150


				;   0100  04  C 320x200 4 color graphics (CGA) 
				;   0101  05  C 320x200 4 color graphics (CGA) 
				;   0110  06  M 640x200 B/W graphics (CGA) 
				;   0111  07  M 80x25 Monochrome text (MDA) 
				;----------------------------------------------------------------------------; 
				; Things you must do: 
				; 	1. Calculate coordinates of existing rectangle and new rectangle. 
				;	2. Convert to memory video RAM addresses 
				;	3. If CGA 80 col, disable video during video RAM operations 
				;	4. If rows to scroll > 0, copy each row, starting at the left column. 
				;	   If scroll up, start from the top of the overlapping area and copy 
				;	   downward. If scroll down, start at the bottom and copy upward. 
				;	5. If rows to scroll > height of rectangle, fill the remaining rows 
				;	   with spaces. 
				; 
				;----------------------------------------------------------------------------; 
				; NOTE: The original XT BIOS (and maybe clones) appear to have a bug where 
				; if the lines to scroll (AL) is greater than the height of the rectangle 
				; it will scroll incorrectly. This behavior has been preserved. 
				;----------------------------------------------------------------------------; 
 F234				INT_10_7 PROC 
 F234  FD				STD					; Set direction flag 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,6 - Scroll active page up 
				;----------------------------------------------------------------------------; 
				; Input: same as INT 10,7 above 
				;----------------------------------------------------------------------------; 
 F235				INT_10_6 PROC 
					PUSHX	AX, BX, SI			; call-preserve these registers 
			     1				IFNB <AX>			; exit if last reg 
 F235  50                    1		PUSH	AX 					; push register and repeat 
			     1		PUSHX	BX, SI, , , , ,  
			     2				IFNB <BX>			; exit if last reg 
 F236  53                    2		PUSH	BX 					; push register and repeat 
			     2		PUSHX	SI, , , , , ,  
			     3				IFNB <SI>			; exit if last reg 
 F237  56                    3		PUSH	SI 					; push register and repeat 
			     3		PUSHX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F238  C4 36 00E8 R			LES	SI, VID_MEM_SEG_DW	; ES = video/regen RAM segment (B800 or B000) 
 F23C  55				PUSH	BP 
				 
				;----------------------------------------------------------------------------; 
				; Register Check: 
				;	AH = saved flags - ZF if scroll up 
				;	AL = number of rows to scroll 
				;	BH = attribute to be used on blank line 
				;	BL = scratch 
				;	CH = row of upper left corner of scroll window 
				;	CL = column of upper left corner of scroll window 
				;	DH = row of lower right corner of scroll window 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-151


				;	DL = column of lower right corner of scroll window 
				; 
 F23D  80 FC 06				CMP	AH, 6				; is scroll up? 
 F240  9F				LAHF					; save ZF if scroll up 
 F241  8B E8				MOV	BP, AX			; save original AL / AH flags 
 F243  8B FA				MOV	DI, DX			; save original DX 
 F245  75 02				JNZ	INT_10_CHECK_BOUNDS	; jump if scroll down 
				 
				;----------------------------------------------------------------------------; 
				; On scroll up, the new rectangle to scroll is above the old one so start the 
				; bottom left of the new rectangle at the top left of the old one. This  
				; will be later adjusted by the number of rows to scroll. 
				; 
 F247  8B D1				MOV	DX, CX			; if scroll up, DX becomes "top" 
				 
				;----------------------------------------------------------------------------; 
				; Make sure lower right column does not exceed screen width 
				; 
 F249				INT_10_CHECK_BOUNDS: 
 F249  A0 004A R			MOV	AL, BYTE PTR VID_COLS	; AL = video mode columns 
 F24C  3A D0				CMP	DL, AL			; is rect right column > screen columns? 
 F24E  72 03				JB	INT_10_BOUNDS_OK 
 F250  8A D0				MOV	DL, AL			; number of screen columns (80 or 40) 
 F252  4A				DEC	DX				; fixup for 0-based column index (0-79, etc) 
 F253				INT_10_BOUNDS_OK: 
 F253  F6 E6				MUL	DH				; AX = memory offset of col 0 of new bottom row 
 F255  8A F0				MOV	DH, AL			; save AL 
				 
				;----------------------------------------------------------------------------; 
				; Is graphics mode? 
				; 
 F257  E8 F085 R			CALL	INT_10_IS_TXT		; NZ if CGA GFX, ZR if CGA/MDA Text 
 F25A  8A C6				MOV	AL, DH			; restore AL 
 F25C  B6 00				MOV	DH, 0				; DX = lower right column position 
 F25E  1E				PUSH	DS				; save BDA data SEG 
 F25F  75 5D				JNZ	INT_10_SCR_GFX 
				 
				;----------------------------------------------------------------------------; 
				; Scroll in text mode 
				;----------------------------------------------------------------------------; 
				; To calculate scroll memory offsets: 
				; 
				;  rect_height = rect_height + 1 
				;  next_row = screen_cols - rect_width 
				; 
				;  if scroll down: 
				; 	rect_height = - rect_height 
				;	next_row = - next_row 
				; 
				;  new_top = old_top - rect_height 
				;  new_bottom = old_bottom - rect_height 
				; 
 F261				INT_10_SCR_TXT: 
 F261  03 D0				ADD	DX, AX			; DX = byte offset of new bottom row and col 
 F263  D1 E2				SHL	DX, 1				; WORD-align memory offset 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-152


 F265  03 16 004E R			ADD	DX, VID_SEG			; DX = memory offset bottom row/col in video page 
 F269  8B F2				MOV	SI, DX			; SI = memory offset of new rect bottom (midpoint) 
 F26B  87 FA				XCHG	DI, DX			; DI = new rect bottom, DX = row/col pos. 
 F26D  2B D1				SUB	DX, CX			; DH = rect height (rows), DL = rect width (cols) 
 F26F  8B 0E 004A R			MOV	CX, VID_COLS		; CL = current video mode cols (80 or 40), CH = 0 
 F273  8C C0				MOV	AX, ES			; source and destination is video/regen RAM 
 F275  8E D8				MOV	DS, AX 
 F277  8B C5				MOV	AX, BP			; AL = # of rows to scroll 
 F279  D0 E1				SHL	CL, 1				; WORD-align bytes per full row (now 160 or 80) 
 F27B  F6 E1				MUL	CL				; AX = size in WORDs of full rows to scroll 
 F27D  95				XCHG	AX, BP			; AL = # rows, AH = func, BP = WORD size of rect. rows 
 F27E  42				INC	DX				; convert 0-based indexes to 1-based loop counters 
 F27F  FE C6				INC	DH 
 F281  9E				SAHF					; set ZF if scroll up 
 F282  8A E7				MOV	AH, BH			; AH = fill attribute byte 
 F284  9C				PUSHF					; save scroll direction flag (out of registers!) 
 F285  8B D9				MOV	BX, CX			; BX = WORD size of one screen row (80 or 160) 
 F287  8A CA				MOV	CL, DL			; CX = BYTE size of one rectangle row 
 F289  2B D9				SUB	BX, CX			; BX = WORD offset btwn end of rect. col and start col 
 F28B  2B D9				SUB	BX, CX			;  on next row (subtract twice to WORD align) 
 F28D  9D				POPF					; set ZF if scroll up 
 F28E  74 04				JZ	INT_10_CGA_CHECK		; jump if scroll up 
				 
				;----------------------------------------------------------------------------; 
				; On scroll down, subtract (instead of add) the difference between the end  
				; of the current rectangle and the next row start. 
				; 
				; The start address of source rectangle will also be above (instead of below) 
				; the destination rectangle. 
				; 
				; These offsets are then added the top/bottom of current rectangle to get the 
				; new rectangle coords, either above or below depending on scroll direction. 
				; 
 F290  F7 DB				NEG	BX				; BX = - WORD size offset to start of next row 
 F292  F7 DD				NEG	BP				; BP = - WORD size of region of rows to scroll 
				 
 F294				INT_10_CGA_CHECK: 
								ENDIF 
				 
 F294				INT_10_6_CHECK_CLS: 
 F294  84 C0				TEST	AL, AL			; is number of lines to scroll 0? 
 F296  74 14				JZ	INT_10_6_TXT_CLR		; if so, skip move and only clear 
				 
				;----------------------------------------------------------------------------; 
				; Move scrolled window rectangle to new location in video memory  
				; 
 F298  2A F0				SUB	DH, AL			; DH = rect height - lines to scroll 
 F29A  74 0E				JZ	INT_10_6_TXT_CLR_1	; is number of lines to move 0? 
 F29C  03 F5				ADD	SI, BP			; SI = source row starting address 
 F29E				INT_10_6_TXT_MOVE_LOOP: 
 F29E  8A CA				MOV	CL, DL			; CX = number of columns (chars) to move 
 F2A0  F3/ A5				REP	MOVSW				; copy row from [DS:SI] to [ES:DI] 
 F2A2  03 FB				ADD	DI, BX			; move to start of next row 
 F2A4  03 F3				ADD	SI, BX 
 F2A6  FE CE				DEC	DH 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-153


 F2A8  75 F4				JNZ	INT_10_6_TXT_MOVE_LOOP	; loop through all rows 
 F2AA				INT_10_6_TXT_CLR_1: 
 F2AA  8A F0				MOV	DH, AL			; DH = remaining lines to clear 
				 
				;----------------------------------------------------------------------------; 
				; Clear (fill with spaces) the newly cleared area 
				; 
 F2AC				INT_10_6_TXT_CLR: 
 F2AC  B0 20				MOV	AL, VID_SP			; fill blank lines with spaces 
 F2AE				INT_10_6_TXT_CLR_LOOP: 
 F2AE  8A CA				MOV	CL, DL			; write rect width number of blank chars 
 F2B0  F3/ AB				REP	STOSW				; write attribute and space to col 
 F2B2  03 FB				ADD	DI, BX			; move to start of next row 
 F2B4  FE CE				DEC	DH 
 F2B6  75 F6				JNZ	INT_10_6_TXT_CLR_LOOP	; loop through all rows 
								ENDIF 
 F2B8  1F				POP	DS				; restore BDA SEG 
				 
								ENDIF 
				 
 F2B9				INT_10_6_DONE: 
					POPX	BP, SI, BX, AX 
			     1				IFNB <BP>			; exit if last reg 
 F2B9  5D                    1		POP	BP 					; pop register and repeat 
			     1		POPX	SI, BX, AX, , , ,  
			     2				IFNB <SI>			; exit if last reg 
 F2BA  5E                    2		POP	SI 					; pop register and repeat 
			     2		POPX	BX, AX, , , , ,  
			     3				IFNB <BX>			; exit if last reg 
 F2BB  5B                    3		POP	BX 					; pop register and repeat 
			     3		POPX	AX, , , , , ,  
			     4				IFNB <AX>			; exit if last reg 
 F2BC  58                    4		POP	AX 					; pop register and repeat 
			     4		POPX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F2BD  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,6/7 - Scroll up or down in graphics mode 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AX = memory offset of col 0 of new bottom row 
				;	BH = attribute to be used on blank line 
				;	BL = (scratch) 
				;	BP (high) = flags (ZF if scroll up, NZ if scroll down) 
				;	CH = row/Y of upper left corner of scroll window 
				;	CL = column/X of upper left corner of scroll window 
				;	DX = lower right column/X position 
				;	DI = original row/column parameter 
				; 
				; Perform BitBlt operation within video RAM. 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-154


				;----------------------------------------------------------------------------; 
 F2BE				INT_10_SCR_GFX PROC 
 F2BE  D1 E0				SHL	AX, 1				; BYTE (char) align memory offset for line 
 F2C0  D1 E0				SHL	AX, 1				;  (default for 640x200) 
 F2C2  03 D0				ADD	DX, AX 
 F2C4  87 D7				XCHG	DX, DI			; DI = memory offset of new rect bottom 
 F2C6  42				INC	DX				; DX = original row/col 
 F2C7  FE C6				INC	DH				; use 0-based indexes for 1-based counters 
 F2C9  2B D1				SUB	DX, CX			; DH = rect height, DL = rect width 
 F2CB  95				XCHG	AX, BP			; restore original AL / AH = func flag 
 F2CC  8A D8				MOV	BL, AL			; BL = lines to scroll 
 F2CE  BD 0050				MOV	BP, 80			; 1 scanline = 80 bytes 
 F2D1  B9 0002				MOV	CX, 2				; CL = 2, CH = 0 (needed later for counters) 
 F2D4  D2 E6				SHL	DH, CL			; rect height * char (row) height / 2 fields 
 F2D6  D2 E3				SHL	BL, CL			; lines to scroll * char height / 2 fields 
 F2D8  80 3E 0049 R 06			CMP	VID_MODE, 6			; is 640x200 mode? 
 F2DD  74 08				JZ	INT_10_SCR_GFX_2		; jump if so 
				 
				;----------------------------------------------------------------------------; 
				; is 320x200/4 color - adjust to 2 bits per pixel (16 bits per glyph) 
				; 
 F2DF  D1 E7				SHL	DI, 1				; WORD (char) align mem offset 
 F2E1  D0 E2				SHL	DL, 1				; WORD (char) align rect width 
 F2E3  9E				SAHF					; set ZF if scroll up 
 F2E4  74 0A				JZ	INT_10_SCR_GFX_RDY	; jump if scroll up 
				 
				;----------------------------------------------------------------------------; 
				; is 320x200 AND scroll down 
				; 
 F2E6  47				INC	DI				; fixup start address for last pixel 
				 
 F2E7				INT_10_SCR_GFX_2: 
 F2E7  9E				SAHF					; set ZF if scroll up 
 F2E8  74 06				JZ	INT_10_SCR_GFX_RDY	; jump if scroll up 
				 
				;----------------------------------------------------------------------------; 
				; is scroll down 
				; 
 F2EA  81 C7 00F0			ADD	DI, 240			; fixup bottom row of new rect. 
 F2EE  F7 DD				NEG	BP				; if scroll down, subtract offset instead 
				 
				;----------------------------------------------------------------------------; 
				; ready to begin 
				; 
 F2F0				INT_10_SCR_GFX_RDY: 
 F2F0  84 C0				TEST	AL, AL			; is number of lines to scroll 0? 
 F2F2  74 33				JZ	INT_10_SCR_GFX_CLR	; if so, skip move and only clear 
				 
				;----------------------------------------------------------------------------; 
				; Bit block transfer pixel data in video memory 
				; 
 F2F4  8B F7				MOV	SI, DI			; SI = mem offset of new rectangle 
 F2F6  8B C5				MOV	AX, BP			; AL = 1 scanline (80 if up, -80 if down) 
 F2F8  F6 EB				IMUL	BL				; AX = offset of lines to scroll * +/- 80 
 F2FA  03 F0				ADD	SI, AX			; SI = mem offset of old rectangle 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-155


 F2FC  8C C0				MOV	AX, ES			; set DS to video regen segment 
 F2FE  8E D8				MOV	DS, AX			;  for source (old) rectangle 
 F300  53				PUSH	BX				; save lines to clear and attribute 
 F301  2A F3				SUB	DH, BL			; DH = # of lines to write 
					;JZ	INT_10_SCR_GFX_CLR_1	; check that loop > 1 (necessary?) 
 F303  8B C6				MOV	AX, SI			; save source 
 F305  8B DF				MOV	BX, DI			; save destination 
 F307				INT_10_SCR_GFX_MOVE_LOOP: 
 F307  8A CA				MOV	CL, DL			; # of pixels to copy 
 F309  F3/ A4				REP	MOVSB				; copy odd field 
 F30B  BE 2000				MOV	SI, CGA_MEM_FLD		; vid mem offset for interlaced field 
 F30E  8B FE				MOV	DI, SI 
 F310  03 F0				ADD	SI, AX			; add to line offset 
 F312  03 FB				ADD	DI, BX 
 F314  8A CA				MOV	CL, DL			; # of pixels to copy 
 F316  F3/ A4				REP	MOVSB				; copy even field 
 F318  03 C5				ADD	AX, BP			; move to next line 
 F31A  03 DD				ADD	BX, BP 
 F31C  8B F0				MOV	SI, AX			; reset source 
 F31E  8B FB				MOV	DI, BX			; reset dest 
 F320  FE CE				DEC	DH 
 F322  75 E3				JNZ	INT_10_SCR_GFX_MOVE_LOOP 
 F324  5B				POP	BX 
				 
				;----------------------------------------------------------------------------; 
				; Clear old window rectangle 
				; 
 F325				INT_10_SCR_GFX_CLR_1: 
 F325  8A F3				MOV	DH, BL			; # of lines to clear 
 F327				INT_10_SCR_GFX_CLR: 
 F327  8A C7				MOV	AL, BH			; AL = attribute/color byte to write 
 F329  8B F7				MOV	SI, DI			; save destination 
 F32B				INT_10_SCR_GFX_CLR_LOOP: 
 F32B  8A CA				MOV	CL, DL			; # of pixels to clear 
 F32D  F3/ AA				REP	STOSB				; clear odd field 
 F32F  BF 2000				MOV	DI, CGA_MEM_FLD		; vid mem offset for interlaced field 
 F332  03 FE				ADD	DI, SI 
 F334  8A CA				MOV	CL, DL			; # of pixels to clear 
 F336  F3/ AA				REP	STOSB				; clear even field 
 F338  03 F5				ADD	SI, BP			; move to next line 
 F33A  8B FE				MOV	DI, SI			; reset dest 
 F33C  FE CE				DEC	DH 
 F33E  75 EB				JNZ	INT_10_SCR_GFX_CLR_LOOP 
 F340  1F				POP	DS 
 F341  E9 F2B9 R			JMP	INT_10_6_DONE 
				 
 F344				INT_10_SCR_GFX ENDP 
				 
 F344				INT_10_6 ENDP 
 F344				INT_10_7 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,8 - Read character and attribute at cursor 
				;----------------------------------------------------------------------------; 
				; Input: 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-156


				;	BH = display page 
				; Output: 
				;	AH = attribute of character (alpha modes only) 
				;	AL = character at cursor position 
				; 
				; http://www.techhelpmanual.com/92-cga_video_snow_and_cls_flash.html 
				;----------------------------------------------------------------------------; 
 F344				INT_10_8 PROC 
 F344  E8 F5D1 R			CALL	INT_10_GET_CUR_ADDR	; ES:DI = video RAM offset of cursor 
 F347  A0 0049 R			MOV	AL, VID_MODE		; AL = current video mode (0-7) 
 F34A  3C 07				CMP	AL, 7				; is MDA mode 7? 
 F34C  75 04				JNZ	INT_10_8_CHK_CGA		; if not, jump to check CGA or gfx 
				 
				;----------------------------------------------------------------------------; 
				; Standard, fast routine 
				; 
 F34E				INT_10_8_FAST: 
 F34E  26: 8B 05			MOV	AX, ES:[DI]			; just read from memory and return 
 F351  C3				RET 
				 
 F352				INT_10_8_CHK_CGA: 
 F352  D0 E8				SHR	AL, 1				; Video modes: 0=40,1=80,2=low-gfx,3=hi-gfx 
 F354  3C 01				CMP	AL, 1				; is CGA modes 2,3? 
							ENDIF 
				 
 F356  76 F6				JBE	INT_10_8_FAST		; if not GFX modes 4,5,6 jump to fast text 
										; fall through to graphics 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,8 - Read character and attribute at cursor in CGA graphic mode 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AL = 3 if high res, 2 if low-res 
				;	ES = video mem segment 
				; Output: 
				;	AH = 0 
				;	AL = character at cursor position, 0 if not found 
				;----------------------------------------------------------------------------; 
 F358				INT_10_8_MODE_GFX PROC 
					PUSHX	BX, CX, DX, SI 
			     1				IFNB <BX>			; exit if last reg 
 F358  53                    1		PUSH	BX 					; push register and repeat 
			     1		PUSHX	CX, DX, SI, , , ,  
			     2				IFNB <CX>			; exit if last reg 
 F359  51                    2		PUSH	CX 					; push register and repeat 
			     2		PUSHX	DX, SI, , , , ,  
			     3				IFNB <DX>			; exit if last reg 
 F35A  52                    3		PUSH	DX 					; push register and repeat 
			     3		PUSHX	SI, , , , , ,  
			     4				IFNB <SI>			; exit if last reg 
 F35B  56                    4		PUSH	SI 					; push register and repeat 
			     4		PUSHX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-157


			     2				ENDIF 
			     1				ENDIF 
 F35C  83 EC 08				SUB	SP, 8				; reserve 8 bytes for target bitmap 
				 
				;----------------------------------------------------------------------------; 
				; Lookup page, calculate charpos and set up data segments 
				; 
 F35F  E8 F4AE R			CALL	INT_10_GFX_CHARPOS	; DI = memory offset of curr. cursor 
 F362  8B F7				MOV	SI, DI			; SI = memory offset of curr. cursor 
 F364  8B FC				MOV	DI, SP			; DI = start of temp space 
 F366  06				PUSH	ES				; DS = ES 
 F367  1F				POP	DS 
 F368  16				PUSH	SS				; ES = SS 
 F369  07				POP	ES 
 F36A  B9 0004				MOV	CX, 4				; loop counter for high and low res 
 F36D  BA 2000				MOV	DX, CGA_MEM_FLD		; CGA memory interlace field offset 
 F370  3C 03				CMP	AL, 3				; is high-res graphics mode? 
 F372  74 5D				JZ	INT_10_8_GFX_HIGH		; jump to handle high-res 1 bpp spacing 
				 
				;----------------------------------------------------------------------------; 
				; Low-res - Load and pack 8 character bytes from video mem into [DS:BP] 
				;----------------------------------------------------------------------------; 
 F374				INT_10_8_MODE_GFX_LOW: 
 F374  D1 E6				SHL	SI, 1				; align for two bytes/char in 320x200 
				 
 F376				INT_10_8_GFX_LOW_1: 
 F376  8B 04				MOV	AX, [SI]			; AX = next two chars from video mem 
 F378  86 C4				XCHG	AL, AH			; convert endian from WORD read 
				 
				;----------------------------------------------------------------------------; 
				; Shift and OR the color bits together so that non-zero value will produce 1 
				; 
 F37A  8B D8				MOV	BX, AX			; copy bit pattern 
 F37C  D1 E0				SHL	AX, 1				; shift low bit into high bit 
 F37E  0B D8				OR	BX, AX			; make high bit a 1 if either bit is 1 
				 
				;----------------------------------------------------------------------------; 
				; Copy the only odd bits from the WORD value into a BYTE value. 
				; 
 F380  B4 08				MOV	AH, 8				; loop through the eight 2 bpp values 
 F382				INT_10_8_GFX_LOW_2: 
 F382  D1 E3				SHL	BX, 1				; even bit into CF 
 F384  12 C0				ADC	AL, AL			; shift CF onto low order bit 
 F386  D1 E3				SHL	BX, 1				; discard pixel odd bit 
 F388  FE CC				DEC	AH				; dec loop counter 
 F38A  75 F6				JNZ	INT_10_8_GFX_LOW_2 
 F38C  AA				STOSB					; save byte to local storage 
 F38D  33 F2				XOR	SI, DX			; toggle video field memory offset 
 F38F  85 F2				TEST	SI, DX			; is next field even? 
 F391  75 E3				JNZ	INT_10_8_GFX_LOW_1	; jump if next field is even 
 F393  83 C6 50				ADD	SI, 80			; if next field is odd, move to next line 
 F396  E2 DE				LOOP	INT_10_8_GFX_LOW_1	; loop all 8 bitmap bytes and fall through 
				 
				;----------------------------------------------------------------------------; 
				; Do a linear search (uh, time complexity anyone?) of ROM BIOS and INT 1Fh  
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-158


				; for the 8x8 1 bpp bitmap at the cursor position. 
				; 
 F398				INT_10_8_GFX_SEARCH: 
 F398  8B FC				MOV	DI, SP			; DI = char bitmap from video mem 
 F39A  BE FA6E R			MOV	SI, OFFSET GFX_CHARSET	; SI = BIOS ROM table 
 F39D  8C CB				MOV	BX, CS			; DS = CS 
 F39F  8E DB				MOV	DS, BX 
 F3A1  33 C0				XOR	AX, AX			; start codepoint counter at 0 
 F3A3				INT_10_8_GFX_SEARCH_TBL: 
 F3A3  BB 0080				MOV	BX, 128			; loop counter for each charset table 
 F3A6				INT_10_8_GFX_SEARCH_CHR: 
 F3A6  56				PUSH	SI				; save target bitmap and ROM table offsets 
 F3A7  57				PUSH	DI 
 F3A8  B1 04				MOV	CL, 4				; compare [CS:SI] (ROM table) to 
 F3AA  F3/ A7				REPE	CMPSW				;  [ES:DI] (char bitmap from vid mem) 
 F3AC  5F				POP	DI				; restart target bitmap at beginning  
 F3AD  5E				POP	SI				; ROM table always advanced by 8  
 F3AE  74 19				JE	INT_10_8_GFX_DONE		; end search if match found 
 F3B0  83 C6 08				ADD	SI, 8				; next char in table 
 F3B3  FE C0				INC	AL				; next codepoint to try 
 F3B5  74 12				JZ	INT_10_8_GFX_DONE		; if AL > 255, char not found 
 F3B7  4B				DEC	BX				; dec charset loop counter 
 F3B8  75 EC				JNZ	INT_10_8_GFX_SEARCH_CHR	; loop until end of table set 
				 
				;----------------------------------------------------------------------------; 
				; Search again in user charset at 0000:007C (INT 1Fh). 
				; 
 F3BA  99				CWD					; DX = 0000h 
 F3BB  8E DA				MOV	DS, DX			; DS = IVT 
							ASSUME DS:_IVT 
 F3BD  C5 36 007C R			LDS	SI, IVT_1F			; DS:SI = user charset 
							ASSUME DS:_BDA 
 F3C1  8C DA				MOV	DX, DS			; see if custom table has been vectored 
 F3C3  0B D6				OR	DX, SI			;  and not the default of 0000:0000 
 F3C5  75 DC				JNZ	INT_10_8_GFX_SEARCH_TBL	; if so, continue search 
 F3C7  33 C0				XOR	AX, AX			; otherwise return not found (0) 
 F3C9				INT_10_8_GFX_DONE: 
 F3C9  83 C4 08				ADD	SP, 8				; restore stack pointer 
					POPX	SI, DX, CX, BX 
			     1				IFNB <SI>			; exit if last reg 
 F3CC  5E                    1		POP	SI 					; pop register and repeat 
			     1		POPX	DX, CX, BX, , , ,  
			     2				IFNB <DX>			; exit if last reg 
 F3CD  5A                    2		POP	DX 					; pop register and repeat 
			     2		POPX	CX, BX, , , , ,  
			     3				IFNB <CX>			; exit if last reg 
 F3CE  59                    3		POP	CX 					; pop register and repeat 
			     3		POPX	BX, , , , , ,  
			     4				IFNB <BX>			; exit if last reg 
 F3CF  5B                    4		POP	BX 					; pop register and repeat 
			     4		POPX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-159


			     1				ENDIF 
 F3D0  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; High-res - Load 8 character bytes from video mem into [DS:BP] 
				;----------------------------------------------------------------------------; 
 F3D1				INT_10_8_GFX_HIGH: 
 F3D1  A4				MOVSB					; copy odd field 
 F3D2  4E				DEC	SI				; undo MOVSB source inc 
 F3D3  33 F2				XOR	SI, DX			; toggle video field memory offset 
 F3D5  A4				MOVSB					; copy even field 
 F3D6  33 F2				XOR	SI, DX			; toggle video field memory offset back 
 F3D8  83 C6 4F				ADD	SI, 80-1			; move to next line (undo MOVSB inc of SI) 
 F3DB  E2 F4				LOOP	INT_10_8_GFX_HIGH		; loop 8 times 
 F3DD  EB B9				JMP	INT_10_8_GFX_SEARCH	; rejoin the search 
				 
 F3DF				INT_10_8_MODE_GFX ENDP 
				 
 F3DF				INT_10_8 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,9 - Write character and attribute at cursor 
				;----------------------------------------------------------------------------; 
				; INT 10,A - Write character at current cursor 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AH = 09 or 0A 
				;	AL = ASCII character to write 
				;	BH = display page  (or mode 13h, background pixel value) 
				;	BL = foreground color (graphics mode only) 
				;	CX = count of characters to write (CX >= 1) 
				; 
				; This code is performance sensitive, so jumps are prioritizied 
				; and some code is duplicated to avoid jumps. For example, AH=0AH is used  
				; far more frequently than 09H so it gets the fall through cases. 
				;----------------------------------------------------------------------------; 
 F3DF				INT_10_9 PROC 
 F3DF				INT_10_A PROC 
 F3DF  51				PUSH	CX 
 F3E0  50				PUSH	AX				; save AX 
 F3E1  E8 F5D1 R			CALL	INT_10_GET_CUR_ADDR	; ES:DI = video RAM offset of cursor 
 F3E4  A0 0049 R			MOV	AL, VID_MODE		; AL = current video mode (0-7) 
 F3E7  3C 07				CMP	AL, 7				; is MDA mode 7? 
 F3E9  75 12				JNZ	INT_10_CHK_CGA		; if not, jump to check CGA 
				 
				;----------------------------------------------------------------------------; 
				; Use standard, fast routine for direct video memory writes 
				; 
 F3EB				INT_10_9A_FAST: 
 F3EB  58				POP	AX				; restore AX 
 F3EC  80 FC 09				CMP	AH, 9				; is function 9 (char + attribute)? 
 F3EF  74 06				JZ	INT_10_9_FAST		; if so, jump 
				 
				;----------------------------------------------------------------------------; 
				; AH = 0AH: Write Character 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-160


				; 
 F3F1				INT_10_A_FAST: 
 F3F1  AA				STOSB					; write char, skip attribute 
 F3F2  47				INC	DI 
 F3F3  E2 FC				LOOP	INT_10_A_FAST 
 F3F5  59				POP	CX 
 F3F6  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; AH = 09H: Write Character and Attribute 
				; 
 F3F7				INT_10_9_FAST: 
 F3F7  8A E3				MOV	AH, BL			; char attribute into high byte 
 F3F9  F3/ AB				REP	STOSW				; write with attribute 
 F3FB  59				POP	CX 
 F3FC  C3				RET 
				 
 F3FD				INT_10_CHK_CGA: 
 F3FD  D0 E8				SHR	AL, 1				; group remaining video modes 
 F3FF  3C 01				CMP	AL, 1				; is CGA modes 2,3? 
							ENDIF 
				 
 F401  76 E8				JBE	INT_10_9A_FAST		; is not GFX modes 4,5,6 jump to fast text 
 F403  58				POP	AX				; restore AX and fall through to graphics 
				 
				;----------------------------------------------------------------------------; 
				; INT 10, 9 and A - Write character in CGA graphics mode 
				;----------------------------------------------------------------------------; 
 F404				INT_10_9A_MODE_GFX PROC 
					PUSHX	AX, BX, DX, SI, DS 
			     1				IFNB <AX>			; exit if last reg 
 F404  50                    1		PUSH	AX 					; push register and repeat 
			     1		PUSHX	BX, DX, SI, DS, , ,  
			     2				IFNB <BX>			; exit if last reg 
 F405  53                    2		PUSH	BX 					; push register and repeat 
			     2		PUSHX	DX, SI, DS, , , ,  
			     3				IFNB <DX>			; exit if last reg 
 F406  52                    3		PUSH	DX 					; push register and repeat 
			     3		PUSHX	SI, DS, , , , ,  
			     4				IFNB <SI>			; exit if last reg 
 F407  56                    4		PUSH	SI 					; push register and repeat 
			     4		PUSHX	DS, , , , , ,  
			     5				IFNB <DS>			; exit if last reg 
 F408  1E                    5		PUSH	DS 					; push register and repeat 
			     5		PUSHX	, , , , , ,  
			     6				ENDIF 
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F409  8A 3E 0049 R			MOV	BH, VID_MODE		; BH = current video mode 
 F40D  E8 F4AE R			CALL	INT_10_GFX_CHARPOS	; DI = memory offset of curr. cursor 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-161


				; If extended ASCII, use custom table revectored at 1Fh 
				; 
 F410  BE FA6E R			MOV	SI, OFFSET GFX_CHARSET	; default to lower set using BIOS table 
 F413  8C CA				MOV	DX, CS			;  located in CS 
 F415  8E DA				MOV	DS, DX			; DS = CS 
 F417  84 C0				TEST	AL, AL			; is extended (AL > 127)? 
 F419  79 0A				JNS	INT_10_9A_GFX_2		; Jump if not 
 F41B  24 7F				AND	AL, 01111111b		; AL = low 7 bits of CP 
 F41D  33 D2				XOR	DX, DX			; Set DS to IVT to load DS and SI from 
 F41F  8E DA				MOV	DS, DX			; INT 1Fh 
							ASSUME DS:_IVT 
 F421  C5 36 007C R			LDS	SI, IVT_1F			; use custom font table 
				 
 F425				INT_10_9A_GFX_2: 
 F425  98				CBW					; AH = 0 
 F426  D1 E0				SHL	AX, 1				; AX = char * 8 
 F428  D1 E0				SHL	AX, 1 
 F42A  D1 E0				SHL	AX, 1 
 F42C  03 F0				ADD	SI, AX			; SI = offset in char table 
 F42E  80 FF 06				CMP	BH, 6 
 F431  74 56				JE	INT_10_9A_GFX_HIGH	; jump if high res 
				 
				;----------------------------------------------------------------------------; 
				; Low-res (320x200) graphics modes 4-5 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AX = ASCII character to write * 8 bytes 
				;	BH = video mode 
				;	BL = foreground color 
				;	CX = number of times to repeat character 
				;	DS:SI = start of character offset in font bitmap table 
				;	ES:DI = cursor location in video RAM 
				;----------------------------------------------------------------------------; 
				; Things you must do: 
				;	1. Transform each BYTE of 1 bit glyph into 2 bpp color WORD 
				;	2. If BL has high bit set, XOR new char with current char 
				;	3. Write new bitmap to CGA interlaced video memory 
				;----------------------------------------------------------------------------; 
 F433				INT_10_9A_GFX_LOW: 
 F433  8A D3				MOV	DL, BL			; DL = foreground color bits 
 F435  83 E2 03				AND	DX, 0011b			; zero extend 2 bit color 
				 
				;----------------------------------------------------------------------------; 
				; Repeat/expand 2 color bits in DL into into DX 
				; 
 F438				INT_10_9A_GFX_FG: 
 F438  0A F2				OR	DH, DL			; copy 2 bits 
 F43A  D0 E2				SHL	DL, 1				; move color bits to next position 
 F43C  D0 E2				SHL	DL, 1 
 F43E  75 F8				JNZ	INT_10_9A_GFX_FG		; loop until DL = 0 
 F440  8A D6				MOV	DL, DH			; copy to both bytes of DX 
				 
				;----------------------------------------------------------------------------; 
				; Repeat for number of chars to write in CX to create color mask 
				; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-162


 F442  D1 E7				SHL	DI, 1				; align for two bytes/char in 320x200 
 F444				INT_10_9A_GFX_LOW_CHAR: 
 F444  56				PUSH	SI				; save char glyph start offset for each loop 
 F445  57				PUSH	DI				; start each char at first row of vid mem 
				 
				;----------------------------------------------------------------------------; 
				; Transform glyph bitmap to 2 bit color and move into video memory 
				; 
 F446  51				PUSH	CX				; save repeat counter 
 F447  B9 0008				MOV	CX, 8				; loop 8 bytes 
 F44A				INT_10_9A_GFX_LOW_BYTE: 
 F44A  AC				LODSB					; Load next byte 
				 
				;----------------------------------------------------------------------------; 
				; Parallel-deposit bits of input char and transform 1 bit pixel into 2 bpp 
				; 
 F44B  53				PUSH	BX 
 F44C  51				PUSH	CX				; save bitmap counter 
 F44D  33 DB				XOR	BX, BX			; clear output 
 F44F  B1 08				MOV	CL, 8				; loop 8 bits of input char 
 F451				INT_10_9A_GFX_LOW_PDEP: 
 F451  D0 E0				SHL	AL, 1				; CF = source pixel bit 
 F453  9F				LAHF					; save CF 
 F454  D1 D3				RCL	BX, 1				; shift CF into next bit 
 F456  9E				SAHF					; restore CF 
 F457  D1 D3				RCL	BX, 1				; shift CF into next bit again 
 F459  E2 F6				LOOP	INT_10_9A_GFX_LOW_PDEP 
 F45B  93				XCHG	AX, BX			; AX = result 
 F45C  86 C4				XCHG	AL, AH			; convert endian 
 F45E  59				POP	CX 
 F45F  5B				POP	BX 
 F460  23 C2				AND	AX, DX			; combine with color mask 
				 
				;----------------------------------------------------------------------------; 
				; In gfx mode, if BL bit 7=1 then value of BL is XOR'ed with the bg color 
				; 
 F462  84 DB				TEST	BL, BL			; high bit set? 
 F464  79 03				JNS	INT_10_9A_GFX_LOW_WR	; jump if not 
 F466  26: 33 05			XOR	AX, ES:[DI]			; XOR byte for current field 
 F469				INT_10_9A_GFX_LOW_WR: 
 F469  26: 89 05			MOV	ES:[DI], AX			; write 2 bytes to video memory 
 F46C  81 F7 2000			XOR	DI, CGA_MEM_FLD		; alternate video fields 
 F470  F7 C7 2000			TEST	DI, CGA_MEM_FLD		; is an even field next? 
 F474  75 03				JNZ	INT_10_9A_GFX_LOW_NEXT	; jump if even (use same offset for even) 
 F476  83 C7 50				ADD	DI, 80			; if next is odd, move to next bitmap row 
 F479				INT_10_9A_GFX_LOW_NEXT: 
 F479  E2 CF				LOOP	INT_10_9A_GFX_LOW_BYTE	; loop 8 glyph bytes/lines 
				 
 F47B  59				POP	CX				; restore repeat counter 
 F47C  5F				POP	DI 
 F47D  5E				POP	SI 
 F47E  47				INC	DI				; move to next video mem WORD offset 
 F47F  47				INC	DI 
 F480  E2 C2				LOOP	INT_10_9A_GFX_LOW_CHAR	; repeat for CX number of chars 
				 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-163


 F482				INT_10_9A_MODE_GFX_DONE: 
					POPX	DS, SI, DX, BX, AX 
			     1				IFNB <DS>			; exit if last reg 
 F482  1F                    1		POP	DS 					; pop register and repeat 
			     1		POPX	SI, DX, BX, AX, , ,  
			     2				IFNB <SI>			; exit if last reg 
 F483  5E                    2		POP	SI 					; pop register and repeat 
			     2		POPX	DX, BX, AX, , , ,  
			     3				IFNB <DX>			; exit if last reg 
 F484  5A                    3		POP	DX 					; pop register and repeat 
			     3		POPX	BX, AX, , , , ,  
			     4				IFNB <BX>			; exit if last reg 
 F485  5B                    4		POP	BX 					; pop register and repeat 
			     4		POPX	AX, , , , , ,  
			     5				IFNB <AX>			; exit if last reg 
 F486  58                    5		POP	AX 					; pop register and repeat 
			     5		POPX	, , , , , ,  
			     6				ENDIF 
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
				 
 F487				INT_10_9A_MODE_GFX_EXIT: 
 F487  59				POP	CX				; restore CX and rebalance stack 
 F488  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; High-res (640x200) graphics mode 6 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AX = ASCII character to write * 8 bytes 
				;	BH = current video mode 
				;	BL = foreground color 
				;	CX = number of times to repeat character 
				;	DS:SI = start of character offset in font bitmap table 
				;	ES:DI = cursor location in video RAM 
				;----------------------------------------------------------------------------; 
				; Things you must do: 
				;	1. If BL has high bit set, XOR new char with current char 
				;	2. Write new bitmap to CGA interlaced video memory 
				;----------------------------------------------------------------------------; 
				 
				;----------------------------------------------------------------------------; 
				; Repeat for number of chars to write in CX 
				; 
 F489				INT_10_9A_GFX_HIGH: 
 F489  56				PUSH	SI				; save char glyph start offset for each loop 
 F48A  57				PUSH	DI				; start each char at first row of vid mem 
				 
				;----------------------------------------------------------------------------; 
				; Copy glyph bitmap to interlaced video memory 
				; 
 F48B  B7 04				MOV	BH, 4				; loop 4 words (8 bytes) 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-164


 F48D				INT_10_9A_GFX_HIGH_WORD: 
 F48D  AD				LODSW					; load next two glyph rows 
				 
				;----------------------------------------------------------------------------; 
				; In gfx mode, if BL bit 7=1 then value of BL is XOR'ed with the bg color 
				; 
 F48E  84 DB				TEST	BL, BL			; high bit set? 
 F490  79 08				JNS	INT_10_9A_GFX_HIGH_WR	; jump if not 
 F492  26: 32 05			XOR	AL, ES:[DI]			; XOR byte on odd field 
 F495  26: 32 A5 2000			XOR	AH, ES:CGA_MEM_FLD[DI]	; and even field 
				 
				;----------------------------------------------------------------------------; 
				; Write next two bytes to each field 
				; 
 F49A				INT_10_9A_GFX_HIGH_WR: 
 F49A  AA				STOSB					; write odd field in AL 
 F49B  26: 88 A5 1FFF			MOV	ES:CGA_MEM_FLD[DI][-1], AH	; write even field in AH 
 F4A0  83 C7 4F				ADD	DI, 80-1			; move to next bitmap row 
 F4A3  FE CF				DEC	BH 
 F4A5  75 E6				JNZ	INT_10_9A_GFX_HIGH_WORD	; loop 4 words 
 F4A7  5F				POP	DI				; restore video mem cursor offset 
 F4A8  5E				POP	SI				; restore start of glyph 
 F4A9  47				INC	DI				; move to next video mem BYTE offset  
 F4AA  E2 DD				LOOP	INT_10_9A_GFX_HIGH	; repeat for CX number of chars 
 F4AC  EB D4				JMP	INT_10_9A_MODE_GFX_DONE	; exit 
				 
				;----------------------------------------------------------------------------; 
				; Calculate graphics memory address for current current position 
				;----------------------------------------------------------------------------; 
				; Input: DS = BDA 
				; Output: 
				;	DI = Current cursor vid mem offset 
				; 
				; Clobbers DX 
				;----------------------------------------------------------------------------; 
 F4AE				INT_10_GFX_CHARPOS PROC 
							ASSUME DS:_BDA 
 F4AE  8B F8				MOV	DI, AX			; save original AX 
 F4B0  A0 004A R			MOV	AL, BYTE PTR VID_COLS	; AL = screen mode cols (40 or 80) 
 F4B3  8B 16 0050 R			MOV	DX, VID_CURS_POS		; DH = cursor row pos, DL = column 
 F4B7  F6 E6				MUL	DH				; AX = screen cols * current row 
 F4B9  D1 E0				SHL	AX, 1				; AX = AX * 4 
 F4BB  D1 E0				SHL	AX, 1				; (8 rows / 2 fields) 
 F4BD  92				XCHG	AX, DX			; AL = current column, DX = row offset 
 F4BE  98				CBW					; AX = current column 
 F4BF  03 C2				ADD	AX, DX			; AX = current row/column vid mem offset 
 F4C1  97				XCHG	AX, DI			; AX = original, DI = row/col vid mem offset 
 F4C2  C3				RET 
 F4C3				INT_10_GFX_CHARPOS ENDP 
				 
 F4C3				INT_10_9A_MODE_GFX ENDP 
				 
 F4C3				INT_10_A ENDP 
 F4C3				INT_10_9 ENDP 
				 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-165


				;----------------------------------------------------------------------------; 
				; INT 10,B - Set color palette 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AH = 0B 
				;	BH = palette color ID 
				;	   = 0 to set background and border color 
				;	   = 1 to select 4 color palette 
				;	BL = color value (when BH = 0) 
				;	   = palette value (when BH = 1) 
				;----------------------------------------------------------------------------; 
				;	|7|6|5|4|3|2|1|0|  3D9 Color Select Register (Graphics) 
				;	 | | | | | `-------- RGB for background 
				;	 | | | | `--------- intensity 
				;	 | | | `---------- unused 
				;	 | | `----------- 1 = palette 1, 0=palette 0 (see below) 
				;	 `-------------- unused 
				;	  Palette 0 = green, red, brown 
				;	  Palette 1 = cyan, magenta, white 
				; 
				; VID_CSGFX	RECORD	CGPH:2=11B,CGPL:1,CGX:1,CGIN:1,CGBG:3 
				;----------------------------------------------------------------------------; 
 F4C3				INT_10_B PROC 
 F4C3  50				PUSH	AX 
 F4C4  A0 0066 R			MOV	AL, VID_COLOR			; get current color byte 
 F4C7  84 FF				TEST	BH, BH				; set BG/border or palette? 
 F4C9  75 07				JNZ	INT_10_B_SET_PAL			; jump if set palette 
 F4CB				INT_10_B_SET_COL: 
 F4CB  24 E0				AND	AL, MASK CGPH OR MASK CGPL	; isolate current palette 
 F4CD  80 E3 1F				AND	BL, 00011111B			; isolate color bits 
 F4D0  EB 0B				JMP	SHORT INT_10_B_DONE 
 F4D2				INT_10_B_SET_PAL: 
 F4D2  24 DF				AND	AL, NOT MASK CGPL			; clear palette bit 
 F4D4  80 E3 01				AND	BL, 00000001B			; isolate palette selector bit 
							ELSE 
						REPT	3 
					ROR	BL, 1					; move low bit into bit 5 
						ENDM 
 F4D7  D0 CB                 1		ROR	BL, 1					; move low bit into bit 5 
 F4D9  D0 CB                 1		ROR	BL, 1					; move low bit into bit 5 
 F4DB  D0 CB                 1		ROR	BL, 1					; move low bit into bit 5 
							ENDIF 
 F4DD				INT_10_B_DONE: 
 F4DD  0A C3				OR	AL, BL				; combine bytes 
 F4DF  A2 0066 R			MOV	VID_COLOR, AL			; save to BDA 
 F4E2  52				PUSH	DX 
 F4E3  8B 16 0063 R			MOV	DX, VID_PORT 
 F4E7  83 C2 05				ADD	DX, CGA_COLOR-CGA_IDX		; DX = 6845 color select reg (3D9H) 
 F4EA  EE				OUT	DX, AL				; send to CGA Color Select Register 
 F4EB  5A				POP	DX 
 F4EC  58				POP	AX 
 F4ED  C3				RET 
 F4EE				INT_10_B ENDP 
				 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-166


				; INT 10,C - Write graphics pixel at coordinate 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AL = color value (XOR'ed with current pixel if bit 7=1) 
				;	BH = page number, see VIDEO PAGES 
				;	CX = column number (zero based) 
				;	DX = row number (zero based) 
				;----------------------------------------------------------------------------; 
 F4EE				INT_10_C PROC 
 F4EE  50				PUSH	AX 
 F4EF  51				PUSH	CX 
 F4F0  E8 F51C R			CALL	INT_10_GFX_PIXEL		; ES:DI = memory offset, AH/CL mask/counter 
 F4F3  8A E8				MOV	CH, AL			; save original AL 
 F4F5  22 C4				AND	AL, AH			; mask only selected pixel 
 F4F7  D2 E0				SHL	AL, CL			; shift into correct bit position 
 F4F9  84 ED				TEST	CH, CH			; is high bit of color value set? 
 F4FB  78 0D				JS	INT_10_C_XOR		; if so, XOR byte in memory 
 F4FD  D2 E4				SHL	AH, CL			; shift mask for pixel position 
 F4FF  F6 D4				NOT	AH				; invert mask to clear current pixel 
 F501  26: 22 25			AND	AH, ES:[DI]			; clear pixel bits 
 F504  0A C4				OR	AL, AH			; replace with new pixel value 
 F506  AA				STOSB					; write to video buffer 
 F507				INT_10_C_DONE: 
 F507  59				POP	CX 
 F508  58				POP	AX 
 F509  C3				RET 
 F50A				INT_10_C_XOR: 
 F50A  26: 30 05			XOR	ES:[DI], AL			; just XOR and 'XIT 
 F50D  EB F8				JMP	SHORT INT_10_C_DONE 
 F50F				INT_10_C ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,D - Read graphics pixel at coordinate 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	BH = page number 
				;	CX = X / column (zero based) 
				;	DX = Y / row (zero based) 
				; Output: 
				;	AL = color of pixel read 
				;	AH clobbered 
				;----------------------------------------------------------------------------; 
 F50F				INT_10_D PROC 
 F50F  51				PUSH	CX 
 F510  E8 F51C R			CALL	INT_10_GFX_PIXEL		; ES:DI = memory offset, AH/CL mask/counter 
 F513  26: 8A 05			MOV	AL, ES:[DI]			; read packed pixel byte 
 F516  D2 E8				SHR	AL, CL			; shift into low order bit(s) 
 F518  22 C4				AND	AL, AH			; mask only selected pixel 
 F51A  59				POP	CX 
 F51B  C3				RET 
 F51C				INT_10_D ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Get Video Memory Pixel Offset and Pixel Byte Mask 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-167


				; Input: 
				;	CX = X / column (zero based) 
				;	DX = Y / row (zero based) 
				; 
				; Output 
				;	DI = pixel byte offset 
				;	AH = pixel data mask 
				;	CL = pixel right shift counter 
				;	CH = pixel index (big endian) 
				;	ES = VID_MEM_SEG 
				; 
				; Example of read: 
				;	MOV	AL, PIXEL_DAT 
				;	SHR	AL, CL 
				;	AND	AL, AH 
				; 
				; http://www.techhelpmanual.com/89-video_memory_layouts.html 
				;----------------------------------------------------------------------------; 
 F51C				INT_10_GFX_PIXEL PROC 
 F51C  C4 3E 00E8 R			LES	DI, VID_MEM_SEG_DW	; ES = video/regen RAM segment 
 F520  53				PUSH	BX 
 F521  52				PUSH	DX 
				 
				;----------------------------------------------------------------------------; 
				; Calculate X offset 
				; 
 F522  8B F9				MOV	DI, CX			; DI = X position (zero based) 
 F524  D1 EF				SHR	DI, 1 
 F526  D1 EF				SHR	DI, 1				; DI = DI / 4 (two bit alignment) 
				 
				;----------------------------------------------------------------------------; 
				; Unpack pixel bit(s) 
				; 
 F528  B4 03				MOV	AH, 0011B			; pixel mask = 0011B 
 F52A  8A DC				MOV	BL, AH			; index mask = 0011B (bits 0-3) 
 F52C  8A E9				MOV	CH, CL			; save CH = CL 
 F52E  B1 01				MOV	CL, 1				; ROL multiplier = 1 
 F530  80 3E 0049 R 06			CMP	VID_MODE, 6			; is 640x200 gfx mode? 
 F535  72 07				JB	NOT_HI_RES			; if low-res, skip 
				 
				;----------------------------------------------------------------------------; 
				; Is "high res" (640x200) 
				; 
 F537  D0 EC				SHR	AH, 1				; pixel mask = 0001B 
 F539  D0 D3				RCL	BL, 1				; index mask = 0111B (bits 0-7) 
 F53B  49				DEC	CX				; ROL multiplier = 0 
 F53C  D1 EF				SHR	DI, 1				; DI = DI / 8 (one bit alignment) 
 F53E				NOT_HI_RES: 
				 
				;----------------------------------------------------------------------------; 
				; Calculate right-shift counter: 
				; - 640x200: CL = (7 - i) * 1 
				; - 320x200: CL = (3 - i) * 2 
				; 
 F53E  22 EB				AND	CH, BL			; CH = packed pixel index 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-168


 F540  2A DD				SUB	BL, CH			; calculate right-shift counter 
 F542  D2 E3				SHL	BL, CL			; multiply by 1 (high res) or 2 (low res) 
 F544  8A CB				MOV	CL, BL			; CL = shift count 
				 
				;----------------------------------------------------------------------------; 
				; Calculate Y offset 
				; 
				; Y offset = (DX / 2) * 80 + 2000H[DX is odd] 
				; 
 F546  D1 EA				SHR	DX, 1				; DX = DX / 2 
 F548  86 D6				XCHG	DL, DH			; DX = DX << 8 
 F54A  73 04				JNC	FIELD_EVEN			; is odd or even field? 
 F54C  81 C7 2000			ADD	DI, CGA_MEM_FLD		; odd field address offset 
 F550				FIELD_EVEN: 
 F550  D1 EA				SHR	DX, 1 
 F552  D1 EA				SHR	DX, 1 
 F554  03 FA				ADD	DI, DX			; DI += (DX / 2) * 16 
 F556  D1 EA				SHR	DX, 1 
 F558  D1 EA				SHR	DX, 1 
 F55A  03 FA				ADD	DI, DX			; DI += (DX / 2) * 64 
 F55C  5A				POP	DX 
 F55D  5B				POP	BX 
 F55E  C3				RET 
 F55F				INT_10_GFX_PIXEL ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,E - Write text in teletype mode 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AH = 0E 
				;	AL = ASCII character to write 
				;	BH = page number (text modes) - override it with BDA value though 
				;	BL = foreground pixel color (graphics modes) 
				; 
				; Output: 
				;	Character to console 
				;	All registers preserved 
				;----------------------------------------------------------------------------; 
				; Things you must do: 
				;	1. Get video page from BDA - ignore what was passed in BH (why?) 
				;	2. Get cursor location (INT 10,3) and keep it handy. 
				;	3. Check for the four special control codes: BELL(7), BS(8), LF(A), CR(D) 
				;		- BELL: beep and exit 
				;		- Backspace: if cursor column is 0, exit else DEC col and go to 6 
				;		- CR: set cursor to column 0 and go to step 6 
				;		- LF: increment row and go to step 5 to check if scroll is needed 
				;	4. Write the char to the current position (INT 10,A) 
				;	5. If new row > last row, scroll up 1 row (INT 10,8). 
				;	6. Update cursor position (INT 10,6) 
				; 
				;----------------------------------------------------------------------------; 
 F55F				INT_10_E PROC 
					PUSHX	AX, BX, CX, DX 
			     1				IFNB <AX>			; exit if last reg 
 F55F  50                    1		PUSH	AX 					; push register and repeat 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-169


			     1		PUSHX	BX, CX, DX, , , ,  
			     2				IFNB <BX>			; exit if last reg 
 F560  53                    2		PUSH	BX 					; push register and repeat 
			     2		PUSHX	CX, DX, , , , ,  
			     3				IFNB <CX>			; exit if last reg 
 F561  51                    3		PUSH	CX 					; push register and repeat 
			     3		PUSHX	DX, , , , , ,  
			     4				IFNB <DX>			; exit if last reg 
 F562  52                    4		PUSH	DX 					; push register and repeat 
			     4		PUSHX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F563  E8 F1EF R			CALL	INT_10_3_CUR_PAGE		; Get cursor pos: DH = row, DL = column 
 F566  3C 0D				CMP	AL, CR			; is maybe a control code? 
 F568  76 3E				JBE	INT_10_E_CTRL		; if so, jump to handle it 
				 
				;----------------------------------------------------------------------------; 
				; Handle a regular char 
				; 
 F56A				INT_10_E_CHAR: 
 F56A  B9 0001				MOV	CX, 1				; repeat only once 
 F56D  E8 F3DF R			CALL	INT_10_A			; write char in AL at current row/col 
				 
				;----------------------------------------------------------------------------; 
				; Handle line wrap 
				; 
 F570  A0 004A R			MOV	AL, BYTE PTR VID_COLS	; get screen cols (80 or 40) 
 F573  48				DEC	AX				; fix 0 index (79 or 39) 
 F574  3A D0				CMP	DL, AL			; reached end of screen cols? 
 F576  72 02				JB	NEXT_COL			; jump if not 
 F578  B2 FF				MOV	DL, -1			; else move to first col and next row 
 F57A				NEXT_COL: 
 F57A  42				INC	DX				; move to next column (and maybe row) 
				 
				;----------------------------------------------------------------------------; 
				; Scroll if necessary 
				; 
 F57B				INT_10_E_SCROLL: 
 F57B  80 FE 18				CMP	DH, VID_DEF_ROWS		; moved past last row? 
 F57E  76 20				JBE	INT_10_E_CURS		; if not, no scroll necessary 
 F580  FE CE				DEC	DH				; undo row scroll 
 F582  E8 F085 R			CALL	INT_10_IS_TXT		; ZF = 1 if CGA/MDA Text, ZF = 0 if gfx 
 F585  98				CBW					; if gfx mode, attribute AH = 0 
 F586  75 03				JNZ	INT_10_E_SCROLL_UP	; jump if graphics 
 F588  E8 F344 R			CALL	INT_10_8			; Read character: AH = attribute, AL = char 
				 
				;----------------------------------------------------------------------------; 
				; Scroll up one line 
				; 
 F58B				INT_10_E_SCROLL_UP: 
 F58B  53				PUSH	BX				; save video page (BH) 
 F58C  93				XCHG	AX, BX			; BH = attribute 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-170


 F58D  B8 0601				MOV	AX, DBW <6, 1>		; AH = 06H Scroll Window Up, AL = 1 line 
 F590  33 C9				XOR	CX, CX			; scroll top left: CH = row 0, CL = col 0 
 F592  52				PUSH	DX				; save cursor bottom 
 F593  8A 16 004A R			MOV	DL, BYTE PTR VID_COLS	; DL = right-most column (1-indexed) 
 F597  B6 18				MOV	DH, VID_DEF_ROWS		; DH = bottom row (always 24) 
 F599  4A				DEC	DX				; fixup 0-indexed column 
 F59A  FC				CLD 
 F59B  E8 F235 R			CALL	INT_10_6			; INT 10H, 06H Scroll Window Up 
 F59E  5A				POP	DX				; restore cursor bottom 
 F59F  5B				POP	BX				; restore video page (BH) 
				 
				;----------------------------------------------------------------------------; 
				; Set new cursor position 
				; 
 F5A0				INT_10_E_CURS: 
 F5A0  E8 F1B6 R			CALL	INT_10_2			; set cursor pos: BH = page, row = DH, col = DL 
				 
 F5A3				INT_10_E_DONE: 
					POPX	DX, CX, BX, AX		; restore caller registers 
			     1				IFNB <DX>			; exit if last reg 
 F5A3  5A                    1		POP	DX 					; pop register and repeat 
			     1		POPX	CX, BX, AX, , , ,  
			     2				IFNB <CX>			; exit if last reg 
 F5A4  59                    2		POP	CX 					; pop register and repeat 
			     2		POPX	BX, AX, , , , ,  
			     3				IFNB <BX>			; exit if last reg 
 F5A5  5B                    3		POP	BX 					; pop register and repeat 
			     3		POPX	AX, , , , , ,  
			     4				IFNB <AX>			; exit if last reg 
 F5A6  58                    4		POP	AX 					; pop register and repeat 
			     4		POPX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 F5A7  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; Handle control codes 
				; 
 F5A8				INT_10_E_CTRL: 
 F5A8  74 11				JE	INT_10_E_CR			; is a CR? (from above) 
 F5AA  3C 0A				CMP	AL, LF			; is an LF? 
 F5AC  74 11				JE	INT_10_E_LF 
 F5AE  3C 08				CMP	AL, BS			; is a backspace? 
 F5B0  74 11				JE	INT_10_E_BS 
 F5B2  3C 07				CMP	AL, BELL			; Isabelle? 
 F5B4  75 B4				JNE	INT_10_E_CHAR		; otherwise, handle as a normal char 
 F5B6				INT_10_E_BELL: 
 F5B6  E8 E8B0 R			CALL	BEEP				; beep for ^G 
 F5B9  EB E8				JMP	INT_10_E_DONE		; exit 
 F5BB				INT_10_E_CR: 
 F5BB  32 D2				XOR	DL, DL			; move to column 0 
 F5BD  EB E1				JMP	INT_10_E_CURS		; update cursor 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-171


 F5BF				INT_10_E_LF: 
 F5BF  FE C6				INC	DH				; move to next row 
 F5C1  EB B8				JMP	INT_10_E_SCROLL		; maybe scroll 
 F5C3				INT_10_E_BS: 
 F5C3  FE CA				DEC	DL				; back space one column 
 F5C5  78 DC				JS	INT_10_E_DONE		; if first column, do nothing and exit 
 F5C7  EB D7				JMP	INT_10_E_CURS		; update cursor 
				 
 F5C9				INT_10_E ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 10,F - Get current video state 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AH = 0F 
				; Output 
				;	AH = number of screen columns 
				;	AL = mode currently set 
				;	BH = current display page 
				;----------------------------------------------------------------------------; 
 F5C9				INT_10_F PROC 
 F5C9  A1 0049 R			MOV	AX, WORD PTR VID_MODE 
 F5CC  8A 3E 0062 R			MOV	BH, VID_PAGE 
 F5D0  C3				RET 
 F5D1				INT_10_F ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Get video memory offset for current cursor position 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	BH = current video page 
				; Output: 
				;	DI = memory offset of current cursor in memory 
				;	ES = video RAM segment 
				; Clobbers: AX 
				;----------------------------------------------------------------------------; 
 F5D1				INT_10_GET_CUR_ADDR PROC 
 F5D1  52				PUSH	DX 
 F5D2  8A C7				MOV	AL, BH			; AL = display page 
 F5D4  C4 3E 00E8 R			LES	DI, VID_MEM_SEG_DW	; ES = video RAM segment 
 F5D8  98				CBW					; AX = page number 
 F5D9  97				XCHG	AX, DI			; DI = page number 
 F5DA  A1 004C R			MOV	AX, VID_BUF_SZ		; AX = VID_BUF_SZ 
 F5DD  F7 E7				MUL	DI				; AX = page size * page (base offset) 
 F5DF  D1 E7				SHL	DI, 1				; word align index 
 F5E1  8B 95 0050 R			MOV	DX, VID_CURS_POS[DI]	; DX = cursor position on page 
 F5E5  97				XCHG	AX, DI			; DI = page base offset 
 F5E6  A0 004A R			MOV	AL, BYTE PTR VID_COLS 
 F5E9  F6 E6				MUL	DH				; AX = screen cols * current row 
 F5EB  92				XCHG	AX, DX			; DX = rows offset, AL = current col 
 F5EC  98				CBW					; AX = current col 
 F5ED  03 C2				ADD	AX, DX			; AX = page relative cursor offset 
 F5EF  D1 E0				SHL	AX, 1				; word align 
 F5F1  03 F8				ADD	DI, AX			; DI = memory offset of cursor 
 F5F3  5A				POP	DX 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-172


 F5F4  C3				RET 
 F5F5				INT_10_GET_CUR_ADDR ENDP 
				 
				;----------------------------------------------------------------------------; 
				; 6845 CRT mode control register values 
				;----------------------------------------------------------------------------; 
				; CGA: 
				;	|7|6|5|4|3|2|1|0|  3D8H Mode Select Register 
				;	     | | | | | `---- 1 = 80x25 text, 0 = 40x25 text 
				;	     | | | | `----- 1 = 320x200 graphics, 0 = text (unused on MDA) 
				;	     | | | `------ 1 = B/W, 0 = color (unused on MDA) 
				;	     | | `------- 1 = enable video signal 
				;	     | `-------- 1 = 640x200 B/W graphics (unused on MDA) 
				;	     `--------- 1 = blink, 0 = no blink 
				; MDA: 
				;	|7|6|5|4|3|2|1|0|  3B8H CRT Control Port 
				;	     | | | | | `---- 1 = 80x25 text 
				;	     | | | `------- unused 
				;	     | | `-------- 1 = enable video signal 
				;	     | `--------- unused 
				;	     `---------- 1 = blinking on 
				; 
				; source: https://stanislavs.org/helppc/6845.html 
				;----------------------------------------------------------------------------; 
 F5F5  2C			CRT_MODE	DB	101100B	; 00: 40x25 B/W text (CGA) 
 F5F6  28					DB	101000B	; 01: 40x25 16 color text (CGA) 
 F5F7  2D					DB 	101101B	; 02: 80x25 16 shades of gray text (CGA) 
 F5F8  29					DB	101001B	; 03: 80x25 16 color text (CGA) 
 F5F9  2A					DB	101010B	; 04: 320x200 4 color graphics (CGA) 
 F5FA  2E					DB	101110B	; 05: 320x200 4 color graphics (CGA) 
 F5FB  1E					DB	011110B	; 06: 640x200 B/W graphics (CGA) 
 F5FC  29					DB	101001B	; 07: 80x25 Monochrome text (MDA, HERC) 
				 
 F5FD				INT_10 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Display system hardware config 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	DS = BDA (0040) 
				; 
				; Clobbers: AX, BX, CX, SI 
				; Size: 193 bytes 
				;----------------------------------------------------------------------------; 
 F5FD				POST_SYS_CONFIG PROC 
							ASSUME DS:_BDA 
				 
							IF POST_VIDEO_TYPE EQ 1 
				;----------------------------------------------------------------------------; 
				; Display Video Type 
				;----------------------------------------------------------------------------; 
 F5FD				POST_SYS_VIDEO PROC 
					POST_COL_2	POST_VIDEO, POST_CLR_VAL1 ; display "Video" left column 
			     1			ENDIF 
			     1			ELSE 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-173


 F5FD  B3 0A                 1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute 
			     1			ENDIF 
 F5FF  BE FF46 R             1		MOV	SI, OFFSET POST_VIDEO 
 F602  E8 F6EA R             1		CALL	POST_START_COL_2 
			     1			ENDIF 
											; default to "None" 
				 
				;----------------------------------------------------------------------------; 
				; Check if INT 10 is using this BIOS. If so, must be CGA or MDA. 
				; 
 F605  1E				PUSH	DS 
 F606  33 C0				XOR	AX, AX				; AX = SEG _IVT 
 F608  8E D8				MOV	DS, AX				; set IVT segment for LDS 
							ASSUME DS:_IVT 
 F60A  C5 06 0040 R			LDS	AX, DWORD PTR IVT_10		; if BIOS, DS = 0F000H, AX = 0F065H 
 F60E  3D F065 R			CMP	AX, OFFSET INT_10			; is offset the BIOS IRR for INT 10? 
 F611  8C D8				MOV	AX, DS				; save for next compare 
 F613  1F				POP	DS					; restore DS 
							ASSUME DS:_BDA 
 F614  75 13				JNE	CHECK_VGA				; if not, jump to VGA check 
 F616  8C CB				MOV	BX, CS				; AX = BIOS code segment 
 F618  3B C3				CMP	AX, BX				; is BIOS segment? 
 F61A  75 0D				JNE	CHECK_VGA				; if not, jump to VGA check 
				 
				;----------------------------------------------------------------------------; 
				; Read BDA for video type 
				; 
 F61C				BIOS_VIDEO: 
 F61C  E8 F085 R			CALL	INT_10_IS_TXT			; CF = 1 if MDA mode 7 
 F61F  BE E826 R			MOV	SI, OFFSET POST_MDA		; default "MDA" 
 F622  72 21				JC	POST_SYS_VIDEO_DONE 
 F624  BE E822 R			MOV	SI, OFFSET POST_CGA		; otherwise "CGA" 
 F627  EB 1C				JMP	SHORT POST_SYS_VIDEO_DONE 
				 
				;----------------------------------------------------------------------------; 
				; Check if VGA 
				; stanislavs.org/helppc/int_10-1a.html 
				; 
 F629				CHECK_VGA: 
 F629  B8 1A00				MOV	AX, DBW <1AH, 0>			; AH = 1AH, get video display 
 F62C  CD 10				INT	10H					; BL = display type 
 F62E  3C 1A				CMP	AL, 1AH				; is VGA? 
 F630  75 05				JNE	CHECK_EGA				; jump if not VGA 
 F632  BE E81A R			MOV	SI, OFFSET POST_VGA		; is "VGA" 
 F635  EB 0E				JMP	SHORT POST_SYS_VIDEO_DONE 
				 
				;----------------------------------------------------------------------------; 
				; Check if EGA 
				; stanislavs.org/helppc/int_10-12.html 
				; 
 F637				CHECK_EGA: 
 F637  B4 12				MOV 	AH, 12H				; AH = 12H, get video configuration 
 F639  B3 10				MOV	BL, 10H				; configuration info 
 F63B  CD 10				INT	10H 
 F63D  80 FB 10				CMP	BL, 10H				; check if param hasn't changed 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-174


 F640  74 03				JE	POST_SYS_VIDEO_DONE		; jump if not EGA 
 F642  BE E81E R			MOV	SI, OFFSET POST_EGA		; is "EGA" 
				 
 F645				POST_SYS_VIDEO_DONE: 
 F645  E8 F71C R			CALL	OUT_SZ				; display detected video adapter 
 F648  E8 F6FC R			CALL	POST_END_COL_NL			; end of column with NL and RET 
				 
 F64B				POST_SYS_VIDEO ENDP 
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Display CPU type 
				; 
					POST_COL_1	POST_CPU, POST_CLR_VAL1	; display 'CPU' left column 
			     1			ENDIF 
			     1			ELSE 
 F64B  B3 0A                 1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute 
			     1			ENDIF 
 F64D  BE E45F R             1		MOV	SI, OFFSET POST_CPU 
 F650  E8 F6C3 R             1		CALL	POST_START_COL_1 
			     1			ENDIF 
											;  SI now points to '8088' 
 F653				CPU_CHECK_TYPE_2: 
					TEST_GFLAG  V20				; ZF = 0 if V20, ZF = 1 if 8088 
 F653  F6 06 0012 R 04       1		TEST	GB_FLAGS, MASK V20 
 F658  74 03				JZ	CPU_CHECK_TYPE_2_DONE		; jump if 8088 
 F65A  BE E485 R			MOV	SI, OFFSET POST_V20		; if not, is V20 
 F65D				CPU_CHECK_TYPE_2_DONE: 
 F65D  E8 F71C R			CALL	OUT_SZ				; write CPU type 
					POST_COL_END				; end first column 
			     1			ENDIF 
 F660  E8 F701 R             1		CALL	POST_END_COL 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Display FPU/math co-processor 
				; 
 F663				FPU_CHECK: 
					POST_COL_2  POST_FPU, POST_CLR_VAL1	; display 'FPU', SI now '8087' 
			     1			ENDIF 
			     1			ELSE 
 F663  B3 0A                 1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute 
			     1			ENDIF 
 F665  BE E468 R             1		MOV	SI, OFFSET POST_FPU 
 F668  E8 F6EA R             1		CALL	POST_START_COL_2 
			     1			ENDIF 
					TEST_EFLAG  FPU				; was FPU detected? 
			     1				IF FPU LT 8 
 F66B  F6 06 0010 R 02       1		TEST	BYTE PTR EQUIP_FLAGS, LOW MASK FPU 
			     1				ENDIF 
 F670  75 03				JNZ	FPU_DISP_DONE			; jump to output if FPU 
 F672  BE FF4C R			MOV	SI, OFFSET POST_NONE		; otherwise 'None' 
 F675				FPU_DISP_DONE: 
 F675  E8 F71C R			CALL	OUT_SZ				; display string 
					POST_COL_END_NL				; end second column, move to NL 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-175


			     1			ENDIF 
 F678  E8 F6FC R             1		CALL	POST_END_COL_NL 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Display LPT ports 
				; 
					POST_COL_1	POST_LPT, POST_CLR_VAL2	; display 'LPT' in column 1 
			     1			ENDIF 
			     1			ELSE 
 F67B  B3 0E                 1		MOV	BL, LOW POST_CLR_VAL2		; BL = attribute 
			     1			ENDIF 
 F67D  BE E489 R             1		MOV	SI, OFFSET POST_LPT 
 F680  E8 F6C3 R             1		CALL	POST_START_COL_1 
			     1			ENDIF 
					GET_EFLAG   LPT				; AX = number of LPT ports 
			     1				ENDIF 
			     1	;----------------------------------------------------------------------------; 
			     1	; Shift if flag is in high byte to low for byte operations 
			     1	; 
			     1				ELSE				; is in high byte 
 = 00C0                      1	??002D	= HIGH MASK LPT 
 = 0006                      1	??002E	= (LPT - 8) AND 0111B 
 = 0011                      1	??002F	= EQUIP_FLAGS[1]			; high BDA flags byte 
			     1				ENDIF 
 F683  A0 0011 R             1		MOV	AL, BYTE PTR ??002F		; AL = equipment flag byte 
 F686  25 00C0               1		AND	AX, ??002D			; isolate bits, clear AH 
			     1	;----------------------------------------------------------------------------; 
			     1	; Determine optimal number of shifts based on bit position and shift 
			     1	; right or left depending on fewest. 
			     1	; 
			     1				ELSE 
			     1					IF ??002E GT 4	; optimal to roll left 
 = 0002                      1						??002E = 8-??002E 
			     1						ELSE		; 0-2 shifts use single op(s) 
			     1							REPT ??002E 
			     1		ROL	AL, 1					; shift value into position 
			     1							ENDM 
 F689  D0 C0                 2		ROL	AL, 1					; shift value into position 
 F68B  D0 C0                 2		ROL	AL, 1					; shift value into position 
			     1						ENDIF 
			     1					ENDIF 
			     1				ENDIF 
			     1				ENDIF 
 F68D  91				XCHG	AX, CX				; CX = number of ports 
 F68E  BE 0008 R			MOV	SI, OFFSET LPT_ADDR 
 F691  E8 F6A7 R			CALL	SHOW_PORT_COUNT 
				 
				;----------------------------------------------------------------------------; 
				; Display COM ports 
				; 
					POST_COL_2	POST_COM, POST_CLR_VAL2	; display 'COM' in column 2 
			     1			ENDIF 
			     1			ELSE 
 F694  B3 0E                 1		MOV	BL, LOW POST_CLR_VAL2		; BL = attribute 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-176


			     1			ENDIF 
 F696  BE E48D R             1		MOV	SI, OFFSET POST_COM 
 F699  E8 F6EA R             1		CALL	POST_START_COL_2 
			     1			ENDIF 
					GET_EFLAG   COM				; AX = number of COM ports 
			     1				ENDIF 
			     1	;----------------------------------------------------------------------------; 
			     1	; Shift if flag is in high byte to low for byte operations 
			     1	; 
			     1				ELSE				; is in high byte 
 = 000E                      1	??0030	= HIGH MASK COM 
 = 0001                      1	??0031	= (COM - 8) AND 0111B 
 = 0011                      1	??0032	= EQUIP_FLAGS[1]			; high BDA flags byte 
			     1				ENDIF 
 F69C  A0 0011 R             1		MOV	AL, BYTE PTR ??0032		; AL = equipment flag byte 
 F69F  25 000E               1		AND	AX, ??0030			; isolate bits, clear AH 
			     1	;----------------------------------------------------------------------------; 
			     1	; Determine optimal number of shifts based on bit position and shift 
			     1	; right or left depending on fewest. 
			     1	; 
			     1				ELSE 
			     1					ELSE			; optimal to roll right 
			     1						ELSE 
			     1							REPT ??0031 
			     1		ROR	AL, 1					; shift value into position 
			     1							ENDM 
 F6A2  D0 C8                 2		ROR	AL, 1					; shift value into position 
			     1						ENDIF 
			     1					ENDIF 
			     1				ENDIF 
			     1				ENDIF 
 F6A4  91				XCHG	AX, CX				; CX = number of ports 
 F6A5  33 F6				XOR	SI, SI				; OFFSET COM_ADDR = 0000H 
				 
				;----------------------------------------------------------------------------; 
				; Display I/O addresses of COM or LPT ports on POST 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	SI = WORD array of ports 
				;	CX = number of ports to show 
				;----------------------------------------------------------------------------; 
 F6A7				SHOW_PORT_COUNT PROC 
 F6A7  E3 0E				JCXZ	PORT_COUNT_NONE			; if no ports, display 'None' 
 F6A9				PORT_COUNT_LOOP: 
 F6A9  AD				LODSW	 
 F6AA  E8 F779 R			CALL	WORD_HEX				; display I/O address in hex 
 F6AD  E8 F74E R			CALL	SPACE					; separate ports with space 
 F6B0  E2 F7				LOOP	PORT_COUNT_LOOP 
 F6B2  BE E49E R			MOV	SI, OFFSET POST_RSEP[1]		; skip leading space in right sep. 
 F6B5  EB 4D				JMP	SHORT POST_END_COL_STR		; display end with sep. in SI and RET 
 F6B7				PORT_COUNT_NONE: 
					PRINT_SZ  POST_NONE			; display 'None' 
			     1			ENDIF 
			     1			IFDIFI <POST_NONE>,<SI>			; if SZ is not SI 
 F6B7  BE FF4C R             1		MOV	SI, OFFSET POST_NONE 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-177


			     1			ENDIF 
 F6BA  E8 F71C R             1		CALL	OUT_SZ 
			     1			ENDIF 
 F6BD  EB 42				JMP	SHORT POST_END_COL		; display end sep and RET 
 F6BF				SHOW_PORT_COUNT ENDP 
				 
 F6BF				POST_SYS_CONFIG ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Write POST column label and start separator  
				;----------------------------------------------------------------------------; 
				; - Start new line 
				; - display column name in color 1 
				; - display left separator in color 1 
				; - set color for inner text to be color 2 
				;----------------------------------------------------------------------------; 
				; Input: 
				; - SI: column name string 
				; - BL: inner text color/attribute 
				; 
				; Output: 
				; - SI: beginning of next adjacent string 
				; - CX: inner text color length = POST_TAB_COL_I 
				;----------------------------------------------------------------------------; 
 F6BF				POST_COL PROC 
				 
				;----------------------------------------------------------------------------; 
				; Handle 40 column mode - move to next line and fall through to col 1 
				; 
 F6BF				POST_START_COL_2_40: 
 F6BF  E8 F745 R			CALL	CRLF				; move to next line 
 F6C2  58				POP	AX				; rebalance stack 
 F6C3				POST_START_COL_1 PROC 
 F6C3  50				PUSH	AX 
 F6C4  B0 06				MOV	AL, POST_COL_W		; column 1 tab width 
 F6C6				POST_START_COL_START: 
 F6C6  53				PUSH	BX				; save inner text color 
 F6C7  8A E3				MOV	AH, BL			; save text color 
 F6C9  B9 0009				MOV	CX, POST_COL_VT		; set attribute on next CX # of chars 
 F6CC  BB 0003				MOV	BX, LOW POST_CLR_TXT	; set outer text color 
 F6CF  E8 F70A R			CALL	OUT_SZ_ATTR			; write SI string with attribute 
 F6D2  E8 F72B R			CALL	MOVE_COL			; move cursor to separator column 
 F6D5  56				PUSH	SI				; save end of string 
 F6D6  BE E499 R			MOV	SI, OFFSET POST_LSEP	; write separator string with 
 F6D9  E8 F71C R			CALL	OUT_SZ			;  existing attributes 
 F6DC  8A DC				MOV	BL, AH			; restore text color 
 F6DE  4E				DEC	SI				; [SI] = previous null char 
 F6DF  B1 13				MOV	CL, POST_TAB_COL_I	; CX = repeat times 
 F6E1  51				PUSH	CX				; save for return 
 F6E2  E8 F70A R			CALL	OUT_SZ_ATTR			; set attributes, skip null string 
 F6E5  59				POP	CX				; CX = inner text color length 
 F6E6  5E				POP	SI				; restore string position 
 F6E7  5B				POP	BX				; BL = attribute for next CX chars 
 F6E8  58				POP	AX 
 F6E9  C3				RET 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-178


 F6EA				POST_START_COL_1 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Same as POST_START_COL_1 except starts at column 2 
				;----------------------------------------------------------------------------; 
 F6EA				POST_START_COL_2 PROC 
							ASSUME DS:_BDA 
 F6EA  50				PUSH	AX 
 F6EB  B4 0F				MOV	AH, 0FH			; get video mode 
 F6ED  CD 10				INT	10H				; AL = video mode 
 F6EF  3C 01				CMP	AL, 1				; is 40 column mode? 
 F6F1  7E CC				JLE	POST_START_COL_2_40 
 F6F3  B0 20				MOV	AL, POST_TAB_COL		; move to start of column 2 
 F6F5  E8 F72B R			CALL	MOVE_COL 
 F6F8  B0 26				MOV	AL, POST_TAB_COL+POST_COL_W	; set abs. position for column 2 tab 
 F6FA  EB CA				JMP	POST_START_COL_START 
 F6FC				POST_START_COL_2 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Same as POST_END_COL and displays a CRLF 
				;----------------------------------------------------------------------------; 
 F6FC				POST_END_COL_NL PROC 
 F6FC  E8 F701 R			CALL	POST_END_COL 
 F6FF  EB 44				JMP	SHORT CRLF			; write CRLF and RET 
 F701				POST_END_COL_NL ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Write POST column end separator  
				;----------------------------------------------------------------------------; 
				; Display right separator in color POST_CLR_TXT 
				; Clobbers: BX 
				;----------------------------------------------------------------------------; 
 F701				POST_END_COL PROC 
 F701  BE E49D R			MOV	SI, OFFSET POST_RSEP 
				 
				;----------------------------------------------------------------------------; 
				; POST_END_COL_STR: Write POST column end separator 
				;----------------------------------------------------------------------------; 
				; Input: CS:SI 
				;----------------------------------------------------------------------------; 
 F704				POST_END_COL_STR PROC 
 F704  B9 0002				MOV	CX, 2 
 F707  BB 0003				MOV	BX, LOW POST_CLR_TXT	; Fall through to OUT_SZ_ATTR and RET 
				 
				;----------------------------------------------------------------------------; 
				; Write a zero-terminated string to console with attributes, no cursor move 
				;----------------------------------------------------------------------------; 
				; Sets attribute in BL for the next CX number of characters, past end of string. 
				; 
				; Input: CS:SI = String, CX = length, BL = attribute, BH = video page 
				; Output: SI = end of string 
				;----------------------------------------------------------------------------; 
 F70A				OUT_SZ_ATTR PROC 
							IF POST_THEME NE 0	; enable color/attribute display 
 F70A  50				PUSH	AX 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-179


				 
							IF MDA_ATTR LT 2	; filter MDA attributes 
				;----------------------------------------------------------------------------; 
				; Filter MDA attributes - display with intensity attribute only 
				; 
 F70B				MDA_COLOR_FIX: 
 F70B  E8 F085 R			CALL	INT_10_IS_TXT		; CF if MDA 
 F70E  73 06				JNC	OUT_SZ_ATTR_SET		; skip if not MDA 
							IF MDA_ATTR EQ 1	; only intensity 
 F710  80 E3 0F				AND	BL, MASK MDIN OR MASK MDFG ; remove MDA blink and background attr 
 F713  80 CB 07				OR	BL, MASK MDFG		; remove MDA underline attr 
							ENDIF 
							ENDIF 
 F716				OUT_SZ_ATTR_SET: 
 F716  B8 0920				MOV	AX, DBW <9, VID_SP>	; write empty char with attr CX # of times 
 F719  CD 10				INT	10H 
 F71B  58				POP	AX				; Fall through to OUT_SZ and RET 
							ENDIF			; POST_THEME NE 0 
				 
				;----------------------------------------------------------------------------; 
				; Display a zero-terminated string in BIOS at CS:[SI] 
				;----------------------------------------------------------------------------; 
				; Input: CS:SI = String, BH = video page 
				; Size: 24 bytes 
				;----------------------------------------------------------------------------; 
 F71C				OUT_SZ PROC 
 F71C  50				PUSH	AX 
 F71D  B4 0E				MOV	AH, 0EH			; TTY output 
 F71F				OUT_SZ_LOOP: 
 F71F  2E: AC				LODS	BYTE PTR CS:[SI]		; AL = CS:[SI++] 
 F721  84 C0				TEST	AL, AL			; is zero terminator? 
 F723  74 04				JZ	OUT_SZ_DONE			; if so, exit 
 F725  CD 10				INT	10H 
 F727  EB F6				JMP	SHORT OUT_SZ_LOOP 
 F729				OUT_SZ_DONE: 
 F729  58				POP	AX 
 F72A  C3				RET 
 F72B				OUT_SZ ENDP 
 F72B				OUT_SZ_ATTR ENDP 
 F72B				POST_END_COL_STR ENDP 
 F72B				POST_END_COL ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Locate cursor to column on current line 
				;----------------------------------------------------------------------------; 
				; Input: 
				; - AL = new col 
				; 
				; Size: 23 bytes 
				;----------------------------------------------------------------------------; 
 F72B				MOVE_COL PROC 
							ELSE 
					PUSHX	AX, BX, CX, DX		; must preserve all of these 
			     1				IFNB <AX>			; exit if last reg 
 F72B  50                    1		PUSH	AX 					; push register and repeat 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-180


			     1		PUSHX	BX, CX, DX, , , ,  
			     2				IFNB <BX>			; exit if last reg 
 F72C  53                    2		PUSH	BX 					; push register and repeat 
			     2		PUSHX	CX, DX, , , , ,  
			     3				IFNB <CX>			; exit if last reg 
 F72D  51                    3		PUSH	CX 					; push register and repeat 
			     3		PUSHX	DX, , , , , ,  
			     4				IFNB <DX>			; exit if last reg 
 F72E  52                    4		PUSH	DX 					; push register and repeat 
			     4		PUSHX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
							ENDIF 
 F72F  50				PUSH	AX				; preserve AL on INT 10H call 
 F730  B7 00				MOV	BH, 0 			; video page 0 (flags preserved) 
 F732  B4 03				MOV	AH, 3 			; get cursor position 
 F734  CD 10				INT	10H 				; DH = row, DL = column 
 F736  58				POP	AX 
 F737				MOVE_COL_SET: 
 F737  8A D0				MOV	DL, AL			; set new column 
 F739  B4 02				MOV	AH, 2 			; set cursor position 
 F73B  CD 10				INT	10H 				; row = DH, column = DL 
							ELSE 
					POPX	DX, CX, BX, AX 
			     1				IFNB <DX>			; exit if last reg 
 F73D  5A                    1		POP	DX 					; pop register and repeat 
			     1		POPX	CX, BX, AX, , , ,  
			     2				IFNB <CX>			; exit if last reg 
 F73E  59                    2		POP	CX 					; pop register and repeat 
			     2		POPX	BX, AX, , , , ,  
			     3				IFNB <BX>			; exit if last reg 
 F73F  5B                    3		POP	BX 					; pop register and repeat 
			     3		POPX	AX, , , , , ,  
			     4				IFNB <AX>			; exit if last reg 
 F740  58                    4		POP	AX 					; pop register and repeat 
			     4		POPX	, , , , , ,  
			     5				ENDIF 
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
							ENDIF 
 F741  C3				RET 
 F742				MOVE_COL ENDP 
 F742				POST_COL ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Display a zero-terminated string in BIOS at CS:[SI] with ending NL 
				;----------------------------------------------------------------------------; 
				; Input: CS:SI = String 
				; Size: 12 bytes 
				;----------------------------------------------------------------------------; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-181


 F742				OUTLN_SZ PROC 
 F742  E8 F71C R			CALL	OUT_SZ			; write original string in SI 
										; fall through to CRLF 
				 
				;----------------------------------------------------------------------------; 
				; Write a CRLF string to console 
				;----------------------------------------------------------------------------; 
 F745				CRLF PROC 
					PRINT_SZ  NL_Z, 1 
			     1			IFNB	<1> 
 F745  56                    1		PUSH	SI					; save SI 
			     1			ENDIF 
			     1			IFDIFI <NL_Z>,<SI>			; if SZ is not SI 
 F746  BE E428 R             1		MOV	SI, OFFSET NL_Z 
			     1			ENDIF 
 F749  E8 F71C R             1		CALL	OUT_SZ 
			     1			IFNB	<1> 
 F74C  5E                    1		POP	SI 
			     1			ENDIF 
 F74D  C3				RET 
 F74E				CRLF ENDP 
				 
 F74E				OUTLN_SZ ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Write a space char to console (8 bytes) 
				;----------------------------------------------------------------------------; 
 F74E				SPACE PROC 
 F74E  50				PUSH	AX				; no clobbery AX 
 F74F  B8 0E20				MOV	AX, DBW <0EH, ' '>	; AH = 0Eh, AL = space char 
 F752  CD 10				INT	10H				; send to console 
 F754  58				POP	AX 
 F755  C3				RET 
 F756				SPACE ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Write Unsigned word as decimal to console 
				;----------------------------------------------------------------------------; 
				; Input: AX value 
				; Clobbers: AX, BX 
				; Size: 23 bytes 
				;----------------------------------------------------------------------------; 
 F756				OUT_DECU PROC 
 F756  BB 000A				MOV	BX, 10			; decimal divisor = 10 
 F759				OUT_DECU_R: 
 F759  52				PUSH	DX				; save remainder digit / caller DX 
 F75A  33 D2				XOR	DX, DX 			; clear high word of dividend 
 F75C  F7 F3				DIV	BX				; AX = DX:AX / 10, DX = DX:AX % 10 
 F75E  85 C0				TEST	AX, AX			; is zero? 
 F760  74 03				JZ	OUT_DECU_DONE		; loop while AX > 0 
 F762  E8 F759 R			CALL	OUT_DECU_R			; recursive call to next division 
 F765				OUT_DECU_DONE: 
 F765  92				XCHG	AX, DX			; AL = digit, AH = 0 
 F766  35 0E30				XOR	AX, DBW <0EH, '0'>	; ASCII convert digit, AH = 0EH 
 F769  CD 10				INT	10H				; write to console 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-182


 F76B  5A				POP	DX				; restore digit 
 F76C  C3				RET 
 F76D				OUT_DECU ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Write DWORD BX:AX as HEX to console 
				;----------------------------------------------------------------------------; 
				; Input: BX:AX - 32 bit value to write 
				; WORDS are separated by a colon ex: 1234:ABCD 
				; 
				; AX clobbered 
				; Size: 50 bytes 
				;----------------------------------------------------------------------------; 
 F76D				DWORD_HEX PROC 
 F76D  50				PUSH	AX 				; save AX 
 F76E  8B C3				MOV	AX, BX 
 F770  E8 F779 R			CALL	WORD_HEX 			; write AX to console as HEX 
 F773  B0 3A				MOV	AL, ':' 
 F775  E8 F794 R			CALL	OUT_CHAR			; Write char in AL to console 
 F778  58				POP	AX 				; restore AX 
				 
				;-------------------------------------------------------------------------- 
				; Write WORD AX as HEX to console 
				;-------------------------------------------------------------------------- 
 F779				WORD_HEX PROC 
 F779  50				PUSH	AX 				; save AX 
 F77A  8A C4				MOV	AL, AH 			; move high byte into low byte 
 F77C  E8 F780 R			CALL	BYTE_HEX 			; write byte as HEX to console 
 F77F  58				POP	AX 				; restore AX 
				 
				;-------------------------------------------------------------------------- 
				; Write BYTE AL as HEX to console 
				;-------------------------------------------------------------------------- 
 F780				BYTE_HEX PROC 
 F780  50				PUSH	AX 				; save AL 
							ELSE 
						REPT	4 
					SHR	AL, 1				; shift high nibble to low nibble 
						ENDM 
 F781  D0 E8                 1		SHR	AL, 1				; shift high nibble to low nibble 
 F783  D0 E8                 1		SHR	AL, 1				; shift high nibble to low nibble 
 F785  D0 E8                 1		SHR	AL, 1				; shift high nibble to low nibble 
 F787  D0 E8                 1		SHR	AL, 1				; shift high nibble to low nibble 
							ENDIF 
 F789  E8 F78D R			CALL	NIB_HEX 			; write low nibble of AL as HEX to console 
 F78C  58				POP	AX 				; restore AL 
				 
				;-------------------------------------------------------------------------- 
				; Write low nibble of AL as HEX to console 
				;-------------------------------------------------------------------------- 
 F78D				NIB_HEX PROC 
 F78D  24 0F				AND	AL, 0FH 			; isolate low nibble 
 F78F  3C 0A				CMP	AL, 0AH 			; if < 0Ah, CF=1 and setup a -1 for ASCII 
										;  adjust since 'A'-'9' is 7 (not 6) 
 F791  1C 69				SBB	AL, -('0'+66H+1) 		; BCD bias for ASCII (30h + 66h + CF) 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-183


										;  AF if AL < 0Ah, CF = 1 
										;  if > 9, high_nibble = 0Ah 
										;  if <=9, high_nibble = 09h 
 F793  2F				DAS					; BCD adjust to ASCII 
										;  if low_nibble < 0Ah, low_nibble -= 6 
										;  high_nibble -= 6 
				 
				;-------------------------------------------------------------------------- 
				; Write char in AL to console 
				;-------------------------------------------------------------------------- 
 F794				OUT_CHAR PROC 
 F794  50				PUSH	AX 
 F795  53				PUSH	BX 
 F796  B7 00				MOV	BH, 0				; video page = 0 (preserve flags) 
 F798  B4 0E				MOV	AH, 0EH			; Write AL to screen tty mode 
 F79A  CD 10				INT	10H				; send to console 
 F79C  5B				POP	BX 
 F79D  58				POP	AX 
 F79E  C3				RET 
				 
 F79F				OUT_CHAR ENDP 
 F79F				NIB_HEX ENDP 
 F79F				BYTE_HEX ENDP 
 F79F				WORD_HEX ENDP 
 F79F				DWORD_HEX ENDP 
				 
				; 
				; 31 BYTES HERE 
				; 
				BYTES_HERE	INT_12 
 = 00A2                      1	BYTES_HERE_INT_12 = INT_12-$ 
			     1			IFDEF BYTES_HERE_INT_12 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 12H - Memory Size Determination 
				;----------------------------------------------------------------------------; 
				; Output 
				;	AX = number of contiguous 1k memory blocks found at startup 
				;----------------------------------------------------------------------------; 
 F841						ORG 0F841H 
 F841				INT_12 PROC 
						ASSUME DS:_BDA 
 F841  FB				STI 					; interrupts on 
 F842  1E				PUSH	DS 				; save DS 
 F843  B8 ---- R			MOV	AX, SEG _BDA 
 F846  8E D8				MOV	DS, AX 			; DS = BDA 
 F848  A1 0013 R			MOV	AX, MEM_SZ_KB 		; AX = DS:[MEM_SZ_KB] 
 F84B  1F				POP	DS 
 F84C  CF				IRET 
 F84D				INT_12 ENDP 
				 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-184


				;----------------------------------------------------------------------------; 
				; INT 11H - BIOS Equipment Determination / BIOS Equipment Flags 
				;----------------------------------------------------------------------------; 
				; Output 
				;	AX = data stored at BIOS Data Area location 0040:0010 
				;----------------------------------------------------------------------------; 
 F84D						ORG 0F84DH 
 F84D				INT_11 PROC 
						ASSUME DS:_BDA 
 F84D  FB				STI 					; interrupts on 
 F84E  1E				PUSH	DS 				; save DS 
 F84F  B8 ---- R			MOV	AX, SEG _BDA 
 F852  8E D8				MOV	DS, AX 			; DS = BDA 
 F854  A1 0010 R			MOV	AX, EQUIP_FLAGS 
 F857  1F				POP	DS 
 F858  CF				IRET 
 F859				INT_11 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 15 - System BIOS Services / Cassette 
				;----------------------------------------------------------------------------; 
				;	INT 15,0  Turn cassette motor on 
				;	INT 15,1  Turn cassette motor off 
				;	INT 15,2  Read blocks from cassette 
				;	INT 15,3  Write blocks to cassette 
				; 
				; Output: 
				;	CF = 1, AH = 86H (unsupported/no cassette present) 
				; 
				; https://stanislavs.org/helppc/int_15.html 
				; http://www.ctyme.com/intr/int-15.htm 
				; http://www.techhelpmanual.com/212-int_15h__at_extended_services___apm.html 
				;----------------------------------------------------------------------------; 
 F859						ORG 0F859H 
 F859				INT_15 PROC 
 F859  FB				STI					; return with interrupts enabled 
							ENDIF 
				 
 F85A  B4 86				MOV	AH, 86H 			; return with unsupported function 
 F85C				INT_15_EXIT: 
 F85C  80 FC 01				CMP	AH, 1				; set CF if error (AH > 0) 
 F85F  F5				CMC 
					IRET_F				; IRET with current flags 
 F860  CA 0002               1		RETF	2 
				 
							ENDIF			; ENDIF CASSETTE EQ 1 
 F863				INT_15 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; 
				; Features not included in 5150/Cassette build go below: 
				; 
				;----------------------------------------------------------------------------; 
				 
						ENDIF 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-185


				 
						ENDIF 
				 
						IF POST_OPT_ROM EQ 1 
				;----------------------------------------------------------------------------; 
				; ROM scan loading - display segment, size and checksum error 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AX = BIOS size in bytes 
				;	DI = Option ROM scan end segment 
				;	DL = ROM checksum value 
				; 
				; Clobbers: BX, DX 
				; 
				; Size: 105 bytes 
				;----------------------------------------------------------------------------; 
 F863				ROM_SCAN_POST PROC 
 F863  50				PUSH	AX						; must call-preserve these 
 F864  56				PUSH	SI 
 F865  9C				PUSHF 
				 
				;----------------------------------------------------------------------------; 
				; Ensure this is not scanning a display option ROM - could crash if video 
				; ISR not is installed 
				; 
 F866  81 FF C800			CMP	DI, 0C800H					; is video ROM scan? 
 F86A  76 32				JBE	ROM_SCAN_POST_EXIT			; exit if so 
				 
				;----------------------------------------------------------------------------; 
				; Display ROM column 
				; 
 F86C  50				PUSH	AX						; save ROM size 
					POST_COL_1  S_OPT_ROM, POST_CLR_VAL2	; start ROM column label 
			     1			ENDIF 
			     1			ELSE 
 F86D  B3 0E                 1		MOV	BL, LOW POST_CLR_VAL2		; BL = attribute 
			     1			ENDIF 
 F86F  BE F8B7 R             1		MOV	SI, OFFSET S_OPT_ROM 
 F872  E8 F6C3 R             1		CALL	POST_START_COL_1 
			     1			ENDIF 
 F875  8C D8				MOV	AX, DS					; AX = ROM segment 
 F877  E8 F779 R			CALL	WORD_HEX					; display as hex 
					POST_COL_END					; end column 1 
			     1			ENDIF 
 F87A  E8 F701 R             1		CALL	POST_END_COL 
			     1			ENDIF 
 F87D  58				POP	AX 
				 
				;----------------------------------------------------------------------------; 
				; Display Size or Checksum error column 
				; 
 F87E  9D				POPF							; restore checksum flag 
 F87F  9C				PUSHF							; re-save flag 
 F880  75 20				JNZ	ROM_SCAN_POST_CHK				; jump if checksum error 
 F882  50				PUSH	AX						; save ROM size again 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-186


					POST_COL_2  S_OPT_SIZE, POST_CLR_VAL2	; start 'Size' column 2 
			     1			ENDIF 
			     1			ELSE 
 F883  B3 0E                 1		MOV	BL, LOW POST_CLR_VAL2		; BL = attribute 
			     1			ENDIF 
 F885  BE F8BB R             1		MOV	SI, OFFSET S_OPT_SIZE 
 F888  E8 F6EA R             1		CALL	POST_START_COL_2 
			     1			ENDIF 
 F88B  58				POP	AX 
 F88C  86 E0				XCHG	AH, AL					; convert bytes to KB 
 F88E  D0 E8				SHR	AL, 1 
 F890  D0 E8				SHR	AL, 1 
 F892  E8 F756 R			CALL	OUT_DECU					; write size as decimal 
					PRINT_SZ	S_OPT_K				; display KB unit 
			     1			ENDIF 
			     1			IFDIFI <S_OPT_K>,<SI>			; if SZ is not SI 
 F895  BE F8C8 R             1		MOV	SI, OFFSET S_OPT_K 
			     1			ENDIF 
 F898  E8 F71C R             1		CALL	OUT_SZ 
			     1			ENDIF 
				 
 F89B				ROM_SCAN_POST_DONE: 
					POST_COL_END_NL					; end column 2 
			     1			ENDIF 
 F89B  E8 F6FC R             1		CALL	POST_END_COL_NL 
			     1			ENDIF 
				 
 F89E				ROM_SCAN_POST_EXIT: 
 F89E  9D				POPF							; restore checksum result flag 
 F89F  5E				POP	SI 
 F8A0  58				POP	AX 
 F8A1  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; Display checksum error 
				; 
 F8A2				ROM_SCAN_POST_CHK: 
					POST_COL_2  POST_ERR_ERR, RED			; 'Error' with red text 
			     1			ENDIF 
			     1			ELSE 
 F8A2  B3 0C                 1		MOV	BL, LOW RED		; BL = attribute 
			     1			ENDIF 
 F8A4  BE E8FF R             1		MOV	SI, OFFSET POST_ERR_ERR 
 F8A7  E8 F6EA R             1		CALL	POST_START_COL_2 
			     1			ENDIF 
					PRINT_SZ	S_OPT_CHK				; display 'Checksum' message 
			     1			ENDIF 
			     1			IFDIFI <S_OPT_CHK>,<SI>			; if SZ is not SI 
 F8AA  BE F8C0 R             1		MOV	SI, OFFSET S_OPT_CHK 
			     1			ENDIF 
 F8AD  E8 F71C R             1		CALL	OUT_SZ 
			     1			ENDIF 
 F8B0  8A C2				MOV	AL, DL					; AL = computed checksum 
 F8B2  E8 F780 R			CALL	BYTE_HEX					; write as hex byte 
 F8B5  EB E4				JMP	ROM_SCAN_POST_DONE			; end column and return 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-187


				 
 F8B7  52 4F 4D 00		S_OPT_ROM	DB	'ROM', 0 
 F8BB  53 69 7A 65 00		S_OPT_SIZE	DB	'Size', 0 
 F8C0  43 68 6B 73 75 6D 20	S_OPT_CHK	DB	'Chksum ', 0			; Checksum 
       00			
 F8C8  20 4B 42 00		S_OPT_K	DB	' ', POST_K_UNIT, 0 
				 
 F8CC				ROM_SCAN_POST ENDP 
						ENDIF 
				 
						IF LIGHT_PEN EQ 1 
				;----------------------------------------------------------------------------; 
				; INT 10,4 - Read Light Pen Position 
				;----------------------------------------------------------------------------; 
				; Return: 
				;	AH = 0 light pen switch not triggered 
				;	   = 1 light pen triggered 
				;	BX = pixel column (0-319 or 0-639, mode dependent) 
				;	CH = raster line (0-199) (CGA and EGA modes 4, 5 and 6) 
				;	CX = raster line (EGA modes except 4, 5 and 6) 
				;	DH = row (0-24) 
				;	DL = column (0-79 or 0-79 mode dependent) 
				; 
				; Size: 128 bytes 
				; 
				; Thx to @Raffzahn for "clean room" specs. 
				;----------------------------------------------------------------------------; 
				; https://nerdlypleasures.blogspot.com/2016/05/ibms-cga-hardware-explained.html 
				; https://www.reenigne.org/blog/cga-reading-the-current-beam-position-with-the-lightpen-latch/ 
				; https://scalibq.wordpress.com/2015/04/19/8088-mph-sprites-where-were-going-we-dont-need-sprites/ 
				;----------------------------------------------------------------------------; 
 F8CC				INT_10_4 PROC 
 F8CC  8B FA				MOV	DI, DX			; save caller DX 
 F8CE  8B 16 0063 R			MOV	DX, VID_PORT		; 6845 I/O port address (3x4h) 
 F8D2  83 C2 06				ADD	DX, CGA_STAT-CGA_IDX	; DX = 3xAh status port 
 F8D5  EC				IN	AL, DX			; read Status Register 
 F8D6  32 E4				XOR	AH, AH			; AH = 0 (switch not triggered) 
 F8D8  A8 04				TEST	AL, MASK VSPE		; light pen on? (/0100b) (0=on, 1=off) 
 F8DA  75 4A				JNZ	INT_10_4_RESET		; if light pen off, reset latch and exit 
 F8DC  A8 02				TEST	AL, MASK VSPT		; light pen trigger set? (0010b) (0=not set, 1=set) 
 F8DE  74 4A				JZ	INT_10_4_EXIT		; if not set, just exit 
				 
				;----------------------------------------------------------------------------; 
				; Trigger is set, read light pen word from 6845. Address Register is latched 
				; into light pen register when LPSTB pulses high. 
				; 
 F8E0  83 EA 06				SUB	DX, CGA_STAT-CGA_IDX	; DX = 3x4h index port 
 F8E3  B0 10				MOV	AL, 10h			; light pen index (MSB) 
 F8E5  EE				OUT	DX, AL			; select index 
 F8E6  42				INC	DX				; DX = 3x5h data port 
 F8E7  EC				IN	AL, DX			; read MSB 
 F8E8  8A E0				MOV	AH, AL			; save MSB 
 F8EA  4A				DEC	DX				; DX = 3x4h index port 
 F8EB  B0 11				MOV	AL, 11h			; light pen index (LSB) 
 F8ED  EE				OUT	DX, AL			; select index 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-188


 F8EE  42				INC	DX				; DX = 3x5h data port 
 F8EF  EC				IN	AL, DX			; read LSB 
				 
				;----------------------------------------------------------------------------; 
				; Calculate screen location from latched address. Address needs a 
				; "calibration factor" applied due to "slow light pen response". 
				; 
				; -3: 0,1,4,5,6 (CGA low-res text/gfx) 
				; -5: 2,3 (CGA hi-res text) 
				; -4: 7 (MDA text) 
				; 
 F8F0  8B 1E 004E R			MOV	BX, VID_SEG			; BX = start offset of video memory 
 F8F4  D1 EB				SHR	BX, 1				; byte align index 
 F8F6  83 C3 03				ADD	BX, 3				; BX = minimum calibration factor 
 F8F9  91				XCHG	AX, CX			; save AX 
 F8FA  E8 F085 R			CALL	INT_10_IS_TXT		; ZF=1 if text, ZF=0 if gfx, CF=1 if MDA 
 F8FD  9F				LAHF					; save video type flags for later 
 F8FE  75 08				JNZ	INT_10_4_CAL_2		; skip if modes 4,5,6 
 F900  72 05				JC	INT_10_4_CAL_1		; +1 if MDA mode 7 
 F902  3C 02				CMP	AL, 2				; AL < 2? 
 F904  7C 02				JL	INT_10_4_CAL_2		; skip if modes 0,1 (+0) 
 F906  43				INC	BX				; +1 for modes 2,3 
 F907				INT_10_4_CAL_1: 
 F907  43				INC	BX				; +1 for modes 2,3,7 
 F908				INT_10_4_CAL_2: 
 F908  2B CB				SUB	CX, BX			; CX = calibrated memory regen offset 
 F90A  73 02				JAE	INT_10_4_CAL_DONE		; is result < 0? 
 F90C  33 C9				XOR	CX, CX			; if so, use base offset 0000 
 F90E				INT_10_4_CAL_DONE: 
 F90E  9E				SAHF					; ZF=1 if text, ZF=0 if gfx 
 F90F  91				XCHG	AX, CX			; restore AX, CL = video mode 
 F910  75 1B				JNZ	INT_10_4_GFX		; jump if graphics mode 
				 
				;----------------------------------------------------------------------------; 
				; Calculate output for Text mode 
				; 
				; Input: 
				;	AX = calibrated memory offset 
				; Output: 
				;	BX = pixel column (0-319 or 0-639) 
				;	CH = raster line (0-199) 
				;	DI = (value for DX) DH = row (0-24), DL = column (0-79) 
				;----------------------------------------------------------------------------; 
				; Formula: 
				;	DX = calibrated memory offset (AX) DIV video columns (DH=row, DL=col) 
				;	BX = col (DL) * 8 
				;	CH = row (DH) * 8 
				;----------------------------------------------------------------------------; 
 F912				INT_10_4_TXT: 
 F912  B1 03				MOV	CL, 3				; shift counter 3 (for * 8) 
 F914  F6 36 004A R			DIV	BYTE PTR VID_COLS		; divide value by char/line 
 F918  86 E0				XCHG	AH, AL			; AH = row, AL = col 
 F91A  8B F8				MOV	DI, AX			; DH = row, DL = col 
 F91C  8A EC				MOV	CH, AH			; CH = row 
 F91E  D2 E5				SHL	CH, CL			; CH = raster line (col * 8) 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-189


 F920  98				CBW					; AH = 0, AL = col 
 F921  D3 E0				SHL	AX, CL			; AX = col * 8 
 F923  93				XCHG	AX, BX			; BX = pixel column 
				 
				;----------------------------------------------------------------------------; 
				; DONE: Clear latch and return with AH = 1 
				; 
 F924				INT_10_4_DONE: 
 F924  B4 01				MOV	AH, 1				; light pen triggered 
				 
				;----------------------------------------------------------------------------; 
				; Light pen strobe reset 
				; 
 F926				INT_10_4_RESET: 
 F926  83 C2 06				ADD	DX, CGA_PEN_RST-CGA_DATA	; pen latch register 
 F929  EE				OUT	DX, AL			; reset light pen latch 
				 
 F92A				INT_10_4_EXIT: 
 F92A  8B D7				MOV	DX, DI			; restore/output DX 
 F92C  C3				RET 
				 
				;----------------------------------------------------------------------------; 
				; Calculate output for GFX mode 
				; 
				; Input: 
				;	AX = calibrated memory offset 
				;	CL = video mode 
				; Output: 
				;	BX = pixel column (0-319 or 0-639) 
				;	CH = raster line (0-199) 
				;	DI = (value for DX) DH = row (0-24), DL = column (0-79) 
				;----------------------------------------------------------------------------; 
				; Formula: 
				; 	DX = calibrated memory offset (AX) DIV 40 (DH=row, DL=col) 
				;	CH = row (DH) * 2 
				;	DH = row (DH) / 4 
				;	if ( high res ): 
				; 		DL = col (DL) * 2 
				;	BX = DL * 8 
				; 
				; Note: output registers used as variable names in comments below. 
				;----------------------------------------------------------------------------; 
 F92D				INT_10_4_GFX: 
 F92D  B5 28				MOV	CH, 40			; divide value by 40 
 F92F  F6 F5				DIV	CH				; AL = row, AH = col 
 F931  86 E0				XCHG	AH, AL			; AH = row, AL = col 
 F933  8A EC				MOV	CH, AH			; CH = row (DH) * 2 
 F935  D0 E5				SHL	CH, 1				; adjust for odd/even fields 
				 
				;----------------------------------------------------------------------------; 
				; Multiply column according to graphics mode 
				; 
 F937  80 F9 06				CMP	CL, 6				; is 640x200 mode? 
 F93A  75 02				JNE	INT_10_4_LOW		; if not, jump 
 F93C  D0 E0				SHL	AL, 1				; DL = col (DL) * 2 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-190


 F93E				INT_10_4_LOW: 
 F93E  B1 03				MOV	CL, 3				; shift counter 3 for * 8 
 F940  8B D8				MOV	BX, AX			; BL = DL for pixel column 
 F942  98				CBW					; zero extend BL 
 F943  D3 E0				SHL	AX, CL			; BX = DL * 8 
 F945  93				XCHG	AX, BX			; return as BX 
 F946  49				DEC	CX				; shift counter 2 for / 4 
 F947  D2 EC				SHR	AH, CL			; DH = row / 4 
 F949  97				XCHG	AX, DI			; return as DX 
 F94A  EB D8				JMP	SHORT INT_10_4_DONE	; clear latch and return with AH=1 
 F94C				INT_10_4 ENDP 
						ENDIF 
				 
				; 
				; 79 BYTES HERE / 0 BYTES HERE 5150 
				; 
				BYTES_HERE	GFX_CHARSET 
 = 0122                      1	BYTES_HERE_GFX_CHARSET = GFX_CHARSET-$ 
			     1			IFDEF BYTES_HERE_GFX_CHARSET 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 1F - 8x8 Font bitmaps 
				;----------------------------------------------------------------------------; 
				; Font bitmaps from "VileR", (CC BY-SA 4.0) 
				; https://int10h.org/oldschool-pc-fonts/ 
				;----------------------------------------------------------------------------; 
 FA6E						ORG 0FA6EH 
 FA6E				GFX_CHARSET LABEL BYTE 
							IF OEM_FONT EQ 1 
				;----------------------------------------------------------------------------; 
				; A more OEM style font 
				; 
 FA6E  00 00 00 00 00 00 00		DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H	; 00H 
       00			
 FA76  7E 81 A5 81 BD 99 81		DB	07EH, 081H, 0A5H, 081H, 0BDH, 099H, 081H, 07EH	; 01H 
       7E			
 FA7E  7E FF DB FF C3 E7 FF		DB	07EH, 0FFH, 0DBH, 0FFH, 0C3H, 0E7H, 0FFH, 07EH	; 02H 
       7E			
 FA86  6C FE FE FE 7C 38 10		DB	06CH, 0FEH, 0FEH, 0FEH, 07CH, 038H, 010H, 000H	; 03H 
       00			
 FA8E  10 38 7C FE 7C 38 10		DB	010H, 038H, 07CH, 0FEH, 07CH, 038H, 010H, 000H	; 04H 
       00			
 FA96  38 7C 38 FE FE 7C 38		DB	038H, 07CH, 038H, 0FEH, 0FEH, 07CH, 038H, 07CH	; 05H 
       7C			
 FA9E  10 10 38 7C FE 7C 38		DB	010H, 010H, 038H, 07CH, 0FEH, 07CH, 038H, 07CH	; 06H 
       7C			
 FAA6  00 00 18 3C 3C 18 00		DB	000H, 000H, 018H, 03CH, 03CH, 018H, 000H, 000H	; 07H 
       00			
 FAAE  FF FF E7 C3 C3 E7 FF		DB	0FFH, 0FFH, 0E7H, 0C3H, 0C3H, 0E7H, 0FFH, 0FFH	; 08H 
       FF			
 FAB6  00 3C 66 42 42 66 3C		DB	000H, 03CH, 066H, 042H, 042H, 066H, 03CH, 000H	; 09H 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-191


       00			
 FABE  FF C3 99 BD BD 99 C3		DB	0FFH, 0C3H, 099H, 0BDH, 0BDH, 099H, 0C3H, 0FFH	; 0AH 
       FF			
 FAC6  0F 07 0F 7D CC CC CC		DB	00FH, 007H, 00FH, 07DH, 0CCH, 0CCH, 0CCH, 078H	; 0BH 
       78			
 FACE  3C 66 66 66 3C 18 7E		DB	03CH, 066H, 066H, 066H, 03CH, 018H, 07EH, 018H	; 0CH 
       18			
 FAD6  3F 33 3F 30 30 70 F0		DB	03FH, 033H, 03FH, 030H, 030H, 070H, 0F0H, 0E0H	; 0DH 
       E0			
 FADE  7F 63 7F 63 63 67 E6		DB	07FH, 063H, 07FH, 063H, 063H, 067H, 0E6H, 0C0H	; 0EH 
       C0			
 FAE6  99 5A 3C E7 E7 3C 5A		DB	099H, 05AH, 03CH, 0E7H, 0E7H, 03CH, 05AH, 099H	; 0FH 
       99			
 FAEE  80 E0 F8 FE F8 E0 80		DB	080H, 0E0H, 0F8H, 0FEH, 0F8H, 0E0H, 080H, 000H	; 10H 
       00			
 FAF6  02 0E 3E FE 3E 0E 02		DB	002H, 00EH, 03EH, 0FEH, 03EH, 00EH, 002H, 000H	; 11H 
       00			
 FAFE  18 3C 7E 18 18 7E 3C		DB	018H, 03CH, 07EH, 018H, 018H, 07EH, 03CH, 018H	; 12H 
       18			
 FB06  66 66 66 66 66 00 66		DB	066H, 066H, 066H, 066H, 066H, 000H, 066H, 000H	; 13H 
       00			
 FB0E  7F DB DB 7B 1B 1B 1B		DB	07FH, 0DBH, 0DBH, 07BH, 01BH, 01BH, 01BH, 000H	; 14H 
       00			
 FB16  3E 63 38 6C 6C 38 CC		DB	03EH, 063H, 038H, 06CH, 06CH, 038H, 0CCH, 078H	; 15H 
       78			
 FB1E  00 00 00 00 7E 7E 7E		DB	000H, 000H, 000H, 000H, 07EH, 07EH, 07EH, 000H	; 16H 
       00			
 FB26  18 3C 7E 18 7E 3C 18		DB	018H, 03CH, 07EH, 018H, 07EH, 03CH, 018H, 0FFH	; 17H 
       FF			
 FB2E  18 3C 7E 18 18 18 18		DB	018H, 03CH, 07EH, 018H, 018H, 018H, 018H, 000H	; 18H 
       00			
 FB36  18 18 18 18 7E 3C 18		DB	018H, 018H, 018H, 018H, 07EH, 03CH, 018H, 000H	; 19H 
       00			
 FB3E  00 18 0C FE 0C 18 00		DB	000H, 018H, 00CH, 0FEH, 00CH, 018H, 000H, 000H	; 1AH 
       00			
 FB46  00 30 60 FE 60 30 00		DB	000H, 030H, 060H, 0FEH, 060H, 030H, 000H, 000H	; 1BH 
       00			
 FB4E  00 00 C0 C0 C0 FE 00		DB	000H, 000H, 0C0H, 0C0H, 0C0H, 0FEH, 000H, 000H	; 1CH 
       00			
 FB56  00 24 66 FF 66 24 00		DB	000H, 024H, 066H, 0FFH, 066H, 024H, 000H, 000H	; 1DH 
       00			
 FB5E  00 18 3C 7E FF FF 00		DB	000H, 018H, 03CH, 07EH, 0FFH, 0FFH, 000H, 000H	; 1EH 
       00			
 FB66  00 FF FF 7E 3C 18 00		DB	000H, 0FFH, 0FFH, 07EH, 03CH, 018H, 000H, 000H	; 1FH 
       00			
 FB6E  00 00 00 00 00 00 00		DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H	; 20H   
       00			
 FB76  30 78 78 30 30 00 30		DB	030H, 078H, 078H, 030H, 030H, 000H, 030H, 000H	; 21H ! 
       00			
 FB7E  6C 6C 6C 00 00 00 00		DB	06CH, 06CH, 06CH, 000H, 000H, 000H, 000H, 000H	; 22H " 
       00			
 FB86  6C 6C FE 6C FE 6C 6C		DB	06CH, 06CH, 0FEH, 06CH, 0FEH, 06CH, 06CH, 000H	; 23H # 
       00			
 FB8E  30 7C C0 78 0C F8 30		DB	030H, 07CH, 0C0H, 078H, 00CH, 0F8H, 030H, 000H	; 24H $ 
       00			
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-192


 FB96  00 C6 CC 18 30 66 C6		DB	000H, 0C6H, 0CCH, 018H, 030H, 066H, 0C6H, 000H	; 25H % 
       00			
 FB9E  38 6C 38 76 DC CC 76		DB	038H, 06CH, 038H, 076H, 0DCH, 0CCH, 076H, 000H	; 26H & 
       00			
 FBA6  60 60 C0 00 00 00 00		DB	060H, 060H, 0C0H, 000H, 000H, 000H, 000H, 000H	; 27H ' 
       00			
 FBAE  18 30 60 60 60 30 18		DB	018H, 030H, 060H, 060H, 060H, 030H, 018H, 000H	; 28H ( 
       00			
 FBB6  60 30 18 18 18 30 60		DB	060H, 030H, 018H, 018H, 018H, 030H, 060H, 000H	; 29H ) 
       00			
 FBBE  00 66 3C FF 3C 66 00		DB	000H, 066H, 03CH, 0FFH, 03CH, 066H, 000H, 000H	; 2AH * 
       00			
 FBC6  00 30 30 FC 30 30 00		DB	000H, 030H, 030H, 0FCH, 030H, 030H, 000H, 000H	; 2BH + 
       00			
 FBCE  00 00 00 00 00 30 30		DB	000H, 000H, 000H, 000H, 000H, 030H, 030H, 060H	; 2CH , 
       60			
 FBD6  00 00 00 FC 00 00 00		DB	000H, 000H, 000H, 0FCH, 000H, 000H, 000H, 000H	; 2DH - 
       00			
 FBDE  00 00 00 00 00 30 30		DB	000H, 000H, 000H, 000H, 000H, 030H, 030H, 000H	; 2EH . 
       00			
 FBE6  06 0C 18 30 60 C0 80		DB	006H, 00CH, 018H, 030H, 060H, 0C0H, 080H, 000H	; 2FH / 
       00			
 FBEE  7C C6 CE DE F6 E6 7C		DB	07CH, 0C6H, 0CEH, 0DEH, 0F6H, 0E6H, 07CH, 000H	; 30H 0 
       00			
 FBF6  30 70 30 30 30 30 FC		DB	030H, 070H, 030H, 030H, 030H, 030H, 0FCH, 000H	; 31H 1 
       00			
 FBFE  78 CC 0C 38 60 CC FC		DB	078H, 0CCH, 00CH, 038H, 060H, 0CCH, 0FCH, 000H	; 32H 2 
       00			
 FC06  78 CC 0C 38 0C CC 78		DB	078H, 0CCH, 00CH, 038H, 00CH, 0CCH, 078H, 000H	; 33H 3 
       00			
 FC0E  1C 3C 6C CC FE 0C 1E		DB	01CH, 03CH, 06CH, 0CCH, 0FEH, 00CH, 01EH, 000H	; 34H 4 
       00			
 FC16  FC C0 F8 0C 0C CC 78		DB	0FCH, 0C0H, 0F8H, 00CH, 00CH, 0CCH, 078H, 000H	; 35H 5 
       00			
 FC1E  38 60 C0 F8 CC CC 78		DB	038H, 060H, 0C0H, 0F8H, 0CCH, 0CCH, 078H, 000H	; 36H 6 
       00			
 FC26  FC CC 0C 18 30 30 30		DB	0FCH, 0CCH, 00CH, 018H, 030H, 030H, 030H, 000H	; 37H 7 
       00			
 FC2E  78 CC CC 78 CC CC 78		DB	078H, 0CCH, 0CCH, 078H, 0CCH, 0CCH, 078H, 000H	; 38H 8 
       00			
 FC36  78 CC CC 7C 0C 18 70		DB	078H, 0CCH, 0CCH, 07CH, 00CH, 018H, 070H, 000H	; 39H 9 
       00			
 FC3E  00 30 30 00 00 30 30		DB	000H, 030H, 030H, 000H, 000H, 030H, 030H, 000H	; 3AH : 
       00			
 FC46  00 30 30 00 00 30 30		DB	000H, 030H, 030H, 000H, 000H, 030H, 030H, 060H	; 3BH ; 
       60			
 FC4E  18 30 60 C0 60 30 18		DB	018H, 030H, 060H, 0C0H, 060H, 030H, 018H, 000H	; 3CH < 
       00			
 FC56  00 00 FC 00 00 FC 00		DB	000H, 000H, 0FCH, 000H, 000H, 0FCH, 000H, 000H	; 3DH = 
       00			
 FC5E  60 30 18 0C 18 30 60		DB	060H, 030H, 018H, 00CH, 018H, 030H, 060H, 000H	; 3EH > 
       00			
 FC66  78 CC 0C 18 30 00 30		DB	078H, 0CCH, 00CH, 018H, 030H, 000H, 030H, 000H	; 3FH ? 
       00			
 FC6E  7C C6 DE DE DE C0 78		DB	07CH, 0C6H, 0DEH, 0DEH, 0DEH, 0C0H, 078H, 000H	; 40H @ 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-193


       00			
 FC76  30 78 CC CC FC CC CC		DB	030H, 078H, 0CCH, 0CCH, 0FCH, 0CCH, 0CCH, 000H	; 41H A 
       00			
 FC7E  FC 66 66 7C 66 66 FC		DB	0FCH, 066H, 066H, 07CH, 066H, 066H, 0FCH, 000H	; 42H B 
       00			
 FC86  3C 66 C0 C0 C0 66 3C		DB	03CH, 066H, 0C0H, 0C0H, 0C0H, 066H, 03CH, 000H	; 43H C 
       00			
 FC8E  F8 6C 66 66 66 6C F8		DB	0F8H, 06CH, 066H, 066H, 066H, 06CH, 0F8H, 000H	; 44H D 
       00			
 FC96  FE 62 68 78 68 62 FE		DB	0FEH, 062H, 068H, 078H, 068H, 062H, 0FEH, 000H	; 45H E 
       00			
 FC9E  FE 62 68 78 68 60 F0		DB	0FEH, 062H, 068H, 078H, 068H, 060H, 0F0H, 000H	; 46H F 
       00			
 FCA6  3C 66 C0 C0 CE 66 3E		DB	03CH, 066H, 0C0H, 0C0H, 0CEH, 066H, 03EH, 000H	; 47H G 
       00			
 FCAE  CC CC CC FC CC CC CC		DB	0CCH, 0CCH, 0CCH, 0FCH, 0CCH, 0CCH, 0CCH, 000H	; 48H H 
       00			
 FCB6  78 30 30 30 30 30 78		DB	078H, 030H, 030H, 030H, 030H, 030H, 078H, 000H	; 49H I 
       00			
 FCBE  1E 0C 0C 0C CC CC 78		DB	01EH, 00CH, 00CH, 00CH, 0CCH, 0CCH, 078H, 000H	; 4AH J 
       00			
 FCC6  E6 66 6C 78 6C 66 E6		DB	0E6H, 066H, 06CH, 078H, 06CH, 066H, 0E6H, 000H	; 4BH K 
       00			
 FCCE  F0 60 60 60 62 66 FE		DB	0F0H, 060H, 060H, 060H, 062H, 066H, 0FEH, 000H	; 4CH L 
       00			
 FCD6  C6 EE FE FE D6 C6 C6		DB	0C6H, 0EEH, 0FEH, 0FEH, 0D6H, 0C6H, 0C6H, 000H	; 4DH M 
       00			
 FCDE  C6 E6 F6 DE CE C6 C6		DB	0C6H, 0E6H, 0F6H, 0DEH, 0CEH, 0C6H, 0C6H, 000H	; 4EH N 
       00			
 FCE6  38 6C C6 C6 C6 6C 38		DB	038H, 06CH, 0C6H, 0C6H, 0C6H, 06CH, 038H, 000H	; 4FH O 
       00			
 FCEE  FC 66 66 7C 60 60 F0		DB	0FCH, 066H, 066H, 07CH, 060H, 060H, 0F0H, 000H	; 50H P 
       00			
 FCF6  78 CC CC CC DC 78 1C		DB	078H, 0CCH, 0CCH, 0CCH, 0DCH, 078H, 01CH, 000H	; 51H Q 
       00			
 FCFE  FC 66 66 7C 6C 66 E6		DB	0FCH, 066H, 066H, 07CH, 06CH, 066H, 0E6H, 000H	; 52H R 
       00			
 FD06  78 CC E0 70 1C CC 78		DB	078H, 0CCH, 0E0H, 070H, 01CH, 0CCH, 078H, 000H	; 53H S 
       00			
 FD0E  FC B4 30 30 30 30 78		DB	0FCH, 0B4H, 030H, 030H, 030H, 030H, 078H, 000H	; 54H T 
       00			
 FD16  CC CC CC CC CC CC FC		DB	0CCH, 0CCH, 0CCH, 0CCH, 0CCH, 0CCH, 0FCH, 000H	; 55H U 
       00			
 FD1E  CC CC CC CC CC 78 30		DB	0CCH, 0CCH, 0CCH, 0CCH, 0CCH, 078H, 030H, 000H	; 56H V 
       00			
 FD26  C6 C6 C6 D6 FE EE C6		DB	0C6H, 0C6H, 0C6H, 0D6H, 0FEH, 0EEH, 0C6H, 000H	; 57H W 
       00			
 FD2E  C6 C6 6C 38 38 6C C6		DB	0C6H, 0C6H, 06CH, 038H, 038H, 06CH, 0C6H, 000H	; 58H X 
       00			
 FD36  CC CC CC 78 30 30 78		DB	0CCH, 0CCH, 0CCH, 078H, 030H, 030H, 078H, 000H	; 59H Y 
       00			
 FD3E  FE C6 8C 18 32 66 FE		DB	0FEH, 0C6H, 08CH, 018H, 032H, 066H, 0FEH, 000H	; 5AH Z 
       00			
 FD46  78 60 60 60 60 60 78		DB	078H, 060H, 060H, 060H, 060H, 060H, 078H, 000H	; 5BH [ 
       00			
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-194


 FD4E  C0 60 30 18 0C 06 02		DB	0C0H, 060H, 030H, 018H, 00CH, 006H, 002H, 000H	; 5CH \ 
       00			
 FD56  78 18 18 18 18 18 78		DB	078H, 018H, 018H, 018H, 018H, 018H, 078H, 000H	; 5DH ] 
       00			
 FD5E  10 38 6C C6 00 00 00		DB	010H, 038H, 06CH, 0C6H, 000H, 000H, 000H, 000H	; 5EH ^ 
       00			
 FD66  00 00 00 00 00 00 00		DB	000H, 000H, 000H, 000H, 000H, 000H, 000H, 0FFH	; 5FH _ 
       FF			
 FD6E  30 30 18 00 00 00 00		DB	030H, 030H, 018H, 000H, 000H, 000H, 000H, 000H	; 60H ` 
       00			
 FD76  00 00 78 0C 7C CC 76		DB	000H, 000H, 078H, 00CH, 07CH, 0CCH, 076H, 000H	; 61H a 
       00			
 FD7E  E0 60 60 7C 66 66 DC		DB	0E0H, 060H, 060H, 07CH, 066H, 066H, 0DCH, 000H	; 62H b 
       00			
 FD86  00 00 78 CC C0 CC 78		DB	000H, 000H, 078H, 0CCH, 0C0H, 0CCH, 078H, 000H	; 63H c 
       00			
 FD8E  1C 0C 0C 7C CC CC 76		DB	01CH, 00CH, 00CH, 07CH, 0CCH, 0CCH, 076H, 000H	; 64H d 
       00			
 FD96  00 00 78 CC FC C0 78		DB	000H, 000H, 078H, 0CCH, 0FCH, 0C0H, 078H, 000H	; 65H e 
       00			
 FD9E  38 6C 60 F0 60 60 F0		DB	038H, 06CH, 060H, 0F0H, 060H, 060H, 0F0H, 000H	; 66H f 
       00			
 FDA6  00 00 76 CC CC 7C 0C		DB	000H, 000H, 076H, 0CCH, 0CCH, 07CH, 00CH, 0F8H	; 67H g 
       F8			
 FDAE  E0 60 6C 76 66 66 E6		DB	0E0H, 060H, 06CH, 076H, 066H, 066H, 0E6H, 000H	; 68H h 
       00			
 FDB6  30 00 70 30 30 30 78		DB	030H, 000H, 070H, 030H, 030H, 030H, 078H, 000H	; 69H i 
       00			
 FDBE  0C 00 0C 0C 0C CC CC		DB	00CH, 000H, 00CH, 00CH, 00CH, 0CCH, 0CCH, 078H	; 6AH j 
       78			
 FDC6  E0 60 66 6C 78 6C E6		DB	0E0H, 060H, 066H, 06CH, 078H, 06CH, 0E6H, 000H	; 6BH k 
       00			
 FDCE  70 30 30 30 30 30 78		DB	070H, 030H, 030H, 030H, 030H, 030H, 078H, 000H	; 6CH l 
       00			
 FDD6  00 00 CC FE FE D6 C6		DB	000H, 000H, 0CCH, 0FEH, 0FEH, 0D6H, 0C6H, 000H	; 6DH m 
       00			
 FDDE  00 00 F8 CC CC CC CC		DB	000H, 000H, 0F8H, 0CCH, 0CCH, 0CCH, 0CCH, 000H	; 6EH n 
       00			
 FDE6  00 00 78 CC CC CC 78		DB	000H, 000H, 078H, 0CCH, 0CCH, 0CCH, 078H, 000H	; 6FH o 
       00			
 FDEE  00 00 DC 66 66 7C 60		DB	000H, 000H, 0DCH, 066H, 066H, 07CH, 060H, 0F0H	; 70H p 
       F0			
 FDF6  00 00 76 CC CC 7C 0C		DB	000H, 000H, 076H, 0CCH, 0CCH, 07CH, 00CH, 01EH	; 71H q 
       1E			
 FDFE  00 00 DC 76 66 60 F0		DB	000H, 000H, 0DCH, 076H, 066H, 060H, 0F0H, 000H	; 72H r 
       00			
 FE06  00 00 7C C0 78 0C F8		DB	000H, 000H, 07CH, 0C0H, 078H, 00CH, 0F8H, 000H	; 73H s 
       00			
 FE0E  10 30 7C 30 30 34 18		DB	010H, 030H, 07CH, 030H, 030H, 034H, 018H, 000H	; 74H t 
       00			
 FE16  00 00 CC CC CC CC 76		DB	000H, 000H, 0CCH, 0CCH, 0CCH, 0CCH, 076H, 000H	; 75H u 
       00			
 FE1E  00 00 CC CC CC 78 30		DB	000H, 000H, 0CCH, 0CCH, 0CCH, 078H, 030H, 000H	; 76H v 
       00			
 FE26  00 00 C6 D6 FE FE 6C		DB	000H, 000H, 0C6H, 0D6H, 0FEH, 0FEH, 06CH, 000H	; 77H w 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-195


       00			
 FE2E  00 00 C6 6C 38 6C C6		DB	000H, 000H, 0C6H, 06CH, 038H, 06CH, 0C6H, 000H	; 78H x 
       00			
 FE36  00 00 CC CC CC 7C 0C		DB	000H, 000H, 0CCH, 0CCH, 0CCH, 07CH, 00CH, 0F8H	; 79H y 
       F8			
 FE3E  00 00 FC 98 30 64 FC		DB	000H, 000H, 0FCH, 098H, 030H, 064H, 0FCH, 000H	; 7AH z 
       00			
 FE46  1C 30 30 E0 30 30 1C		DB	01CH, 030H, 030H, 0E0H, 030H, 030H, 01CH, 000H	; 7BH { 
       00			
 FE4E  18 18 18 00 18 18 18		DB	018H, 018H, 018H, 000H, 018H, 018H, 018H, 000H	; 7CH | 
       00			
 FE56  E0 30 30 1C 30 30 E0		DB	0E0H, 030H, 030H, 01CH, 030H, 030H, 0E0H, 000H	; 7DH } 
       00			
 FE5E  76 DC 00 00 00 00 00		DB	076H, 0DCH, 000H, 000H, 000H, 000H, 000H, 000H	; 7EH ~ 
       00			
 FE66  00 10 38 6C C6 C6 FE		DB	000H, 010H, 038H, 06CH, 0C6H, 0C6H, 0FEH, 000H	; 7FH 
       00			
							ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 1A - System and "Real Time" Clock BIOS Services 
				;----------------------------------------------------------------------------; 
				; INT 1A,0   Read system clock counter 
				; INT 1A,1   Set system clock counter 
				;----------------------------------------------------------------------------; 
 FE6E						ORG 0FE6EH 
 FE6E				INT_1A PROC 
						ASSUME DS:_BDA 
 FE6E  FB				STI						; enable interrupts 
 FE6F  80 EC 01				SUB	AH, 1 				; is function 0 or 1? 
 FE72  77 18				JA	INT_1A_EXIT 			; if not, exit 
 FE74  1E				PUSH	DS 
 FE75  56				PUSH	SI 
 FE76  BE ---- R			MOV	SI, SEG _BDA 			; get BDA segment 
 FE79  8E DE				MOV	DS, SI 				; DS = BDA 
 FE7B  BE 006C R			MOV	SI, OFFSET TIMER			; SI = BIOS Timer 
 FE7E  FA				CLI 						; disable interrupts 
 FE7F  74 0C				JZ	INT_1A_SET 				; AH = 1, jump to Set clock 
											; AH = 0, fall through to Read 
				 
				;----------------------------------------------------------------------------; 
				; INT 1A,0   Read system clock counter 
				;----------------------------------------------------------------------------; 
				; Output: 
				;	AL = midnight flag, 1 if 24 hours passed since reset 
				;	CX = high order word of tick count 
				;	DX = low order word of tick count 
				;----------------------------------------------------------------------------; 
 FE81				INT_1A_READ PROC 
 FE81  FC				CLD						; string direction forward 
 FE82  AD				LODSW 					; AX = low word of timer 
 FE83  92				XCHG	AX, DX 
 FE84  AD				LODSW 					; AX = high word of timer 
 FE85  91				XCHG	AX, CX 
 FE86  33 C0				XOR	AX, AX				; reset midnight flag to 0 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-196


 FE88  86 04				XCHG	AL, [SI]				; AL = BDA flag, BDA = 0 
 FE8A				INT_1A_DONE: 
					;STI 						; re-enable interrupts 
 FE8A  5E				POP	SI 
 FE8B  1F				POP	DS 
 FE8C				INT_1A_EXIT: 
 FE8C  CF				IRET 
 FE8D				INT_1A_READ ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 1A,1   Set system clock counter 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AH = 0 
				;	CX = high order word of tick count 
				;	DX = low order word of tick count 
				;----------------------------------------------------------------------------; 
 FE8D				INT_1A_SET PROC 
 FE8D  89 14				MOV	[SI].LW, DX				; set low word ticks (seconds) 
 FE8F  89 4C 02				MOV	[SI].HW, CX				; set high word ticks (hours) 
 FE92  88 64 04				MOV	[SI].OF, AH				; reset midnight counter (0) 
 FE95  EB F3				JMP	SHORT INT_1A_DONE 
 FE97				INT_1A_SET ENDP 
				 
 FE97				INT_1A ENDP 
				 
 FE97				INT_08_PROC PROC 
				;----------------------------------------------------------------------------; 
				; INT 8 - Floppy Motor shutoff has elapsed - shut off motor 
				;----------------------------------------------------------------------------; 
 FE97				INT_08_MOTOR_OFF: 
 FE97  B0 F0				MOV	AL, NOT MASK FMOT			; BDA motor off on all drives 
 FE99  20 06 003F R			AND	FD_MOTOR_ST, AL			; write to BDA 
 FE9D  34 FC				XOR	AL, NOT MASK FDSEL		; FDC motor off on all drives 
 FE9F  BA 03F2				MOV	DX, FDC_CTRL 			; FD control port 
 FEA2  EE				OUT	DX, AL 				; write to controller 
 FEA3  EB 20				JMP	SHORT INT_08_INT_1C 
				 
				; 
				; 0 BYTES HERE 
				; 
				BYTES_HERE	INT_08 
 = 0000                      1	BYTES_HERE_INT_08 = INT_08-$ 
			     1			IFDEF BYTES_HERE_INT_08 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT 8 - Timer 
				;----------------------------------------------------------------------------; 
				; - Run 18.2 times per second by PIT Timer 
				; - f = 1193182 / 10000H 
				; - Increment 32 bit counter, overflows at 24 hours + 9.67 sec 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-197


				;	( 3600s/h - 65,536t / ( 1,193,182t/s / 65,536t ) ) * 24h = ~9.67s 
				; - Decrement floppy disk motor timeout counter 
				;  	  if reaches 0, turns off motor 
				; - only take jumps on special cases 
				; 
				; IMPORTANT NOTE: ROM BASIC's INT 1CH handler clobbers DX, so DX 
				; MUST be call-preserved here. 
				;----------------------------------------------------------------------------; 
 FEA5						ORG 0FEA5H 
 FEA5				INT_08 PROC 
						ASSUME DS:_BDA 
 FEA5  50				PUSH	AX 					; save AX, DX, DS and DI 
 FEA6  52				PUSH	DX					; workaround ROM BASIC INT 1Ch bug 
 FEA7  1E				PUSH	DS 
 FEA8  57				PUSH	DI 
 FEA9  B8 ---- R			MOV	AX, SEG _BDA 			; DS = BIOS Data Area 
 FEAC  8E D8				MOV	DS, AX 
 FEAE  99				CWD						; DX = 0 
				 
				;----------------------------------------------------------------------------; 
				; Increment Timer 
				; 
 FEAF				INT_08_TICK_TIMER:				; Advance the time ticker 
 FEAF  BF 006C R			MOV	DI, OFFSET TIMER 			; Low timer at BDA 0040:006C 
 FEB2  83 05 01				ADD	[DI].LW, 1				; increment low word 
 FEB5  11 55 02				ADC	[DI].HW, DX				; carry into high word 
 FEB8  83 7D 02 18			CMP	[DI].HW, 24 			; rolled over to next day? 
 FEBC  73 13				JAE	INT_08_TICK_DAY			; if so, check for day rollover 
				 
				;----------------------------------------------------------------------------; 
				; Decrement Floppy Motor shutoff counter 
				; 
 FEBE				INT_08_FD_MOTOR: 					; Check if there is a motor timeout 
 FEBE  FB				STI						; interrupts back on 
 FEBF  FE 0E 0040 R			DEC	FD_MOTOR_CT 			; increment counter, has reached 0? 
 FEC3  74 D2				JZ	INT_08_MOTOR_OFF			; if so, turn off motor 
				 
				;----------------------------------------------------------------------------; 
				; Call INT 1CH user vector 
				; 
 FEC5				INT_08_INT_1C: 
 FEC5  CD 1C				INT	1CH					; call user timer hook 
				 
				;----------------------------------------------------------------------------; 
				; Interrupt Complete - send EOI and return 
				; 
 FEC7				INT_08_EOI: 
 FEC7  FA				CLI						; disable interrupts for EOI 
 FEC8  B0 20				MOV	AL, EOI 				; End of Interrupt OCW 
 FECA  E6 20				OUT	INT_P0, AL				; write EOI to port 0 
 FECC  5F				POP	DI 
 FECD  1F				POP	DS 
 FECE  5A				POP	DX					; restore DX 
 FECF  58				POP	AX 
 FED0  CF				IRET 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-198


				 
				;----------------------------------------------------------------------------; 
				; Check if day has rolled over (24H + 9.67s) and reset 32 bit ticker if so 
				; 
 FED1				INT_08_TICK_DAY: 
 FED1  80 3D B0				CMP	BYTE PTR [DI].LW, 176 		; has day rolled over? 
 FED4  72 E8				JB	INT_08_FD_MOTOR			; if not, handle FD motor timeout 
				 
				;----------------------------------------------------------------------------; 
				; Timer has rolled over 24 hours - reset counters and increment midnight 
				; http://www.ctyme.com/intr/rb-2271.htm 
				; http://www.phatcode.net/res/246/files/pctim003.txt 
				; 
 FED6				INT_08_RESET: 
 FED6  89 15				MOV	[DI].LW, DX				; TIMER low word = 0 
 FED8  89 55 02				MOV	[DI].HW, DX				; TIMER high word = 0 
 FEDB  FE 45 04				INC	[DI].OF				; increment TIMER midnight counter 
 FEDE  EB DE				JMP	INT_08_FD_MOTOR			; continue and check motor 
				 
 FEE0				INT_08 ENDP 
 FEE0				INT_08_PROC ENDP 
				 
				; 
				; 3 BYTES HERE 
				; 
				BYTES_HERE	VECTOR_TABLE 
 = 0003                      1	BYTES_HERE_VECTOR_TABLE = VECTOR_TABLE-$ 
			     1			IFDEF BYTES_HERE_VECTOR_TABLE 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Interrupt Vector Table - These fill the IVT prior to bootstrap 
				;----------------------------------------------------------------------------; 
				; Each ISR is found at the compatibility offset described here: 
				; https://www.intel.com/content/dam/doc/reference-guide/efi-compatibility-support-module-specificati
				on-v097.pdf 
				;----------------------------------------------------------------------------; 
 FEE3						ORG 0FEE3H 
 FEE3				VECTOR_TABLE PROC 
 FEE3  FF23 R				DW  OFFSET INT_IRQ 		; INT 00 
 FEE5  FF23 R				DW  OFFSET INT_IRQ 		; INT 01 
 FEE7  E2C3 R				DW  OFFSET INT_02 		; INT 02	NMI 
 FEE9  FF23 R				DW  OFFSET INT_IRQ 		; INT 03 
 FEEB  FF23 R				DW  OFFSET INT_IRQ 		; INT 04 
 FEED  FF54 R				DW  OFFSET INT_05 		; INT 05	Print Screen 
 FEEF  FF23 R				DW  OFFSET INT_IRQ 		; INT 06 
 FEF1  FF23 R				DW  OFFSET INT_IRQ 		; INT 07 
				 
				;----------------------------------------------------------------------------; 
				; Compatibility fixed ORG for INT 08 - 1Eh 
				; 
 FEF3						ORG 0FEF3H 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-199


 FEF3  FEA5 R				DW  OFFSET INT_08 		; INT 08	IRQ0 System timer 
 FEF5  E937 R				DW  OFFSET INT_09_POST		; INT 09	IRQ1 Keyboard IRQ (during POST) 
 FEF7  FF23 R				DW  OFFSET INT_IRQ		; INT 0A	IRQ2 Reserved 
 FEF9  FF23 R				DW  OFFSET INT_IRQ		; INT 0B	IRQ3 COM2 
 FEFB  FF23 R				DW  OFFSET INT_IRQ		; INT 0C	IRQ4 COM1 
 FEFD  FF23 R				DW  OFFSET INT_IRQ		; INT 0D	IRQ5 XT FDC 
 FEFF  EF57 R				DW  OFFSET INT_0E			; INT 0E	IRQ6 Floppy Controller 
 FF01  FF23 R				DW  OFFSET INT_IRQ		; INT 0F	IRQ7 LPT 
 FF03  F065 R				DW  OFFSET INT_10			; INT 10	Video 
 FF05  F84D R				DW  OFFSET INT_11			; INT 11	Equipment Check 
 FF07  F841 R				DW  OFFSET INT_12			; INT 12	Memory Size 
 FF09  EC59 R				DW  OFFSET INT_13			; INT 13	Floppy Disk 
 FF0B  E739 R				DW  OFFSET INT_14			; INT 14	Serial Port 
 FF0D  F859 R				DW  OFFSET INT_15			; INT 15	System Services 
 FF0F  E82E R				DW  OFFSET INT_16			; INT 16	Keyboard Services 
 FF11  EFD2 R				DW  OFFSET INT_17			; INT 17	Printer 
 FF13  E41B R				DW  OFFSET INT_18 		; INT 18	Unbootable/ROM BASIC 
 FF15  E6F2 R				DW  OFFSET INT_19			; INT 19	Bootstrap 
 FF17  FE6E R				DW  OFFSET INT_1A			; INT 1A	Time of day 
 FF19  FF53 R				DW  OFFSET INT_RET 		; INT 1B	Ctrl Brk 
 FF1B  FF53 R				DW  OFFSET INT_RET 		; INT 1C	Timer Tick 
 FF1D  F0A4 R				DW  OFFSET INT_1D 		; INT 1D	CRTC param table 
 FF1F  EFC7 R				DW  OFFSET INT_1E 		; INT 1E	Floppy param table 
 = 001F				L_VECTOR_TABLE = ($-VECTOR_TABLE)/2	; number of vectors 1Fh (31) 
 FF21  0000				DW  0 				; INT 1F	8x8 (CP 128-255) custom 
										;		 video font table (0000:0000) 
 FF23				VECTOR_TABLE ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT_IRQ - Handle placeholder hardware interrupts 
				;----------------------------------------------------------------------------; 
				; ISR for any hardware interrupts that have yet to be vectored. 
				; Acknowledge interrupt, mask the active one and write last HW interrupt to BDA. 
				; 
				; Output: 
				;	INT_LAST = last interrupt or 0FFh if non-hardware/unknown interrupt 
				;----------------------------------------------------------------------------; 
 FF23						ORG 0FF23H 
 FF23				INT_IRQ PROC 
							ASSUME DS:_BDA_ABS 
 FF23  50				PUSH	AX 
 FF24  1E				PUSH	DS				; save DS 
 FF25  B0 0B				MOV	AL, OCW3 <,,,,11b> 	; AL = OCW3 Read ISR reg on next pulse 
 FF27  E6 20				OUT	INT_P0, AL			; write to PIC A0 (20h) 
 FF29  33 C0				XOR	AX, AX			; AH = 0, delay for PIC at least 1 clock pulse 
 FF2B  8E D8				MOV	DS, AX			; set DS to BDA_ABS (segment 0000h) 
 FF2D  E4 20				IN	AL, INT_P0			; get current In-Service Register (ISR) 
 FF2F  48				DEC	AX				; if ISR is zero there is no active hardware int 
 FF30  7C 0D				JL	INT_IRQ_DONE		; if no active int, exit with INT_LAST = FFh 
 FF32  40				INC	AX				; otherwise INT_LAST = active interrupt level 
 FF33  8A E0				MOV	AH, AL 			; restore ISR and save to AH 
 FF35  E4 21				IN	AL, INT_IMR			; get current Interrupt Mask Register (IMR) 
 FF37  0A C4				OR	AL, AH 			; mask active interrupt 
 FF39  E6 21				OUT	INT_IMR, AL			; write new IMR to PIC A1 (21h) 
 FF3B  B0 20				MOV	AL, EOI 			; AL = OCW2 End of Interrupt 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-200


 FF3D  E6 20				OUT	INT_P0, AL			; write EOI to PIC A0 (20h) 
 FF3F				INT_IRQ_DONE: 
 FF3F  88 26 046B R			MOV	INT_LAST_ABS, AH	 	; save last interrupt to BDA 
 FF43  1F				POP	DS 
 FF44  58				POP	AX 
 FF45  CF				IRET 
							ASSUME DS:NOTHING 
 FF46				INT_IRQ ENDP 
				 
				;----------------------------------------------------------------------------; 
				; POST Video Adapter Type Strings (2 of 2) 
				; 11 bytes 
				; 
								IF POST_VIDEO_TYPE EQ 1 
 FF46  56 69 64 65 6F 00	POST_VIDEO		DB	'Video', 0 
								ENDIF 
 FF4C  4E 6F 6E 65 00		POST_NONE		DB	'None', 0	; must be contiguous to POST_VIDEO 
				 
				; 
				; 2 BYTES HERE 
				; 
				BYTES_HERE	INT_RET 
 = 0002                      1	BYTES_HERE_INT_RET = INT_RET-$ 
			     1			IFDEF BYTES_HERE_INT_RET 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; INT_RET - Handle placeholder software interrupts 
				;----------------------------------------------------------------------------; 
 FF53						ORG 0FF53H 
 FF53				INT_RET PROC 
 FF53  CF				IRET 
 FF54				INT_RET ENDP 
				 
				;----------------------------------------------------------------------------; 
				; INT 5 - Print Screen 
				;----------------------------------------------------------------------------; 
				; Print the contents of the current screen/page. 
				; 
				; Output: 
				; - Screen contents to PRN (BIOS printer 0) 
				; - Status to BDA 50:0H: 
				;	00	Print screen has not been called, or upon return 
				;			from a call there were no errors 
				;	01	Print screen is already in progress 
				;	FF	Error encountered during printing 
				;----------------------------------------------------------------------------; 
				; Things you must do: 
				; 	1. Check status (BDA 50:0H) to ensure PrtScn is not already in progress. 
				;	2. Set working status to 1. 
				;	3. Get the current screen size (columns) and video page. 
				;	4. Save the current cursor position, then move to the top. 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-201


				;	5. Read the char at that position and send to printer. 
				;	6. If last column reached, move screen cursor to start of next line 
				;		and send CR and LF to printer to start new line. 
				;	7. Keep looping until past the last row (always 25) 
				;	8. Restore screen cursor position 
				;	9. Set BDA status to either success (0) or error (-1) 
				;----------------------------------------------------------------------------; 
 FF54						ORG 0FF54H 
 FF54				INT_05 PROC 
							ASSUME DS:_BDA 
 FF54  FC				CLD						; string direction forward 
					PUSHX	AX, DI, ES				; preserve caller registers 
			     1				IFNB <AX>			; exit if last reg 
 FF55  50                    1		PUSH	AX 					; push register and repeat 
			     1		PUSHX	DI, ES, , , , ,  
			     2				IFNB <DI>			; exit if last reg 
 FF56  57                    2		PUSH	DI 					; push register and repeat 
			     2		PUSHX	ES, , , , , ,  
			     3				IFNB <ES>			; exit if last reg 
 FF57  06                    3		PUSH	ES 					; push register and repeat 
			     3		PUSHX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 FF58  BF ---- R			MOV	DI, SEG _DOS_DAT 
 FF5B  8E C7				MOV	ES, DI				; ES = seg 50H 
 FF5D  33 FF				XOR	DI, DI				; DI = PTRSCN_ST (offset 00H) 
 FF5F  B0 01				MOV	AL, 1					; print status = 1 (in progress) 
 FF61  AE				SCASB						; is in progress already? 
 FF62  74 42				JZ	INT_05_EXIT				; if so, exit 
 FF64  FB				STI						; Interrupts should be okay now 
 FF65  4F				DEC	DI					; undo earlier SCASB increment 
 FF66  AA				STOSB						; update status to 1 
					PUSHX	BX, CX, DX				; preserve working registers 
			     1				IFNB <BX>			; exit if last reg 
 FF67  53                    1		PUSH	BX 					; push register and repeat 
			     1		PUSHX	CX, DX, , , , ,  
			     2				IFNB <CX>			; exit if last reg 
 FF68  51                    2		PUSH	CX 					; push register and repeat 
			     2		PUSHX	DX, , , , , ,  
			     3				IFNB <DX>			; exit if last reg 
 FF69  52                    3		PUSH	DX 					; push register and repeat 
			     3		PUSHX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 FF6A  B4 0F				MOV	AH, 0FH				; get video state (columns) 
 FF6C  CD 10				INT	10H					; AH = screen columns, BH = page 
 FF6E  8A DC				MOV	BL, AH				; BL = screen columns 
 FF70  4B				DEC	BX					; fix 0 index 
 FF71  B4 03				MOV	AH, 3					; get cursor position 
 FF73  CD 10				INT	10H					; DH = cursor row, DL = cursor column 
 FF75  52				PUSH	DX					; save starting cursor position 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-202


 FF76  E8 FFAA R			CALL	LPT_CRLF				; start print head on new line 
 FF79  72 1F				JC	INT_05_DONE				; exit if print error 
 FF7B  99				CWD						; start position at row 0, col 0 
 FF7C				INT_05_LOOP_1: 
 FF7C  B4 02				MOV	AH, 2					; set cursor position 
 FF7E  CD 10				INT	10H					; set cursor to DH=row, DL=col 
 FF80  B4 08				MOV	AH, 8					; get char/attr at current position 
 FF82  CD 10				INT	10H					; AL = char at current position 
 FF84  E8 FFB3 R			CALL	LPT_CHAR				; print char in AL 
 FF87  72 11				JC	INT_05_DONE				; exit if print error 
 FF89  3A DA				CMP	BL, DL				; end of screen cols? 
 FF8B  75 07				JNE	INT_05_NEXT_COL			; jump if not 
 FF8D  B2 FF				MOV	DL, -1				; else move to first col and next row 
 FF8F  E8 FFAA R			CALL	LPT_CRLF				; CR and LF to PRN 
 FF92  72 06				JC	INT_05_DONE				; exit if print error 
 FF94				INT_05_NEXT_COL: 
 FF94  42				INC	DX					; move to next column (and maybe row) 
 FF95  80 FE 19				CMP	DH, VID_DEF_ROWS+1		; end of screen rows? 
 FF98  75 E2				JNE	INT_05_LOOP_1			; loop while not last row, CF=0 when done 
 FF9A				INT_05_DONE: 
 FF9A  1A C0				SBB	AL, AL				; print status: AL = 0 if NC, AL = -1 if CF 
 FF9C  4F				DEC	DI					; undo earlier STOSB increment 
 FF9D  AA				STOSB						; update BDA status 
 FF9E  5A				POP	DX					; restore starting cursor position 
 FF9F  B4 02				MOV	AH, 2					; set cursor position in DH/DL 
 FFA1  CD 10				INT	10H 
					POPX	DX, CX, BX 
			     1				IFNB <DX>			; exit if last reg 
 FFA3  5A                    1		POP	DX 					; pop register and repeat 
			     1		POPX	CX, BX, , , , ,  
			     2				IFNB <CX>			; exit if last reg 
 FFA4  59                    2		POP	CX 					; pop register and repeat 
			     2		POPX	BX, , , , , ,  
			     3				IFNB <BX>			; exit if last reg 
 FFA5  5B                    3		POP	BX 					; pop register and repeat 
			     3		POPX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
 FFA6				INT_05_EXIT: 
					POPX	ES, DI, AX 
			     1				IFNB <ES>			; exit if last reg 
 FFA6  07                    1		POP	ES 					; pop register and repeat 
			     1		POPX	DI, AX, , , , ,  
			     2				IFNB <DI>			; exit if last reg 
 FFA7  5F                    2		POP	DI 					; pop register and repeat 
			     2		POPX	AX, , , , , ,  
			     3				IFNB <AX>			; exit if last reg 
 FFA8  58                    3		POP	AX 					; pop register and repeat 
			     3		POPX	, , , , , ,  
			     4				ENDIF 
			     3				ENDIF 
			     2				ENDIF 
			     1				ENDIF 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-203


 FFA9  CF				IRET 
				 
				;----------------------------------------------------------------------------; 
				; LPT_CRLF - Write CR and LF to PRN 
				;----------------------------------------------------------------------------; 
 FFAA				LPT_CRLF PROC 
 FFAA  B0 0D				MOV	AL, CR 
 FFAC  E8 FFB3 R			CALL	LPT_CHAR 
 FFAF  72 11				JC	LPT_CHAR_EXIT			; exit if print error 
				 
				;----------------------------------------------------------------------------; 
				; LPT_LF - Write LF to PRN 
				;----------------------------------------------------------------------------; 
 FFB1				LPT_LF PROC 
 FFB1  B0 0A				MOV	AL, LF 
				 
				;----------------------------------------------------------------------------; 
				; LPT_CHAR - Write a char to PRN 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	AL = char to print 
				; Output: 
				;	CF = 1 (CY) if timeout 
				; 
				; AL clobbered if null 
				;----------------------------------------------------------------------------; 
 FFB3				LPT_CHAR PROC 
 FFB3  52				PUSH	DX 
 FFB4  B4 00				MOV	AH, 0					; Print Character function 
 FFB6  99				CWD						; DX = printer 0 (PRN) 
 FFB7  84 C0				TEST	AL, AL				; was input char a null? 
 FFB9  75 02				JNZ	LPT_CHAR_OUT			; jump if not 
 FFBB  B0 20				MOV	AL, ' '				; if so, use a space 
 FFBD				LPT_CHAR_OUT: 
 FFBD  CD 17				INT	17H					; Print AL to PRN0 
 FFBF  D0 EC				SHR	AH, 1					; CF if timeout 
 FFC1  5A				POP	DX 
 FFC2				LPT_CHAR_EXIT: 
 FFC2  C3				RET 
 FFC3				LPT_CHAR ENDP 
 FFC3				LPT_LF ENDP 
 FFC3				LPT_CRLF ENDP 
				 
 FFC3				INT_05 ENDP 
				 
				;----------------------------------------------------------------------------; 
				; Check if a 8087 FPU is present and perform quick tests 
				;----------------------------------------------------------------------------; 
				; Input: 
				;	DI = any non-zero value 
				; Output: 
				;	ZF = 0 if no FPU, ZF = 1 if present 
				; 
				; Clobbers: BX, DI 
				; 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-204


				; Sources: 
				;   https://retrocomputing.stackexchange.com/questions/16529/detecting-the-external-x87-fpu 
				;   Intel(R) App Note AP-485 "Intel(R) Processor Identification and the CPUID Instruction" 
				;----------------------------------------------------------------------------; 
 FFC3				HAS_FPU PROC 
 FFC3  97				XCHG	AX, DI			; save AX 
 FFC4  DB E3				FNINIT 				; reset FPU, no wait 
				 
				;----------------------------------------------------------------------------; 
				; Test Status Word 
				; 
 FFC6				FPU_TEST_SW: 
 FFC6  50				PUSH	AX 				; init temp word to non-zero 
 FFC7  8B DC				MOV	BX, SP	 		; use stack memory 
 FFC9  36: DD 3F			FNSTSW WORD PTR SS:[BX]		; store status word 
 FFCC  90				NOP					; delay to allow FPU to complete 
 FFCD  58				POP	AX 				; AX = control word if FNSTCW executed 
 FFCE  84 C0				TEST	AL, AL 			; check exception flags 
 FFD0  75 0C				JNZ	FPU_TEST_DONE		; if flags = 00, FPU is present 
				 
				;----------------------------------------------------------------------------; 
				; Test Control Word 
				; 
 FFD2				FPU_TEST_CW: 
 FFD2  50				PUSH	AX 
 FFD3  36: D9 3F			FNSTCW WORD PTR SS:[BX]		; store control word 
 FFD6  90				NOP					; delay to allow FPU to complete 
 FFD7  58				POP	AX 				; AX = control word 
 FFD8  35 103F				XOR	AX, 0103FH 			; isolate interesting status flags 
 FFDB  25 003F				AND	AX, 03FH 			; check for 8087 "signature" 
										; ZF = 0 if no FPU 
 FFDE				FPU_TEST_DONE: 
 FFDE  97				XCHG	AX, DI			; restore AX 
 FFDF  C3				RET 
 FFE0				HAS_FPU ENDP 
				 
				; 
				; 0 BYTES HERE 
				; 
				BYTES_HERE	VER 
 = 0000                      1	BYTES_HERE_VER = VER-$ 
			     1			IFDEF BYTES_HERE_VER 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
				;----------------------------------------------------------------------------; 
				; Version and Build Strings 
				;----------------------------------------------------------------------------; 
 FFE0						ORG	0FFE0H 
 FFE0  56 65 72 3A 20		VER 	DB	'Ver: ' 
 FFE5  30 2E 32 2E 36			DB	VER_NUM 
 FFEA  2D				DB	'-'				; Show CPU type and 
 FFEB  38				DB	CPU_TYPE			; architecture target 
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Page     1-205


 FFEC  58				DB	ARCH_TYPE 
							ENDIF 
 FFED  20				DB	' '				; space before date 
 FFEE  00				DB	0 
				 
				; 
				; 0 BYTES HERE 
				; 
				BYTES_HERE	POWER_ON 
 = 0001                      1	BYTES_HERE_POWER_ON = POWER_ON-$ 
			     1			IFDEF BYTES_HERE_POWER_ON 
			     1			IF2 
			     1			ENDIF 
			     1			ENDIF 
			     1			ENDIF 
				 
 FFEF				BIOS		ENDS 
glabios.asm(12506): warning A4102: Segment near (or at) 64K limit
				 
				;============================================================================; 
				; 
				;				* * *    END OF BIOS   * * * 
				; 
				;============================================================================; 
				 
				END 

Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-1


Macros:

		N a m e			Lines

AAD_I  . . . . . . . . . . . . .  	   1
AAM_I  . . . . . . . . . . . . .  	   1
BEEP_OFF . . . . . . . . . . . .  	   1
BEEP_ON  . . . . . . . . . . . .  	   6
BEXT . . . . . . . . . . . . . .  	   2
BINS . . . . . . . . . . . . . .  	   2
BYTES_HERE . . . . . . . . . . .  	   9
CALL_NS  . . . . . . . . . . . .  	   9
CGA_WAIT_SYNC  . . . . . . . . .  	  26
CLR1 . . . . . . . . . . . . . .  	   1
CMP_EFLAG  . . . . . . . . . . .  	  25
GET_EFLAG  . . . . . . . . . . .  	  64
IO_DELAY . . . . . . . . . . . .  	   2
IO_DELAY_LONG  . . . . . . . . .  	   4
IO_DELAY_SHORT . . . . . . . . .  	   4
IO_DELAY_TURBO . . . . . . . . .  	   5
IRET_F . . . . . . . . . . . . .  	   1
JNWB . . . . . . . . . . . . . .  	   2
JWB  . . . . . . . . . . . . . .  	   4
NOT1 . . . . . . . . . . . . . .  	   1
POPX . . . . . . . . . . . . . .  	   4
POST_CODE  . . . . . . . . . . .  	   8
POST_COL_1 . . . . . . . . . . .  	  13
POST_COL_2 . . . . . . . . . . .  	  13
POST_COL_END . . . . . . . . . .  	   7
POST_COL_END_NL  . . . . . . . .  	   7
POST_FLAG_CLR  . . . . . . . . .  	  10
POST_FLAG_FLIP . . . . . . . . .  	   5
POST_FLAG_SET  . . . . . . . . .  	   5
POST_FLAG_TEST . . . . . . . . .  	   5
PRINTLN_SZ . . . . . . . . . . .  	  10
PRINT_SZ . . . . . . . . . . . .  	  10
PUSHX  . . . . . . . . . . . . .  	   4
ROL4 . . . . . . . . . . . . . .  	   1
ROR4 . . . . . . . . . . . . . .  	   1
SET1 . . . . . . . . . . . . . .  	   1
SET_EFLAG  . . . . . . . . . . .  	  41
SET_GFLAG  . . . . . . . . . . .  	   4
SET_SZ_ATTR  . . . . . . . . . .  	  18
TEST1  . . . . . . . . . . . . .  	   1
TEST_EFLAG . . . . . . . . . . .  	   5
TEST_GFLAG . . . . . . . . . . .  	   1
V20_OP1  . . . . . . . . . . . .  	   6

Structures and Records:

                N a m e                 Width   # fields
                                        Shift   Width   Mask    Initial

BEEP_SL  . . . . . . . . . . . .  	0008	0002
  BEEP_S . . . . . . . . . . . .  	0004	0004	00F0	0000
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-2


  BEEP_L . . . . . . . . . . . .  	0000	0004	000F	0000
COM_LCR  . . . . . . . . . . . .  	0008	0007
  DLAB . . . . . . . . . . . . .  	0007	0001	0080	0000
  LCBK . . . . . . . . . . . . .  	0006	0001	0040	0000
  LCPD . . . . . . . . . . . . .  	0005	0001	0020	0000
  LCEPS  . . . . . . . . . . . .  	0004	0001	0010	0000
  LCPEN  . . . . . . . . . . . .  	0003	0001	0008	0000
  LCSB . . . . . . . . . . . . .  	0002	0001	0004	0000
  LCWLS  . . . . . . . . . . . .  	0000	0002	0003	0000
COM_LSR  . . . . . . . . . . . .  	0008	0008
  LSX  . . . . . . . . . . . . .  	0007	0001	0080	0000
  TSRE . . . . . . . . . . . . .  	0006	0001	0040	0000
  THRE . . . . . . . . . . . . .  	0005	0001	0020	0000
  LBI  . . . . . . . . . . . . .  	0004	0001	0010	0000
  LFE  . . . . . . . . . . . . .  	0003	0001	0008	0000
  LPE  . . . . . . . . . . . . .  	0002	0001	0004	0000
  LOE  . . . . . . . . . . . . .  	0001	0001	0002	0000
  LDR  . . . . . . . . . . . . .  	0000	0001	0001	0000
COM_MCR  . . . . . . . . . . . .  	0008	0006
  MCRX . . . . . . . . . . . . .  	0005	0003	00E0	0000
  MCLB . . . . . . . . . . . . .  	0004	0001	0010	0000
  MCO2 . . . . . . . . . . . . .  	0003	0001	0008	0000
  MCO1 . . . . . . . . . . . . .  	0002	0001	0004	0000
  RTS  . . . . . . . . . . . . .  	0001	0001	0002	0000
  DTR  . . . . . . . . . . . . .  	0000	0001	0001	0000
COM_MSR  . . . . . . . . . . . .  	0008	0008
  MLSD . . . . . . . . . . . . .  	0007	0001	0080	0000
  MRI  . . . . . . . . . . . . .  	0006	0001	0040	0000
  MDSR . . . . . . . . . . . . .  	0005	0001	0020	0000
  MCTS . . . . . . . . . . . . .  	0004	0001	0010	0000
  DDCD . . . . . . . . . . . . .  	0003	0001	0008	0000
  DRI  . . . . . . . . . . . . .  	0002	0001	0004	0000
  DDSR . . . . . . . . . . . . .  	0001	0001	0002	0000
  DCTS . . . . . . . . . . . . .  	0000	0001	0001	0000
CRTC . . . . . . . . . . . . . .  	0010	0010
  H_TC . . . . . . . . . . . . .  	0000
  H_CL . . . . . . . . . . . . .  	0001
  H_SP . . . . . . . . . . . . .  	0002
  H_SW . . . . . . . . . . . . .  	0003
  V_TL . . . . . . . . . . . . .  	0004
  V_SL . . . . . . . . . . . . .  	0005
  V_DR . . . . . . . . . . . . .  	0006
  V_SP . . . . . . . . . . . . .  	0007
  IL . . . . . . . . . . . . . .  	0008
  MSL  . . . . . . . . . . . . .  	0009
  CSL  . . . . . . . . . . . . .  	000A
  CEL  . . . . . . . . . . . . .  	000B
  SA_H . . . . . . . . . . . . .  	000C
  SA_L . . . . . . . . . . . . .  	000D
  CA_H . . . . . . . . . . . . .  	000E
  CA_L . . . . . . . . . . . . .  	000F
DBT  . . . . . . . . . . . . . .  	000B	000B
  SRT  . . . . . . . . . . . . .  	0000
  HLT_ND . . . . . . . . . . . .  	0001
  FMCT . . . . . . . . . . . . .  	0002
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-3


  FBPS . . . . . . . . . . . . .  	0003
  SPT  . . . . . . . . . . . . .  	0004
  SGAP . . . . . . . . . . . . .  	0005
  LSEC . . . . . . . . . . . . .  	0006
  FGAP . . . . . . . . . . . . .  	0007
  FFILL  . . . . . . . . . . . .  	0008
  HDST . . . . . . . . . . . . .  	0009
  FMST . . . . . . . . . . . . .  	000A
DBW  . . . . . . . . . . . . . .  	0010	0002
  HWB  . . . . . . . . . . . . .  	0008	0008	FF00	0000
  LWB  . . . . . . . . . . . . .  	0000	0008	00FF	0000
DMA_CR . . . . . . . . . . . . .  	0008	0008
  DACK . . . . . . . . . . . . .  	0007	0001	0080	0000
  DREQ . . . . . . . . . . . . .  	0006	0001	0040	0000
  DWS  . . . . . . . . . . . . .  	0005	0001	0020	0000
  DPRI . . . . . . . . . . . . .  	0004	0001	0010	0000
  DTIM . . . . . . . . . . . . .  	0003	0001	0008	0000
  DDIS . . . . . . . . . . . . .  	0002	0001	0004	0000
  DHLD . . . . . . . . . . . . .  	0001	0001	0002	0000
  DM2M . . . . . . . . . . . . .  	0000	0001	0001	0000
DMA_MR . . . . . . . . . . . . .  	0008	0005
  DMM  . . . . . . . . . . . . .  	0006	0002	00C0	0040
  DMINC  . . . . . . . . . . . .  	0005	0001	0020	0000
  DMAI . . . . . . . . . . . . .  	0004	0001	0010	0010
  DMOP . . . . . . . . . . . . .  	0002	0002	000C	0000
  DMCH . . . . . . . . . . . . .  	0000	0002	0003	0000
DMA_SMR  . . . . . . . . . . . .  	0008	0002
  SMCLR  . . . . . . . . . . . .  	0002	0006	00FC	0000
  SMCH . . . . . . . . . . . . .  	0000	0002	0003	0000
DMA_SR . . . . . . . . . . . . .  	0008	0008
  CR3  . . . . . . . . . . . . .  	0007	0001	0080	0000
  CR2  . . . . . . . . . . . . .  	0006	0001	0040	0000
  CR1  . . . . . . . . . . . . .  	0005	0001	0020	0000
  CR0  . . . . . . . . . . . . .  	0004	0001	0010	0000
  TC3  . . . . . . . . . . . . .  	0003	0001	0008	0000
  TC2  . . . . . . . . . . . . .  	0002	0001	0004	0000
  TC1  . . . . . . . . . . . . .  	0001	0001	0002	0000
  TC0  . . . . . . . . . . . . .  	0000	0001	0001	0000
DNB  . . . . . . . . . . . . . .  	0008	0002
  HBN  . . . . . . . . . . . . .  	0004	0004	00F0	0000
  LBN  . . . . . . . . . . . . .  	0000	0004	000F	0000
EFLAGS86 . . . . . . . . . . . .  	0008	0008
  FSF  . . . . . . . . . . . . .  	0007	0001	0080	0000
  FZF  . . . . . . . . . . . . .  	0006	0001	0040	0000
  FR1  . . . . . . . . . . . . .  	0005	0001	0020	0000
  FAF  . . . . . . . . . . . . .  	0004	0001	0010	0000
  FR2  . . . . . . . . . . . . .  	0003	0001	0008	0000
  FPF  . . . . . . . . . . . . .  	0002	0001	0004	0000
  FR3  . . . . . . . . . . . . .  	0001	0001	0002	0002
  FCF  . . . . . . . . . . . . .  	0000	0001	0001	0000
EQFLAGS  . . . . . . . . . . . .  	0010	000A
  LPT  . . . . . . . . . . . . .  	000E	0002	C000	0000
  X1 . . . . . . . . . . . . . .  	000D	0001	2000	0000
  GAM  . . . . . . . . . . . . .  	000C	0001	1000	0000
  COM  . . . . . . . . . . . . .  	0009	0003	0E00	0000
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-4


  DMA  . . . . . . . . . . . . .  	0008	0001	0100	0000
  FLP  . . . . . . . . . . . . .  	0006	0002	00C0	0000
  VID  . . . . . . . . . . . . .  	0004	0002	0030	0000
  MBRAM  . . . . . . . . . . . .  	0002	0002	000C	000C
  FPU  . . . . . . . . . . . . .  	0001	0001	0002	0000
  IPL  . . . . . . . . . . . . .  	0000	0001	0001	0000
FDC_CB . . . . . . . . . . . . .  	0008	0004
  FC0MT  . . . . . . . . . . . .  	0007	0001	0080	0000
  FC0MF  . . . . . . . . . . . .  	0006	0001	0040	0040
  FC0SK  . . . . . . . . . . . .  	0005	0001	0020	0000
  FC0CMD . . . . . . . . . . . .  	0000	0005	001F	0000
FDC_CB1  . . . . . . . . . . . .  	0008	0003
  FC1X . . . . . . . . . . . . .  	0003	0005	00F8	0000
  FC1HD  . . . . . . . . . . . .  	0002	0001	0004	0000
  FC1DS  . . . . . . . . . . . .  	0000	0002	0003	0000
FDC_CSB  . . . . . . . . . . . .  	0007	0007
  SB0  . . . . . . . . . . . . .  	0000
  SB1  . . . . . . . . . . . . .  	0001
  SB2  . . . . . . . . . . . . .  	0002
  CYL  . . . . . . . . . . . . .  	0003
  HEAD . . . . . . . . . . . . .  	0004
  SEC  . . . . . . . . . . . . .  	0005
  BPS  . . . . . . . . . . . . .  	0006
FDC_DOR  . . . . . . . . . . . .  	0008	0007
  FDMD . . . . . . . . . . . . .  	0007	0001	0080	0000
  FDMC . . . . . . . . . . . . .  	0006	0001	0040	0000
  FDMB . . . . . . . . . . . . .  	0005	0001	0020	0000
  FDMA . . . . . . . . . . . . .  	0004	0001	0010	0000
  FDDMA  . . . . . . . . . . . .  	0003	0001	0008	0000
  FDCEN  . . . . . . . . . . . .  	0002	0001	0004	0000
  FDSEL  . . . . . . . . . . . .  	0000	0002	0003	0000
FDC_MF . . . . . . . . . . . . .  	0008	0003
  FWRT . . . . . . . . . . . . .  	0007	0001	0080	0000
  FMTBD  . . . . . . . . . . . .  	0004	0003	0070	0000
  FMOT . . . . . . . . . . . . .  	0000	0004	000F	0000
FDC_MFD  . . . . . . . . . . . .  	0008	0005
  FMOTX  . . . . . . . . . . . .  	0004	0004	00F0	0000
  FMOT3  . . . . . . . . . . . .  	0003	0001	0008	0000
  FMOT2  . . . . . . . . . . . .  	0002	0001	0004	0000
  FMOT1  . . . . . . . . . . . .  	0001	0001	0002	0000
  FMOT0  . . . . . . . . . . . .  	0000	0001	0001	0000
FDC_MODE . . . . . . . . . . . .  	0008	0008
  FM1X . . . . . . . . . . . . .  	0007	0001	0080	0000
  FM1D . . . . . . . . . . . . .  	0006	0001	0040	0000
  FM1M . . . . . . . . . . . . .  	0005	0001	0020	0000
  FM18 . . . . . . . . . . . . .  	0004	0001	0010	0000
  FM0X . . . . . . . . . . . . .  	0003	0001	0008	0000
  FM0D . . . . . . . . . . . . .  	0002	0001	0004	0000
  FM0M . . . . . . . . . . . . .  	0001	0001	0002	0000
  FM08 . . . . . . . . . . . . .  	0000	0001	0001	0000
FDC_MSR  . . . . . . . . . . . .  	0008	0008
  FDRR . . . . . . . . . . . . .  	0007	0001	0080	0000
  FIOD . . . . . . . . . . . . .  	0006	0001	0040	0000
  FDND . . . . . . . . . . . . .  	0005	0001	0020	0000
  FDRW . . . . . . . . . . . . .  	0004	0001	0010	0000
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-5


  F3SK . . . . . . . . . . . . .  	0003	0001	0008	0000
  F2SK . . . . . . . . . . . . .  	0002	0001	0004	0000
  F1SK . . . . . . . . . . . . .  	0001	0001	0002	0000
  F0SK . . . . . . . . . . . . .  	0000	0001	0001	0000
FDC_SF . . . . . . . . . . . . .  	0008	0006
  FWIF . . . . . . . . . . . . .  	0007	0001	0080	0000
  FSTBD  . . . . . . . . . . . .  	0004	0003	0070	0000
  FCAL3  . . . . . . . . . . . .  	0003	0001	0008	0000
  FCAL2  . . . . . . . . . . . .  	0002	0001	0004	0000
  FCAL1  . . . . . . . . . . . .  	0001	0001	0002	0000
  FCAL0  . . . . . . . . . . . .  	0000	0001	0001	0000
FDC_ST0  . . . . . . . . . . . .  	0008	0006
  ST0CS  . . . . . . . . . . . .  	0006	0002	00C0	0000
  ST0SK  . . . . . . . . . . . .  	0005	0001	0020	0000
  ST0CHK . . . . . . . . . . . .  	0004	0001	0010	0000
  ST0NR  . . . . . . . . . . . .  	0003	0001	0008	0000
  ST0HD  . . . . . . . . . . . .  	0002	0001	0004	0000
  ST0DRV . . . . . . . . . . . .  	0000	0002	0003	0000
FDC_STATE  . . . . . . . . . . .  	0008	0005
  FSR  . . . . . . . . . . . . .  	0006	0002	00C0	0000
  FDDS . . . . . . . . . . . . .  	0005	0001	0020	0000
  FSE  . . . . . . . . . . . . .  	0004	0001	0010	0000
  FDX  . . . . . . . . . . . . .  	0003	0001	0008	0000
  FSD  . . . . . . . . . . . . .  	0000	0003	0007	0000
GFLAGS . . . . . . . . . . . . .  	0008	0004
  GTBD1  . . . . . . . . . . . .  	0004	0004	00F0	0000
  TURBO  . . . . . . . . . . . .  	0003	0001	0008	0000
  V20  . . . . . . . . . . . . .  	0002	0001	0004	0000
  GTBD2  . . . . . . . . . . . .  	0000	0002	0003	0000
ICW1 . . . . . . . . . . . . . .  	0008	0005
  D4 . . . . . . . . . . . . . .  	0004	0004	00F0	0010
  LTIM . . . . . . . . . . . . .  	0003	0001	0008	0000
  ADI  . . . . . . . . . . . . .  	0002	0001	0004	0000
  SNGL . . . . . . . . . . . . .  	0001	0001	0002	0002
  IC4  . . . . . . . . . . . . .  	0000	0001	0001	0001
ICW2 . . . . . . . . . . . . . .  	0008	0002
  ICW2IVA  . . . . . . . . . . .  	0003	0005	00F8	0000
  ICW2X  . . . . . . . . . . . .  	0000	0003	0007	0000
ICW4 . . . . . . . . . . . . . .  	0008	0004
  SFNM . . . . . . . . . . . . .  	0004	0004	00F0	0000
  ICWBUF . . . . . . . . . . . .  	0002	0002	000C	0000
  AEOI . . . . . . . . . . . . .  	0001	0001	0002	0000
  UPM  . . . . . . . . . . . . .  	0000	0001	0001	0000
KB . . . . . . . . . . . . . . .  	0010	0002
  KBK  . . . . . . . . . . . . .  	000A	0006	FC00	0000
  KBS  . . . . . . . . . . . . .  	0000	000A	03FF	0000
KBBRK  . . . . . . . . . . . . .  	0008	0002
  KBRK . . . . . . . . . . . . .  	0007	0001	0080	0000
  KBRX . . . . . . . . . . . . .  	0000	0007	007F	0000
KBFLAGS1 . . . . . . . . . . . .  	0008	0008
  K1IN . . . . . . . . . . . . .  	0007	0001	0080	0000
  K1CL . . . . . . . . . . . . .  	0006	0001	0040	0000
  K1NL . . . . . . . . . . . . .  	0005	0001	0020	0000
  K1SL . . . . . . . . . . . . .  	0004	0001	0010	0000
  K1AL . . . . . . . . . . . . .  	0003	0001	0008	0000
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-6


  K1CT . . . . . . . . . . . . .  	0002	0001	0004	0000
  K1LS . . . . . . . . . . . . .  	0001	0001	0002	0000
  K1RS . . . . . . . . . . . . .  	0000	0001	0001	0000
KBFLAGS2 . . . . . . . . . . . .  	0008	0008
  K2IN . . . . . . . . . . . . .  	0007	0001	0080	0000
  K2CL . . . . . . . . . . . . .  	0006	0001	0040	0000
  K2NL . . . . . . . . . . . . .  	0005	0001	0020	0000
  K2SL . . . . . . . . . . . . .  	0004	0001	0010	0000
  K2PA . . . . . . . . . . . . .  	0003	0001	0008	0000
  K2SY . . . . . . . . . . . . .  	0002	0001	0004	0000
  K2LA . . . . . . . . . . . . .  	0001	0001	0002	0000
  K2LC . . . . . . . . . . . . .  	0000	0001	0001	0000
KBFLAGS3 . . . . . . . . . . . .  	0008	0008
  KERD . . . . . . . . . . . . .  	0007	0001	0080	0000
  KEFI . . . . . . . . . . . . .  	0006	0001	0040	0000
  KENL . . . . . . . . . . . . .  	0005	0001	0020	0000
  KEEN . . . . . . . . . . . . .  	0004	0001	0010	0000
  KERA . . . . . . . . . . . . .  	0003	0001	0008	0000
  KERC . . . . . . . . . . . . .  	0002	0001	0004	0000
  KEE0 . . . . . . . . . . . . .  	0001	0001	0002	0000
  KEE1 . . . . . . . . . . . . .  	0000	0001	0001	0000
KBFLAGS4 . . . . . . . . . . . .  	0008	0008
  KLTE . . . . . . . . . . . . .  	0007	0001	0080	0000
  KLMU . . . . . . . . . . . . .  	0006	0001	0040	0000
  KLRF . . . . . . . . . . . . .  	0005	0001	0020	0000
  KLAK . . . . . . . . . . . . .  	0004	0001	0010	0000
  KLCI . . . . . . . . . . . . .  	0003	0001	0008	0000
  KLCL . . . . . . . . . . . . .  	0002	0001	0004	0000
  KLNL . . . . . . . . . . . . .  	0001	0001	0002	0000
  KLSL . . . . . . . . . . . . .  	0000	0001	0001	0000
KBP  . . . . . . . . . . . . . .  	0010	0002
  KBPK . . . . . . . . . . . . .  	0006	000A	FFC0	0000
  KBPS . . . . . . . . . . . . .  	0000	0006	003F	0000
KBW  . . . . . . . . . . . . . .  	0010	0002
  KBWK . . . . . . . . . . . . .  	0009	0007	FE00	0000
  KBWS . . . . . . . . . . . . .  	0000	0009	01FF	0000
KP . . . . . . . . . . . . . . .  	0010	0002
  KPWP . . . . . . . . . . . . .  	0004	000C	FFF0	0000
  KPWPX  . . . . . . . . . . . .  	0000	0004	000F	0000
MDA_CH_ATTR  . . . . . . . . . .  	0008	0004
  MDBK . . . . . . . . . . . . .  	0007	0001	0080	0000
  MDBG . . . . . . . . . . . . .  	0004	0003	0070	0000
  MDIN . . . . . . . . . . . . .  	0003	0001	0008	0000
  MDFG . . . . . . . . . . . . .  	0000	0003	0007	0007
NMI  . . . . . . . . . . . . . .  	0008	0002
  NMIE . . . . . . . . . . . . .  	0007	0001	0080	0000
  NMIX . . . . . . . . . . . . .  	0000	0007	007F	0000
OCW1 . . . . . . . . . . . . . .  	0008	0008
  IRQ7 . . . . . . . . . . . . .  	0007	0001	0080	0000
  IRQ6 . . . . . . . . . . . . .  	0006	0001	0040	0000
  IRQ5 . . . . . . . . . . . . .  	0005	0001	0020	0000
  IRQ4 . . . . . . . . . . . . .  	0004	0001	0010	0000
  IRQ3 . . . . . . . . . . . . .  	0003	0001	0008	0000
  IRQ2 . . . . . . . . . . . . .  	0002	0001	0004	0000
  IRQ1 . . . . . . . . . . . . .  	0001	0001	0002	0000
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-7


  IRQ0 . . . . . . . . . . . . .  	0000	0001	0001	0000
OCW2 . . . . . . . . . . . . . .  	0008	0003
  O2CMD  . . . . . . . . . . . .  	0005	0003	00E0	0020
  O2X  . . . . . . . . . . . . .  	0003	0002	0018	0000
  O2L  . . . . . . . . . . . . .  	0000	0003	0007	0000
OCW3 . . . . . . . . . . . . . .  	0008	0005
  O3D7 . . . . . . . . . . . . .  	0007	0001	0080	0000
  ESMM . . . . . . . . . . . . .  	0005	0002	0060	0000
  O3D3 . . . . . . . . . . . . .  	0003	0002	0018	0008
  O3P  . . . . . . . . . . . . .  	0002	0001	0004	0000
  O3RR . . . . . . . . . . . . .  	0000	0002	0003	0000
PFLAGS . . . . . . . . . . . . .  	0010	000A
  WARM . . . . . . . . . . . . .  	000F	0001	8000	0000
  PKI  . . . . . . . . . . . . .  	000E	0001	4000	0000
  PKEY . . . . . . . . . . . . .  	000D	0001	2000	0000
  PFDC . . . . . . . . . . . . .  	000C	0001	1000	0000
  PFSK . . . . . . . . . . . . .  	000B	0001	0800	0000
  PDMA . . . . . . . . . . . . .  	000A	0001	0400	0000
  PMEM . . . . . . . . . . . . .  	0009	0001	0200	0000
  PFXX . . . . . . . . . . . . .  	0008	0001	0100	0000
  PTBD . . . . . . . . . . . . .  	0002	0006	00FC	0000
  GRND . . . . . . . . . . . . .  	0000	0002	0003	0000
PIT_CW . . . . . . . . . . . . .  	0008	0004
  PCWSC  . . . . . . . . . . . .  	0006	0002	00C0	0000
  PCWRW  . . . . . . . . . . . .  	0004	0002	0030	0000
  PCWM . . . . . . . . . . . . .  	0001	0003	000E	0000
  PCWBCD . . . . . . . . . . . .  	0000	0001	0001	0000
PPI_B_F  . . . . . . . . . . . .  	0008	0008
  PBKB . . . . . . . . . . . . .  	0007	0001	0080	0000
  PBKC . . . . . . . . . . . . .  	0006	0001	0040	0000
  PBIO . . . . . . . . . . . . .  	0005	0001	0020	0000
  PBPC . . . . . . . . . . . . .  	0004	0001	0010	0000
  PBSW . . . . . . . . . . . . .  	0003	0001	0008	0000
  PBTB . . . . . . . . . . . . .  	0002	0001	0004	0000
  PBSP . . . . . . . . . . . . .  	0001	0001	0002	0000
  PBST . . . . . . . . . . . . .  	0000	0001	0001	0000
PPI_CR . . . . . . . . . . . . .  	0008	0007
  PPEN . . . . . . . . . . . . .  	0007	0001	0080	0080
  PPAM . . . . . . . . . . . . .  	0005	0002	0060	0000
  PPAD . . . . . . . . . . . . .  	0004	0001	0010	0010
  PPCU . . . . . . . . . . . . .  	0003	0001	0008	0008
  PPBM . . . . . . . . . . . . .  	0002	0001	0004	0000
  PPBD . . . . . . . . . . . . .  	0001	0001	0002	0000
  PPCL . . . . . . . . . . . . .  	0000	0001	0001	0001
PPI_C_X_H  . . . . . . . . . . .  	0008	0006
  PC2PE  . . . . . . . . . . . .  	0007	0001	0080	0000
  PC2IE  . . . . . . . . . . . .  	0006	0001	0040	0000
  PC2T2  . . . . . . . . . . . .  	0005	0001	0020	0000
  PC2CI  . . . . . . . . . . . .  	0004	0001	0010	0000
  PCDRV  . . . . . . . . . . . .  	0002	0002	000C	0000
  PCVID  . . . . . . . . . . . .  	0000	0002	0003	0000
PPI_C_X_L  . . . . . . . . . . .  	0008	0007
  PCPE . . . . . . . . . . . . .  	0007	0001	0080	0000
  PCIE . . . . . . . . . . . . .  	0006	0001	0040	0000
  PCT2 . . . . . . . . . . . . .  	0005	0001	0020	0000
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-8


  PCCI . . . . . . . . . . . . .  	0004	0001	0010	0000
  PCMB . . . . . . . . . . . . .  	0002	0002	000C	0000
  PCFP . . . . . . . . . . . . .  	0001	0001	0002	0000
  PCFD . . . . . . . . . . . . .  	0000	0001	0001	0000
PRN_CTRL . . . . . . . . . . . .  	0008	0006
  LCX  . . . . . . . . . . . . .  	0005	0003	00E0	0000
  LCIRQ  . . . . . . . . . . . .  	0004	0001	0010	0000
  LCDR . . . . . . . . . . . . .  	0003	0001	0008	0000
  LCINI  . . . . . . . . . . . .  	0002	0001	0004	0000
  LCLF . . . . . . . . . . . . .  	0001	0001	0002	0000
  LCOUT  . . . . . . . . . . . .  	0000	0001	0001	0000
PRN_STAT . . . . . . . . . . . .  	0008	0007
  LPBZ . . . . . . . . . . . . .  	0007	0001	0080	0000
  LPACK  . . . . . . . . . . . .  	0006	0001	0040	0000
  LPOP . . . . . . . . . . . . .  	0005	0001	0020	0000
  LPSEL  . . . . . . . . . . . .  	0004	0001	0010	0000
  LPIO . . . . . . . . . . . . .  	0003	0001	0008	0000
  LPX  . . . . . . . . . . . . .  	0001	0002	0006	0000
  LPTO . . . . . . . . . . . . .  	0000	0001	0001	0000
TIMER_C  . . . . . . . . . . . .  	0005	0003
  LW . . . . . . . . . . . . . .  	0000
  HW . . . . . . . . . . . . . .  	0002
  OF . . . . . . . . . . . . . .  	0004
V20_F3 . . . . . . . . . . . . .  	0008	0002
  VF3_OPC  . . . . . . . . . . .  	0003	0005	00F8	00C0
  VF3_SRC  . . . . . . . . . . .  	0000	0003	0007	0000
V20_F4 . . . . . . . . . . . . .  	0008	0003
  VF4_OPC  . . . . . . . . . . .  	0006	0002	00C0	00C0
  VF4_DST  . . . . . . . . . . .  	0003	0003	0038	0000
  VF4_SRC  . . . . . . . . . . .  	0000	0003	0007	0000
V20_R  . . . . . . . . . . . . .  	0008	0002
  VRW  . . . . . . . . . . . . .  	0003	0005	00F8	0000
  ROPC . . . . . . . . . . . . .  	0000	0003	0007	0000
V40_WCY1 . . . . . . . . . . . .  	0008	0004
  IOW  . . . . . . . . . . . . .  	0006	0002	00C0	0000
  UMW  . . . . . . . . . . . . .  	0004	0002	0030	0000
  MMW  . . . . . . . . . . . . .  	0002	0002	000C	0000
  LMW  . . . . . . . . . . . . .  	0000	0002	0003	0000
VID_ATTR . . . . . . . . . . . .  	0008	0002
  VBG  . . . . . . . . . . . . .  	0004	0004	00F0	0000
  VFB  . . . . . . . . . . . . .  	0000	0004	000F	0007
VID_CSGFX  . . . . . . . . . . .  	0008	0005
  CGPH . . . . . . . . . . . . .  	0006	0002	00C0	0000
  CGPL . . . . . . . . . . . . .  	0005	0001	0020	0020
  CGX  . . . . . . . . . . . . .  	0004	0001	0010	0010
  CGIN . . . . . . . . . . . . .  	0003	0001	0008	0008
  CGBG . . . . . . . . . . . . .  	0000	0003	0007	0007
VID_CSTXT  . . . . . . . . . . .  	0008	0004
  CTX  . . . . . . . . . . . . .  	0005	0003	00E0	0020
  CTBI . . . . . . . . . . . . .  	0004	0001	0010	0010
  CTIN . . . . . . . . . . . . .  	0003	0001	0008	0000
  CTBC . . . . . . . . . . . . .  	0000	0003	0007	0000
VID_STAT . . . . . . . . . . . .  	0008	0005
  VSX  . . . . . . . . . . . . .  	0004	0004	00F0	0000
  VSVS . . . . . . . . . . . . .  	0003	0001	0008	0000
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-9


  VSPE . . . . . . . . . . . . .  	0002	0001	0004	0000
  VSPT . . . . . . . . . . . . .  	0001	0001	0002	0000
  VSHS . . . . . . . . . . . . .  	0000	0001	0001	0000

Segments and Groups:

                N a m e         	Length	 Align	Combine Class

BIOS . . . . . . . . . . . . . .  	00010000 PARA	NONE	
RESET  . . . . . . . . . . . . .  	0000	AT	FFFF	
_BASIC . . . . . . . . . . . . .  	0000	AT	F600	
_BDA . . . . . . . . . . . . . .  	00F0	AT	0040	
_BDA_ABS . . . . . . . . . . . .  	0482	AT	0000	
_BIOS  . . . . . . . . . . . . .  	FFF0	AT	F000	
_BOOT_STACK  . . . . . . . . . .  	0100	AT	0030	
_CGA_MEM . . . . . . . . . . . .  	4000	AT	B800	
_DOS_DAT . . . . . . . . . . . .  	0034	AT	0050	
_IPL_SEG . . . . . . . . . . . .  	7E00	AT	0000	
_IVT . . . . . . . . . . . . . .  	0080	AT	0000	
_MDA_MEM . . . . . . . . . . . .  	1000	AT	B000	
_OPT_ROM . . . . . . . . . . . .  	0000	AT	C800	
_VID_BIOS  . . . . . . . . . . .  	0005	AT	C000	

Symbols:            

                N a m e         	Type	 Value	 Attr

ADI  . . . . . . . . . . . . . .  		0002	
AEOI . . . . . . . . . . . . . .  		0001	
ANY_KEY  . . . . . . . . . . . .  	L BYTE	E44A	BIOS
ARCH_5150  . . . . . . . . . . .  	NUMBER	0050	
ARCH_5160  . . . . . . . . . . .  	NUMBER	0058	
ARCH_5160V2  . . . . . . . . . .  	NUMBER	0059	
ARCH_BOOK88  . . . . . . . . . .  	NUMBER	0042	
ARCH_CPQ . . . . . . . . . . . .  	NUMBER	0051	
ARCH_EHB . . . . . . . . . . . .  	NUMBER	0048	
ARCH_EMU . . . . . . . . . . . .  	NUMBER	0045	
ARCH_FE2010  . . . . . . . . . .  	NUMBER	0046	
ARCH_ID  . . . . . . . . . . . .  	NUMBER	00FE	
ARCH_LASER . . . . . . . . . . .  	NUMBER	004C	
ARCH_M88 . . . . . . . . . . . .  	NUMBER	004D	
ARCH_MARTY . . . . . . . . . . .  	NUMBER	0043	
ARCH_MIST  . . . . . . . . . . .  	NUMBER	0049	
ARCH_SUB_TYPE  . . . . . . . . .  	NUMBER	0000	
ARCH_TD3300  . . . . . . . . . .  	NUMBER	0053	
ARCH_TURBO . . . . . . . . . . .  	NUMBER	0054	
ARCH_TYPE  . . . . . . . . . . .  	ALIAS	 ARCH_5160		
ARCH_UM82  . . . . . . . . . . .  	NUMBER	0055	
ARCH_VEN888  . . . . . . . . . .  	NUMBER	0056	
ARCH_VIRTUALXT . . . . . . . . .  	NUMBER	004A	
ATKB_CMD . . . . . . . . . . . .  	NUMBER	0064	
ATKB_IO  . . . . . . . . . . . .  	NUMBER	0060	

BANNER_STRINGS . . . . . . . . .  	N PROC	E428	BIOS	Length = 0037
BASE_RAM_ERROR . . . . . . . . .  	L NEAR	E153	BIOS
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-10


BASE_RAM_TEST  . . . . . . . . .  	L NEAR	E127	BIOS
BASE_RAM_ZERO  . . . . . . . . .  	L NEAR	E158	BIOS
BASIC_ROM  . . . . . . . . . . .  	NUMBER	0001	
BASIC_TOP  . . . . . . . . . . .  	L WORD	0000	_BASIC
BEEP . . . . . . . . . . . . . .  	N PROC	E8B0	BIOS	Length = 0013
BEEP_1K  . . . . . . . . . . . .  	NUMBER	04A9	
BEEP_1K7 . . . . . . . . . . . .  	NUMBER	04A0	
BEEP_2K  . . . . . . . . . . . .  	NUMBER	0250	
BEEP_A4  . . . . . . . . . . . .  	NUMBER	0A98	
BEEP_A5  . . . . . . . . . . . .  	NUMBER	054C	
BEEP_B4  . . . . . . . . . . . .  	NUMBER	0970	
BEEP_B5  . . . . . . . . . . . .  	NUMBER	04B8	
BEEP_C4  . . . . . . . . . . . .  	NUMBER	11D1	
BEEP_C5  . . . . . . . . . . . .  	NUMBER	08E8	
BEEP_C6  . . . . . . . . . . . .  	NUMBER	0474	
BEEP_D5  . . . . . . . . . . . .  	NUMBER	07F0	
BEEP_DEFAULT . . . . . . . . . .  	ALIAS	 BEEP_A5		
BEEP_E5  . . . . . . . . . . . .  	NUMBER	0712	
BEEP_ERR_HIGH  . . . . . . . . .  	ALIAS	 BEEP_F5		
BEEP_ERR_LOW . . . . . . . . . .  	ALIAS	 BEEP_C5		
BEEP_F5  . . . . . . . . . . . .  	NUMBER	06AC	
BEEP_G5  . . . . . . . . . . . .  	NUMBER	05F2	
BEEP_L . . . . . . . . . . . . .  		0000	
BEEP_OFF_P . . . . . . . . . . .  	N PROC	E8F3	BIOS	Length = 0005
BEEP_ON_1  . . . . . . . . . . .  	N PROC	E8E4	BIOS	Length = 000F
BEEP_ON_P  . . . . . . . . . . .  	N PROC	E8DE	BIOS	Length = 0015
BEEP_PROC  . . . . . . . . . . .  	N PROC	E874	BIOS	Length = 0084
BEEP_S . . . . . . . . . . . . .  		0004	
BELL . . . . . . . . . . . . . .  	NUMBER	0007	
BIOS_BREAK . . . . . . . . . . .  	L BYTE	0071	_BDA
BIOS_INT_VECTORS_LOOP  . . . . .  	L NEAR	E1C9	BIOS
BIOS_ROM_SCAN  . . . . . . . . .  	N PROC	E4AA	BIOS	Length = 0043
BIOS_TOP . . . . . . . . . . . .  	N PROC	E000	BIOS	Length = 0059
BIOS_VIDEO . . . . . . . . . . .  	L NEAR	F61C	BIOS
BLACK  . . . . . . . . . . . . .  	NUMBER	0000	
BLOCK_LOOP . . . . . . . . . . .  	L NEAR	E50F	BIOS
BLOCK_LOOP_DONE  . . . . . . . .  	L NEAR	E51B	BIOS
BLUE . . . . . . . . . . . . . .  	NUMBER	0009	
BOOT . . . . . . . . . . . . . .  	N PROC	E05B	BIOS	Length = 03CD
BOOT_DEVICE  . . . . . . . . . .  	L NEAR	E40C	BIOS
BOOT_FAIL  . . . . . . . . . . .  	L BYTE	E42B	BIOS
BOOT_MEDIUM  . . . . . . . . . .  	NUMBER	004D	
BOOT_NORMAL  . . . . . . . . . .  	NUMBER	004E	
BOOT_RETRY . . . . . . . . . . .  	L NEAR	E40F	BIOS
BOOT_SPEED . . . . . . . . . . .  	ALIAS	 BOOT_NORMAL		
BOOT_TURBO . . . . . . . . . . .  	NUMBER	0054	
BROWN  . . . . . . . . . . . . .  	NUMBER	0006	
BS . . . . . . . . . . . . . . .  	NUMBER	0008	
BULL . . . . . . . . . . . . . .  	NUMBER	00F9	
BYTES_HERE_BOOT  . . . . . . . .  	NUMBER	0002	
BYTES_HERE_GFX_CHARSET . . . . .  	NUMBER	0122	
BYTES_HERE_INT_02  . . . . . . .  	NUMBER	0034	
BYTES_HERE_INT_08  . . . . . . .  	NUMBER	0000	
BYTES_HERE_INT_09  . . . . . . .  	NUMBER	000D	
BYTES_HERE_INT_0E  . . . . . . .  	NUMBER	0001	
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-11


BYTES_HERE_INT_10_JMP  . . . . .  	NUMBER	0000	
BYTES_HERE_INT_12  . . . . . . .  	NUMBER	00A2	
BYTES_HERE_INT_13  . . . . . . .  	NUMBER	0024	
BYTES_HERE_INT_14  . . . . . . .  	NUMBER	001B	
BYTES_HERE_INT_16  . . . . . . .  	NUMBER	0000	
BYTES_HERE_INT_19  . . . . . . .  	NUMBER	00E4	
BYTES_HERE_INT_1D  . . . . . . .  	NUMBER	0001	
BYTES_HERE_INT_1E  . . . . . . .  	NUMBER	0038	
BYTES_HERE_INT_RET . . . . . . .  	NUMBER	0002	
BYTES_HERE_POWER_ON  . . . . . .  	NUMBER	0001	
BYTES_HERE_VECTOR_TABLE  . . . .  	NUMBER	0003	
BYTES_HERE_VER . . . . . . . . .  	NUMBER	0000	
BYTE_HEX . . . . . . . . . . . .  	N PROC	F780	BIOS	Length = 001F

CASSETTE . . . . . . . . . . . .  	NUMBER	0000	
CAS_CRC  . . . . . . . . . . . .  	L WORD	0069	_BDA
CAS_PREV . . . . . . . . . . . .  	L BYTE	006B	_BDA
CAS_RELOCATE . . . . . . . . . .  	NUMBER	0000	
CAS_TIME_CNT . . . . . . . . . .  	L WORD	0067	_BDA
CGA_COLOR  . . . . . . . . . . .  	NUMBER	03D9	
CGA_CTRL . . . . . . . . . . . .  	NUMBER	03D8	
CGA_DATA . . . . . . . . . . . .  	NUMBER	03D5	
CGA_IDX  . . . . . . . . . . . .  	NUMBER	03D4	
CGA_MEM_40 . . . . . . . . . . .  	L BYTE	0000	_CGA_MEM	Length = 0800
CGA_MEM_80 . . . . . . . . . . .  	L BYTE	0800	_CGA_MEM	Length = 3800
CGA_MEM_FLD  . . . . . . . . . .  	NUMBER	2000	
CGA_MEM_SZ . . . . . . . . . . .  	NUMBER	4000	
CGA_PEN_RST  . . . . . . . . . .  	NUMBER	03DB	
CGA_SNOW_REMOVE  . . . . . . . .  	NUMBER	0000	
CGA_STAT . . . . . . . . . . . .  	NUMBER	03DA	
CGBG . . . . . . . . . . . . . .  		0000	
CGIN . . . . . . . . . . . . . .  		0003	
CGPH . . . . . . . . . . . . . .  		0006	
CGPL . . . . . . . . . . . . . .  		0005	
CGX  . . . . . . . . . . . . . .  		0004	
CHECKSUM_LOOP  . . . . . . . . .  	L NEAR	E4F6	BIOS
CHECK_ALT_ON . . . . . . . . . .  	L NEAR	EAAD	BIOS
CHECK_BASIC_ROM  . . . . . . . .  	L NEAR	E1D7	BIOS
CHECK_EGA  . . . . . . . . . . .  	L NEAR	F637	BIOS
CHECK_ROM  . . . . . . . . . . .  	L NEAR	E4AD	BIOS
CHECK_TOP_ROW_NUM  . . . . . . .  	L NEAR	EA9E	BIOS
CHECK_VGA  . . . . . . . . . . .  	L NEAR	F629	BIOS
CLEAR_POST_SCREEN  . . . . . . .  	L NEAR	E3F8	BIOS
COLD_BOOT  . . . . . . . . . . .  	NUMBER	0000	
COM  . . . . . . . . . . . . . .  		0009	
COM1_DATA  . . . . . . . . . . .  	NUMBER	03F8	
COM1_IER . . . . . . . . . . . .  	NUMBER	03F9	
COM1_IIR . . . . . . . . . . . .  	NUMBER	03FA	
COM1_LCR . . . . . . . . . . . .  	NUMBER	03FB	
COM1_LSR . . . . . . . . . . . .  	NUMBER	03FD	
COM1_MCR . . . . . . . . . . . .  	NUMBER	03FC	
COM1_MSR . . . . . . . . . . . .  	NUMBER	03FE	
COM1_SPR . . . . . . . . . . . .  	NUMBER	03FF	
COM2_DATA  . . . . . . . . . . .  	NUMBER	02F8	
COM2_IIR . . . . . . . . . . . .  	NUMBER	02FA	
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-12


COM3_DATA  . . . . . . . . . . .  	NUMBER	03E8	
COM3_IIR . . . . . . . . . . . .  	NUMBER	03EA	
COM4_DATA  . . . . . . . . . . .  	NUMBER	02E8	
COM4_IIR . . . . . . . . . . . .  	NUMBER	02EA	
COM_ADDR . . . . . . . . . . . .  	L WORD	0000	_BDA	Length = 0004
COM_DETECT_LOOP  . . . . . . . .  	L NEAR	E306	BIOS
COM_TIME . . . . . . . . . . . .  	L BYTE	007C	_BDA	Length = 0004
COM_TIME_B . . . . . . . . . . .  	NUMBER	007C	
COM_TO . . . . . . . . . . . . .  	NUMBER	0001	
COPYRIGHT  . . . . . . . . . . .  	L BYTE	E02F	BIOS
COPY_YEAR  . . . . . . . . . . .  	TEXT  '2022-25'		
CPU_8088 . . . . . . . . . . . .  	NUMBER	0038	
CPU_CHECK_TYPE_2 . . . . . . . .  	L NEAR	F653	BIOS
CPU_CHECK_TYPE_2_DONE  . . . . .  	L NEAR	F65D	BIOS
CPU_INST_TEST  . . . . . . . . .  	L NEAR	E082	BIOS
CPU_IS_V20 . . . . . . . . . . .  	L NEAR	E200	BIOS
CPU_REG_PASS . . . . . . . . . .  	L NEAR	E082	BIOS
CPU_REG_TEST . . . . . . . . . .  	L NEAR	E060	BIOS
CPU_TEST_PASS  . . . . . . . . .  	L NEAR	E09A	BIOS
CPU_TYPE . . . . . . . . . . . .  	ALIAS	 CPU_8088		
CPU_TYPE_8088  . . . . . . . . .  	L NEAR	E20E	BIOS
CPU_TYPE_DONE  . . . . . . . . .  	L NEAR	E20E	BIOS
CPU_V20  . . . . . . . . . . . .  	NUMBER	0056	
CR . . . . . . . . . . . . . . .  	NUMBER	000D	
CR0  . . . . . . . . . . . . . .  		0004	
CR1  . . . . . . . . . . . . . .  		0005	
CR2  . . . . . . . . . . . . . .  		0006	
CR3  . . . . . . . . . . . . . .  		0007	
CRLF . . . . . . . . . . . . . .  	N PROC	F745	BIOS	Length = 0009
CRLF_SHOW_CURSOR . . . . . . . .  	N PROC	F032	BIOS	Length = 0013
CRT_MODE . . . . . . . . . . . .  	L BYTE	F5F5	BIOS
CTBC . . . . . . . . . . . . . .  		0000	
CTBI . . . . . . . . . . . . . .  		0004	
CTIN . . . . . . . . . . . . . .  		0003	
CTX  . . . . . . . . . . . . . .  		0005	
CURL_BOT . . . . . . . . . . . .  	NUMBER	00F5	
CURL_TOP . . . . . . . . . . . .  	NUMBER	00F4	
CURSOR_DEFAULT . . . . . . . . .  	L WORD	00E8	_BDA
CYAN . . . . . . . . . . . . . .  	NUMBER	0003	

D4 . . . . . . . . . . . . . . .  		0004	
DACK . . . . . . . . . . . . . .  		0007	
DARKBLUE . . . . . . . . . . . .  	NUMBER	0001	
DARKGRAY . . . . . . . . . . . .  	NUMBER	0008	
DARKGREEN  . . . . . . . . . . .  	NUMBER	0002	
DARKMAGENTA  . . . . . . . . . .  	NUMBER	0005	
DARKRED  . . . . . . . . . . . .  	NUMBER	0004	
DBLARROW . . . . . . . . . . . .  	NUMBER	001D	
DCTS . . . . . . . . . . . . . .  		0000	
DDCD . . . . . . . . . . . . . .  		0003	
DDIS . . . . . . . . . . . . . .  		0002	
DDSR . . . . . . . . . . . . . .  		0001	
DETECT_MEMORY  . . . . . . . . .  	N PROC	E501	BIOS	Length = 0090
DETECT_MEMORY_ERR  . . . . . . .  	L NEAR	E562	BIOS
DETECT_MEMORY_ERR_2  . . . . . .  	L NEAR	E588	BIOS
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-13


DETECT_MEMORY_ERR_DONE . . . . .  	L NEAR	E58C	BIOS
DHLD . . . . . . . . . . . . . .  		0001	
DISABLE_NMI  . . . . . . . . . .  	L NEAR	E09A	BIOS
DLAB . . . . . . . . . . . . . .  		0007	
DM2M . . . . . . . . . . . . . .  		0000	
DMA  . . . . . . . . . . . . . .  		0008	
DMAI . . . . . . . . . . . . . .  		0004	
DMA_0_A  . . . . . . . . . . . .  	NUMBER	0000	
DMA_0_C  . . . . . . . . . . . .  	NUMBER	0001	
DMA_1_A  . . . . . . . . . . . .  	NUMBER	0002	
DMA_1_C  . . . . . . . . . . . .  	NUMBER	0003	
DMA_2_A  . . . . . . . . . . . .  	NUMBER	0004	
DMA_2_C  . . . . . . . . . . . .  	NUMBER	0005	
DMA_3_A  . . . . . . . . . . . .  	NUMBER	0006	
DMA_3_C  . . . . . . . . . . . .  	NUMBER	0007	
DMA_CMD  . . . . . . . . . . . .  	NUMBER	0008	
DMA_FF . . . . . . . . . . . . .  	NUMBER	000C	
DMA_MASK . . . . . . . . . . . .  	NUMBER	000A	
DMA_MASKR  . . . . . . . . . . .  	NUMBER	000E	
DMA_MMASK  . . . . . . . . . . .  	NUMBER	000F	
DMA_MODE . . . . . . . . . . . .  	NUMBER	000B	
DMA_PASS . . . . . . . . . . . .  	L NEAR	E101	BIOS
DMA_P_C0 . . . . . . . . . . . .  	NUMBER	0087	
DMA_P_C1 . . . . . . . . . . . .  	NUMBER	0083	
DMA_P_C2 . . . . . . . . . . . .  	NUMBER	0081	
DMA_P_C3 . . . . . . . . . . . .  	NUMBER	0082	
DMA_REQ  . . . . . . . . . . . .  	NUMBER	0009	
DMA_RESET  . . . . . . . . . . .  	NUMBER	000D	
DMA_SETUP_CH . . . . . . . . . .  	L NEAR	E11C	BIOS
DMA_STATUS_OK  . . . . . . . . .  	L NEAR	E3B5	BIOS
DMCH . . . . . . . . . . . . . .  		0000	
DMINC  . . . . . . . . . . . . .  		0005	
DMM  . . . . . . . . . . . . . .  		0006	
DMOP . . . . . . . . . . . . . .  		0002	
DONE_ZERO_ALL_RAM  . . . . . . .  	L NEAR	E560	BIOS
DOS_FD_PARAM . . . . . . . . . .  	L BYTE	0022	_DOS_DAT	Length = 000E
DOT  . . . . . . . . . . . . . .  	NUMBER	00FA	
DPRI . . . . . . . . . . . . . .  		0004	
DRAM_REFRESH . . . . . . . . . .  	NUMBER	0012	
DREQ . . . . . . . . . . . . . .  		0006	
DRI  . . . . . . . . . . . . . .  		0002	
DTIM . . . . . . . . . . . . . .  		0003	
DTR  . . . . . . . . . . . . . .  		0000	
DWORD_HEX  . . . . . . . . . . .  	N PROC	F76D	BIOS	Length = 0032
DWS  . . . . . . . . . . . . . .  		0005	

EKB_FLAGS1 . . . . . . . . . . .  	L BYTE	0096	_BDA
EKB_FLAGS2 . . . . . . . . . . .  	L BYTE	0097	_BDA
EOI  . . . . . . . . . . . . . .  	NUMBER	0020	
EQUIP_FLAGS  . . . . . . . . . .  	L WORD	0010	_BDA
ESMM . . . . . . . . . . . . . .  		0005	
EXP_UNIT . . . . . . . . . . . .  	NUMBER	0001	
EXP_UNIT_CTRL  . . . . . . . . .  	NUMBER	0213	

F0SK . . . . . . . . . . . . . .  		0000	
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-14


F1SK . . . . . . . . . . . . . .  		0001	
F2SK . . . . . . . . . . . . . .  		0002	
F3SK . . . . . . . . . . . . . .  		0003	
FAF  . . . . . . . . . . . . . .  		0004	
FC0CMD . . . . . . . . . . . . .  		0000	
FC0MF  . . . . . . . . . . . . .  		0006	
FC0MT  . . . . . . . . . . . . .  		0007	
FC0SK  . . . . . . . . . . . . .  		0005	
FC1DS  . . . . . . . . . . . . .  		0000	
FC1HD  . . . . . . . . . . . . .  		0002	
FC1X . . . . . . . . . . . . . .  		0003	
FCAL0  . . . . . . . . . . . . .  		0000	
FCAL1  . . . . . . . . . . . . .  		0001	
FCAL2  . . . . . . . . . . . . .  		0002	
FCAL3  . . . . . . . . . . . . .  		0003	
FCF  . . . . . . . . . . . . . .  		0000	
FDCEN  . . . . . . . . . . . . .  		0002	
FDC_ADV_SEEK . . . . . . . . . .  	NUMBER	0001	
FDC_A_STAT . . . . . . . . . . .  	NUMBER	03F0	
FDC_B_STAT . . . . . . . . . . .  	NUMBER	03F1	
FDC_CHECK_SEEK . . . . . . . . .  	L NEAR	EDF5	BIOS
FDC_CMD_FMT  . . . . . . . . . .  	NUMBER	000D	
FDC_CMD_RD . . . . . . . . . . .  	NUMBER	0006	
FDC_CMD_RDEL . . . . . . . . . .  	NUMBER	000C	
FDC_CMD_RECAL  . . . . . . . . .  	NUMBER	0007	
FDC_CMD_RSID . . . . . . . . . .  	NUMBER	000A	
FDC_CMD_RTRK . . . . . . . . . .  	NUMBER	0002	
FDC_CMD_SEEK . . . . . . . . . .  	NUMBER	000F	
FDC_CMD_SENSE  . . . . . . . . .  	NUMBER	0008	
FDC_CMD_SPEC . . . . . . . . . .  	NUMBER	0003	
FDC_CMD_STAT . . . . . . . . . .  	NUMBER	0004	
FDC_CMD_WDEL . . . . . . . . . .  	NUMBER	0009	
FDC_CMD_WR . . . . . . . . . . .  	NUMBER	0005	
FDC_CTRL . . . . . . . . . . . .  	NUMBER	03F2	
FDC_DATA . . . . . . . . . . . .  	NUMBER	03F5	
FDC_DMA_BOUND  . . . . . . . . .  	L NEAR	ECE9	BIOS
FDC_DRIVE_STARTED  . . . . . . .  	L NEAR	EE65	BIOS
FDC_ENABLE . . . . . . . . . . .  	NUMBER	0000	
FDC_ERR1_MAP . . . . . . . . . .  	L BYTE	EF40	BIOS
FDC_ERR_MAP_LOOP . . . . . . . .  	L NEAR	EF33	BIOS
FDC_ERR_SEC_CT . . . . . . . . .  	NUMBER	0000	
FDC_FORMAT . . . . . . . . . . .  	N PROC	EDCD	BIOS	Length = 001B
FDC_FORMAT_ERR . . . . . . . . .  	L NEAR	EDCA	BIOS
FDC_HLT_WAIT . . . . . . . . . .  	NUMBER	0001	
FDC_INIT_DMA . . . . . . . . . .  	L NEAR	ED0C	BIOS
FDC_INIT_DMA_EXIT  . . . . . . .  	L NEAR	ED4D	BIOS
FDC_IPL_SW . . . . . . . . . . .  	NUMBER	0001	
FDC_LAST_ST  . . . . . . . . . .  	L 0007	0042	_BDA
FDC_MOTOR_ON . . . . . . . . . .  	L NEAR	EE35	BIOS
FDC_RECAL  . . . . . . . . . . .  	N PROC	EE34	BIOS	Length = 005E
FDC_RECAL_DONE . . . . . . . . .  	L NEAR	EE90	BIOS
FDC_RECAL_ERR  . . . . . . . . .  	L NEAR	EE90	BIOS
FDC_RECV . . . . . . . . . . . .  	N PROC	EE92	BIOS	Length = 004B
FDC_RECV_ALL . . . . . . . . . .  	N PROC	EEE9	BIOS	Length = 0032
FDC_RECV_ALL_DONE  . . . . . . .  	L NEAR	EF0D	BIOS
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-15


FDC_RECV_ALL_LOOP  . . . . . . .  	L NEAR	EEF6	BIOS
FDC_RECV_CHECK_ERR . . . . . . .  	L NEAR	EF08	BIOS
FDC_RECV_DELAY . . . . . . . . .  	L NEAR	EEFE	BIOS
FDC_RECV_FDC_ERR . . . . . . . .  	L NEAR	EF12	BIOS
FDC_RECV_READY . . . . . . . . .  	L NEAR	EEC2	BIOS
FDC_RECV_STATUS  . . . . . . . .  	N PROC	EEE7	BIOS	Length = 0034
FDC_RECV_WAIT_POLL . . . . . . .  	L NEAR	EEBE	BIOS
FDC_RWV  . . . . . . . . . . . .  	N PROC	ED7A	BIOS	Length = 004D
FDC_RWVF . . . . . . . . . . . .  	L NEAR	ED60	BIOS
FDC_RWV_ERR  . . . . . . . . . .  	L NEAR	EDCA	BIOS
FDC_RWV_SEND_WAIT  . . . . . . .  	L NEAR	EDA8	BIOS
FDC_SEC_COUNT  . . . . . . . . .  	L NEAR	EDB2	BIOS
FDC_SEC_COUNT_SAME . . . . . . .  	L NEAR	EDC5	BIOS
FDC_SEC_COUNT_SAME_CYL . . . . .  	L NEAR	EDC3	BIOS
FDC_SEEK . . . . . . . . . . . .  	N PROC	EDE8	BIOS	Length = 004C
FDC_SEEK_DONE  . . . . . . . . .  	L NEAR	EE2B	BIOS
FDC_SEEK_ERR . . . . . . . . . .  	L NEAR	EE2E	BIOS
FDC_SEEK_RECAL_ERR . . . . . . .  	L NEAR	EE2E	BIOS
FDC_SEEK_SETTLE  . . . . . . . .  	L NEAR	EE21	BIOS
FDC_SEND . . . . . . . . . . . .  	N PROC	EE9A	BIOS	Length = 0043
FDC_SEND_PARAM . . . . . . . . .  	N PROC	EE97	BIOS	Length = 0046
FDC_SEND_READY . . . . . . . . .  	L NEAR	EEB9	BIOS
FDC_SEND_RECV  . . . . . . . . .  	L NEAR	EE9D	BIOS
FDC_SEND_WAIT_POLL . . . . . . .  	L NEAR	EEAB	BIOS
FDC_SEND_WAIT_POLL_1 . . . . . .  	L NEAR	EEB5	BIOS
FDC_SEND_WAIT_TIMER  . . . . . .  	L NEAR	EEC9	BIOS
FDC_STAT . . . . . . . . . . . .  	NUMBER	03F4	
FDC_ST_BADCMD  . . . . . . . . .  	NUMBER	0001	
FDC_ST_DISK_CHG  . . . . . . . .  	NUMBER	0006	
FDC_ST_DMA_64K . . . . . . . . .  	NUMBER	0009	
FDC_ST_DMA_OVR . . . . . . . . .  	NUMBER	0008	
FDC_ST_ERR_CRC . . . . . . . . .  	NUMBER	0010	
FDC_ST_ERR_FDC . . . . . . . . .  	NUMBER	0020	
FDC_ST_ERR_MARK  . . . . . . . .  	NUMBER	0002	
FDC_ST_ERR_MED . . . . . . . . .  	NUMBER	000C	
FDC_ST_ERR_SEC . . . . . . . . .  	NUMBER	0004	
FDC_ST_ERR_SEEK  . . . . . . . .  	NUMBER	0040	
FDC_ST_ERR_WP  . . . . . . . . .  	NUMBER	0003	
FDC_ST_OK  . . . . . . . . . . .  	NUMBER	0000	
FDC_ST_SENSE . . . . . . . . . .  	NUMBER	00FF	
FDC_ST_TIMEOUT . . . . . . . . .  	NUMBER	0080	
FDC_WAIT_DONE  . . . . . . . . .  	L NEAR	EEC3	BIOS
FDC_WAIT_ERR_EXIT  . . . . . . .  	L NEAR	EF3C	BIOS
FDC_WAIT_ERR_EXIT_OK . . . . . .  	L NEAR	EF3F	BIOS
FDC_WAIT_EXIT  . . . . . . . . .  	L NEAR	EEC5	BIOS
FDC_WAIT_INT . . . . . . . . . .  	N PROC	EF6A	BIOS	Length = 0025
FDC_WAIT_INT_DONE  . . . . . . .  	L NEAR	EF8C	BIOS
FDC_WAIT_INT_LOOP1 . . . . . . .  	L NEAR	EF70	BIOS
FDC_WAIT_INT_LOOP2 . . . . . . .  	L NEAR	EF73	BIOS
FDC_WAIT_INT_OK  . . . . . . . .  	L NEAR	EF88	BIOS
FDC_WAIT_SENSE . . . . . . . . .  	N PROC	EEDD	BIOS	Length = 003E
FDC_WAIT_SENSE_EXIT  . . . . . .  	L NEAR	EF11	BIOS
FDC_WAIT_STATUS  . . . . . . . .  	N PROC	EF1B	BIOS	Length = 002D
FDC_WAIT_STATUS_ERR  . . . . . .  	N PROC	EF23	BIOS	Length = 0025
FDC_WAIT_STATUS_ERR_DONE . . . .  	L NEAR	EF3A	BIOS
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-16


FDC_WAIT_TIMEOUT . . . . . . . .  	L NEAR	EED4	BIOS
FDC_ZERO_BDA . . . . . . . . . .  	NUMBER	0000	
FDDMA  . . . . . . . . . . . . .  		0003	
FDDS . . . . . . . . . . . . . .  		0005	
FDMA . . . . . . . . . . . . . .  		0004	
FDMB . . . . . . . . . . . . . .  		0005	
FDMC . . . . . . . . . . . . . .  		0006	
FDMD . . . . . . . . . . . . . .  		0007	
FDND . . . . . . . . . . . . . .  		0005	
FDRR . . . . . . . . . . . . . .  		0007	
FDRW . . . . . . . . . . . . . .  		0004	
FDSEL  . . . . . . . . . . . . .  		0000	
FDX  . . . . . . . . . . . . . .  		0003	
FD_AUTO_DETECT . . . . . . . . .  	NUMBER	0000	
FD_CAL_ST  . . . . . . . . . . .  	L BYTE	003E	_BDA
FD_CAL_ST_ABS  . . . . . . . . .  	L BYTE	043E	_BDA_ABS
FD_LAST_OP . . . . . . . . . . .  	L BYTE	0041	_BDA
FD_LR  . . . . . . . . . . . . .  	L BYTE	008B	_BDA
FD_MEDIA_ST  . . . . . . . . . .  	L BYTE	0090	_BDA	Length = 0004
FD_MODE  . . . . . . . . . . . .  	L BYTE	008F	_BDA
FD_MOTOR_CT  . . . . . . . . . .  	L BYTE	0040	_BDA
FD_MOTOR_CT_ABS  . . . . . . . .  	L BYTE	0440	_BDA_ABS
FD_MOTOR_ST  . . . . . . . . . .  	L BYTE	003F	_BDA
FD_TRACK . . . . . . . . . . . .  	L BYTE	0094	_BDA	Length = 0002
FE2010_CONF_REG  . . . . . . . .  	L BYTE	00EC	_BDA
FIELD_EVEN . . . . . . . . . . .  	L NEAR	F550	BIOS
FIOD . . . . . . . . . . . . . .  		0006	
FLP  . . . . . . . . . . . . . .  		0006	
FM08 . . . . . . . . . . . . . .  		0000	
FM0D . . . . . . . . . . . . . .  		0002	
FM0M . . . . . . . . . . . . . .  		0001	
FM0X . . . . . . . . . . . . . .  		0003	
FM18 . . . . . . . . . . . . . .  		0004	
FM1D . . . . . . . . . . . . . .  		0006	
FM1M . . . . . . . . . . . . . .  		0005	
FM1X . . . . . . . . . . . . . .  		0007	
FMOT . . . . . . . . . . . . . .  		0000	
FMOT0  . . . . . . . . . . . . .  		0000	
FMOT1  . . . . . . . . . . . . .  		0001	
FMOT2  . . . . . . . . . . . . .  		0002	
FMOT3  . . . . . . . . . . . . .  		0003	
FMOTX  . . . . . . . . . . . . .  		0004	
FMTBD  . . . . . . . . . . . . .  		0004	
FOUND_ROM  . . . . . . . . . . .  	L NEAR	E4BC	BIOS
FPF  . . . . . . . . . . . . . .  		0002	
FPU  . . . . . . . . . . . . . .  		0001	
FPU_CHECK  . . . . . . . . . . .  	L NEAR	F663	BIOS
FPU_DISP_DONE  . . . . . . . . .  	L NEAR	F675	BIOS
FPU_TEST_CW  . . . . . . . . . .  	L NEAR	FFD2	BIOS
FPU_TEST_DONE  . . . . . . . . .  	L NEAR	FFDE	BIOS
FPU_TEST_SW  . . . . . . . . . .  	L NEAR	FFC6	BIOS
FR1  . . . . . . . . . . . . . .  		0005	
FR2  . . . . . . . . . . . . . .  		0003	
FR3  . . . . . . . . . . . . . .  		0001	
FSD  . . . . . . . . . . . . . .  		0000	
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-17


FSE  . . . . . . . . . . . . . .  		0004	
FSF  . . . . . . . . . . . . . .  		0007	
FSR  . . . . . . . . . . . . . .  		0006	
FSTBD  . . . . . . . . . . . . .  		0004	
FWIF . . . . . . . . . . . . . .  		0007	
FWRT . . . . . . . . . . . . . .  		0007	
FZF  . . . . . . . . . . . . . .  		0006	

GAM  . . . . . . . . . . . . . .  		000C	
GAME_CTRL  . . . . . . . . . . .  	NUMBER	0201	
GB_FLAGS . . . . . . . . . . . .  	L BYTE	0012	_BDA
GET_SW_SETTINGS  . . . . . . . .  	L NEAR	E20E	BIOS
GFX_CHARSET  . . . . . . . . . .  	L BYTE	FA6E	BIOS
GRAY . . . . . . . . . . . . . .  	NUMBER	0007	
GREEN  . . . . . . . . . . . . .  	NUMBER	000A	
GRND . . . . . . . . . . . . . .  		0000	
GTBD1  . . . . . . . . . . . . .  		0004	
GTBD2  . . . . . . . . . . . . .  		0000	

HALF . . . . . . . . . . . . . .  	NUMBER	00AB	
HALT_BEEP  . . . . . . . . . . .  	N PROC	E874	BIOS	Length = 003C
HALT_BEEP_1  . . . . . . . . . .  	L NEAR	E155	BIOS
HALT_BEEP_2  . . . . . . . . . .  	L NEAR	E254	BIOS
HALT_BEEP_REP  . . . . . . . . .  	L NEAR	E887	BIOS
HALT_BEEP_START  . . . . . . . .  	L NEAR	E87E	BIOS
HALT_BEEP_START_ODD  . . . . . .  	L NEAR	E885	BIOS
HALT_ERROR . . . . . . . . . . .  	L NEAR	E0EA	BIOS
HAS_FPU  . . . . . . . . . . . .  	N PROC	FFC3	BIOS	Length = 001D
HBN  . . . . . . . . . . . . . .  		0004	
HDC_CTRL . . . . . . . . . . . .  	NUMBER	0321	
HDC_DMA  . . . . . . . . . . . .  	NUMBER	0323	
HDC_PULSE  . . . . . . . . . . .  	NUMBER	0322	
HDC_READ . . . . . . . . . . . .  	NUMBER	0320	
HDC_STAT . . . . . . . . . . . .  	NUMBER	0324	
HDD_POST . . . . . . . . . . . .  	N PROC	E3CB	BIOS	Length = 0003
HDD_POST_DONE  . . . . . . . . .  	L NEAR	E3CE	BIOS
HD_COUNT . . . . . . . . . . . .  	L BYTE	0075	_BDA
HD_CTRL  . . . . . . . . . . . .  	L BYTE	0076	_BDA
HD_LAST_ST . . . . . . . . . . .  	L BYTE	0074	_BDA
HD_PORT  . . . . . . . . . . . .  	L BYTE	0077	_BDA
HEART  . . . . . . . . . . . . .  	NUMBER	0003	
HELLO_WORLD  . . . . . . . . . .  	L NEAR	E263	BIOS
HIDE_CURSOR  . . . . . . . . . .  	N PROC	F03B	BIOS	Length = 000A
HL . . . . . . . . . . . . . . .  	NUMBER	00C4	
HWB  . . . . . . . . . . . . . .  		0008	

IC4  . . . . . . . . . . . . . .  		0000	
ICW2IVA  . . . . . . . . . . . .  		0003	
ICW2X  . . . . . . . . . . . . .  		0000	
ICWBUF . . . . . . . . . . . . .  		0002	
INIT_AT_KBC  . . . . . . . . . .  	NUMBER	0000	
INIT_DMA1  . . . . . . . . . . .  	L NEAR	E0BF	BIOS
INIT_EXP_CHASSIS . . . . . . . .  	L NEAR	E121	BIOS
INIT_EXP_CHASSIS_DONE  . . . . .  	L NEAR	E127	BIOS
INIT_PIT1  . . . . . . . . . . .  	L NEAR	E0EC	BIOS
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-18


INIT_PIT1_TEST . . . . . . . . .  	L NEAR	E0D2	BIOS
INIT_PIT1_TEST_DONE  . . . . . .  	L NEAR	E0EC	BIOS
INIT_PIT1_TEST_READ  . . . . . .  	L NEAR	E0DA	BIOS
INIT_ROM_BASIC_DONE  . . . . . .  	L NEAR	E1F9	BIOS
INIT_ROM_BASIC_SEG . . . . . . .  	L NEAR	E1CD	BIOS
INIT_SW_INT_VECTORS  . . . . . .  	L NEAR	E1C0	BIOS
INIT_V40 . . . . . . . . . . . .  	NUMBER	0000	
INIT_VIDEO . . . . . . . . . . .  	L NEAR	E09E	BIOS
INT_02 . . . . . . . . . . . . .  	N PROC	E2C3	BIOS	Length = 0020
INT_02_NMI_HALT  . . . . . . . .  	L NEAR	E2D5	BIOS
INT_02_NMI_PAR . . . . . . . . .  	L NEAR	E2CC	BIOS
INT_05 . . . . . . . . . . . . .  	N PROC	FF54	BIOS	Length = 006F
INT_05_DONE  . . . . . . . . . .  	L NEAR	FF9A	BIOS
INT_05_EXIT  . . . . . . . . . .  	L NEAR	FFA6	BIOS
INT_05_LOOP_1  . . . . . . . . .  	L NEAR	FF7C	BIOS
INT_05_NEXT_COL  . . . . . . . .  	L NEAR	FF94	BIOS
INT_08 . . . . . . . . . . . . .  	N PROC	FEA5	BIOS	Length = 003B
INT_08_EOI . . . . . . . . . . .  	L NEAR	FEC7	BIOS
INT_08_FD_MOTOR  . . . . . . . .  	L NEAR	FEBE	BIOS
INT_08_INT_1C  . . . . . . . . .  	L NEAR	FEC5	BIOS
INT_08_MOTOR_OFF . . . . . . . .  	L NEAR	FE97	BIOS
INT_08_PROC  . . . . . . . . . .  	N PROC	FE97	BIOS	Length = 0049
INT_08_RESET . . . . . . . . . .  	L NEAR	FED6	BIOS
INT_08_TICK_DAY  . . . . . . . .  	L NEAR	FED1	BIOS
INT_08_TICK_TIMER  . . . . . . .  	L NEAR	FEAF	BIOS
INT_09 . . . . . . . . . . . . .  	N PROC	E987	BIOS	Length = 02AE
INT_09_POST  . . . . . . . . . .  	N PROC	E937	BIOS	Length = 001B
INT_09_POST_DONE . . . . . . . .  	L NEAR	E946	BIOS
INT_0E . . . . . . . . . . . . .  	N PROC	EF57	BIOS	Length = 0013
INT_10 . . . . . . . . . . . . .  	N PROC	F065	BIOS	Length = 0598
INT_10_0 . . . . . . . . . . . .  	N PROC	F0E4	BIOS	Length = 00BC
INT_10_0_1 . . . . . . . . . . .  	L NEAR	F0F2	BIOS
INT_10_0_COLOR_BYTE  . . . . . .  	L NEAR	F187	BIOS
INT_10_0_CRTC_LOOP . . . . . . .  	L NEAR	F177	BIOS
INT_10_0_DETECT_DONE . . . . . .  	L NEAR	F147	BIOS
INT_10_0_IS_40_COL . . . . . . .  	L NEAR	F145	BIOS
INT_10_0_IS_CGA  . . . . . . . .  	L NEAR	F121	BIOS
INT_10_0_IS_CGA_GFX  . . . . . .  	L NEAR	F12E	BIOS
INT_10_0_IS_CGA_TEXT . . . . . .  	L NEAR	F13C	BIOS
INT_10_1 . . . . . . . . . . . .  	N PROC	F1A0	BIOS	Length = 0016
INT_10_2 . . . . . . . . . . . .  	N PROC	F1B6	BIOS	Length = 0039
INT_10_2_DONE  . . . . . . . . .  	L NEAR	F1ED	BIOS
INT_10_3 . . . . . . . . . . . .  	N PROC	F1FC	BIOS	Length = 0011
INT_10_3_CUR_PAGE  . . . . . . .  	N PROC	F1EF	BIOS	Length = 001E
INT_10_4 . . . . . . . . . . . .  	N PROC	F8CC	BIOS	Length = 0080
INT_10_4_CAL_1 . . . . . . . . .  	L NEAR	F907	BIOS
INT_10_4_CAL_2 . . . . . . . . .  	L NEAR	F908	BIOS
INT_10_4_CAL_DONE  . . . . . . .  	L NEAR	F90E	BIOS
INT_10_4_DONE  . . . . . . . . .  	L NEAR	F924	BIOS
INT_10_4_EXIT  . . . . . . . . .  	L NEAR	F92A	BIOS
INT_10_4_GFX . . . . . . . . . .  	L NEAR	F92D	BIOS
INT_10_4_LOW . . . . . . . . . .  	L NEAR	F93E	BIOS
INT_10_4_RESET . . . . . . . . .  	L NEAR	F926	BIOS
INT_10_4_TXT . . . . . . . . . .  	L NEAR	F912	BIOS
INT_10_5 . . . . . . . . . . . .  	N PROC	F20D	BIOS	Length = 0027
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-19


INT_10_6 . . . . . . . . . . . .  	N PROC	F235	BIOS	Length = 010F
INT_10_6_CHECK_CLS . . . . . . .  	L NEAR	F294	BIOS
INT_10_6_DONE  . . . . . . . . .  	L NEAR	F2B9	BIOS
INT_10_6_TXT_CLR . . . . . . . .  	L NEAR	F2AC	BIOS
INT_10_6_TXT_CLR_1 . . . . . . .  	L NEAR	F2AA	BIOS
INT_10_6_TXT_CLR_LOOP  . . . . .  	L NEAR	F2AE	BIOS
INT_10_6_TXT_MOVE_LOOP . . . . .  	L NEAR	F29E	BIOS
INT_10_7 . . . . . . . . . . . .  	N PROC	F234	BIOS	Length = 0110
INT_10_8 . . . . . . . . . . . .  	N PROC	F344	BIOS	Length = 009B
INT_10_8_CHK_CGA . . . . . . . .  	L NEAR	F352	BIOS
INT_10_8_FAST  . . . . . . . . .  	L NEAR	F34E	BIOS
INT_10_8_GFX_DONE  . . . . . . .  	L NEAR	F3C9	BIOS
INT_10_8_GFX_HIGH  . . . . . . .  	L NEAR	F3D1	BIOS
INT_10_8_GFX_LOW_1 . . . . . . .  	L NEAR	F376	BIOS
INT_10_8_GFX_LOW_2 . . . . . . .  	L NEAR	F382	BIOS
INT_10_8_GFX_SEARCH  . . . . . .  	L NEAR	F398	BIOS
INT_10_8_GFX_SEARCH_CHR  . . . .  	L NEAR	F3A6	BIOS
INT_10_8_GFX_SEARCH_TBL  . . . .  	L NEAR	F3A3	BIOS
INT_10_8_MODE_GFX  . . . . . . .  	N PROC	F358	BIOS	Length = 0087
INT_10_8_MODE_GFX_LOW  . . . . .  	L NEAR	F374	BIOS
INT_10_9 . . . . . . . . . . . .  	N PROC	F3DF	BIOS	Length = 00E4
INT_10_9A_FAST . . . . . . . . .  	L NEAR	F3EB	BIOS
INT_10_9A_GFX_2  . . . . . . . .  	L NEAR	F425	BIOS
INT_10_9A_GFX_FG . . . . . . . .  	L NEAR	F438	BIOS
INT_10_9A_GFX_HIGH . . . . . . .  	L NEAR	F489	BIOS
INT_10_9A_GFX_HIGH_WORD  . . . .  	L NEAR	F48D	BIOS
INT_10_9A_GFX_HIGH_WR  . . . . .  	L NEAR	F49A	BIOS
INT_10_9A_GFX_LOW  . . . . . . .  	L NEAR	F433	BIOS
INT_10_9A_GFX_LOW_BYTE . . . . .  	L NEAR	F44A	BIOS
INT_10_9A_GFX_LOW_CHAR . . . . .  	L NEAR	F444	BIOS
INT_10_9A_GFX_LOW_NEXT . . . . .  	L NEAR	F479	BIOS
INT_10_9A_GFX_LOW_PDEP . . . . .  	L NEAR	F451	BIOS
INT_10_9A_GFX_LOW_WR . . . . . .  	L NEAR	F469	BIOS
INT_10_9A_MODE_GFX . . . . . . .  	N PROC	F404	BIOS	Length = 00BF
INT_10_9A_MODE_GFX_DONE  . . . .  	L NEAR	F482	BIOS
INT_10_9A_MODE_GFX_EXIT  . . . .  	L NEAR	F487	BIOS
INT_10_9_FAST  . . . . . . . . .  	L NEAR	F3F7	BIOS
INT_10_A . . . . . . . . . . . .  	N PROC	F3DF	BIOS	Length = 00E4
INT_10_A_FAST  . . . . . . . . .  	L NEAR	F3F1	BIOS
INT_10_B . . . . . . . . . . . .  	N PROC	F4C3	BIOS	Length = 002B
INT_10_BOUNDS_OK . . . . . . . .  	L NEAR	F253	BIOS
INT_10_B_DONE  . . . . . . . . .  	L NEAR	F4DD	BIOS
INT_10_B_SET_COL . . . . . . . .  	L NEAR	F4CB	BIOS
INT_10_B_SET_PAL . . . . . . . .  	L NEAR	F4D2	BIOS
INT_10_C . . . . . . . . . . . .  	N PROC	F4EE	BIOS	Length = 0021
INT_10_CGA_CHECK . . . . . . . .  	L NEAR	F294	BIOS
INT_10_CHECK_BOUNDS  . . . . . .  	L NEAR	F249	BIOS
INT_10_CHK_CGA . . . . . . . . .  	L NEAR	F3FD	BIOS
INT_10_C_DONE  . . . . . . . . .  	L NEAR	F507	BIOS
INT_10_C_XOR . . . . . . . . . .  	L NEAR	F50A	BIOS
INT_10_D . . . . . . . . . . . .  	N PROC	F50F	BIOS	Length = 000D
INT_10_DONE  . . . . . . . . . .  	L NEAR	F081	BIOS
INT_10_E . . . . . . . . . . . .  	N PROC	F55F	BIOS	Length = 006A
INT_10_E_BELL  . . . . . . . . .  	L NEAR	F5B6	BIOS
INT_10_E_BS  . . . . . . . . . .  	L NEAR	F5C3	BIOS
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-20


INT_10_E_CHAR  . . . . . . . . .  	L NEAR	F56A	BIOS
INT_10_E_CR  . . . . . . . . . .  	L NEAR	F5BB	BIOS
INT_10_E_CTRL  . . . . . . . . .  	L NEAR	F5A8	BIOS
INT_10_E_CURS  . . . . . . . . .  	L NEAR	F5A0	BIOS
INT_10_E_DONE  . . . . . . . . .  	L NEAR	F5A3	BIOS
INT_10_E_LF  . . . . . . . . . .  	L NEAR	F5BF	BIOS
INT_10_E_SCROLL  . . . . . . . .  	L NEAR	F57B	BIOS
INT_10_E_SCROLL_UP . . . . . . .  	L NEAR	F58B	BIOS
INT_10_F . . . . . . . . . . . .  	N PROC	F5C9	BIOS	Length = 0008
INT_10_GET_CUR_ADDR  . . . . . .  	N PROC	F5D1	BIOS	Length = 0024
INT_10_GFX_CHARPOS . . . . . . .  	N PROC	F4AE	BIOS	Length = 0015
INT_10_GFX_PIXEL . . . . . . . .  	N PROC	F51C	BIOS	Length = 0043
INT_10_IRET  . . . . . . . . . .  	L NEAR	F084	BIOS
INT_10_IS_CGA80  . . . . . . . .  	N PROC	F090	BIOS	Length = 0013
INT_10_IS_CGA80_DONE . . . . . .  	L NEAR	F0A0	BIOS
INT_10_IS_TXT  . . . . . . . . .  	N PROC	F085	BIOS	Length = 000B
INT_10_IS_TXT_DONE . . . . . . .  	L NEAR	F08F	BIOS
INT_10_JMP . . . . . . . . . . .  	L WORD	F045	BIOS
INT_10_RET . . . . . . . . . . .  	L NEAR	F19F	BIOS
INT_10_SCR_GFX . . . . . . . . .  	N PROC	F2BE	BIOS	Length = 0086
INT_10_SCR_GFX_2 . . . . . . . .  	L NEAR	F2E7	BIOS
INT_10_SCR_GFX_CLR . . . . . . .  	L NEAR	F327	BIOS
INT_10_SCR_GFX_CLR_1 . . . . . .  	L NEAR	F325	BIOS
INT_10_SCR_GFX_CLR_LOOP  . . . .  	L NEAR	F32B	BIOS
INT_10_SCR_GFX_MOVE_LOOP . . . .  	L NEAR	F307	BIOS
INT_10_SCR_GFX_RDY . . . . . . .  	L NEAR	F2F0	BIOS
INT_10_SCR_TXT . . . . . . . . .  	L NEAR	F261	BIOS
INT_10_SET_CUR_OFFSET  . . . . .  	L NEAR	F1CD	BIOS
INT_11 . . . . . . . . . . . . .  	N PROC	F84D	BIOS	Length = 000C
INT_12 . . . . . . . . . . . . .  	N PROC	F841	BIOS	Length = 000C
INT_13 . . . . . . . . . . . . .  	N PROC	EC59	BIOS	Length = 0336
INT_13_0 . . . . . . . . . . . .  	N PROC	EC98	BIOS	Length = 004B
INT_13_0_1 . . . . . . . . . . .  	L NEAR	ECAD	BIOS
INT_13_0_2 . . . . . . . . . . .  	L NEAR	ECB3	BIOS
INT_13_0_DONE  . . . . . . . . .  	L NEAR	ECDF	BIOS
INT_13_0_RESET_BAD . . . . . . .  	L NEAR	ECC6	BIOS
INT_13_0_RESET_DONE  . . . . . .  	L NEAR	ECC8	BIOS
INT_13_1 . . . . . . . . . . . .  	N PROC	ECE3	BIOS	Length = 0006
INT_13_2_5 . . . . . . . . . . .  	N PROC	ECEF	BIOS	Length = 00F9
INT_13_2_5_EXIT  . . . . . . . .  	L NEAR	EDC7	BIOS
INT_13_2_5_SEEK_ERR  . . . . . .  	L NEAR	ED4E	BIOS
INT_13_2_5_SETUP_DMA . . . . . .  	L NEAR	ED05	BIOS
INT_13_BAD_CMD . . . . . . . . .  	L NEAR	EC7E	BIOS
INT_13_DONE  . . . . . . . . . .  	L NEAR	EC80	BIOS
INT_13_EXIT  . . . . . . . . . .  	L NEAR	EC8C	BIOS
INT_13_EXIT_1  . . . . . . . . .  	L NEAR	EC8F	BIOS
INT_13_SET_MOTOR_CT  . . . . . .  	L NEAR	EC82	BIOS
INT_14 . . . . . . . . . . . . .  	N PROC	E739	BIOS	Length = 00B2
INT_14_0 . . . . . . . . . . . .  	N PROC	E761	BIOS	Length = 0036
INT_14_0_SET_BAUD  . . . . . . .  	L NEAR	E779	BIOS
INT_14_0_SET_PSW . . . . . . . .  	L NEAR	E77C	BIOS
INT_14_1 . . . . . . . . . . . .  	N PROC	E797	BIOS	Length = 001E
INT_14_2 . . . . . . . . . . . .  	N PROC	E7B5	BIOS	Length = 0016
INT_14_3 . . . . . . . . . . . .  	N PROC	E787	BIOS	Length = 000A
INT_14_DONE  . . . . . . . . . .  	N PROC	E791	BIOS	Length = 0006
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-21


INT_14_EXIT  . . . . . . . . . .  	L NEAR	E795	BIOS
INT_14_POLL  . . . . . . . . . .  	N PROC	E7CB	BIOS	Length = 0020
INT_14_POLL_DONE . . . . . . . .  	L NEAR	E7E9	BIOS
INT_14_POLL_LOOP . . . . . . . .  	L NEAR	E7DB	BIOS
INT_14_POLL_PORT . . . . . . . .  	N PROC	E7D3	BIOS	Length = 0018
INT_14_POLL_RET  . . . . . . . .  	L NEAR	E7EA	BIOS
INT_14_RW_ERR  . . . . . . . . .  	L NEAR	E7B0	BIOS
INT_15 . . . . . . . . . . . . .  	N PROC	F859	BIOS	Length = 000A
INT_15_EXIT  . . . . . . . . . .  	L NEAR	F85C	BIOS
INT_16 . . . . . . . . . . . . .  	N PROC	E82E	BIOS	Length = 0046
INT_16_DONE  . . . . . . . . . .  	L NEAR	E86C	BIOS
INT_17 . . . . . . . . . . . . .  	N PROC	EFD2	BIOS	Length = 0060
INT_17_0 . . . . . . . . . . . .  	L NEAR	EFF7	BIOS
INT_17_0_BUSY_LOOP . . . . . . .  	L NEAR	EFFB	BIOS
INT_17_0_OK  . . . . . . . . . .  	L NEAR	F009	BIOS
INT_17_0_TIMEOUT_LOOP  . . . . .  	L NEAR	EFF9	BIOS
INT_17_1 . . . . . . . . . . . .  	L NEAR	F023	BIOS
INT_17_2 . . . . . . . . . . . .  	L NEAR	F014	BIOS
INT_17_2_STATUS  . . . . . . . .  	L NEAR	F015	BIOS
INT_17_2_STATUS_2  . . . . . . .  	L NEAR	F018	BIOS
INT_17_DONE  . . . . . . . . . .  	L NEAR	F01C	BIOS
INT_17_IRET  . . . . . . . . . .  	L NEAR	F022	BIOS
INT_18 . . . . . . . . . . . . .  	N PROC	E41B	BIOS	Length = 000D
INT_19 . . . . . . . . . . . . .  	N PROC	E6F2	BIOS	Length = 002C
INT_19_BOOT_HD . . . . . . . . .  	NUMBER	0000	
INT_19_IPL_FAIL  . . . . . . . .  	L NEAR	E71D	BIOS
INT_19_READ_MBR  . . . . . . . .  	L NEAR	E704	BIOS
INT_1A . . . . . . . . . . . . .  	N PROC	FE6E	BIOS	Length = 0029
INT_1A_DONE  . . . . . . . . . .  	L NEAR	FE8A	BIOS
INT_1A_EXIT  . . . . . . . . . .  	L NEAR	FE8C	BIOS
INT_1A_READ  . . . . . . . . . .  	N PROC	FE81	BIOS	Length = 000C
INT_1A_SET . . . . . . . . . . .  	N PROC	FE8D	BIOS	Length = 000A
INT_1D . . . . . . . . . . . . .  	N PROC	F0A4	BIOS	Length = 0040
INT_1D_40  . . . . . . . . . . .  	L 0010	F0A4	BIOS
INT_1D_80  . . . . . . . . . . .  	L 0010	F0B4	BIOS
INT_1D_GFX . . . . . . . . . . .  	L 0010	F0C4	BIOS
INT_1D_MDA . . . . . . . . . . .  	L 0010	F0D4	BIOS
INT_1E . . . . . . . . . . . . .  	L 000B	EFC7	BIOS
INT_1E_PARAM . . . . . . . . . .  	N PROC	EF48	BIOS	Length = 000E
INT_IMR  . . . . . . . . . . . .  	NUMBER	0021	
INT_IRQ  . . . . . . . . . . . .  	N PROC	FF23	BIOS	Length = 0023
INT_IRQ_DONE . . . . . . . . . .  	L NEAR	FF3F	BIOS
INT_KB_ALT . . . . . . . . . . .  	N PROC	EA95	BIOS	Length = 003E
INT_KB_ALT_BREAK . . . . . . . .  	L NEAR	EB7B	BIOS
INT_KB_ALT_SKIP  . . . . . . . .  	L BYTE	EC09	BIOS
INT_KB_CHECK_CTRL_NUM  . . . . .  	L NEAR	E9F0	BIOS
INT_KB_CTRL  . . . . . . . . . .  	L NEAR	EB12	BIOS
INT_KB_CTRL_ALPHA  . . . . . . .  	L NEAR	EAF8	BIOS
INT_KB_CTRL_ALT  . . . . . . . .  	L NEAR	EB17	BIOS
INT_KB_CTRL_ALT_DEL  . . . . . .  	L NEAR	EB1C	BIOS
INT_KB_CTRL_ASC_TBL  . . . . . .  	L BYTE	E962	BIOS
INT_KB_CTRL_ASC_TBL_DONE . . . .  	L NEAR	EAED	BIOS
INT_KB_CTRL_ASC_TBL_LOOP . . . .  	L NEAR	EAD9	BIOS
INT_KB_CTRL_BREAK  . . . . . . .  	L NEAR	E9E4	BIOS
INT_KB_CTRL_NO_ALT . . . . . . .  	N PROC	EAD3	BIOS	Length = 003F
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-22


INT_KB_CTRL_NO_ALT_1 . . . . . .  	L NEAR	EB06	BIOS
INT_KB_CTRL_NO_DONE  . . . . . .  	L NEAR	EAEA	BIOS
INT_KB_CTRL_SCAN_TBL . . . . . .  	L BYTE	E96C	BIOS
INT_KB_DONE  . . . . . . . . . .  	L NEAR	EA8C	BIOS
INT_KB_DONE_1  . . . . . . . . .  	L NEAR	EAD1	BIOS
INT_KB_DONE_2  . . . . . . . . .  	L NEAR	EA17	BIOS
INT_KB_DONE_3  . . . . . . . . .  	L NEAR	EB5A	BIOS
INT_KB_FLAG_CLEAR  . . . . . . .  	L NEAR	EB72	BIOS
INT_KB_FLAG_FOUND  . . . . . . .  	L NEAR	EB3E	BIOS
INT_KB_FLAG_LOOP . . . . . . . .  	L NEAR	EB34	BIOS
INT_KB_FLAG_TOGGLE . . . . . . .  	L NEAR	EB51	BIOS
INT_KB_ICNS_BREAK  . . . . . . .  	L NEAR	EB49	BIOS
INT_KB_ICNS_MAKE . . . . . . . .  	L NEAR	EB4F	BIOS
INT_KB_IS_ALT_000  . . . . . . .  	L NEAR	EAB7	BIOS
INT_KB_IS_FLAG . . . . . . . . .  	N PROC	EB28	BIOS	Length = 0053
INT_KB_MEEP_DONE . . . . . . . .  	L NEAR	EA19	BIOS
INT_KB_NOT_ALT_000 . . . . . . .  	L NEAR	EAC4	BIOS
INT_KB_NOT_ICNS  . . . . . . . .  	L NEAR	EB5D	BIOS
INT_KB_NOT_ICNS_1  . . . . . . .  	L NEAR	EB69	BIOS
INT_KB_PAUSE_LOOP  . . . . . . .  	L NEAR	EA10	BIOS
INT_KB_PUT_BUFFER_2  . . . . . .  	L NEAR	EB88	BIOS
INT_KB_SET_PAUSE . . . . . . . .  	L NEAR	EA0A	BIOS
INT_LAST . . . . . . . . . . . .  	L BYTE	006B	_BDA
INT_LAST_ABS . . . . . . . . . .  	L BYTE	046B	_BDA_ABS
INT_P0 . . . . . . . . . . . . .  	NUMBER	0020	
INT_RET  . . . . . . . . . . . .  	N PROC	FF53	BIOS	Length = 0001
IOW  . . . . . . . . . . . . . .  		0006	
IO_DELAY_MS  . . . . . . . . . .  	N PROC	E5E0	BIOS	Length = 002E
IO_DELAY_MS_FDC  . . . . . . . .  	ALIAS	 IO_DELAY_MS		
IO_DELAY_TICK  . . . . . . . . .  	N PROC	E5E4	BIOS	Length = 002A
IO_WAIT_LATCH  . . . . . . . . .  	N PROC	E5FE	BIOS	Length = 0010
IO_WAIT_MS_125 . . . . . . . . .  	N PROC	E5DC	BIOS	Length = 0032
IO_WAIT_MS_DONE  . . . . . . . .  	L NEAR	E5FD	BIOS
IO_WAIT_MS_LOOP  . . . . . . . .  	L NEAR	E5EC	BIOS
IPL  . . . . . . . . . . . . . .  		0000	
IPL_ID . . . . . . . . . . . . .  	L WORD	7DFE	_IPL_SEG
IPL_TOP  . . . . . . . . . . . .  	L BYTE	7C00	_IPL_SEG	Length = 01FE
IRQ0 . . . . . . . . . . . . . .  		0000	
IRQ1 . . . . . . . . . . . . . .  		0001	
IRQ2 . . . . . . . . . . . . . .  		0002	
IRQ3 . . . . . . . . . . . . . .  		0003	
IRQ4 . . . . . . . . . . . . . .  		0004	
IRQ5 . . . . . . . . . . . . . .  		0005	
IRQ6 . . . . . . . . . . . . . .  		0006	
IRQ7 . . . . . . . . . . . . . .  		0007	
ISA_TYPE . . . . . . . . . . . .  	L BYTE	FFFE	BIOS
IS_ALPHA . . . . . . . . . . . .  	L NEAR	EA3B	BIOS
IS_ALPHA_DONE  . . . . . . . . .  	L NEAR	EA45	BIOS
IS_TURBO . . . . . . . . . . . .  	NUMBER	0000	
IVT_08 . . . . . . . . . . . . .  	L WORD	0020	_IVT
IVT_08_SEG . . . . . . . . . . .  	L WORD	0022	_IVT
IVT_09 . . . . . . . . . . . . .  	L WORD	0024	_IVT
IVT_09_SEG . . . . . . . . . . .  	L WORD	0026	_IVT
IVT_10 . . . . . . . . . . . . .  	L WORD	0040	_IVT
IVT_10_SEG . . . . . . . . . . .  	L WORD	0042	_IVT
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-23


IVT_18 . . . . . . . . . . . . .  	L WORD	0060	_IVT
IVT_18_SEG . . . . . . . . . . .  	L WORD	0062	_IVT
IVT_1D . . . . . . . . . . . . .  	L DWORD	0074	_IVT
IVT_1E . . . . . . . . . . . . .  	L DWORD	0078	_IVT
IVT_1F . . . . . . . . . . . . .  	L DWORD	007C	_IVT

K1AL . . . . . . . . . . . . . .  		0003	
K1CL . . . . . . . . . . . . . .  		0006	
K1CT . . . . . . . . . . . . . .  		0002	
K1IN . . . . . . . . . . . . . .  		0007	
K1LS . . . . . . . . . . . . . .  		0001	
K1NL . . . . . . . . . . . . . .  		0005	
K1RS . . . . . . . . . . . . . .  		0000	
K1SL . . . . . . . . . . . . . .  		0004	
K2CL . . . . . . . . . . . . . .  		0006	
K2IN . . . . . . . . . . . . . .  		0007	
K2LA . . . . . . . . . . . . . .  		0001	
K2LC . . . . . . . . . . . . . .  		0000	
K2NL . . . . . . . . . . . . . .  		0005	
K2PA . . . . . . . . . . . . . .  		0003	
K2SL . . . . . . . . . . . . . .  		0004	
K2SY . . . . . . . . . . . . . .  		0002	
KBK  . . . . . . . . . . . . . .  		000A	
KBPK . . . . . . . . . . . . . .  		0006	
KBPS . . . . . . . . . . . . . .  		0000	
KBRK . . . . . . . . . . . . . .  		0007	
KBRX . . . . . . . . . . . . . .  		0000	
KBS  . . . . . . . . . . . . . .  		0000	
KBWK . . . . . . . . . . . . . .  		0009	
KBWS . . . . . . . . . . . . . .  		0000	
KB_ALT . . . . . . . . . . . . .  	L BYTE	0019	_BDA
KB_BUF . . . . . . . . . . . . .  	L WORD	001E	_BDA	Length = 0010
KB_BUF_CLEAR . . . . . . . . . .  	N PROC	E952	BIOS	Length = 0010
KB_BUF_END . . . . . . . . . . .  	L WORD	003E	_BDA
KB_BUF_END_B . . . . . . . . . .  	NUMBER	003E	
KB_BUF_HAS_KEY . . . . . . . . .  	L NEAR	E84F	BIOS
KB_BUF_HD  . . . . . . . . . . .  	L WORD	001A	_BDA
KB_BUF_HD_ABS  . . . . . . . . .  	L WORD	041A	_BDA_ABS
KB_BUF_ST  . . . . . . . . . . .  	L WORD	0080	_BDA
KB_BUF_ST_ABS  . . . . . . . . .  	L WORD	0480	_BDA_ABS
KB_BUF_TL  . . . . . . . . . . .  	L WORD	001C	_BDA
KB_FILTER_SC . . . . . . . . . .  	NUMBER	0000	
KB_FLAGS . . . . . . . . . . . .  	L WORD	0017	_BDA
KB_FLAGS1  . . . . . . . . . . .  	L BYTE	0017	_BDA
KB_FLAGS2  . . . . . . . . . . .  	L BYTE	0018	_BDA
KB_GET_READ  . . . . . . . . . .  	L NEAR	E868	BIOS
KB_HAPPY . . . . . . . . . . . .  	L NEAR	E395	BIOS
KB_HLT_WAIT  . . . . . . . . . .  	NUMBER	0000	
KB_INT_CHAR  . . . . . . . . . .  	L NEAR	EA1E	BIOS
KB_INT_CHECK_FN_KEY  . . . . . .  	L NEAR	E9B6	BIOS
KB_INT_CHECK_FN_KEY_DONE . . . .  	L NEAR	E9DB	BIOS
KB_INT_CHECK_FULL  . . . . . . .  	L NEAR	EA80	BIOS
KB_INT_IS_ALT  . . . . . . . . .  	L NEAR	EA4A	BIOS
KB_INT_IS_ALT_DONE . . . . . . .  	L NEAR	EA59	BIOS
KB_INT_IS_CAPS . . . . . . . . .  	L NEAR	EA36	BIOS
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-24


KB_INT_IS_CAPS_DONE  . . . . . .  	L NEAR	EA4A	BIOS
KB_INT_IS_CTRL . . . . . . . . .  	L NEAR	EA59	BIOS
KB_INT_IS_CTRL_DONE  . . . . . .  	L NEAR	EA65	BIOS
KB_INT_IS_NUM  . . . . . . . . .  	L NEAR	E9F4	BIOS
KB_INT_IS_NUM_DONE . . . . . . .  	L NEAR	EA1E	BIOS
KB_INT_IS_PAUSE  . . . . . . . .  	L NEAR	EA65	BIOS
KB_INT_NOT_FLAG  . . . . . . . .  	L NEAR	EA32	BIOS
KB_INT_PRTSC . . . . . . . . . .  	L NEAR	EA61	BIOS
KB_INT_PUT_BUFFER  . . . . . . .  	L NEAR	EA71	BIOS
KB_INT_PUT_BUFFER_2  . . . . . .  	L NEAR	E9D8	BIOS
KB_INT_SHIFT . . . . . . . . . .  	L NEAR	EA25	BIOS
KB_INT_UC  . . . . . . . . . . .  	L NEAR	EA26	BIOS
KB_KEY_STATUS  . . . . . . . . .  	N PROC	E840	BIOS	Length = 0013
KB_KEY_STATUS_DONE . . . . . . .  	L NEAR	E849	BIOS
KB_RESET_TEST  . . . . . . . . .  	L NEAR	E378	BIOS
KB_SHIFT_STATUS  . . . . . . . .  	N PROC	E86F	BIOS	Length = 0005
KB_WAIT_READ . . . . . . . . . .  	N PROC	E853	BIOS	Length = 001C
KB_WAIT_READ_1 . . . . . . . . .  	L NEAR	E855	BIOS
KEE0 . . . . . . . . . . . . . .  		0001	
KEE1 . . . . . . . . . . . . . .  		0000	
KEEN . . . . . . . . . . . . . .  		0004	
KEFI . . . . . . . . . . . . . .  		0006	
KENL . . . . . . . . . . . . . .  		0005	
KERA . . . . . . . . . . . . . .  		0003	
KERC . . . . . . . . . . . . . .  		0002	
KERD . . . . . . . . . . . . . .  		0007	
KEY_FLAG_ON_TBL  . . . . . . . .  	L BYTE	EC01	BIOS
KEY_SCAN_TBL . . . . . . . . . .  	L BYTE	EB8B	BIOS
KEY_SCAN_TBL_HIGH  . . . . . . .  	L BYTE	EC15	BIOS
KLAK . . . . . . . . . . . . . .  		0004	
KLCI . . . . . . . . . . . . . .  		0003	
KLCL . . . . . . . . . . . . . .  		0002	
KLMU . . . . . . . . . . . . . .  		0006	
KLNL . . . . . . . . . . . . . .  		0001	
KLRF . . . . . . . . . . . . . .  		0005	
KLSL . . . . . . . . . . . . . .  		0000	
KLTE . . . . . . . . . . . . . .  		0007	
KPWP . . . . . . . . . . . . . .  		0004	
KPWPX  . . . . . . . . . . . . .  		0000	

LASER_TURBO  . . . . . . . . . .  	NUMBER	01F0	
LBI  . . . . . . . . . . . . . .  		0004	
LBN  . . . . . . . . . . . . . .  		0000	
LCBK . . . . . . . . . . . . . .  		0006	
LCDR . . . . . . . . . . . . . .  		0003	
LCEPS  . . . . . . . . . . . . .  		0004	
LCINI  . . . . . . . . . . . . .  		0002	
LCIRQ  . . . . . . . . . . . . .  		0004	
LCLF . . . . . . . . . . . . . .  		0001	
LCOUT  . . . . . . . . . . . . .  		0000	
LCPD . . . . . . . . . . . . . .  		0005	
LCPEN  . . . . . . . . . . . . .  		0003	
LCSB . . . . . . . . . . . . . .  		0002	
LCWLS  . . . . . . . . . . . . .  		0000	
LCX  . . . . . . . . . . . . . .  		0005	
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-25


LDR  . . . . . . . . . . . . . .  		0000	
LF . . . . . . . . . . . . . . .  	NUMBER	000A	
LFE  . . . . . . . . . . . . . .  		0003	
LIGHTCYAN  . . . . . . . . . . .  	NUMBER	000B	
LIGHT_PEN  . . . . . . . . . . .  	NUMBER	0001	
LMW  . . . . . . . . . . . . . .  		0000	
LOE  . . . . . . . . . . . . . .  		0001	
LPACK  . . . . . . . . . . . . .  		0006	
LPBZ . . . . . . . . . . . . . .  		0007	
LPE  . . . . . . . . . . . . . .  		0002	
LPIO . . . . . . . . . . . . . .  		0003	
LPOP . . . . . . . . . . . . . .  		0005	
LPSEL  . . . . . . . . . . . . .  		0004	
LPT  . . . . . . . . . . . . . .  		000E	
LPT1 . . . . . . . . . . . . . .  	NUMBER	0378	
LPT2 . . . . . . . . . . . . . .  	NUMBER	0278	
LPTO . . . . . . . . . . . . . .  		0000	
LPT_ADDR . . . . . . . . . . . .  	L WORD	0008	_BDA	Length = 0003
LPT_ADDR_B . . . . . . . . . . .  	NUMBER	0008	
LPT_CHAR . . . . . . . . . . . .  	N PROC	FFB3	BIOS	Length = 0010
LPT_CHAR_EXIT  . . . . . . . . .  	L NEAR	FFC2	BIOS
LPT_CHAR_OUT . . . . . . . . . .  	L NEAR	FFBD	BIOS
LPT_CRLF . . . . . . . . . . . .  	N PROC	FFAA	BIOS	Length = 0019
LPT_DETECT_LOOP  . . . . . . . .  	L NEAR	E32C	BIOS
LPT_LF . . . . . . . . . . . . .  	N PROC	FFB1	BIOS	Length = 0012
LPT_MDA  . . . . . . . . . . . .  	NUMBER	03BC	
LPT_TIME . . . . . . . . . . . .  	L BYTE	0078	_BDA	Length = 0004
LPT_TIME_B . . . . . . . . . . .  	NUMBER	0078	
LPT_TO . . . . . . . . . . . . .  	NUMBER	0014	
LPX  . . . . . . . . . . . . . .  		0001	
LSX  . . . . . . . . . . . . . .  		0007	
LTIM . . . . . . . . . . . . . .  		0003	
LWB  . . . . . . . . . . . . . .  		0000	
L_INT_10_JMP . . . . . . . . . .  	NUMBER	0010	
L_INT_KB_ALT_SKIP  . . . . . . .  	NUMBER	000A	
L_INT_KB_CTRL_ASC_TBL  . . . . .  	NUMBER	000C	
L_INT_KB_CTRL_SCAN_TBL . . . . .  	NUMBER	0006	
L_KEY_FLAG_ON_TBL  . . . . . . .  	NUMBER	0008	
L_KEY_SCAN_TBL . . . . . . . . .  	NUMBER	00AA	
L_POST_ERRORS  . . . . . . . . .  	NUMBER	0006	
L_POST_L . . . . . . . . . . . .  	NUMBER	0002	
L_VECTOR_TABLE . . . . . . . . .  	NUMBER	001F	
L_VID_BDA  . . . . . . . . . . .  	NUMBER	001E	

MAGENTA  . . . . . . . . . . . .  	NUMBER	000D	
MAGIC_WORD . . . . . . . . . . .  	NUMBER	AA55	
MAX_RAM  . . . . . . . . . . . .  	NUMBER	0280	
MAX_RAM_AUTO . . . . . . . . . .  	NUMBER	0000	
MAX_RAM_CGA  . . . . . . . . . .  	NUMBER	02E0	
MAX_RAM_MDA  . . . . . . . . . .  	NUMBER	02C0	
MAX_RAM_PC . . . . . . . . . . .  	NUMBER	0280	
MBRAM  . . . . . . . . . . . . .  		0002	
MBR_CHECK  . . . . . . . . . . .  	NUMBER	0000	
MCLB . . . . . . . . . . . . . .  		0004	
MCO1 . . . . . . . . . . . . . .  		0002	
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-26


MCO2 . . . . . . . . . . . . . .  		0003	
MCRX . . . . . . . . . . . . . .  		0005	
MCTS . . . . . . . . . . . . . .  		0004	
MDA_ATTR . . . . . . . . . . . .  	NUMBER	0001	
MDA_COLOR_FIX  . . . . . . . . .  	L NEAR	F70B	BIOS
MDA_CTRL . . . . . . . . . . . .  	NUMBER	03B8	
MDA_MEM  . . . . . . . . . . . .  	L BYTE	0000	_MDA_MEM	Length = 1000
MDA_PEN_RST  . . . . . . . . . .  	NUMBER	03BB	
MDA_STAT . . . . . . . . . . . .  	NUMBER	03BA	
MDBG . . . . . . . . . . . . . .  		0004	
MDBK . . . . . . . . . . . . . .  		0007	
MDFG . . . . . . . . . . . . . .  		0000	
MDIN . . . . . . . . . . . . . .  		0003	
MDSR . . . . . . . . . . . . . .  		0005	
MEEP . . . . . . . . . . . . . .  	N PROC	E8C8	BIOS	Length = 0016
MEEPMEEP . . . . . . . . . . . .  	N PROC	E8C5	BIOS	Length = 0019
MEEPMEEP_Z . . . . . . . . . . .  	N PROC	E8C3	BIOS	Length = 001B
MEEP_DELAY . . . . . . . . . . .  	NUMBER	0020	
MEM_ADDR_ERR . . . . . . . . . .  	L NEAR	E5B6	BIOS
MEM_ADDR_LOOP  . . . . . . . . .  	L NEAR	E598	BIOS
MEM_ADDR_TEST  . . . . . . . . .  	N PROC	E591	BIOS	Length = 0026
MEM_CHECK  . . . . . . . . . . .  	N PROC	E5C2	BIOS	Length = 000F
MEM_SZ_KB  . . . . . . . . . . .  	L WORD	0013	_BDA
MEM_SZ_PC  . . . . . . . . . . .  	L WORD	0015	_BDA
MEM_TEST . . . . . . . . . . . .  	N PROC	E5B7	BIOS	Length = 001A
MEM_TEST_VERIFY  . . . . . . . .  	L NEAR	E5C9	BIOS
MLSD . . . . . . . . . . . . . .  		0007	
MMW  . . . . . . . . . . . . . .  		0002	
MOVE_COL . . . . . . . . . . . .  	N PROC	F72B	BIOS	Length = 0017
MOVE_COL_SET . . . . . . . . . .  	L NEAR	F737	BIOS
MRI  . . . . . . . . . . . . . .  		0006	
MUTE_TANDY . . . . . . . . . . .  	NUMBER	0000	

NEXT_COL . . . . . . . . . . . .  	L NEAR	F57A	BIOS
NEXT_COM_PORT  . . . . . . . . .  	L NEAR	E322	BIOS
NEXT_LPT_PORT  . . . . . . . . .  	L NEAR	E34A	BIOS
NEXT_ROM . . . . . . . . . . . .  	L NEAR	E4E2	BIOS
NIB_HEX  . . . . . . . . . . . .  	N PROC	F78D	BIOS	Length = 0012
NL2_ANY_KEY  . . . . . . . . . .  	L BYTE	E447	BIOS
NL_ANY_KEY . . . . . . . . . . .  	L BYTE	E448	BIOS
NL_Z . . . . . . . . . . . . . .  	L BYTE	E428	BIOS
NMIE . . . . . . . . . . . . . .  		0007	
NMIX . . . . . . . . . . . . . .  		0000	
NMI_ERR_IO . . . . . . . . . . .  	L BYTE	E4A0	BIOS
NMI_ERR_PAR  . . . . . . . . . .  	L BYTE	E4A2	BIOS
NMI_R0 . . . . . . . . . . . . .  	NUMBER	00A0	
NMI_RESET  . . . . . . . . . . .  	N PROC	E5D1	BIOS	Length = 000B
NOTE1  . . . . . . . . . . . . .  	NUMBER	000D	
NOTE2  . . . . . . . . . . . . .  	NUMBER	000E	
NOT_HI_RES . . . . . . . . . . .  	L NEAR	F53E	BIOS
NO_COM_PORT  . . . . . . . . . .  	L NEAR	E316	BIOS
NO_GAME_PORT . . . . . . . . . .  	L NEAR	E2FE	BIOS
NO_LPT_PORT  . . . . . . . . . .  	L NEAR	E340	BIOS

O2CMD  . . . . . . . . . . . . .  		0005	
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-27


O2L  . . . . . . . . . . . . . .  		0000	
O2X  . . . . . . . . . . . . . .  		0003	
O3D3 . . . . . . . . . . . . . .  		0003	
O3D7 . . . . . . . . . . . . . .  		0007	
O3P  . . . . . . . . . . . . . .  		0002	
O3RR . . . . . . . . . . . . . .  		0000	
OEM_FONT . . . . . . . . . . . .  	NUMBER	0001	
OPT_ROM_END  . . . . . . . . . .  	NUMBER	FE00	
OUTLN_SZ . . . . . . . . . . . .  	N PROC	F742	BIOS	Length = 000C
OUT_CHAR . . . . . . . . . . . .  	N PROC	F794	BIOS	Length = 000B
OUT_DECU . . . . . . . . . . . .  	N PROC	F756	BIOS	Length = 0017
OUT_DECU_DONE  . . . . . . . . .  	L NEAR	F765	BIOS
OUT_DECU_R . . . . . . . . . . .  	L NEAR	F759	BIOS
OUT_SZ . . . . . . . . . . . . .  	N PROC	F71C	BIOS	Length = 000F
OUT_SZ_ATTR  . . . . . . . . . .  	N PROC	F70A	BIOS	Length = 0021
OUT_SZ_ATTR_SET  . . . . . . . .  	L NEAR	F716	BIOS
OUT_SZ_DONE  . . . . . . . . . .  	L NEAR	F729	BIOS
OUT_SZ_LOOP  . . . . . . . . . .  	L NEAR	F71F	BIOS
O_INT_1D_40  . . . . . . . . . .  	NUMBER	0000	
O_INT_1D_80  . . . . . . . . . .  	NUMBER	0010	
O_INT_1D_GFX . . . . . . . . . .  	NUMBER	0020	
O_INT_1D_MDA . . . . . . . . . .  	NUMBER	0030	

PBIO . . . . . . . . . . . . . .  		0005	
PBKB . . . . . . . . . . . . . .  		0007	
PBKC . . . . . . . . . . . . . .  		0006	
PBPC . . . . . . . . . . . . . .  		0004	
PBSP . . . . . . . . . . . . . .  		0001	
PBST . . . . . . . . . . . . . .  		0000	
PBSW . . . . . . . . . . . . . .  		0003	
PBTB . . . . . . . . . . . . . .  		0002	
PC2CI  . . . . . . . . . . . . .  		0004	
PC2IE  . . . . . . . . . . . . .  		0006	
PC2PE  . . . . . . . . . . . . .  		0007	
PC2T2  . . . . . . . . . . . . .  		0005	
PCCI . . . . . . . . . . . . . .  		0004	
PCDRV  . . . . . . . . . . . . .  		0002	
PCFD . . . . . . . . . . . . . .  		0000	
PCFP . . . . . . . . . . . . . .  		0001	
PCIE . . . . . . . . . . . . . .  		0006	
PCMB . . . . . . . . . . . . . .  		0002	
PCPE . . . . . . . . . . . . . .  		0007	
PCT2 . . . . . . . . . . . . . .  		0005	
PCVID  . . . . . . . . . . . . .  		0000	
PCWBCD . . . . . . . . . . . . .  		0000	
PCWM . . . . . . . . . . . . . .  		0001	
PCWRW  . . . . . . . . . . . . .  		0004	
PCWSC  . . . . . . . . . . . . .  		0006	
PDMA . . . . . . . . . . . . . .  		000A	
PFDC . . . . . . . . . . . . . .  		000C	
PFSK . . . . . . . . . . . . . .  		000B	
PFXX . . . . . . . . . . . . . .  		0008	
PIC_INT_FAIL . . . . . . . . . .  	L NEAR	E190	BIOS
PIC_INT_PASS . . . . . . . . . .  	L NEAR	E1B4	BIOS
PIC_INT_TEST . . . . . . . . . .  	L NEAR	E196	BIOS
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-28


PIC_REG_PASS . . . . . . . . . .  	L NEAR	E192	BIOS
PIC_VECT_TMP_LOOP  . . . . . . .  	L NEAR	E19A	BIOS
PIT_CH0  . . . . . . . . . . . .  	NUMBER	0040	
PIT_CH1  . . . . . . . . . . . .  	NUMBER	0041	
PIT_CH2  . . . . . . . . . . . .  	NUMBER	0042	
PIT_CTRL . . . . . . . . . . . .  	NUMBER	0043	
PKEY . . . . . . . . . . . . . .  		000D	
PKI  . . . . . . . . . . . . . .  		000E	
PMEM . . . . . . . . . . . . . .  		0009	
PORT_COUNT_LOOP  . . . . . . . .  	L NEAR	F6A9	BIOS
PORT_COUNT_NONE  . . . . . . . .  	L NEAR	F6B7	BIOS
PORT_TEST  . . . . . . . . . . .  	N PROC	E7EB	BIOS	Length = 002F
PORT_TEST_DONE . . . . . . . . .  	L NEAR	E819	BIOS
POST_BANNER  . . . . . . . . . .  	NUMBER	0001	
POST_CARD  . . . . . . . . . . .  	NUMBER	0001	
POST_CARD_PORT . . . . . . . . .  	NUMBER	0080	
POST_CGA . . . . . . . . . . . .  	L BYTE	E822	BIOS
POST_CLR_COLD  . . . . . . . . .  	ALIAS	 BLUE		
POST_CLR_GB  . . . . . . . . . .  	ALIAS	 GRAY		
POST_CLR_TXT . . . . . . . . . .  	ALIAS	 CYAN		
POST_CLR_VAL1  . . . . . . . . .  	ALIAS	 GREEN		
POST_CLR_VAL2  . . . . . . . . .  	ALIAS	 YELLOW		
POST_CLR_WARM  . . . . . . . . .  	ALIAS	 DARKRED		
POST_CLS . . . . . . . . . . . .  	NUMBER	0000	
POST_COL . . . . . . . . . . . .  	N PROC	F6BF	BIOS	Length = 0083
POST_COL_LBL_W . . . . . . . . .  	NUMBER	0007	
POST_COL_PAD . . . . . . . . . .  	NUMBER	0004	
POST_COL_VT  . . . . . . . . . .  	NUMBER	0009	
POST_COL_W . . . . . . . . . . .  	NUMBER	0006	
POST_COM . . . . . . . . . . . .  	L BYTE	E48D	BIOS
POST_CONFIG  . . . . . . . . . .  	NUMBER	0001	
POST_CPU . . . . . . . . . . . .  	L BYTE	E45F	BIOS
POST_CPU_TEST  . . . . . . . . .  	L NEAR	E05D	BIOS
POST_DETECT_COM  . . . . . . . .  	L NEAR	E2FE	BIOS
POST_DETECT_GAM  . . . . . . . .  	L NEAR	E2F3	BIOS
POST_DETECT_LPT  . . . . . . . .  	L NEAR	E324	BIOS
POST_DETECT_PORTS  . . . . . . .  	N PROC	E2E3	BIOS	Length = 0069
POST_EGA . . . . . . . . . . . .  	L BYTE	E81E	BIOS
POST_END_COL . . . . . . . . . .  	N PROC	F701	BIOS	Length = 002A
POST_END_COL_NL  . . . . . . . .  	N PROC	F6FC	BIOS	Length = 0005
POST_END_COL_STR . . . . . . . .  	N PROC	F704	BIOS	Length = 0027
POST_ERR . . . . . . . . . . . .  	L BYTE	E8F8	BIOS
POST_ERROR . . . . . . . . . . .  	L NEAR	E3E7	BIOS
POST_ERRORS  . . . . . . . . . .  	L WORD	E915	BIOS
POST_ERROR_MSG . . . . . . . . .  	N PROC	E921	BIOS	Length = 0016
POST_ERROR_MSG_EXIT  . . . . . .  	L NEAR	E936	BIOS
POST_ERROR_MSG_LOOP  . . . . . .  	L NEAR	E927	BIOS
POST_ERROR_MSG_NEXT  . . . . . .  	L NEAR	E934	BIOS
POST_ERR_ERR . . . . . . . . . .  	L BYTE	E8FF	BIOS
POST_ERR_MSG . . . . . . . . . .  	N PROC	E8F8	BIOS	Length = 003F
POST_ERR_PDMA  . . . . . . . . .  	L BYTE	E911	BIOS
POST_ERR_PFDC  . . . . . . . . .  	L BYTE	E90D	BIOS
POST_ERR_PKEY  . . . . . . . . .  	L BYTE	E909	BIOS
POST_ERR_PKI . . . . . . . . . .  	L BYTE	E906	BIOS
POST_ERR_WAIT  . . . . . . . . .  	NUMBER	0000	
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-29


POST_FDD . . . . . . . . . . . .  	L BYTE	E491	BIOS
POST_FD_COUNT  . . . . . . . . .  	NUMBER	0000	
POST_FLAG_DONE . . . . . . . . .  	L NEAR	E0B3	BIOS
POST_FPU . . . . . . . . . . . .  	L BYTE	E468	BIOS
POST_GLADOS  . . . . . . . . . .  	NUMBER	0000	
POST_HD  . . . . . . . . . . . .  	L BYTE	E471	BIOS
POST_HDD . . . . . . . . . . . .  	L BYTE	E495	BIOS
POST_HD_CHECK  . . . . . . . . .  	NUMBER	0000	
POST_HD_COUNT  . . . . . . . . .  	NUMBER	0000	
POST_HD_PARMS  . . . . . . . . .  	NUMBER	0000	
POST_KB_RESET  . . . . . . . . .  	N PROC	E34C	BIOS	Length = 0059
POST_K_UNIT  . . . . . . . . . .  	TEXT  'KB'		
POST_L . . . . . . . . . . . . .  	TEXT  ' [ '		
POST_LPT . . . . . . . . . . . .  	L BYTE	E489	BIOS
POST_LSEP  . . . . . . . . . . .  	L BYTE	E499	BIOS
POST_MDA . . . . . . . . . . . .  	L BYTE	E826	BIOS
POST_MEMORY  . . . . . . . . . .  	L BYTE	E477	BIOS
POST_M_UNIT  . . . . . . . . . .  	TEXT  'MB'		
POST_NONE  . . . . . . . . . . .  	L BYTE	FF4C	BIOS
POST_OK  . . . . . . . . . . . .  	L NEAR	E3F8	BIOS
POST_OPT_ROM . . . . . . . . . .  	NUMBER	0001	
POST_QUIET . . . . . . . . . . .  	NUMBER	0000	
POST_R . . . . . . . . . . . . .  	TEXT  ' ]'		
POST_RSEP  . . . . . . . . . . .  	L BYTE	E49D	BIOS
POST_START_COL_1 . . . . . . . .  	N PROC	F6C3	BIOS	Length = 0027
POST_START_COL_2 . . . . . . . .  	N PROC	F6EA	BIOS	Length = 0012
POST_START_COL_2_40  . . . . . .  	L NEAR	F6BF	BIOS
POST_START_COL_START . . . . . .  	L NEAR	F6C6	BIOS
POST_STRINGS . . . . . . . . . .  	N PROC	E45F	BIOS	Length = 004B
POST_SYS_CONFIG  . . . . . . . .  	N PROC	F5FD	BIOS	Length = 00C2
POST_SYS_VIDEO . . . . . . . . .  	N PROC	F5FD	BIOS	Length = 004E
POST_SYS_VIDEO_DONE  . . . . . .  	L NEAR	F645	BIOS
POST_TAB_COL . . . . . . . . . .  	NUMBER	0020	
POST_TAB_COL_I . . . . . . . . .  	NUMBER	0013	
POST_TEST_CHK_ROM  . . . . . . .  	NUMBER	0000	
POST_TEST_DMA  . . . . . . . . .  	NUMBER	0001	
POST_TEST_DMA_TC0  . . . . . . .  	NUMBER	0001	
POST_TEST_FD . . . . . . . . . .  	NUMBER	0000	
POST_TEST_INST . . . . . . . . .  	NUMBER	0001	
POST_TEST_KB . . . . . . . . . .  	NUMBER	0001	
POST_TEST_KEY  . . . . . . . . .  	NUMBER	0000	
POST_TEST_PIC_INT  . . . . . . .  	NUMBER	0001	
POST_TEST_PIC_REG  . . . . . . .  	NUMBER	0001	
POST_TEST_PIT_1  . . . . . . . .  	NUMBER	0001	
POST_TEST_SEEK . . . . . . . . .  	NUMBER	0000	
POST_THEME . . . . . . . . . . .  	NUMBER	0001	
POST_V20 . . . . . . . . . . . .  	L BYTE	E485	BIOS
POST_VGA . . . . . . . . . . . .  	L BYTE	E81A	BIOS
POST_VIDEO . . . . . . . . . . .  	L BYTE	FF46	BIOS
POST_VIDEO_TYPE  . . . . . . . .  	NUMBER	0001	
POST_WARM_COLD . . . . . . . . .  	NUMBER	0000	
POWER_ON . . . . . . . . . . . .  	F PROC	FFF0	BIOS	Length = 0010
PPAD . . . . . . . . . . . . . .  		0004	
PPAM . . . . . . . . . . . . . .  		0005	
PPBD . . . . . . . . . . . . . .  		0001	
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-30


PPBM . . . . . . . . . . . . . .  		0002	
PPCL . . . . . . . . . . . . . .  		0000	
PPCU . . . . . . . . . . . . . .  		0003	
PPEN . . . . . . . . . . . . . .  		0007	
PPI_A  . . . . . . . . . . . . .  	NUMBER	0060	
PPI_B  . . . . . . . . . . . . .  	NUMBER	0061	
PPI_B_BOOT . . . . . . . . . . .  	NUMBER	00AC	
PPI_C  . . . . . . . . . . . . .  	NUMBER	0062	
PPI_CW . . . . . . . . . . . . .  	NUMBER	0063	
PTBD . . . . . . . . . . . . . .  		0002	
PTRSCN_ST  . . . . . . . . . . .  	L BYTE	0000	_DOS_DAT

QUARTER  . . . . . . . . . . . .  	NUMBER	00AC	

RAM_DIGITS . . . . . . . . . . .  	NUMBER	0003	
RAM_PARITY . . . . . . . . . . .  	NUMBER	0000	
RAM_TEST . . . . . . . . . . . .  	NUMBER	731D	
RAM_TEST_1 . . . . . . . . . . .  	NUMBER	95A5	
RAM_TEST_2 . . . . . . . . . . .  	NUMBER	731D	
RAM_TEST_LONG  . . . . . . . . .  	NUMBER	0000	
RANDOM_TAGLINE . . . . . . . . .  	NUMBER	0000	
RED  . . . . . . . . . . . . . .  	NUMBER	000C	
REL_DATE . . . . . . . . . . . .  	L BYTE	FFF5	BIOS
RESET_PPI  . . . . . . . . . . .  	L NEAR	E0B7	BIOS
RESET_VIDEO  . . . . . . . . . .  	L NEAR	E261	BIOS
RESET_VIDEO_DONE . . . . . . . .  	L NEAR	E263	BIOS
ROM_CHECKSUM . . . . . . . . . .  	N PROC	E4ED	BIOS	Length = 0014
ROM_INIT_SP  . . . . . . . . . .  	L WORD	0069	_BDA
ROM_INIT_SS  . . . . . . . . . .  	L WORD	0067	_BDA
ROM_SCAN_DONE  . . . . . . . . .  	L NEAR	E4E9	BIOS
ROM_SCAN_POST  . . . . . . . . .  	N PROC	F863	BIOS	Length = 0069
ROM_SCAN_POST_CHK  . . . . . . .  	L NEAR	F8A2	BIOS
ROM_SCAN_POST_DONE . . . . . . .  	L NEAR	F89B	BIOS
ROM_SCAN_POST_EXIT . . . . . . .  	L NEAR	F89E	BIOS
ROPC . . . . . . . . . . . . . .  		0000	
RTC_DATA . . . . . . . . . . . .  	L WORD	00EE	_BDA
RTC_WAIT . . . . . . . . . . . .  	L BYTE	00A0	_BDA
RTS  . . . . . . . . . . . . . .  		0001	

SETTINGS_5160  . . . . . . . . .  	L NEAR	E211	BIOS
SETTINGS_DONE  . . . . . . . . .  	L NEAR	E229	BIOS
SETTINGS_SAVE  . . . . . . . . .  	L NEAR	E234	BIOS
SET_CURSOR . . . . . . . . . . .  	N PROC	F03E	BIOS	Length = 0007
SFNM . . . . . . . . . . . . . .  		0004	
SHOW_CURSOR  . . . . . . . . . .  	N PROC	F035	BIOS	Length = 0010
SHOW_PORT_COUNT  . . . . . . . .  	N PROC	F6A7	BIOS	Length = 0018
SMCH . . . . . . . . . . . . . .  		0000	
SMCLR  . . . . . . . . . . . . .  		0002	
SNGL . . . . . . . . . . . . . .  		0001	
SPACE  . . . . . . . . . . . . .  	N PROC	F74E	BIOS	Length = 0008
SQUARE . . . . . . . . . . . . .  	NUMBER	00FE	
ST0CHK . . . . . . . . . . . . .  		0004	
ST0CS  . . . . . . . . . . . . .  		0006	
ST0DRV . . . . . . . . . . . . .  		0000	
ST0HD  . . . . . . . . . . . . .  		0002	
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-31


ST0NR  . . . . . . . . . . . . .  		0003	
ST0SK  . . . . . . . . . . . . .  		0005	
STACK_TOP  . . . . . . . . . . .  	L WORD	0100	_BOOT_STACK
STRINGS  . . . . . . . . . . . .  	N PROC	E428	BIOS	Length = 0082
SW1_FLP  . . . . . . . . . . . .  	NUMBER	00C0	
SYN  . . . . . . . . . . . . . .  	NUMBER	0016	
S_OPT_CHK  . . . . . . . . . . .  	L BYTE	F8C0	BIOS
S_OPT_K  . . . . . . . . . . . .  	L BYTE	F8C8	BIOS
S_OPT_ROM  . . . . . . . . . . .  	L BYTE	F8B7	BIOS
S_OPT_SIZE . . . . . . . . . . .  	L BYTE	F8BB	BIOS

TAG0 . . . . . . . . . . . . . .  	L BYTE	E00D	BIOS
TC0  . . . . . . . . . . . . . .  		0000	
TC1  . . . . . . . . . . . . . .  		0001	
TC2  . . . . . . . . . . . . . .  		0002	
TC3  . . . . . . . . . . . . . .  		0003	
TD_MEM . . . . . . . . . . . . .  	NUMBER	00E0	
TD_TURBO . . . . . . . . . . . .  	NUMBER	0090	
TD_WS  . . . . . . . . . . . . .  	NUMBER	0070	
THRE . . . . . . . . . . . . . .  		0005	
TIMER  . . . . . . . . . . . . .  	L 0005	006C	_BDA
TOP_BANNER . . . . . . . . . . .  	L BYTE	E000	BIOS
TRY_INT_18 . . . . . . . . . . .  	L NEAR	E419	BIOS
TSRE . . . . . . . . . . . . . .  		0006	
TURBO  . . . . . . . . . . . . .  		0003	
TURBO_NONE . . . . . . . . . . .  	NUMBER	0000	
TURBO_REV  . . . . . . . . . . .  	NUMBER	0002	
TURBO_STD  . . . . . . . . . . .  	NUMBER	0001	
TURBO_TYPE . . . . . . . . . . .  	NUMBER	0000	

UM82_SPEED . . . . . . . . . . .  	NUMBER	00C0	
UM82_STATUS  . . . . . . . . . .  	NUMBER	00E0	
UMW  . . . . . . . . . . . . . .  		0004	
UNITS_IEC  . . . . . . . . . . .  	NUMBER	0000	
UNSAFE_FLOPPY  . . . . . . . . .  	NUMBER	0000	
UNSAFE_FLP_DIV . . . . . . . . .  	TEXT  3/10		
UNSAFE_REFRESH . . . . . . . . .  	NUMBER	0000	
UPM  . . . . . . . . . . . . . .  		0000	

V20  . . . . . . . . . . . . . .  		0002	
V40_WCR1 . . . . . . . . . . . .  	NUMBER	FFF5	
V40_WCR2 . . . . . . . . . . . .  	NUMBER	FFF6	
VBG  . . . . . . . . . . . . . .  		0004	
VECTOR_TABLE . . . . . . . . . .  	N PROC	FEE3	BIOS	Length = 0040
VER  . . . . . . . . . . . . . .  	L BYTE	FFE0	BIOS
VER_DATE . . . . . . . . . . . .  	TEXT  '01/18/25'		
VER_NAME . . . . . . . . . . . .  	TEXT  'GLaBIOS'		
VER_NUM  . . . . . . . . . . . .  	TEXT  '0.2.6'		
VF3_OPC  . . . . . . . . . . . .  		0003	
VF3_SRC  . . . . . . . . . . . .  		0000	
VF4_DST  . . . . . . . . . . . .  		0003	
VF4_OPC  . . . . . . . . . . . .  		0006	
VF4_SRC  . . . . . . . . . . . .  		0000	
VFB  . . . . . . . . . . . . . .  		0000	
VID  . . . . . . . . . . . . . .  		0004	
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-32


VID_BIOS_SZ  . . . . . . . . . .  	L BYTE	0002	_VID_BIOS
VID_BUF_SZ . . . . . . . . . . .  	L WORD	004C	_BDA
VID_CGA40  . . . . . . . . . . .  	NUMBER	0001	
VID_CGA80  . . . . . . . . . . .  	NUMBER	0002	
VID_COLOR  . . . . . . . . . . .  	L BYTE	0066	_BDA
VID_COLS . . . . . . . . . . . .  	L WORD	004A	_BDA
VID_CURS_POS . . . . . . . . . .  	L WORD	0050	_BDA	Length = 0008
VID_CURS_TYPE  . . . . . . . . .  	L WORD	0060	_BDA
VID_DEF_COLS . . . . . . . . . .  	NUMBER	0050	
VID_DEF_ROWS . . . . . . . . . .  	NUMBER	0018	
VID_MDA  . . . . . . . . . . . .  	NUMBER	0003	
VID_MEM_SEG  . . . . . . . . . .  	L WORD	00EA	_BDA
VID_MEM_SEG_DW . . . . . . . . .  	L DWORD	00E8	_BDA
VID_MN . . . . . . . . . . . . .  	L WORD	0000	_VID_BIOS
VID_MODE . . . . . . . . . . . .  	L BYTE	0049	_BDA
VID_MODE_OK  . . . . . . . . . .  	L NEAR	E257	BIOS
VID_MODE_REG . . . . . . . . . .  	L BYTE	0065	_BDA
VID_MODE_TBL . . . . . . . . . .  	L BYTE	E82B	BIOS
VID_PAGE . . . . . . . . . . . .  	L BYTE	0062	_BDA
VID_PORT . . . . . . . . . . . .  	L WORD	0063	_BDA
VID_ROM  . . . . . . . . . . . .  	NUMBER	0000	
VID_SEG  . . . . . . . . . . . .  	L WORD	004E	_BDA
VID_SP . . . . . . . . . . . . .  	NUMBER	0020	
VID_VEC  . . . . . . . . . . . .  	L WORD	0003	_VID_BIOS
VL . . . . . . . . . . . . . . .  	NUMBER	00B3	
VRW  . . . . . . . . . . . . . .  		0003	
VSHS . . . . . . . . . . . . . .  		0000	
VSPE . . . . . . . . . . . . . .  		0002	
VSPT . . . . . . . . . . . . . .  		0001	
VSVS . . . . . . . . . . . . . .  		0003	
VSX  . . . . . . . . . . . . . .  		0004	

WARM . . . . . . . . . . . . . .  		000F	
WARM_BOOT  . . . . . . . . . . .  	NUMBER	1234	
WARM_BOOT_MEM  . . . . . . . . .  	NUMBER	4321	
WARM_BOOT_SUS  . . . . . . . . .  	NUMBER	5678	
WARM_BOOT_TEST . . . . . . . . .  	NUMBER	9ABC	
WARM_ENABLE  . . . . . . . . . .  	NUMBER	0000	
WARM_FLAG  . . . . . . . . . . .  	L WORD	0072	_BDA
WARM_FLAG_ABS  . . . . . . . . .  	L WORD	0472	_BDA_ABS
WB_LOW_CHECK_OK  . . . . . . . .  	L NEAR	E80B	BIOS
WB_READ_LOOP . . . . . . . . . .  	L NEAR	E806	BIOS
WB_WRITE_1 . . . . . . . . . . .  	L NEAR	E7F1	BIOS
WB_WRITE_LOOP  . . . . . . . . .  	L NEAR	E7F7	BIOS
WHITE  . . . . . . . . . . . . .  	NUMBER	000F	
WORD_HEX . . . . . . . . . . . .  	N PROC	F779	BIOS	Length = 0026

X1 . . . . . . . . . . . . . . .  		000D	

YELLOW . . . . . . . . . . . . .  	NUMBER	000E	

ZERO_ALL_RAM . . . . . . . . . .  	L NEAR	E537	BIOS
ZERO_ALL_RAM_1 . . . . . . . . .  	L NEAR	E553	BIOS
ZERO_ALL_START . . . . . . . . .  	L NEAR	E555	BIOS

Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-33


??0001 . . . . . . . . . . . . .  	L NEAR	E0FB	BIOS
??0002 . . . . . . . . . . . . .  	L NEAR	E0FD	BIOS
??0003 . . . . . . . . . . . . .  	L NEAR	E13B	BIOS
??0004 . . . . . . . . . . . . .  	L NEAR	E13D	BIOS
??0005 . . . . . . . . . . . . .  	L NEAR	E14F	BIOS
??0006 . . . . . . . . . . . . .  	L NEAR	E151	BIOS
??0007 . . . . . . . . . . . . .  	L NEAR	E161	BIOS
??0008 . . . . . . . . . . . . .  	L NEAR	E163	BIOS
??0009 . . . . . . . . . . . . .  	L NEAR	E16B	BIOS
??000A . . . . . . . . . . . . .  	L NEAR	E16D	BIOS
??000B . . . . . . . . . . . . .  	L NEAR	E1A9	BIOS
??000C . . . . . . . . . . . . .  	NUMBER	0030	
??000D . . . . . . . . . . . . .  	NUMBER	0004	
??000E . . . . . . . . . . . . .  	WORD	0010	_BDA
??0010 . . . . . . . . . . . . .  	L NEAR	E37A	BIOS
??0011 . . . . . . . . . . . . .  	L NEAR	E387	BIOS
??0012 . . . . . . . . . . . . .  	L NEAR	E391	BIOS
??0013 . . . . . . . . . . . . .  	L NEAR	E3DA	BIOS
??0014 . . . . . . . . . . . . .  	NUMBER	0000	
??0015 . . . . . . . . . . . . .  	L NEAR	E414	BIOS
??0018 . . . . . . . . . . . . .  	L NEAR	E7FA	BIOS
??001A . . . . . . . . . . . . .  	L NEAR	E88E	BIOS
??001B . . . . . . . . . . . . .  	L NEAR	E890	BIOS
??001C . . . . . . . . . . . . .  	L NEAR	E892	BIOS
??001D . . . . . . . . . . . . .  	L NEAR	E899	BIOS
??001E . . . . . . . . . . . . .  	L NEAR	E89B	BIOS
??001F . . . . . . . . . . . . .  	L NEAR	E89D	BIOS
??0020 . . . . . . . . . . . . .  	L NEAR	E8D2	BIOS
??0021 . . . . . . . . . . . . .  	L NEAR	E8D9	BIOS
??0022 . . . . . . . . . . . . .  	NUMBER	0001	
??0027 . . . . . . . . . . . . .  	L NEAR	F02A	BIOS
??002A . . . . . . . . . . . . .  	NUMBER	0030	
??002B . . . . . . . . . . . . .  	NUMBER	0004	
??002C . . . . . . . . . . . . .  	WORD	0010	_BDA
??002D . . . . . . . . . . . . .  	NUMBER	00C0	
??002E . . . . . . . . . . . . .  	NUMBER	0002	
??002F . . . . . . . . . . . . .  	WORD	0011	_BDA
??0030 . . . . . . . . . . . . .  	NUMBER	000E	
??0031 . . . . . . . . . . . . .  	NUMBER	0001	
??0032 . . . . . . . . . . . . .  	WORD	0011	_BDA
@FILENAME  . . . . . . . . . . .  	TEXT  glabios		
_AH  . . . . . . . . . . . . . .  	NUMBER	0004	
_AL  . . . . . . . . . . . . . .  	NUMBER	0000	
_AX  . . . . . . . . . . . . . .  	NUMBER	0008	
_BDA_SEG . . . . . . . . . . . .  	NUMBER	0400	
_BH  . . . . . . . . . . . . . .  	NUMBER	0007	
_BIOS_TOP  . . . . . . . . . . .  	L WORD	E000	_BIOS
_BL  . . . . . . . . . . . . . .  	NUMBER	0003	
_BOOT  . . . . . . . . . . . . .  	L WORD	E05B	_BIOS
_BP  . . . . . . . . . . . . . .  	NUMBER	000D	
_BX  . . . . . . . . . . . . . .  	NUMBER	000B	
_CH  . . . . . . . . . . . . . .  	NUMBER	0005	
_CL  . . . . . . . . . . . . . .  	NUMBER	0001	
_CX  . . . . . . . . . . . . . .  	NUMBER	0009	
_DH  . . . . . . . . . . . . . .  	NUMBER	0006	
Microsoft (R) Macro Assembler Version 5.00                  2/9/25 20:33:36
GLaBIOS                                                     Symbols-34


_DI  . . . . . . . . . . . . . .  	NUMBER	000F	
_DL  . . . . . . . . . . . . . .  	NUMBER	0002	
_DX  . . . . . . . . . . . . . .  	NUMBER	000A	
_FDC_LAST_ST . . . . . . . . . .  	TEXT  [DI][FDC_LAST_ST-FD_LAST_OP]		
_FD_CAL_ST . . . . . . . . . . .  	TEXT  BYTE PTR [DI][FD_CAL_ST-FD_LAST_OP]		
_FD_LAST_OP  . . . . . . . . . .  	TEXT  BYTE PTR [DI]		
_FD_MEDIA_ST . . . . . . . . . .  	TEXT  BYTE PTR [DI][FD_MEDIA_ST-FD_LAST_OP]		
_FD_MOTOR_ST . . . . . . . . . .  	TEXT  BYTE PTR [DI][FD_MOTOR_ST-FD_LAST_OP]		
_FD_TIMER  . . . . . . . . . . .  	TEXT  BYTE PTR [DI][TIMER-FD_LAST_OP]		
_FD_TRACK  . . . . . . . . . . .  	TEXT  BYTE PTR [DI][FD_TRACK-FD_LAST_OP]		
_KB_FLAGS1 . . . . . . . . . . .  	TEXT  BYTE PTR[BX][-1]		
_KB_FLAGS2 . . . . . . . . . . .  	TEXT  BYTE PTR[BX]		
_POWER_ON  . . . . . . . . . . .  	L WORD	FFF0	_BIOS
_SI  . . . . . . . . . . . . . .  	NUMBER	000E	
_SP  . . . . . . . . . . . . . .  	NUMBER	000C	
__POWER_ON . . . . . . . . . . .  	L FAR 	0000	RESET


  12514 Source  Lines
  13968 Total   Lines
   1495 Symbols

  47610 + 322470 Bytes symbol space free

      1 Warning Errors
      0 Severe  Errors
